[[polymer_manual__basic]]
=== Polymer Core Basics

Polymer components are stored in HTML files. Each file contains one component, which consists of a template (HTML), styles (CSS) and logic (JavaScript).

Polymer components can import and use other Polymer components.

[[polymer_manual__basic__simple_component]]
==== Simple Component

Let's consider a very simple example. The project consists of two files: `index.html` and `alert-button.html`.

* `alert-button.html` defines a Polymer component.

* `index.html` uses this component.

See the source code and the result below.

[TIP]
====
You can play with the example in an application created and deployed by Studio by copying the below files to your `deploy/tomcat/webapps/app-front` folder keeping the relative paths. That is `index.html` should replace the existing file in the web application root, and `alert-button.html` must be created in the new `src/polymer-basic/simple-component` subdirectory.
====

.src/polymer-basic/simple-component/alert-button.html
[source, html]
----
include::{sourcesdir}/polymer-build/src/polymer-basic/simple-component/alert-button.html[]
----

.index.html
[source, html]
----
<html>
<!-- index.html is an entry point of our application. -->
<!-- Usually it loads one root Polymer element which contains all other components. -->
<head>
    <!-- Import of a web component we want to use. -->
	<link rel="import" href="src/polymer-basic/simple-component/alert-button.html">
	<!-- Polyfills. -->
    <!-- Natively web-components work only in Google Chrome. -->
    <!-- For all other browsers polyfills are required. -->
	<script src="bower_components/webcomponentsjs/webcomponents-loader.js"></script>
</head>
<body>
  <alert-button>
    <!-- This text goes to <slot/> of the Polymer element. -->
    Our first simple component - alert button!
  </alert-button>
</body>
</html>
----

*Result:*
[subs="none"]
++++

<link rel="import" href="html/src/polymer-basic/simple-component/alert-button.html">

<div class="polymer-demo-container">
    <alert-button>Our first simple component - alert button!</alert-button>
</div>

++++

So, `alert-button` is a component that is represented by a button and a caption to this button.

On click, this button shows a message: "Hello, User!". The code using this component might provide a caption inside
`<alert-button/>` tag. But the `slot` is not required and can be omitted while using `alert-button`.

These are the basics that allow you to write and use simple Polymer components.

[TIP]
====
`index.html` in our example contains a polyfill script.
This script checks what exactly our browser doesn't support (HTML imports, shadow DOM, custom elements) and loads
only polyfills that are really required. See details https://github.com/webcomponents/webcomponentsjs[here].
====

What we have learned so far::
+
--
* Polymer components are declared in HTML files inside the `dom-module` tag.

* Each Polymer component file can contain CSS (optional), HTML (optional) and JavaScript (mandatory).

* Polymer component is declared by creating a class that extends `Polymer.Element` and registering it with `customElements` object.
Our web component has to contain static property `is` which has to match the id of the `dom-module` element. This id
is used to refer to the component afterwards.

* Polymer component class can contain an arbitrary number of functions that can be called in handlers from HTML.

* CSS declared in Polymer elements don't affect the rest of the application.

* Polymer components can import and use other Polymer components.
--

[[polymer_manual__basic__properties]]
==== Properties

Properties are used for data binding, which is an essential part of any modern web framework.

Let's consider a component that demonstrates binding abilities of Polymer. It is an input where users can type something, and all they are typing is duplicated below by using property binding.

*Our guesser component*
[subs="none"]
++++

<link rel="import" href="html/src/polymer-basic/properties/name-guesser.html">

<div class="polymer-demo-container">
    <name-guesser placeholder="Your name goes here"></name-guesser>
</div>

++++

*Source code*

.index.html
[source, html]
----
<html>
<head>
	<link rel="import" href="src/polymer-basic/properties/name-guesser.html">
	<script src="bower_components/webcomponentsjs/webcomponents-loader.js"></script>
</head>
<body>
    <name-guesser placeholder="Your name goes here"></name-guesser>
</body>
</html>
----

.src/polymer-basic/properties/name-guesser.html
[source, html]
----
include::{sourcesdir}/polymer-build/src/polymer-basic/properties/name-guesser.html[]
----

There are two types of binding:

* `++[[ ]]++` - one-way binding. An enclosed component listens to changes of a property and refreshes its state. In other words, the data flows downward - from the host component to children components.
+
In our example, the `placeholder` property uses one-way binding: we just pass its value down to the `input` component.

* `++{{ }}++` - two-way binding. An enclosed component not only listens to property changes but can also change the property value itself. That is the data can flow both ways - from host to children and back.
+
In our example, the `name` property uses two-way binding to receive a value from the `iron-input` component and display it in `div`.

In this example, we could use two-way binding for all properties and the component would still work as expected. But it's important to choose a correct binding, because it increases code readability and simplifies refactoring.

A Polymer component can configure all its properties in an object returned by the `properties` getter. It can just specify a type of a property (String, Boolean, Number, Object, Array, Date) or provide a number of different parameters. One of these parameters is `value` which specifies a default value for the property.

In our example, the `placeholder` property has default value "Your name please". But it's overwritten with "Your name goes here" passed from the host host `name-guesser` element defined in `index.html`. We could also provide a name, e.g.

[source, html]
----
<name-guesser name="Charlie"></name-guesser>
----

That would cause the input to be filled on initialization:

[subs="none"]
++++

<div class="polymer-demo-container">
    <name-guesser name="Charlie" placeholder="Your name goes here"></name-guesser>
</div>

++++

Apart from `value`, a property can have a number of other attributes (`observer`, `notify`, etc.) that partially will be reviewed further.

Pay attention to the following important detail: properties are named in CamelCase in JavaScript but in kebab-case in HTML. For example, the `bind-value` property of the `iron-input` component is defined in the source code of the component as follows:

[source, javascript]
----
...
properties: {

  /**
   * Use this property instead of `value` for two-way data binding.
   */
  bindValue: {
    type: String
  },
  ...
----

What we have learned so far::
+
--
* Use `++[[ ]]++` for one-way binding.

* Use `++{{ }}++` for two-way binding.

* Describe your properties in an object returned by the `properties` getter.

* For each property you can define type, default value and a number of other parameters.

* You can provide properties from outside of a Polymer component by using HTML attributes.

* `iron-input` is a Polymer component that allows you to use two-way binding in `input` element.
--

[[polymer_manual__basic__templating]]
==== Templating

Polymer provides convenient means for templating: conditional template (`dom-if`) and template repeater (`dom-repeat`).

The following example demonstrates these features. It's a component named `name-list`, which allows a user to create a list of names. It provides an input where the user can enter some name and confirm it by pushing a confirm button. The confirmed name will be added to the list and displayed below.

To prevent a user from entering too many names there is a property `maxNameLength`. When a list size reaches some limit (3, by default) the input disappears.

*Result*
[subs="none"]
++++

<link rel="import" href="html/src/polymer-basic/templating/name-list.html">

<div class="polymer-demo-container">
    <name-list></name-list>
</div>

++++

*Source code*

.index.html
[source, html]
----
<html>
<head>
	<link rel="import" href="src/polymer-basic/templating/name-list.html">
	<script src="bower_components/webcomponentsjs/webcomponents-loader.js"></script>
</head>
<body>
    <name-list></name-list>
</body>
</html>
----

.src/polymer-basic/templating/name-list.html
[source, html]
----
include::{sourcesdir}/polymer-build/src/polymer-basic/templating/name-list.html[]
----

This example shows how we can work with `dom-if` and dom-repeat templates.

Another interesting detail is how we change properties. We should use special Polymer methods to mutate our properties. If we forget to do it and change our properties as we change local variables (using "=" operator) then UI won't be updated
when property is updated.

[TIP]
====
Strictly speaking, you don't have to always use the `set()` method.
In an example above you could just write `this.newName = '';` and it would work.
However, `this.names.push(this.newName);` wouldn't work in any case.

If you are working with objects, you have to always use the `set()` method.

`this.someObject.someProperty = 'value'; // does not work`

`this.set('someObject.someProperty', 'value'); // works`

If in some cases you use "=", then a further refactoring can easily break the correct behavior by mixing up the rules. So we recommend always use `set()` instead of a simple value assignment. This will guarantee that you won't forget the rules and won't break anything later because of refactoring.
====

What we have learned so far::
+
--
* `dom-if` template can be used when some content should be shown/hidden on some condition.

* `dom-repeat` template can be used to display an array of elements.

* The default values of object properties have to be specified with functions to avoid sharing a state between components.

* We should mutate web component properties by using a set of Polymer methods.
--

[[polymer_manual__basic__events]]
==== Events Firing and Handling

Often child components must notify parent ones that something happened: a button was pushed, a form was confirmed, etc. In Polymer, such notification can be implemented using the standard observer pattern. A child component sends some event and a parent listens to it.

Let's consider the following example: there is a simple form consisting of an input and a button. Users enter their name
and the form notifies the parent component that the form was confirmed and passes the entered name to the parent.

*The form*
[subs="none"]
++++

<link rel="import" href="html/src/polymer-basic/events/event-manager.html">

<div class="polymer-demo-container">
    <event-manager></event-manager>
</div>

++++

*Source code*

.index.html
[source, html]
----
<html>
<head>
	<link rel="import" href="src/polymer-basic/events/event-manager.html">
	<script src="bower_components/webcomponentsjs/webcomponents-loader.js"></script>
</head>
<body>
    <event-manager></event-manager>
</body>
</html>
----

.src/polymer-basic/events/event-manager.html
[source, html]
----
include::{sourcesdir}/polymer-build/src/polymer-basic/events/event-manager.html[]
----

.src/polymer-basic/events/participation-form.html
[source, html]
----
include::{sourcesdir}/polymer-build/src/polymer-basic/events/participation-form.html[]
----

[TIP]
====
If you have some experience with JavaScript events, you probably noticed that we didn't put `e.stopPropagation()`
expression into `formSubmitted(e)` method of the `EventManager` component.
The reason we don't stop propagation is that there is no propagation.

For example, there are Component1, Component2 and Component3.
Component1 contains Component2.
Component2 contains Component3.
Component3 sends some event.
In this case Component2 will receive this event and Component1 won't.
This behavior is convenient in most cases but can be changed by using `composed` property.
See more details in https://www.polymer-project.org/2.0/docs/devguide/events[the official guide].
====

What we have learned so far::
+
--
* The `dispatchEvent(event)` method is used to send events. To create an event, we can use `CustomEvent` constructor
which accepts as parameters the event name (mandatory) and a settings object (optional).
We can put our custom parameters into the `detail` property of the settings object.

* `on-{eventName}` attributes are used to listen to events.

* Event parameters can be retrieved using the `detail` property of an event.
--

[[polymer_manual__basic__library]]
==== Polymer Elements Library

Polymer provides a large set of standard components that are grouped in collections:
https://www.webcomponents.org/collection/PolymerElements/iron-elements[iron-elements], https://www.webcomponents.org/collection/PolymerElements/paper-elements[paper-elements], https://www.webcomponents.org/collection/PolymerElements/app-elements[app-elements], https://www.webcomponents.org/collection/PolymerElements/gold-elements[gold-elements], etc.

The first two collections are the most basic and commonly used:

* Iron elements provide some very basic elements that are required for almost every project: input, label, etc.

* Paper elements provide a set of UI components implementing material design: input, checkbox, slider, etc.

You already saw `iron-input` in our previous examples. Let's check one of the paper elements: `paper-checkbox`. It is a flat design implementation of a simple checkbox. Below is a simple application that uses this element.

*Music taste analyzer*
[subs="none"]
++++

<link rel="import" href="html/src/polymer-basic/library/music-survey.html">

<div class="polymer-demo-container">
    <music-survey></music-survey>
</div>

++++

It’s a component that can analyze person’s music preferences and draw a mental portrait based on it.
Let's check how it works under the hood.

*Source code*

.index.html
[source, html]
----
<html>
<head>
	<link rel="import" href="src/polymer-basic/library/music-survey.html">
	<script src="bower_components/webcomponentsjs/webcomponents-loader.js"></script>
</head>
<body>
    <music-survey></music-survey>
</body>
</html>
----

.src/polymer-basic/library/music-survey.html
[source, html]
----
include::{sourcesdir}/polymer-build/src/polymer-basic/library/music-survey.html[]
----

To learn more about the standard library of Polymer elements visit https://www.webcomponents.org/collection/Polymer/elements

What we have learned so far::
+
--
* Polymer offers a number of ready-to-use components.

* Iron components are the most important components from the standard library.

* Paper components library provides a list of UI components implementing material design.

* We can use `Polymer.dom(this.root).querySelectorAll("some-selector-there")` to find elements in our component.
--