[[quick_start]]
== Quick Start

In this chapter, we will create a small project to demonstrate how to use the business processes subsystem. As an illustration we will  implement a contract approval process software. 

Commonly an approval process involve the following steps:

* A user creates the `Contract` object, defines actors and initiates an approval process.
* An actor with the `Controller` role receives the task to validate an attached contract.
* If the validation is passed then the contract is transferred to the users with the `Manager` role assigned, otherwise the process will be terminated with `Not valid` state.
* After the associated managers approve or reject the contract it turns, respectively, into the `Approved` or `Not approved` state.

[[qs_project_creation]]
=== Creating the Project
. Create a new project in Cuba Studio:

* Project name: `bpm-demo`
* Project namespace: `demo`
* Root package: `com.company.demo`

image::StudioNewProject.png[]

[start=2]
. Open the project properties window (*Project properties* section, *Edit* button).
. Activate the BPM subsystem in the *Base projects* list.

image::StudioSelectBpmModule.png[]

[start=4]
. Press *OK* button at the project properties page. The system will ask you for the confirmation. Agree.

[[qs_data_model_creation]]
=== Creating the Data Model

Go to the *Entities* tab and press *New entity*. The class name is `Contract`.

image::CreateContractEntity.png[]

Create the following entity attributes:

* `number` (`String` type)
* `date` (`Date` type)
* `state` (`String` type)

image::ContractEntityAttributes.png[]

Go to the *Instance name* tab. In the *Name pattern field* enter the value `Contract %s` and add the `number` attribute to *Name pattern attributes*.

image::ContractEntityNamePattern.png[]

Press the *OK* button to save the entity.

[[qs_standard_screen_creation]]
=== Standard screens creation

In the *Entities* section of navigator panel select the `Contract` entity and click the *Generate standard screens* button. Default values of the screen creating window suits us, so just click *Create*.

image::CreateContractScreens.png[]

[[qs_beans_creation]]
=== Creating Business Logic Beans

[[qs_approvalHelper]]
==== ApprovalHelper Bean

The `updateState()` method of the `ApprovalHelper` bean will be invoked from the contract approval process for setting a contract state.

.Method parameters:
* `entityId` - contract entity identifier
* `state` - contract state

Open the project in an IDE. A simple way to do it is to use an *IDE* button from any section of the Studio navigator, e.g. *Project properties*.

Create a package `com.company.demo.core` in the `core` module. Create `ApprovalHelper` class in this package.

.ApprovalHelper.java
[source,java]
----
package com.company.demo.core;

import com.company.demo.entity.Contract;
import com.haulmont.cuba.core.EntityManager;
import com.haulmont.cuba.core.Persistence;
import com.haulmont.cuba.core.Transaction;
import javax.annotation.ManagedBean;
import javax.inject.Inject;
import java.util.UUID;

@ManagedBean("demo_ApprovalHelper")
public class ApprovalHelper {

    @Inject
    private Persistence persistence;

    public void updateState(UUID entityId, String state) {
        Transaction tx = persistence.getTransaction();
        try {
            EntityManager em = persistence.getEntityManager();
            Contract contract = em.find(Contract.class, entityId);
            if (contract != null) {
                contract.setState(state);
            }
            tx.commit();
        } finally {
            tx.end();
        }
    }
}
----

[[qs_run_app]]
=== Creating the Database and Running the Application

Press the *Generate DB scripts* button of the *Entities* navigator section. In the database manager window press the *Create database* button.

image::StudioCreateDatabase.png[]

Start the server with *Run -> Start application server* command.

Open the application in a browser at http://localhost:8080/app or just click the link in the bottom of Studio navigator panel.

[[qs_process_creation]]
=== Creating the Process

[[qs_process_model_creation]]
==== Creating the Process model

The final version of process model will look like this:

image::ProcessFull.png[]

Let's look at the sequence of steps to create the model.

Open the screen *BPM -> Process models* in the running application web interface and press *Create*. Enter the model name `Contract approval` and press *OK*. A new browser tab *Model editor* will be opened.

Select the *Process roles* property in the model properties panel. The process roles edit window will be opened.

image::ProcessRolesProperty.png[]

There are two types of actors participate in the process: a manager and a controller. Create two roles: `Controller` and `Manager`.

image::ProcessRolesEditor.png[]

Drag and drop the *Start event* node from the *Start Events* group to the workspace. We need to display a form to select the process actors when the process starts. Select the start event node. Select the *Start form* in its properties panel - a form selection window will be opened. Select `Standard form` in the *Form name* field. Then add two form parameters:

* `procActorsVisible` with `true` value indicates that a table for process actors selection will be displayed on the form.
* `attachmentsVisible` with `true` value indicates that a table for attachments upload will be displayed on the form.

image::StartForm.png[]

Add the *User task* node from an *Activities* group to the model. Name it `Validation`.

image::ModelValidationNode.png[]

Select this node and assign the `controller` value to the *Process role* property at the properties panel. This is how we defined that the task will be assigned to a process actor with `controller` role.

image::SelectProcRoleForValidation.png[]

Next select the *Task outcomes* property. The window for task outcomes edit will be opened. Outcomes define possible users actions when users receive tasks. Create two outcomes: `Valid` and `Not valid`. Define the `Standard form` for both outcomes. Add form parameter `commentRequired=true` for the `Not valid` outcome, because we want to make a user add a comment in case of invalid contract.

image::OutcomesForValidation.png[]

Depending on the controller's decision we have to send the contract to managers approval or to finish the process with the `Not valid` state. The *Exclusive gateway* node from the *Gateways* group is used to control the process flow. Add it to the workspace and then add two more elements: *Script task* with `Set 'Not valid' state` name and *User task* with `Approval` name. Name the flow to the *Script task* as `Not valid` and the flow to the *User task* should be named `Valid`.

image::ModelValidationExclGateway.png[]

Select the `Not valid` flow. Expand the *Flow outcome* dropdown list from the properties panel. It shows outcomes from the tasks before the gateway. Select the `Not valid` value.

image::NotValidFlowOutcome.png[]

Now, if the `Not valid` outcome is selected, a transition to this flow will be performed.

The `Valid` flow should be marked as the default flow (if no other flows condition are true). Select the `Valid` flow and tick the *Default flow* property.

Next select the Exclusive gateway and open its *Flow order* property editor. Make sure that the `Not valid` flow goes on the first place in a list. If it is not true then change the flows sequence.

image::ValidationFlowOrder.png[]

Let's move to the `Set 'Not valid' state` node. We need to set the `state` property of the Contract entity to the `Not valid` value. Select the node. Set the *Script format* property value to `groovy`. Click on the *Script* property field - the script editor will be opened. Copy and paste the following code there:

[source,groovy]
----
import com.company.demo.entity.Contract

def em = persistence.getEntityManager()
def contract = em.find(Contract.class, entityId)
contract.setState('Not valid')
----

You are allowed to use the process variables and platform objects `persistence` and `metadata` (see https://www.cuba-platform.ru/manual[CUBA Platform. Developer's Manual]) in scripts. An `entityId` variable is created on process start and stores an identifier of the linked entity.

After the contract state is changed, the process should be finished. Let's add an *End event* node from the *End events* group to the workspace and link the node with the `Set 'Not valid' state`.

Let's go back to the `Approval` task. Define the `manager` process role for it like we did for the first task. In order the task to be assigned to many managers simultaneously set its *Multi-instance type* property to `Parallel`. 

image::ApprovalMutlInstanceType.png[]

Create two task outcomes: `Approve` and `Reject` (*Task outcomes* property). For both outcomes set the `Standard form` form and set `commentRequired` parameter to `true` for the `Reject` outcome.

After the approval is completed, or `Approved` either `Not approved` status should be assigned to the contract depending on the approval result. Add an *Exclusive gateway* node after the `Approval task`. Add two *Service task* after the exclusive gateway: `Set 'Approved' state` and `Set 'Not approved' state`. They will do the same thing as the Script task we added earlier, but in another way. They will invoke a Spring bean method. Name the flow to the `Set 'Approved' state` as `Approved`, and name the flow to the `Set 'Not approved' state` as `Not approved`.

image::ModelWithApproval.png[]

Select the `Not approved` flow node and select the `Reject` value in the *Flow outcome* list. Now if at least one of the managers performs the `Reject` action then this outcome will be initiated. Select the `Approved` flow node and check the *Default flow* checkbox. This means that if no other flow is initiated then this flow will be used.

Set the flow order for the Exclusive gateway like we did for the previous one. Select the Exclusive gateway and open the *Flow order* property editor. `Not approved` should be processed first.

image::ApprovalFlowOrder.png[]

Let's go back to the Service task. Select the `Set 'Approved' state` node and set its *Expression* property to the following value:

[source,groovy]
----
${demo_ApprovalHelper.updateState(entityId, 'Approved')}
----

Apply the following script for the `Set 'Not approved' state`:

[source,groovy]
----
${demo_ApprovalHelper.updateState(entityId, 'Not approved')}
----

Activiti engine is integrated with the String framework, so we can access Spring managed beans by their names. `entityId` is a process variable that stores an identifier of the contract which is linked to the process. Its value is set on a process start.

Link both Service tasks with the End event and press the save model button. The model is ready and we can move to the model deployment.

image::ProcessFull.png[]

[[qs_process_model_deployment]]
==== Process Model Deployment

The model deployment process consists of the following steps:

* Generating a process XML in BPMN 2.0 notation from the model.
* Deploying the process to Activiti engine internal tables.
* Creating a ProcDefinition object that relates to the Activiti process.
* Creating ProcRole objects for process roles defined in the model.

Select the model in the list on the *Process models* screen. Press the *Deploy* button. The model deployment window will be displayed. The model is deployed for the first time, so the *Create new process* option is selected. You will be able to deploy the model to existing processes for further model changes. Click *OK*. The process definition is created.

image::DeployModelScreen.png[]

Open the screen *BPM -> Process Definitions*. Open the 'Contract approval' item for editing. Change the *Code* field value to `contractApproval`. We will search the process definition object by this code later in this chapter.

image::ProcDefinitionEdit.png[]

[[qs_screens_adaptation]]
=== Adapting Screens to the Process

In this section, we will add an ability to work with the contract approval process to the contract editor screen.

[[qs_contract_edit_descriptor]]
==== Contract Editor Screen Layout

Find the `contract-edit.xml` screen in the *Screens* panel in Studio and open the screen for editing. Go to the *XML* tab and completely replace its content with the following code:

.contract-edit.xml
[source,xml]
----
include::{sourcesdir}/quickstart/contract-edit.xml[]
----

Go to the *Layout* tab. The resulting screen layout is shown below:

image::ContractEditStudioLayout.png[]

The screen contains a FieldGroup for contract editing, a frame for displaying process actions, and a table with process attachments.

[[qs_contract_edit_controller]]
==== Contract Editor Controller

Go to the *Controller* tab and replace its content with the following code:

.ContractEdit.java
[source,java]
----
include::{sourcesdir}/quickstart/ContractEdit.java[]
----

Press *OK* to save the changes.

Let's examine the controller code in details.

To start the process, we have to create an instance of the process (`ProcInstance` object), link it to a process definition (`ProcDefinition` object), and perform start. The process instance can be started both without a link to any project entity and with this link. In our case a link to the contract is mandatory.

In the beginning of the `postInit()` method an instance of contract approval process is searched by `findProcDefinition()` method, which searches for a process definition with the `contractApproval` code. Next, there is a check whether a ProcInstance object linked with the contract exists in the database (`findProcInstance()` method). If the process instance object doesn't exist, then it is created, the relation to ProcDefinition is set, and a linked entity name and identifier are filled.

[source,java]
----
if (procInstance == null) {
    procInstance = metadata.create(ProcInstance.class);
    procInstance.setProcDefinition(procDefinition);
    procInstance.setEntityName("demo$Contract");
    procInstance.setEntityId(getItem().getId());
}
----

`CommitListener` adds the created `ProcInstance` object to the list of entities that will be sent to the middleware for be committed.

[source,java]
----
getDsContext().addListener(new DsContext.CommitListenerAdapter() {
    @Override
    public void beforeCommit(CommitContext context) {
        if (procInstance != null && PersistenceHelper.isNew(procInstance)) {
            context.getCommitInstances().add(procInstance);
        }
    }
});
----

Next, go to the `initProcActionsFrame()` method.

A `ProcActionsFrame` is a standard frame displaying the buttons with available process actions. `ProcActionsFrame` is linked with a `ProcInstance` instance. If the process is not started yet, the frame will display the start process button. If the process is started and there are active tasks for the current user, then the frame will display buttons for task completion according to the task outcomes defined in the process model. For the detailed information about ProcActionsFrame see <<ui.adoc#proc_actions_frame>>.

[source, java]
----
private void initProcActionsFrame() {
    procActionsFrame.setBeforeStartProcessPredicate(new ProcAction.BeforeActionPredicate() {
        @Override
        public boolean evaluate() {
            if (PersistenceHelper.isNew(getItem())) {
                showNotification(getMessage("saveContract"), NotificationType.WARNING);
                return false;
            }
            return true;
        }
    });
    procActionsFrame.setAfterStartProcessListener(new ProcAction.AfterActionListener() {
        @Override
        public void actionCompleted() {
            showNotification(getMessage("processStarted"), NotificationType.HUMANIZED);
            close(COMMIT_ACTION_ID);
        }
    });
    procActionsFrame.setBeforeCompleteTaskPredicate(new ProcAction.BeforeActionPredicate() {
        @Override
        public boolean evaluate() {
            return commit();
        }
    });
    procActionsFrame.setAfterCompleteTaskListener(new ProcAction.AfterActionListener() {
        @Override
        public void actionCompleted() {
            showNotification(getMessage("taskCompleted"), NotificationType.HUMANIZED);
            close(COMMIT_ACTION_ID);
        }
    });
    procActionsFrame.setCancelProcessEnabled(false);
    procActionsFrame.init(procInstance);
}
----

The `procActionsFrame.setBeforeStartProcessPredicate()` method adds the check that is performed before the process start. If the contract is not saved yet, the process will not start and the warning message will be shown.

The `procActionsFrame.setBeforeCompleteTaskPredicate()` method invokes an editor commit and allows to complete a process action only if the editor commit was successful. 

`setAfterProcessStartListener` and `setAfterCompleteTaskListener` methods will be invoked after corresponding events. They will show the notification and close the contract editor.

After all necessary listeners and predicates are set up, the initialization frame is invoked.

[source,java]
----
procActionsFrame.init(procInstance);
----

UI components are created during the frame initialization.

[[qs_localization]]
==== Localized Messages File

In Studio, open the `messages.properties` file from a package with contract screens. Replace its content with the following text:

[source]
----
messages.properties
browseCaption = Contract browser
editCaption = Contract editor
attachments = Attachments
process = Contract approval
saveContract = Save the contract before starting a process
processStarted = Process started
taskCompleted = Task completed
----

[[qs_work_with_app]]
=== Working With the Application

Hot deploy mechanism is enabled in Studio by default, so all changes in screens should be already sent to the application server. If Hot Deploy is disabled then restart the server in Studio with the *Run -> Restart application server* command.

[[qs_users_creation]]
==== Creating Users

We have to create test users for the process demonstration. Open the *Administration -> Users* screen and create 3 users:

* login: `norman`, First name: `Tommy`, Last name: `Norman`, Full name: `Tommy Norman`
* login: `roberts`, First name: `Casey`, Last name: `Roberts`, Full name: `Casey Roberts`
* login: `pierce`, First name: `Walter`, Last name: `Pierce`, Full name: `Walter Pierce`

[[qs_start_process]]
==== Creating the Contract and Starting the Process

* Open the contract list *Application -> Contracts* and create a new contract. Fill *Number* and *Date* fields, and click *Save* button.
* Click *Start process* button, the start process form should appear. During the model creation we defined the `Standard form` with attributes `procActorsVisible=true` and `attachmentsVisible=true` for the *Start event* node. That's why now we see the form with the process actors and attachments tables.
* Enter a comment and add actors: the controller is `norman` and the two managers are `pierce` and `roberts`.
* Add an attachment by using an *Upload* button from the attachments table.

image::StartProcessForm.png[]

[start=5]
. Press *OK*. Now the process is started.

[[qs_validation]]
==== Controller Validation Stage

Log in as `norman`.

When a process reaches the *User task* node, a `ProcTask` object is created. This object is linked to the particular process actor. The BPM subsystem has a screen for displaying the uncompleted tasks for the current user. Open it: *BPM -> Process tasks*.

image::ProcTaskBrowse.png[]

Wee see that the user `norman` has one uncompleted task `Validation` of the `Contract approval` process. Select it and click the *Open process instance* button. The following screen will appear:

image::ProcInstanceEdit.png[]

It displays the information about the process start time, initiator, attachments list, actors list, process instance tasks list. The screen also allows you to open the linked entity editor and execute a process action. We will complete a process task in another way - using `procActionsFrame` that we added earlier to the contract editor.

Close the *Process Instance Edit* screen and open the contract instance.

image::ContractEditValidation.png[]

The current user (`norman`) has an uncompleted task (ProcTask), so the `procActionsFrame` displays available process actions. When we were defining the `Validation` UserTask node, we set two possible outcomes: `Valid` and `Not valid`. That's why two buttons are added to the `procActionsFrame`.

Click the *Valid* button. In the opened window enter the following comment:

image::ValidationCompleteForm.png[]

Click *OK*.

After the successful validation the contract should go to managers parallel approval.

[[qs_approval]]
==== Manager Approval Stage

Log in as the `pierce` user.

Open the current task list *BPM -> Process tasks*. There is the `Approval` task there.

image::TaskListApproval.png[]

Open the *Process Instance Editor*.

image::ProcInstanceEditApproval.png[]

Pay attention to the *Tasks* table. The previous task `Validation` has been completed with the `Valid` outcome, and two new `Approval` tasks were created for managers `pierce` and `roberts`.

Approve the contract pressing the *Approve* button.

Then log in as `roberts`. Open the contract from the list *Application -> Contracts*.

User `roberts` has an uncompleted task, so the `procActionsFrame` displays *Approve* and *Reject* actions. Click the *Reject* button.

image::CompleteApprovalForm.png[]

When we were defining the `Reject` outcome in the model designer, we set a `commentRequired` form parameter to `true`, therefore you see that the comment is required in the task complete form. Enter the comment and press *OK*.

One of the managers has rejected the contract, so the `Not approved` state should be assigned to the contract. Let's check it. Open the contract.

image::ContractEditNotApproved.png[]

The approval process is completed with the `Not approved` state.