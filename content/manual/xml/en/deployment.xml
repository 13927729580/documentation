<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" []>
<chapter id="chapter_deployment" lang="en"><title lang="en">Application Deployment</title><para>This chapter describes different aspects of CUBA applications deployment and operation.</para>The diagram below shows possible structure of a deployed application.<mediaobject>
    <imageobject>
      <imagedata align="center" fileref="img/DeploymentStructure.png"/>
    </imageobject>
  </mediaobject><para>In the example above, the application prevents a single point of failure existence, provides load balancing and various client types connection. In the simplest case, however, the server part of an application can be installed on one computer that includes the database. Various deployment options depending on load and fault tolerance requirements are described in detail in   <xref linkend="scaling"/>. </para><section id="app_dirs">
    <title>Application Directories</title>
    <para>This section describes file system directories used by various <link linkend="app_tiers">application blocks</link> at runtime.</para>
    <section id="conf_dir">
      <title>Configuration Directory</title>
      <para>The configuration directory is intended for resources that complement and override application properties, user interface and business logic after the application is deployed. Overriding is provided by the loading mechanism of the   <link linkend="resources">Resources</link> infrastructure interface. Firstly it performs search in the configuration directory and then in CLASSPATH, so that resources from the configuration directory take precedence over identically named resources located in JAR files and class directories.</para>
      <para>The configuration directory may contain the following resource types:<itemizedlist>
          <listitem>
            <para> <link linkend="app_properties_files">local.app.properties</link> – a file that defines  deployment parameters of the server-based application blocks.</para>
          </listitem>
          <listitem>
            <para> <link linkend="metadata.xml">metadata.xml</link>, <link linkend="persistence.xml">persistence.xml</link>, <link linkend="views.xml">views.xml</link>,   <link linkend="remoting-spring.xml">remoting-spring.xml</link> configuration files.</para>
          </listitem>
          <listitem>
            <para><link linkend="screen_xml">XML-descriptors</link> of UI screens.</para>
          </listitem>
          <listitem>
            <para><link linkend="screen_controller">Controllers</link> of UI screens in the form of Java or Groovy source code.</para>
          </listitem>
          <listitem>
            <para>Groovy scripts or classes, and Java source code that is used by the application via the  <link linkend="scripting">Scripting</link> interface.</para>
          </listitem>
        </itemizedlist></para>
      <para>The location of the configuration directory is determined by the   <link linkend="cuba.confDir">cuba.confDir</link> application property. For the Middleware, Web Client and Web Portal blocks in  <link linkend="fast_deployment">fast deployment</link> configuration in  <application>Tomcat</application>, it is a subdirectory with the web application name in the   <filename>tomcat/conf</filename> directory, for example,  <filename>tomcat/conf/app-core</filename> for the Middleware.</para>
    </section>
    <section id="work_dir">
      <title>Work Directory</title>
      <para>The application uses the work directory to store data and configuration files.</para>
      <para>For example, the <filename>filestorage</filename> subdirectory of the work directory is used by the <link linkend="file_storage">file storage</link>. In addition, the  Middleware block saves generated <link linkend="persistence.xml">persistence.xml</link> and <filename>orm.xml</filename> files in the work directory on start. </para>
      <para>Work directory location is determined by the  <link linkend="cuba.dataDir">cuba.dataDir</link> application property. For the  Middleware, Web Client and Web Portal blocks in  <link linkend="fast_deployment">fast deployment</link> configuration in <application>Tomcat</application>, it is a subdirectory with the name of the web application in the  <filename>tomcat/work</filename> directory.</para>
    </section>
    <section id="log_dir"><title>Log Directory</title>The application uses the log directory to store log files.<para>The content and settings of the log files are determined by the configuration of the  <application>Apache Log4j</application> framework. The configuration file location is determined by  <link linkend="log4j.configuration">log4j.configuration</link> application property.</para><para>This directory can also be used to store arbitrary information about the running application. The log directory location is determined by   <link linkend="cuba.logDir">cuba.logDir</link> application property. For the  Middleware, Web Client and Web Portal blocks in  <link linkend="fast_deployment">fast deployment</link> configuration   in  <application>Tomcat</application>, it is the  <filename>tomcat/logs</filename> directory.</para><para>See also  <xref linkend="logging"/>.</para></section>
    <section id="temp_dir">
      <title>Temporary Directory</title>
      <para>This directory can be used for creating arbitrary temporary files at application run time. The path to the temporary directory is determined by the   <link linkend="cuba.tempDir">cuba.tempDir</link> application property. For the Middleware, Web Client and Web Portal blocks in  <link linkend="fast_deployment">fast deployment</link> configuration  in  <application>Tomcat</application>, it is a subdirectory with the web application name in the  <filename>tomcat/temp</filename> directory.</para>
    </section>
    <section id="db_dir">
      <title>Database Scripts Directory</title>
      <para>This directory of the deployed Middleware block stores the set of SQL scripts to create and update the DB.</para>
      <para>The script directory structure reproduces the one described in  <xref linkend="db_scripts"/>, but it also has an additional top level that separates  <link linkend="base_projects">base projects</link> and the application scripts. The numbering of top level directories is performed by project build <link linkend="build.gradle">tasks</link>.</para>
      <para>The DB scripts directory location is determined by   <link linkend="cuba.dbDir">cuba.dbDir</link> application property. For <link linkend="fast_deployment">fast deployment</link> configuration  in  <application>Tomcat</application>, it is the  <filename>WEB-INF/db</filename> subdirectory of the middleware web application directory: <filename>tomcat/webapps/app-core/WEB-INF/db</filename>.</para>
    </section>
  </section><section id="deployment_variants" lang="en"><title>Deployment Options</title>This section describes different ways to deploy CUBA applications.<section id="fast_deployment"><title>Fast Deployment in Tomcat</title>Fast deployment is used by default when developing an application, as it provides minimum time for building, installation and starting the application. This option is also convenient when using the application in production.<para>Fast deployment is performed using the   <link linkend="build.gradle_deploy">deploy</link> task that is declared for <structname>core</structname> and <structname>web</structname> modules in the  <filename>build.gradle</filename> file. Before the first execution of  <code>deploy</code>, a local Tomcat server should be set up and initialized using the  <link linkend="build.gradle_setupTomcat">setupTomcat</link> task. </para><para>As result of fast deployment,  the following structure is created in the directory that is specified by the <code>ext.tomcatDir</code> property of the   <filename>build.gradle</filename> script (only important directories and files are listed below):<programlisting>bin/
    setenv.bat, setenv.sh
    startup.bat, startup.sh
    debug.bat, debug.sh
    shutdown.bat, shutdown.sh

conf/
    catalina.properties
    server.xml
    log4j.xml
    logging.properties
    Catalina/
        localhost/
    app/
    app-core/

lib/
    hsqldb-2.2.9.jar

logs/
    app.log

shared/
    lib/

temp/
    app/
    app-core/

webapps/
    app/
    app-core/

work/
    app/
    app-core/</programlisting></para><itemizedlist>
        <listitem>
          <para><filename>bin</filename> – the directory that contains tools to start and stop the Tomcat server:</para>
          <itemizedlist>
            <listitem>
              <para><filename>setenv.bat</filename>, <filename>setenv.sh</filename> – the scripts that set environment variables. These scripts should be used for setting JVM memory parameters, specifying a configuration file for  <link linkend="logging_setup_tomcat">logging</link>, configuring  <link linkend="jmx_remote_access">access to JMX</link>, parameters to  <link linkend="debug_setup">connect the debugger</link>.</para>
            </listitem>
            <listitem>
              <para><filename>startup.bat</filename>, <filename>startup.sh</filename> – the scripts that start Tomcat. The server starts in a separate console window in <application>Windows</application> and in background in  <application>*nix</application>.</para>
              <para>To start the server in the current console window, use the following commands instead of  <filename>startup.*</filename>:</para>
              <para><prompt>&gt; catalina.bat run</prompt></para>
              <para><prompt>$ ./catalina.sh run</prompt></para>
            </listitem>
            <listitem>
              <para><code>debug.bat</code>, <code>debug.sh</code> – the scripts that are similar to  <code>startup.*</code>, but start Tomcat with an ability to connect the debugger. These scripts are launched when running the  <link linkend="build.gradle_start">start</link> task of the build script.</para>
            </listitem>
            <listitem>
              <para><filename>shutdown.bat</filename>, <filename>shutdown.sh</filename> – the scripts that stop Tomcat.</para>
            </listitem>
          </itemizedlist>
        </listitem>
        <listitem>
          <para><filename>conf</filename> – the directory that contains configuration files of Tomcat and its deployed applications.</para>
          <itemizedlist>
            <listitem>
              <para><filename>catalina.properties</filename> – the Tomcat properties. To load shared libraries from the  <filename>shared/lib</filename> directory (see below), this file should contain the following line:<programlisting>shared.loader=${catalina.home}/shared/lib/*.jar</programlisting></para>
            </listitem>
            <listitem>
              <para><filename>server.xml</filename> – Tomcat configuration descriptor.  Server ports can be changed in this file.</para>
            </listitem>
            <listitem>
              <para><filename>log4j.xml</filename> – application  <link linkend="logging_setup_tomcat">logging</link> configuration descriptor.</para>
            </listitem>
            <listitem>
              <para><filename>logging.properties</filename> – Tomcat server logging configuration descriptor.</para>
            </listitem>
            <listitem>
              <para><filename>Catalina/localhost</filename> – in this directory,  <link linkend="context.xml">context.xml</link> application deployment descriptors can be placed. Descriptors located in this directory take precedence over the descriptors in the  <filename>META-INF</filename> application directories. This approach is often convenient for production environment. For example, with this descriptor, it is possible to specify the server-level database connection parameters that are different from those specified in the application itself.</para>
              <para>Server level deployment descriptor should have the application name and the<filename>.xml</filename> extension. So, to create this descriptor, for example, for the  <code>app-core</code> application, the contents of the  <filename>webapps/app-core/META-INF/context.xml</filename> file should be copied to  <filename>conf/Catalina/localhost/app-core.xml</filename> file.</para>
            </listitem>
            <listitem>
              <para><filename>app</filename> – web client application <link linkend="conf_dir">configuration directory</link>.</para>
            </listitem>
            <listitem>
              <para><filename>app-core</filename> – middleware application  <link linkend="conf_dir">configuration directory</link>.</para>
            </listitem>
          </itemizedlist>
        </listitem>
        <listitem>
          <para><filename>lib</filename> – directory of the libraries that are loaded by the server’s  <firstterm>common classloader</firstterm>. These libraries are available for both the server and all web applications deployed in it. In particular, this directory should have JDBC drivers of the utilized databases (<filename>hsqldb-XYZ.jar</filename>, <filename>postgresql-XYZ.jar</filename>, etc.)</para>
        </listitem>
        <listitem>
          <para><code>logs</code> – application and server  <link linkend="logging">logs</link> directory. The main log file of the application is  <filename>app.log</filename>.</para>
        </listitem>
        <listitem>
          <para><filename>shared/lib</filename> – directory of libraries that are available to all deployed applications. These libraries classes are loaded by the server’s special  <firstterm>shared classloader</firstterm>. Its usage is configured in the <filename>conf/catalina.properties</filename> file as described above.</para>
          <para><link linkend="build.gradle_deploy">Deploy</link> tasks of the build file use this directory to store all libraries not listed in the  <code>jarNames</code> parameter, i.e. not specific for the given application.</para>
        </listitem>
        <listitem>
          <para><filename>temp/app</filename>, <filename>temp/app-core</filename> – web client and the middleware applications   <link linkend="temp_dir">temporary directories</link>.</para>
        </listitem>
        <listitem>
          <para><filename>webapps</filename> – web application directories. Each application is located in its own subdirectory in the <firstterm>exploded WAR</firstterm> format.</para>
          <para><link linkend="build.gradle_deploy">Deploy</link> tasks of the build file create application subdirectories with the names specified in the  <code>appName</code> parameters and, among other things, copy the libraries mentioned in the <code>jarNames</code> parameter to the  <filename>WEB-INF/lib</filename> subdirectory for each application.</para>
        </listitem>
        <listitem>
          <para><filename>work/app</filename>, <filename>work/app-core</filename> – web client and the middleware applications  <link linkend="work_dir">work directories</link>.</para>
        </listitem>
      </itemizedlist></section><section id="war_deployment">
      <title>Deployment in WAR</title>
      <para>JavaEE standard  application deployment into WAR files is performed using the  <link linkend="build.gradle_buildWar">buildWar</link> and  <link linkend="build.gradle_createWarDistr">createWarDistr</link> build tasks. An example of building WAR files and their deployment on the <application>Glassfish 4</application> server is provided below.</para>
      <orderedlist>
        <listitem>
          <para>Add tasks to build WAR for the <structname>core</structname> and <structname>web</structname> modules to   <link linkend="build.gradle">build.gradle</link>:<programlisting>configure(coreModule) {
    ...
    task buildWar(dependsOn: assemble, type: CubaWarBuilding) {
        appName = &apos;app-core&apos;
        appHome = &apos;${app.home}&apos;
    }
}

configure(webModule) {
    ...
    task buildWar(dependsOn: assemble, type: CubaWarBuilding) {
        appName = &apos;app&apos;
        appHome = &apos;${app.home}&apos;
    }
}</programlisting></para>
        </listitem>
        <listitem>
          <para>Add the task to build a distribution to <filename>build.gradle</filename>:<programlisting>task createWarDistr(dependsOn: [coreModule.buildWar, webModule.buildWar], type: CubaWarDistribution) {
    appHome = &apos;${app.home}&apos;
}</programlisting></para>
        </listitem>
        <listitem>Start build process:<para><prompt>gradlew createWarDistr</prompt></para><para>As a result, the home directory named <filename>${app.home}</filename> and the  <filename>app-core.war</filename> and <filename>app.war</filename> files are created in the   <filename>build/war</filename> project subdirectory. Name of the home directory does not matter here, as the actual name will be set for the server using a Java system variable.</para></listitem>
        <listitem>
          <para>Copy the content of  <filename>build/war/${app.home}</filename> to the server, for example, to the  <filename>/home/user/app_home</filename> directory.</para>
        </listitem>
        <listitem>
          <para>Install the  <application>Glassfish 4</application> server, for example, into the  <filename>/home/user/glassfish4</filename> directory.</para>
        </listitem>
        <listitem>
          <para>Copy the JDBC driver of the database to the  <filename>/home/user/glassfish4/glassfish/domains/domain1/lib</filename> directory. You can take the driver file from the  <filename>lib</filename> directory in Studio, or from the  <filename>build/tomcat/lib</filename> project directory (if <link linkend="fast_deployment">fast deployment</link> in Tomcat has been performed before).</para>
        </listitem>
        <listitem>
          <para>Start the server:</para>
          <para><prompt>$ cd /home/user/glassfish4/bin</prompt></para>
          <para><prompt>$ ./asadmin start-domain</prompt></para>
        </listitem>
        <listitem>
          <para>Go to  <code>http://localhost:4848</code> and do the following steps in the server management console:</para>
          <orderedlist>
            <listitem>
              <para>Create a  <guilabel>JDBC Connection Pool</guilabel> to connect to our database, for example:<itemizedlist>
                  <listitem>
                    <para>Pool Name: AppDB </para>
                  </listitem>
                  <listitem>
                    <para>Resource Type: javax.sql.DataSource</para>
                  </listitem>
                  <listitem>
                    <para>Database Driver Vendor: Postgresql</para>
                  </listitem>
                  <listitem>
                    <para>Datasource Classname: org.postgresql.ds.PGSimpleDataSource </para>
                  </listitem>
                  <listitem>
                    <para>User: cuba</para>
                  </listitem>
                  <listitem>
                    <para>DatabaseName: app_db</para>
                  </listitem>
                  <listitem>
                    <para>Password: cuba</para>
                  </listitem>
                </itemizedlist></para>
            </listitem>
            <listitem>
              <para>Create a  <guilabel>JDBC Resource</guilabel>:<itemizedlist>
                  <listitem>
                    <para>JNDI Name: jdbc/CubaDS</para>
                  </listitem>
                  <listitem>
                    <para>Pool Name: AppDB</para>
                  </listitem>
                </itemizedlist></para>
            </listitem>
            <listitem>
              <para>In the  <guilabel>server (Admin Server)</guilabel> -&gt; <guilabel>Properties</guilabel> -&gt; <guilabel>System Properties</guilabel> screen, set the following Java system variables:<itemizedlist>
                  <listitem>
                    <para><code>app.home = /home/user/app_home</code> – application home directory.</para>
                  </listitem>
                  <listitem>
                    <para><code>log4j.configuration = file:///home/user/app_home/log4j.xml</code> – application  <link linkend="logging">logging</link> configuration file.</para>
                  </listitem>
                </itemizedlist></para>
            </listitem>
          </orderedlist>
        </listitem>
        <listitem>Restart the server:<para><prompt>$ ./asadmin stop-domain</prompt></para><para><prompt>$ ./asadmin start-domain</prompt></para></listitem>
        <listitem>
          <para>Open the server console at  <code>http://localhost:4848</code> and, in the  <guilabel>Applications</guilabel> screen, perform deployment of the  <filename>app-core.war</filename> and <filename>app.war</filename> files located in the distribution folder created in Step 3. </para>
        </listitem>
        <listitem>
          <para>The application has now been started:<itemizedlist>
              <listitem>
                <para>Web interface is available at  <code>http://localhost:8080/app</code></para>
              </listitem>
              <listitem>
                <para>Log files are created in the  <filename>/home/user/app_home/logs</filename></para>
              </listitem>
            </itemizedlist></para>
        </listitem>
      </orderedlist>
    </section></section><section id="scaling" lang="en">
    <title>Application Scaling</title>
    <para>This section describes ways to scale a CUBA application that consists of the <structname>Middleware</structname> and the <structname>Web Client</structname> for increased load and stronger fault tolerance requirements.</para>
    <para><informaltable frame="all">
        <tgroup cols="2">
          <colspec colname="c1"/>
          <colspec colname="c2"/>
          <tbody>
            <row>
              <entry align="left" valign="top">
                <para role=""><emphasis role="bold">Stage 1. Both blocks are deployed on the same application server.</emphasis> </para>
                <para>This is the simplest option implemented by the standard  <link linkend="fast_deployment">fast deployment</link> procedure.</para>
                <para>In this case, maximum data transfer performance between the <structname>Web Client </structname>and the <structname>Middleware</structname> is provided, because when the <link linkend="cuba.useLocalServiceInvocation">cuba.useLocalServiceInvocation</link> application property is enabled, the Middleware services are invoked bypassing the network stack.</para>
              </entry>
              <entry>
                <mediaobject>
                  <imageobject>
                    <imagedata align="center" fileref="img/scaling_1.png"/>
                  </imageobject>
                </mediaobject>
              </entry>
            </row>
            <row>
              <entry align="left" valign="top">
                <para><emphasis role="bold">Stage 2. The Middleware and the Web Client blocks are deployed on separate application servers.</emphasis></para>
                <para>This option allows you to distribute load between two application servers and use server resources better. Furthermore, in this case the load coming from web users has smaller effect on the other processes execution. Here, the other processes mean handling other client types (for example, Desktop), running <link linkend="scheduled_tasks">scheduled tasks</link> and, potentially, integration tasks which are performed by the middle layer.</para>
                <para>Requirements for server resources:<itemizedlist>
                    <listitem>
                      <para>Tomcat 1 (Web Client):<itemizedlist>
                          <listitem>
                            <para>Memory size – proportional to the number of simultaneous users</para>
                          </listitem>
                          <listitem>
                            <para>CPU power – depends on the usage intensity</para>
                          </listitem>
                        </itemizedlist></para>
                    </listitem>
                    <listitem>
                      <para>Tomcat 2 (Middleware):<itemizedlist>
                          <listitem>
                            <para>Memory size – fixed and relatively small</para>
                          </listitem>
                          <listitem>
                            <para>CPU power – depends on the intensity of web client usage and of other processes  </para>
                          </listitem>
                        </itemizedlist></para>
                    </listitem>
                  </itemizedlist></para>
                <para>In this case and when more complex deployment options are used, the Web Client’s  <link linkend="cuba.useLocalServiceInvocation">cuba.useLocalServiceInvocation</link> application property should be set to  <code>false</code>, and <link linkend="cuba.connectionUrlList">cuba.connectionUrlList</link> property should contain the URL of the Middleware block.</para>
              </entry>
              <entry>
                <mediaobject>
                  <imageobject>
                    <imagedata align="center" fileref="img/scaling_2.png"/>
                  </imageobject>
                </mediaobject>
              </entry>
            </row>
            <row>
              <entry align="left" valign="top">
                <para><emphasis role="bold">Stage 3. A cluster of Web Client servers works with one Middleware server.</emphasis></para>
                <para>This option is used when memory requirements for the Web Client exceed the capabilities of a single JVM due to a large number of concurrent users. In this case, a cluster of Web Client servers (two or more) is started and user connection is performed through a Load Balancer. All Web Client servers work with one Middleware server.</para>
                <para>Duplication of Web Client servers automatically provides fault tolerance at this level. However, the replication of HTTP sessions is not supported, in case of unscheduled outage of one of the Web Client servers, all users connected to it will have to login into the application again.</para>
                <para>Configuration of this option is described in  <xref linkend="cluster_webclient"/>.</para>
              </entry>
              <entry>
                <mediaobject>
                  <imageobject>
                    <imagedata align="center" fileref="img/scaling_3.png"/>
                  </imageobject>
                </mediaobject>
              </entry>
            </row>
            <row>
              <entry align="left" valign="top">
                <para><emphasis role="bold">Stage 4. A cluster of Web Client servers working with a cluster of Middleware servers.</emphasis></para>
                <para>This is the maximum deployment option, which provides fault tolerance and load balancing for the Middleware and the Web Client.</para>
                <para>Connection of users to the Web Client servers is performed through a load balancer. The Web Client servers work with a cluster of Middleware servers. They do not need an additional load balancer – it is sufficient to determine the list of URLs for the Middleware servers in the <link linkend="cuba.connectionUrlList">cuba.connectionUrlList</link> application property.</para>
                <para>Middleware servers exchange the information about user sessions, locks, etc. In this case, full fault tolerance of the Middleware is provided – in case of an outage of one of the servers, execution of requests from client blocks will continue on an available server without affecting users.</para>
                <para>Configuration of this option is described in  <xref linkend="cluster_mw"/>.</para>
              </entry>
              <entry>
                <mediaobject>
                  <imageobject>
                    <imagedata align="center" fileref="img/scaling_4.png"/>
                  </imageobject>
                </mediaobject>
              </entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable></para>
    <section id="cluster_webclient">
      <title lang="en">Setting up a Web Client Cluster</title>
      <para>This section describes the following deployment configuration:<mediaobject>
          <imageobject>
            <imagedata align="center" fileref="img/cluster_webclient.png"/>
          </imageobject>
        </mediaobject></para>
      <para>Servers <code>host1</code> and  <code>host2</code> host Tomcat instances with the <code>app</code> web-app implementing the Web Client block. Users access the load balancer at  <code>http://host0/app</code>, which redirects their requests to the servers. Server  <code>host3</code> hosts a Tomcat instance with the  <code>app-core</code> web-app that implements the Middleware block.</para>
      <section id="cluster_webclient_lb">
        <title>Installing and Setting up a Load Balancer</title>
        <para>Let us consider the installation of a load balancer based on <application>Apache HTTP Server</application> for <application>Ubuntu 14.04</application>.</para>
        <orderedlist>
          <listitem>
            <para>Install  <application>Apache HTTP Server</application> and its  <application>mod_jk</application> module:</para>
            <para><prompt>$ sudo apt-get install apache2 libapache2-mod-jk</prompt></para>
          </listitem>
          <listitem>
            <para>Replace the contents of the  <filename>/etc/libapache2-mod-jk/workers.properties</filename> file with the following:<programlisting>workers.tomcat_home=
workers.java_home=
ps=/

worker.list=tomcat1,tomcat2,loadbalancer,jkstatus

worker.tomcat1.port=8009
worker.tomcat1.host=host1
worker.tomcat1.type=ajp13
worker.tomcat1.connection_pool_timeout=600
worker.tomcat1.lbfactor=1

worker.tomcat2.port=8009
worker.tomcat2.host=host2
worker.tomcat2.type=ajp13
worker.tomcat2.connection_pool_timeout=600
worker.tomcat2.lbfactor=1

worker.loadbalancer.type=lb
worker.loadbalancer.balance_workers=tomcat1,tomcat2

worker.jkstatus.type=status</programlisting></para>
          </listitem>
          <listitem>
            <para>Add the lines listed below to  <code>/etc/apache2/sites-available/000-default.conf</code>:<programlisting>&lt;VirtualHost *:80&gt;
...
    &lt;Location /jkmanager&gt;
        JkMount jkstatus
        Order deny,allow
        Allow from all
    &lt;/Location&gt;

    JkMount /jkmanager/* jkstatus
    JkMount /app loadbalancer
    JkMount /app/* loadbalancer

&lt;/VirtualHost&gt;</programlisting> </para>
          </listitem>
          <listitem>
            <para>Restart the Apache HTTP service:</para>
            <para><prompt>$ sudo service apache2 restart</prompt></para>
          </listitem>
        </orderedlist>
      </section>
      <section id="cluster_webclient_tomcat">
        <title>Setting up Web Client Servers</title>
        <para>On the Tomcat 1 and Tomcat 2 servers, the following settings should be applied:<orderedlist>
            <listitem>
              <para>In  <code>tomcat/conf/server.xml</code>, add the  <code>jvmRoute</code> parameter equivalent to the name of the worker specified in the load balancer settings for <code>tomcat1</code> and <code>tomcat2</code>:<programlisting>&lt;Server port=&quot;8005&quot; shutdown=&quot;SHUTDOWN&quot;&gt;
  ...
  &lt;Service name=&quot;Catalina&quot;&gt;
    ...
    &lt;Engine name=&quot;Catalina&quot; defaultHost=&quot;localhost&quot; jvmRoute=&quot;tomcat1&quot;&gt;
      ...
    &lt;/Engine&gt;
  &lt;/Service&gt;
&lt;/Server&gt;</programlisting></para>
            </listitem>
            <listitem>
              <para>Set the following application properties in  <filename>tomcat/conf/app/local.app.properties</filename>:<programlisting>cuba.useLocalServiceInvocation = false
cuba.connectionUrlList = http://host3:8080/app-core

cuba.webHostName = host1
cuba.webPort = 8080
cuba.webContextName = app</programlisting></para>
              <para><link linkend="cuba.webHostName">cuba.webHostName</link>, <link linkend="cuba.webPort">cuba.webPort</link> and <link linkend="cuba.webContextName">cuba.webContextName</link> parameters are not mandatory for WebClient cluster, but they allow easier identification of a server in other platform mechanisms, such as the  <link linkend="jmx_console"> JMX console</link>. Additionally, <guilabel>Client Info</guilabel>  attribute of  the <guilabel>User Sessions</guilabel> screen shows an identifier of the Web Client that the current user is working with.</para>
            </listitem>
          </orderedlist></para>
      </section>
    </section>
    <section id="cluster_mw">
      <title>Setting up a Middleware Cluster</title>
      <para>This section describes the following deployment configuration:<mediaobject>
          <imageobject>
            <imagedata align="center" fileref="img/cluster_mw.png"/>
          </imageobject>
        </mediaobject></para>
      <para>Servers  <code>host1</code> and <code>host2</code> host Tomcat instances with the  <code>app</code>  web-app implementing the Web Client block. Cluster configuration for these servers is described in the  <link linkend="cluster_webclient">previous section</link>. Servers  <code>host3</code> and <code>host4</code> host Tomcat instances with the <code>app-core</code> web-app implementing the Middleware block. They are configured to interact and share information about user sessions, locks, cash flushes, etc.</para>
      <section id="cluster_mw_client">
        <title>Setting up Connection to the Middleware Cluster</title>
        <para>In order for the client blocks to be able to work with multiple Middleware servers, the list of URLs should be specified to these servers in the  <link linkend="cuba.connectionUrlList">cuba.connectionUrl</link> application property. For the Web Client, this can be done in <filename>tomcat/conf/app/local.app.properties</filename>:<programlisting>cuba.useLocalServiceInvocation = false
cuba.connectionUrlList = http://host3:8080/app-core,http://host4:8080/app-core

cuba.webHostName = host1
cuba.webPort = 8080
cuba.webContextName = app</programlisting></para>
        <para>The order of servers in  <code>cuba.connectionUrl</code> defines priority and order for the client to send the requests. In the example above, the client will first attempt to access  <code>host1</code>, and then, if it is not available, <code>host2</code>. If a request to  <code>host2</code> completes successfully, the client will save <code>host2</code> as the first server in the list and will continue working with this server. Restarting a client will reset the initial values. Uniform distribution of clients among all servers can be achieved using the <link linkend="cuba.randomServerPriority">cuba.randomServerPriority</link> property.</para>
      </section>
      <section id="cluster_mw_server">
        <title>Configuring Interaction between Middleware Servers</title>
        <para>Middleware servers can maintain shared lists of  <link linkend="userSession">user sessions</link> and other objects and coordinate invalidation of caches. <link linkend="cuba.cluster.enabled">cuba.cluster.enabled</link> property should be enabled on each server to achieve this. Example of the <filename>tomcat/conf/app-core/local.app.properties</filename> file is shown below:<programlisting>cuba.cluster.enabled = true

cuba.webHostName = host3
cuba.webPort = 8080
cuba.webContextName = app-core</programlisting></para>
        <para>For the Middleware servers, correct values of the   <link linkend="cuba.webHostName">cuba.webHostName</link>, <link linkend="cuba.webPort">cuba.webPort</link> and <link linkend="cuba.webContextName">cuba.webContextName</link> properties should be specified to form a unique  <link linkend="serverId">Server ID</link>.</para>
        <para>Interaction mechanism is based on  <ulink url="http://www.jgroups.org">JGroups</ulink>. It is possible to fine-tune the interaction using the  <filename>jgroups.xml</filename> file located in the root of <filename>cuba-core-&lt;version&gt;.jar</filename>. It can be copied to  <filename>tomcat/conf/app-core</filename> and configured as needed.</para>
        <para><code>ClusterManagerAPI</code> bean provides the program interface for servers interaction in the Middleware cluster. It can be used in the application – see JavaDocs and examples in the platform code.</para>
      </section>
    </section>
    <section id="serverId">
      <title>Server ID</title>
      <para><firstterm>Server ID</firstterm> is used for reliable identification of servers in a  <structname>Middleware</structname> cluster. The identifier is formatted as <literal>host:port/context</literal>:<programlisting>tezis.haulmont.com:80/app-core</programlisting><programlisting>192.168.44.55:8080/app-core</programlisting></para>
      <para>The identifier is formed based on the configuration parameters <link linkend="cuba.webHostName">cuba.webHostName</link>, <link linkend="cuba.webPort">cuba.webPort</link>, <link linkend="cuba.webContextName">cuba.webContextName</link>, therefore it is very important to specify these parameters for the Middleware blocks working within the cluster. </para>
      <para>Server ID can be obtained using the  <code>ServerInfoAPI</code> bean or via the  <link linkend="serverInfoMBean">ServerInfoMBean</link> JMX interface.</para>
    </section>
  </section><section id="jmx_tools" lang="en">
    <title>Using JMX Tools</title>
    <para>This section describes various aspects of using  <application>Java Management Extensions</application> in CUBA-based applications.</para>
    <section id="jmx_console"><title>Built-In JMX Console</title><para>The Web Client module of the <structname>cuba</structname> base project contains  JMX objects viewing and editing tool. The entry point for this tool is <filename>com/haulmont/cuba/web/app/ui/jmxcontrol/browse/display-mbeans.xml</filename> screen registered under the <code>jmxConsole</code> identifier and accessible via <guimenu>Administration</guimenu> &gt; <guimenu>JMX Console</guimenu> in the standard  application menu.</para><para>Without extra configuration, the console shows all JMX objects registered in the JVM where the Web Client block of the current user is running. Therefore, in the simplest case, when all application blocks are deployed to one web container instance, the console has access to the JMX beans of all tiers as well as the JMX objects of the JVM itself and the web container. </para><para>Names of the application beans have a prefix corresponding to the name of the web-app that contains them. For example, the  <code>app-core.cuba:type=CachingFacade</code> bean has been loaded by the  <structname>app-core</structname> web-app implementing the  Middleware block, while the <code>app.cuba:type=CachingFacade</code> bean has been loaded by the  <structname>app</structname> web-app implementing the  Web Client block.</para><para>JMX console can also work with the JMX objects of a remote JVM. This is useful when application blocks are deployed over several instances of a web container, for example separate  Web Client and Middleware. </para><para>To connect to a remote JVM, a previously created connection should be selected in the  <guilabel>JMX Connection</guilabel> field of the console, or a new connection can be created:</para><figure>
        <title>Editing a JMX Connection</title>
        <mediaobject>
          <imageobject>
            <imagedata align="center" fileref="img/jmx-connection-edit.png"/>
          </imageobject>
        </mediaobject>
      </figure><para>To get a connection, JMX host, port, login and password should be specified. There is also the <guilabel>Host name</guilabel> field, which is populated automatically, if any CUBA-application block is detected at the specified address. In this case, the value of this field is defined as the combination of  <link linkend="cuba.webHostName">cuba.webHostName</link> and   <link linkend="cuba.webPort">cuba.webPort</link> properties of this block, which allows identifying the server that contains it. If the connection is done to a 3rd party JMX interface, then the  <guilabel>Host name</guilabel> field will have the &quot;Unknown JMX interface&quot; value. However it can be changed arbitrarily. </para>In order to allow a remote JVM connection, the JVM should be configured properly (see below).</section>
    <section id="jmx_remote_access">
      <title>Setting up a Remote JMX Connection</title>
      <para>This section describes  <application>Tomcat</application> startup configuration required for a remote connection of JMX tools.</para>
      <section>
        <title>Tomcat JMX for Windows</title>
        <itemizedlist>
          <listitem>
            <para>Edit  <filename>bin/setenv.bat</filename> in the following way:<programlisting>set CATALINA_OPTS=%CATALINA_OPTS% ^
-Dcom.sun.management.jmxremote ^
-Djava.rmi.server.hostname=192.168.10.10 ^
-Dcom.sun.management.jmxremote.ssl=false ^
-Dcom.sun.management.jmxremote.port=7777 ^
-Dcom.sun.management.jmxremote.authenticate=true ^
-Dcom.sun.management.jmxremote.password.file=../conf/jmxremote.password ^
-Dcom.sun.management.jmxremote.access.file=../conf/jmxremote.access</programlisting></para>
            <para>Here, the  <code>java.rmi.server.hostname</code> parameter should contain the actual IP address or the DNS name of the computer where the server is running; <code>com.sun.management.jmxremote.port</code> sets the port for JMX tools connection.</para>
          </listitem>
          <listitem>
            <para>Edit the  <filename>conf/jmxremote.access</filename> file. It should contain user names that will be connecting to the JMX and their access level. For example:<programlisting>admin readwrite</programlisting></para>
          </listitem>
          <listitem>
            <para>Edit the   <filename>conf/jmxremote.password</filename> file. It should contain passwords for the JMX users, for example:<programlisting>admin admin</programlisting></para>
          </listitem>
          <listitem>
            <para>The password file should have reading permissions only for the user running the  <application>Tomcat</application>. server. You  can configure permissions the following way:<itemizedlist>
                <listitem>
                  <para>Open the command line and go to the  <filename>conf</filename> folder</para>
                </listitem>
                <listitem>Run the command:<para><prompt>cacls jmxremote.password /P &quot;domain_name\user_name&quot;:R</prompt>

</para><para>where  <code>domain_name\user_name</code> is the user’s domain and name</para></listitem>
                <listitem>
                  <para>After this command is executed, the file will be displayed as locked (with a lock icon) in  <application>Explorer</application>.</para>
                </listitem>
              </itemizedlist></para>
          </listitem>
          <listitem>
            <para>If  <application>Tomcat</application> is installed as a Windows service, than the service should be started on behalf of the user who has access permissions for  <filename>jmxremote.password</filename>. It should be kept in mind that in this case the <filename>bin/setenv.bat</filename> file is ignored and the corresponding JVM startup properties should be specified in the application that configures the service.</para>
          </listitem>
        </itemizedlist>
      </section>
      <section>
        <title>Tomcat JMX for Linux</title>
        <para><itemizedlist>
            <listitem>
              <para>Edit  <filename>bin/setenv.sh</filename> the following way:<programlisting>CATALINA_OPTS=&quot;$CATALINA_OPTS -Dcom.sun.management.jmxremote \
-Djava.rmi.server.hostname=192.168.10.10 \
-Dcom.sun.management.jmxremote.port=7777 \
-Dcom.sun.management.jmxremote.ssl=false \
-Dcom.sun.management.jmxremote.authenticate=true&quot;

CATALINA_OPTS=&quot;$CATALINA_OPTS -Dcom.sun.management.jmxremote.password.file=../conf/jmxremote.password -Dcom.sun.management.jmxremote.access.file=../conf/jmxremote.access&quot;</programlisting></para>
              <para>Here, the  <code>java.rmi.server.hostname</code> parameter should contain the real IP address or the DNS name of the computer where the server is running;  <code>com.sun.management.jmxremote.port</code> sets the port for JMX tools connection</para>
            </listitem>
            <listitem>
              <para>Edit  <filename>conf/jmxremote.access</filename> file. It should contain user names that will be connecting to the JMX and their access level. For example:<programlisting>admin readwrite</programlisting></para>
            </listitem>
            <listitem>
              <para>Edit the   <filename>conf/jmxremote.password</filename> file. It should contain passwords for the JMX users, for example:<programlisting>admin admin</programlisting></para>
            </listitem>
            <listitem>
              <para>The password file should have reading permissions only for the user running the <application>Tomcat</application> server. Permissions for the current user can be configured the following way:<itemizedlist>
                  <listitem>
                    <para>Open the command line and go to the  <filename>conf</filename> folder.</para>
                  </listitem>
                  <listitem>
                    <para>Run the command:</para>
                    <para><prompt>chmod go-rwx jmxremote.password</prompt>

</para>
                  </listitem>
                </itemizedlist></para>
            </listitem>
          </itemizedlist></para>
      </section>
    </section>
  </section><section id="db_update_in_prod" lang="en">
    <title>Creating and Updating the Database in Production</title>
    <para>This section describes different ways of creating and updating a database during application deployment and operation. To learn more about the structure and the rules of database scripts, please see  <xref linkend="db_scripts"/> and <xref linkend="db_update_in_dev"/>.</para>
    <section id="db_update_in_prod_by_server">
      <title>Execution of Database Scripts by Server</title>
      <para><link linkend="db_update_server">The execution of DB scripts by server</link> mechanism can be used for both database initialization and its further update during the application development and data schema modification.</para>
      <para>The following actions should be completed to initialize a new database:<itemizedlist>
          <listitem>
            <para>Enable the   <link linkend="cuba.automaticDatabaseUpdate">cuba.automaticDatabaseUpdate</link> application property by adding the following line to the  <link linkend="app_properties_files">local.app.properties</link> file:<programlisting>cuba.automaticDatabaseUpdate = true</programlisting></para>
          </listitem>
          <listitem>
            <para>Create an empty database corresponding to the URL specified in the data source description in <link linkend="context.xml">context.xml</link>.</para>
          </listitem>
          <listitem>
            <para>Start the application server containing the  Middleware block. At application start, the database will be initialized and ready for work.</para>
          </listitem>
        </itemizedlist></para>
      <para>After that, each time when the application server starts, a scripts execution mechanism will compare the set of scripts located in the  <link linkend="db_dir">database scripts directory</link> with the list of already executed scripts registered in the database. If new scripts are found, they will be executed and registered as well. Typically it is enough to include the update scripts in each new application version, and the database will be actualized each time when the application server is restarted.</para>
      <para>When using the database scripts execution mechanism at server start, the following should be considered:<itemizedlist>
          <listitem>
            <para>If any error occurs when running a script, the Middleware block stops initialization and becomes inoperable. The client blocks generate messages about inability to connect to the  Middleware. </para>
            <para>Check the  <filename>app.log</filename> file located in  <link linkend="log_dir">the server’s log folder</link> for a message about SQL execution from the <code>com.haulmont.cuba.core.sys.DbUpdaterEngine</code> logger and, possibly, further error messages to identify the error reasons.</para>
          </listitem>
          <listitem>
            <para>The update scripts, as well as the DDL and the SQL commands within the scripts separated with <code>&quot;^&quot;</code>, are executed in separate transactions. That is why when an update fails there is still a big chance that a part of the scripts or even individual commands of the last script will have been executed and committed to the database.</para>
            <para>With this in mind, creating a backup copy of the database immediately before starting the server is highly recommended. Then, when the error reason is fixed, the database can be restored and automatic process restarted.</para>
            <para>If the backup is missing, you should identify which part of the script was executed and committed after the error is fixed. If the entire script failed to execute, the automatic process can be simply restarted. If some of the commands before the erroneous one were separated with the <code>&quot;^&quot;</code> character, executed in a separate transaction and committed, then the remaining part of the commands should be run and this script should be registered in  <database>SYS_DB_CHANGELOG</database> manually. After that, the server can be started and the automatic update mechanism will start processing the next unexecuted script.</para>
              <para>CUBA Studio generates update scripts with ";" delimiter for all database types except
                  Oracle. If update script commands are separated by semicolons, the script is executed in one transaction
                  and entirely rolled back in case of failure. This behavior ensures consistency between the database
                  schema and the list of executed update scripts.</para>
          </listitem>
        </itemizedlist></para>
    </section>
    <section id="db_update_in_prod_cmdline">
      <title>Initializing and Updating a Database from The Command Line</title>
      <para>Database create and update scripts can be run from the command line using the  <code>com.haulmont.cuba.core.sys.utils.DbUpdaterUtil</code> class included in the platform&apos;s Middleware block. At startup, the following arguments should be specified:<itemizedlist>
          <listitem>
            <para><literal>dialect</literal> – DBMS type, possible values: postgres, mssql, oracle.</para>
          </listitem>
          <listitem>
            <para><literal>dbUser</literal> – database user name.</para>
          </listitem>
          <listitem>
            <para><literal>dbPassword</literal> – database user password.</para>
          </listitem>
          <listitem>
            <para><literal>dbUrl</literal> – database connection URL. For primary initialization, the specified database should be empty; the database is not cleared automatically in advance.</para>
          </listitem>
          <listitem>
            <para><literal>scriptsDir</literal> – absolute path to the folder containing scripts in the standard structure. Typically, this is the <link linkend="db_dir">database scripts directory</link> supplied with the application.</para>
          </listitem>
          <listitem>
            <para>one of the possible commands:<itemizedlist>
                <listitem>
                  <para><literal>create</literal> – initialize the database.</para>
                </listitem>
                <listitem>
                  <para><literal>check</literal> – show all unexecuted update scripts.</para>
                </listitem>
                <listitem>
                  <para><literal>update</literal> – update the database.</para>
                </listitem>
              </itemizedlist></para>
          </listitem>
        </itemizedlist></para>
      <para>An example of a script for Linux running <code>DbUpdaterUtil</code>:<programlisting language="bash">#!/bin/sh

DB_URL=&quot;jdbc:postgresql://localhost/mydb&quot;

APP_CORE_DIR=&quot;./../webapps/app-core&quot;
WEBLIB=&quot;$APP_CORE_DIR/WEB-INF/lib&quot;
SCRIPTS=&quot;$APP_CORE_DIR/WEB-INF/db&quot;
TOMCAT=&quot;./../lib&quot;
SHARED=&quot;./../shared/lib&quot;

CLASSPATH=&quot;&quot;
for jar in `ls &quot;$TOMCAT/&quot;`
do
  CLASSPATH=&quot;$TOMCAT/$jar:$CLASSPATH&quot;
done

for jar in `ls &quot;$WEBLIB/&quot;`
do
  CLASSPATH=&quot;$WEBLIB/$jar:$CLASSPATH&quot;
done

for jar in `ls &quot;$SHARED/&quot;`
do
  CLASSPATH=&quot;$SHARED/$jar:$CLASSPATH&quot;
done

java -cp $CLASSPATH com.haulmont.cuba.core.sys.utils.DbUpdaterUtil \
 -dialect postgres -dbUrl $DB_URL \
 -dbUser $1 -dbPassword $2 \
 -scriptsDir $SCRIPTS \
 -$3</programlisting></para>
      <para>This script is designed to work with the database named  <literal>mydb</literal> running on the local <application>PostgreSQL</application> server. The script should be located in the <filename>bin</filename> folder of the Tomcat server and should be started with <literal>{username}</literal>, <literal>{password}</literal> and <literal>{command}</literal>, for example:</para>
      <para><prompt>./dbupdate.sh cuba cuba123 update</prompt></para>
      <para>Script execution progress is displayed in the console. If any error occurs, same actions as described in the previous section for the automatic update mechanism should be performed.</para>
      <warning>
        <para>When updating the database from the command line, the existing Groovy scripts are started, but only their main part gets executed. Due to the lack of the server context, the script’s <code>PostUpdate</code> part is ignored with the corresponding message written to the console.</para>
      </warning>
    </section>
  </section></chapter>
