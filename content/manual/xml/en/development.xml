<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" []>
<chapter id="chapter_development" lang="en" xmlns:xi="http://www.w3.org/2001/XInclude">
  <title lang="en">Application Development</title>
  <para>This chapter contains practical information on how to create platform-based applications.</para>
  <section>
    <title lang="en">Recommended Code Style</title>
    <para><emphasis role="bold">Code Formatting</emphasis></para>
    <itemizedlist>
      <listitem>
        <para>For Java and Groovy code, it is recommended to follow the standard style described in <ulink url="http://www.oracle.com/technetwork/java/codeconvtoc-136057.html">Code Conventions for the Java Programming Language</ulink>. When programming in  <application>IntelliJ IDEA</application>, you can just use the default style and  <keycap>Ctrl-Alt-L</keycap> shortcut for formatting.</para>
        <para>The maximum line length is 120 characters. The indentation is 4 characters; using spaces instead of tabs is enabled.</para>
      </listitem>
      <listitem>
        <para>XML code: indentation is 4 characters; using spaces instead of tabs is enabled.</para>
      </listitem>
    </itemizedlist>
    <para><emphasis role="bold">Naming Conventions</emphasis></para>
    <informaltable frame="all" align="center">
      <tgroup cols="3" align="center">
        <colspec colname="c1"/>
        <colspec colname="c2"/>
        <colspec colname="c3"/>
        <thead wordsize="16">
          <row>
            <entry colname="Имя атрибута" role="bord">Identifier</entry>
            <entry colname="Тип атрибута" role="caption">Naming Rule</entry>
            <entry colname="Тип атрибута" role="caption">Example</entry>
          </row>
        </thead>
        <tbody>
          <row>
            <entry namest="c1" nameend="c3" align="center">
              <emphasis role="bold">Java and Groovy classes </emphasis>
            </entry>
          </row>
          <row>
            <entry align="left">Screen controller class</entry>
            <entry align="left">
              <para>UpperCamelCase</para>
              <para>Browse screen controller <code>− {EntityClass}Browse</code></para>
              <para>Edit screen controller <code>− {EntityClass}Edit</code>.</para>
            </entry>
            <entry align="left">
              <para><code>CustomerBrowse</code></para>
              <para><code>OrderEdit</code></para>
            </entry>
          </row>
          <row>
            <entry namest="c1" nameend="c3" align="center">
              <emphasis role="bold">XML screen descriptors</emphasis>
            </entry>
          </row>
          <row>
            <entry align="left">Component identifier, parameter names in queries</entry>
            <entry align="left">
              <para>lowerCamelCase, only letters and numbers.</para>
            </entry>
            <entry align="left">
              <para><literal>attributesTable</literal></para>
              <para><literal>:component$relevantTo</literal></para>
              <para><literal>:ds$attributesDs</literal></para>
            </entry>
          </row>
          <row>
            <entry align="left">Datasource identifier</entry>
            <entry align="left">
              <para>lowerCamelCase, only letters and numbers ending with <code>Ds</code>.</para>
            </entry>
            <entry align="left">
              <code>attributesDs</code>
            </entry>
          </row>
          <row>
            <entry namest="c1" nameend="c3" align="center">
              <emphasis role="bold">SQL scripts</emphasis>
            </entry>
          </row>
          <row>
            <entry align="left">Reserved words</entry>
            <entry align="left">lowercase</entry>
            <entry align="left">
              <literal>create table</literal>
            </entry>
          </row>
          <row>
            <entry align="left">Tables</entry>
            <entry align="left">UPPER_CASE. The name is preceded by the project name to form a namespace. It is recommended to use singular form in table names.</entry>
            <entry align="left">
              <para><literal>SALES_CUSTOMER</literal></para>
            </entry>
          </row>
          <row>
            <entry align="left">Columns</entry>
            <entry align="left">UPPER_CASE</entry>
            <entry align="left">
              <para><literal>CUSTOMER</literal></para>
              <para><literal>TOTAL_AMOUNT</literal></para>
            </entry>
          </row>
          <row>
            <entry align="left">Foreign key columns</entry>
            <entry align="left">UPPER_CASE. Consists of the table referred by the column (without the project prefix) and the _ID suffix.</entry>
            <entry align="left">
              <literal>CUSTOMER_ID</literal>
            </entry>
          </row>
          <row>
            <entry align="left">Indexes</entry>
            <entry align="left">UPPER_CASE. Consists of the IDX_ prefix, name of the table that the index is created for (with the project prefix) and names of the fields included in the index.</entry>
            <entry align="left">
              <literal>IDX_SALES_CUSTOMER_NAME</literal>
            </entry>
          </row>
        </tbody>
      </tgroup>
    </informaltable>
  </section>
  <section id="project_file_structure">
    <title lang="en">Project File Structure</title>
    <para>Below is the project file structure of a simple application,  <application>Sales</application>, consisting of the  <structname>Middleware</structname>,  <structname>Web Client</structname> and <structname>Web Portal</structname> <link linkend="app_tiers">blocks</link>.</para>
    <figure>
      <title lang="en">Project File Structure</title>
      <mediaobject>
        <imageobject>
          <imagedata align="center" fileref="img/project_structure.png"/>
        </imageobject>
      </mediaobject>
    </figure>
    <para>The project root contains build scripts (<filename>build.gradle</filename>, <filename>settings.gradle</filename>) and  <application>IntelliJ IDEA</application> project files.</para>
    <para id="text_module_id">The  <filename>modules</filename> directory includes the subdirectories of the project  <link linkend="app_modules">modules</link> − <structname>global</structname>, <structname>core</structname>, <structname>gui</structname>, <structname>portal, web</structname>. </para>
    <figure>
      <title lang="en">The global Module Structure</title>
      <mediaobject>
        <imageobject>
          <imagedata align="center" fileref="img/project_structure_global.png"/>
        </imageobject>
      </mediaobject>
    </figure>
    <para>The  <structname>global</structname> module contains the source code directory,  <filename>src</filename>, with configuration files –  <link linkend="metadata.xml">metadata.xml</link>, <link linkend="persistence.xml">persistence.xml</link> and <link linkend="views.xml">views.xml</link>. The  <code>com.sample.sales.core</code> package contains interfaces of the  <structname>Middleware</structname> services; the  <code>com.sample.sales.entity</code> package contains  <link linkend="data_model">entity</link> classes and  <link linkend="message_packs">localization files</link> for them.</para>
    <figure>
      <title lang="en">The core Module Structure</title>
      <mediaobject>
        <imageobject>
          <imagedata align="center" fileref="img/project_structure_core.png"/>
        </imageobject>
      </mediaobject>
    </figure>
    <para>The  <structname>core</structname> module contains the following directories:<itemizedlist>
        <listitem>
          <para><filename>db</filename> – directory with the database <link linkend="db_scripts">create and update scripts</link>.</para>
        </listitem>
        <listitem>
          <para><filename>src</filename> – source code directory; its root contains the  <link linkend="app_properties_files">application properties</link> file of the  <structname>Middleware</structname> block and the <link linkend="spring.xml">spring.xml</link> configuration file. The  <code>com.samples.sales.core</code> package contains the   <structname>Middleware</structname> classes: implementations of  <link linkend="services">services</link>, <link linkend="managed_beans">managed beans</link> and <link linkend="jmx_beans">JMX beans</link>.</para>
        </listitem>
        <listitem>
          <para lang="en"><filename>web</filename> – directory with the configuration files of the web application built from the  <structname>Middleware</structname> block:  <link linkend="context.xml">context.xml</link> and <link linkend="web.xml">web.xml</link>.</para>
        </listitem>
      </itemizedlist></para>
    <figure>
      <title>The gui Module Structure</title>
      <mediaobject>
        <imageobject>
          <imagedata align="center" fileref="img/project_structure_gui.png"/>
        </imageobject>
      </mediaobject>
    </figure>
    <para>The  <structname>gui</structname> module includes the source code directory, <filename>src</filename>, with the  <link linkend="screens.xml">screens.xml</link> configuration file. The  <code>com.sample.sales.gui</code> package contains XML descriptors and screen controllers, and   <link linkend="message_packs">localization files</link> for them.</para>
    <figure>
      <title>The web Module Structure</title>
      <mediaobject>
        <imageobject>
          <imagedata align="center" fileref="img/project_structure_web.png"/>
        </imageobject>
      </mediaobject>
    </figure>
    <para>The  <structname>web</structname> module contains the following directories:<itemizedlist>
        <listitem>
          <para><filename>src</filename> – source code directory with the  <link linkend="app_properties_files">application properties</link> file of the  <structname>Web Client</structname> block and configuration files –  <link linkend="menu.xml">web-menu.xml</link>, <link linkend="permissions.xml">web-permissions.xml</link>,  <link linkend="screens.xml">web-screens.xml</link> and  <link linkend="spring.xml">web-spring.xml</link>. The  <code>com.samples.sales.web</code> package contains the main class of the  <structname>Web Client</structname> block (inheritor of  <code>DefaultApp</code>) and the <link linkend="main_message_pack">main localized messages pack</link>.</para>
        </listitem>
        <listitem>
          <para><filename>web</filename> – directory with configuration files of the web application built from the  <structname>Web Client</structname>:  <link linkend="context.xml">context.xml</link> and <link linkend="web.xml">web.xml</link>.</para>
        </listitem>
      </itemizedlist></para>
  </section>
  <section id="build_scripts">
    <title>Build Scripts Overview</title>
    <para>Platform based projects are built using  <application>Gradle</application> build system. Build scripts are two files in the project root directory:<itemizedlist>
        <listitem>
          <para><filename>settings.gradle</filename> – defines the project name and the set of <link linkend="app_modules">modules</link>.</para>
        </listitem>
        <listitem>
          <para><filename>build.gradle</filename> – defines the build configuration.</para>
        </listitem>
      </itemizedlist></para>
    <para>This section describes the structure of the scripts and the purpose and parameters of Gradle tasks.</para>
    <section id="build.gradle">
      <title>The Structure of build.gradle</title>
      <para>The  <code>allprojects</code> section defines the group and version of the project  <link linkend="artifact">artifacts</link> being built. Artifact names are based on module names specified in <filename>settings.gradle</filename>. If the <code>ext.isSnapshot</code> property is  <code>true</code>, artifact names will have the <code>SNAPSHOT</code> suffix. The <code>ext.tomcatDir</code> property sets the location of the Tomcat <link linkend="build.gradle_setupTomcat">installation</link> directory. Furthermore, the  <code>allprojects</code> section may have the following optional properties:<itemizedlist>
          <listitem>
            <para><code>ext.copyright</code> – the copyright notice text that is inserted by  <application>IntelliJ IDEA</application> into the source text files.</para>
          </listitem>
          <listitem>
            <para><code>ext.vcs</code> – type of VCS used in the project. If this property is specified, IntelliJ IDEA’s generated project files will have a VCS integration parameter for this VCS. Possible values:  <literal>svn</literal>, <literal>git</literal>. </para>
          </listitem>
          <listitem>
            <para><code>ext.uploadUrl</code> – URL of the  <link linkend="artifact_repository">repository</link> where assembled project artifacts will be uploaded to upon completion of the  <code>uploadArchives</code> task.  <orgname>Haulmont</orgname> repository is used by default.</para>
          </listitem>
          <listitem>
            <para><code>ext.uploadUser</code> – name of the repository user that will be used to upload assembled project artifacts. <literal>HAULMONT_REPOSITORY_USER</literal> environment variable value is used by default.</para>
          </listitem>
          <listitem>
            <para><code>ext.uploadPassword</code> repository user password that will be used to upload assembled project artifacts.  <literal>HAULMONT_REPOSITORY_PASSWORD</literal> environment variable value is used by default. </para>
          </listitem>
        </itemizedlist><tip>
          <para>Instead of setting project properties in <filename>build.gradle</filename> itself, you can do it by passing a command-line argument with the  <literal>-P</literal> prefix, for example:</para>
          <para><prompt>gradlew uploadArchives -PuploadUser=myuser -PuploadPassword=mypassword</prompt></para>
        </tip></para>
      <para>In the   <code>buildscript</code> section, the following actions are executed:<itemizedlist>
          <listitem>
            <para>The base projects version  is specified.</para>
          </listitem>
          <listitem>
            <para>The set of repositories for loading project dependencies  is specified. Values of  <code>repoUser</code> and   <code>repoPass</code> project properties or standard values explicitly set in the build script are used as credentials to access the repository. Similar to other project properties, you can pass  <code>repoUser</code> and <code>repoPass</code> in the command line arguments with  <literal>-P</literal> prefix.</para>
          </listitem>
          <listitem>
            <para>Dependency from the  <structname>cuba-plugin</structname> is declared; the plugin contains the project&apos;s build specifics and is connected to the module build configuration using the following method:<programlisting>apply(plugin: &apos;cuba&apos;)</programlisting></para>
          </listitem>
        </itemizedlist></para>
      <para>Then, application modules building parameters are defined  in the  <code>configure</code> section.</para>
      <para><firstterm>Tasks</firstterm> are executable units in Gradle. They are defined both in the plugins and in the build script itself. Below are CUBA-specific tasks; their parameters can be configured in <filename>build.gradle</filename>.<itemizedlist>
          <listitem>
            <para><code>enhance</code> – the  <code>CubaEnhancing</code>-type task that executes bytecode enhancement of persistent entity classes. It is declared in the <structname>global</structname> <link linkend="app_modules">module</link>. The path to the  <link linkend="persistence.xml">persistence.xml</link> project file is specified in the <code>persistenceXml</code> task parameter.</para>
            <para>For example:<programlisting>task enhance(type: CubaEnhancing) {
    persistenceXml = &quot;${globalModule.projectDir}/src/persistence.xml&quot;
}</programlisting></para>
          </listitem>
          <listitem id="build.gradle_enhanceTransient">
            <para><code>enhanceTransient</code> – the  <code>CubaEnhanceTransient</code>-type task that executes bytecode enhancement of non-persistent entity classes. The path to the <link linkend="metadata.xml">metadata.xml</link> project file is specified in the  <code>metadataXml</code> task parameter.</para>
            <para>For example:<programlisting><xi:include href="../../source/development/build_gradle_enhanceTransient_1.groovy" encoding="UTF-8" parse="text"/></programlisting></para>
          </listitem>
          <listitem id="build.gradle_setupTomcat">
            <para><code>setupTomcat</code> – the  <code>CubaSetupTomcat</code>-type task that performs installation and initialization of the local Tomcat server for subsequent <link linkend="fast_deployment">fast deployment</link> of the application. This task is automatically added to the project when you connect the  <structname>cuba</structname> build plugin, so you don’t need to declare it in <filename>build.gradle</filename>. Tomcat installation directory is specified by the  <code>ext.tomcatDir</code> property in the <code>allprojects</code> section. By default, it is the project’s <filename>build/tomcat</filename> subfolder.</para>
          </listitem>
          <listitem id="build.gradle_deploy">
            <para><code>deploy</code> – the  <code>CubaDeployment</code>-type task that performs  <link linkend="fast_deployment">fast deployment</link> of a module to Tomcat. It is declared in the  <structname>core</structname>, <structname>web</structname> and  <structname>portal</structname> modules. Parameters:<itemizedlist>
                <listitem>
                  <para><code>appName</code> – name of the web application that will be created from the module. In fact, it is the name of a subdirectory inside <filename>tomcat/webapps</filename>.</para>
                </listitem>
                <listitem>
                  <para><code>jarNames</code> – the list of  JAR file names (without versions) produced as a result of building a module and intended to be placed into the <filename>WEB-INF/lib</filename> catalog of the web application. All other module artifacts and dependencies will be copied to <filename>tomcat/shared/lib</filename>.</para>
                </listitem>
              </itemizedlist></para>
            <para>For example:<programlisting>task deploy(dependsOn: assemble, type: CubaDeployment) {
    appName = &apos;app-core&apos;
    jarNames = [&apos;cuba-global&apos;, &apos;cuba-core&apos;, &apos;app-global&apos;, &apos;app-core&apos;]
}</programlisting></para>
          </listitem>
          <listitem id="build.gradle_buildWar">
            <para><code>buildWar</code> – the  <code>CubaWarBuilding</code>-type task that builds a module into a WAR file. It can be declared in the  <structname>core</structname>, <structname>web</structname> and  <structname>portal</structname> modules, if  <link linkend="war_deployment">application deployment to WAR</link> is required. The built WAR files are located in the <filename>build/distributions</filename> module subdirectories.</para>
            <para>Task parameters:<itemizedlist>
                <listitem>
                  <para><code>appName</code> – the name of the resulting WAR file.</para>
                </listitem>
                <listitem>
                  <para><code>appHome</code> – the path to the application home directory. The home directory contains the  <link linkend="logging">logging</link> configuration file, the <link linkend="db_dir">database scripts directory</link>, and the <link linkend="conf_dir">configuration</link>, <link linkend="temp_dir">temporary</link> and <link linkend="work_dir">work</link> directories of the application.</para>
                  <para>In the  <code>appHome</code> parameter, you can specify either an absolute path to the home directory or a system variable, which should be set at server start. For example: <code>appHome = &apos;/work/sales_home&apos;</code> or  <code>appHome = &apos;${app.home}&apos;</code>.</para>
                </listitem>
                <listitem>
                  <para><code>appProperties</code> – the map of the properties that will be written to the  <filename>WEB-INF/local.app.properties</filename> file in addition to those defined in the task itself. By default, the  <code>buildWar</code> task creates this file and defines properties <code>cuba.logDir</code>, <code>cuba.confDir</code>, <code>cuba.tempDir</code>, <code>cuba.dataDir</code> in it, in order to work with the application home directory mentioned above. Additionally, the following parameter is set for the middleware:<programlisting>cuba.dataSourceJndiName = jdbc/CubaDS</programlisting>and for the web client:<programlisting>cuba.connectionUrl = http://localhost:8080/${appName}-core
cuba.useLocalServiceInvocation = false</programlisting></para>
                </listitem>
              </itemizedlist></para>
            <para>An example of a task in the  <structname>web</structname> module:
              <programlisting><xi:include href="../../source/development/build_gradle_buildWar_1.groovy" encoding="UTF-8" parse="text"/></programlisting>
            </para>
          </listitem>
          <listitem id="build.gradle_createWarDistr">
            <para><code>createWarDistr</code> – the  <code>CubaWarDistribution</code>-type task that prepares the distribution that includes application  <link linkend="war_deployment">WAR files</link> and their home directory. The task must depend on the tasks of the <code>buildWar</code> module and have the following parameters:<itemizedlist>
                <listitem>
                  <para><code>appHome</code> – the path to the home directory of the application (see  <code>buildWar</code> task description for details).</para>
                </listitem>
                <listitem>
                  <para><code>distrDir</code> – target folder for the distribution content. It is an optional parameter; by default, the <filename>build/war</filename> project subdirectory is used.</para>
                </listitem>
              </itemizedlist></para>
            <para>Below is a sample task description:<programlisting>task createWarDistr(dependsOn: [coreModule.buildWar, webModule.buildWar], type: CubaWarDistribution) {
    appHome = &apos;${app.home}&apos;
}</programlisting></para>
          </listitem>
          <listitem id="build.gradle_createDb">
            <para><code>createDb</code> – the  <code>CubaDbCreation</code>-type task that creates application database by executing the corresponding  <link linkend="db_scripts">scripts</link>. It is declared in the <structname>core</structname> module. Parameters:<itemizedlist>
                <listitem>
                  <para><code>dbms</code> – the DBMS type; specified as string (<code>hsql</code>, <code>postgres</code>, <code>mssql</code>, or <code>oracle</code>).</para>
                </listitem>
                <listitem>
                  <para><code>dbName</code> – the database name.</para>
                </listitem>
                <listitem>
                  <para><code>dbUser</code> – the DBMS username.</para>
                </listitem>
                <listitem>
                  <para><code>dbPassword</code> – the DBMS user password.</para>
                </listitem>
                <listitem>
                  <para><code>host</code> – the DBMS host and port (optional) in the  <code>host[:port]</code> format. If not specified,  <code>localhost</code> is used. </para>
                </listitem>
                <listitem>
                  <para><code>masterUrl</code> – the URL used to connect when creating the database. If not specified,
                    the default value that depends on the DBMS type and the <code>host</code> parameter is used.</para>
                </listitem>
                <listitem>
                  <para><code>dropDbSql</code> – the SQL command to delete the database. If not specified, the default value that depends on the DBMS type is used.</para>
                </listitem>
                <listitem>
                  <para><code>createDbSql</code> – the SQL command to create a database. If not specified, the default value that depends on the DBMS type is used.</para>
                </listitem>
                <listitem>
                  <para><code>driverClasspath</code> – the list of  JAR files containing the JDBC driver. The items in the list are separated by &quot;:&quot; on Linux and by &quot;;&quot; on Windows. If not specified, the system uses the dependencies that are part of the current module’s  <code>jdbc</code> configuration. Explicit definition of  <code>driverClasspath</code> is necessary when using Oracle, because its JDBC driver is not available in the dependencies.</para>
                </listitem>
                <listitem>
                  <para><code>oracleSystemPassword</code> – the SYSTEM user password for Oracle.</para>
                </listitem>
              </itemizedlist></para>
            <para>Example for PostgreSQL:<programlisting>task createDb(dependsOn: assemble, description: &apos;Creates local database&apos;, type: CubaDbCreation) {
    dbms = &apos;postgres&apos;
    dbName = &apos;sales&apos;
    dbUser = &apos;cuba&apos;
    dbPassword = &apos;cuba&apos;
}</programlisting></para>
            <para>Example for MS SQL Server:<programlisting>task createDb(dependsOn: assemble, description: &apos;Creates local database&apos;, type: CubaDbCreation) {
    dbms = &apos;mssql&apos;
    dbName = &apos;sales&apos;
    dbUser = &apos;sa&apos;
    dbPassword = &apos;saPass1&apos;
}</programlisting></para>
            <para>Example for Oracle:<programlisting>task createDb(dependsOn: assemble, description: &apos;Creates database&apos;, type: CubaDbCreation) {
    dbms = &apos;oracle&apos;
    host = &apos;192.168.1.10&apos;
    dbName = &apos;orcl&apos;
    dbUser = &apos;sales&apos;
    dbPassword = &apos;sales&apos;
    oracleSystemPassword = &apos;manager&apos;
    driverClasspath = &quot;$tomcatDir/lib/ojdbc6.jar&quot;
}</programlisting></para>
          </listitem>
          <listitem id="build.gradle_updateDb">
            <para><code>updateDb</code> – the  <code>CubaDbUpdate</code>-type task that updates the database by executing the corresponding  <link linkend="db_scripts">scripts</link>. It is similar to the  <code>createDb</code> task, except that the  <code>dropDbSql</code> and  <code>createDbSql</code> parameters are omitted.</para>
          </listitem>
          <listitem>
            <para><code>startDb</code> – the  <code>CubaHsqlStart</code>-type task that starts the local HSQLDB server. Parameters:<itemizedlist>
                <listitem>
                  <para><code>dbName</code> – database name, default is  <code>cubadb</code>.</para>
                </listitem>
                <listitem>
                  <para><code>dbDataDir</code> – database directory, default is the  <code>data</code> subfolder of the project.</para>
                </listitem>
                <listitem>
                  <para><code>dbPort</code> – server port, default is  9001.</para>
                </listitem>
              </itemizedlist></para>
            <para>For example:
              <programlisting><xi:include href="../../source/development/build_gradle_startDb_1.groovy" encoding="UTF-8" parse="text"/></programlisting>
            </para>
          </listitem>
          <listitem>
            <para><code>stopDb</code> – the  <code>CubaHsqlStop</code>-type task that stops the local HSQLDB server. The parameters are similar to <code>startDb</code>.</para>
          </listitem>
          <listitem id="build.gradle_start">
            <para><code>start</code> – the  <code>CubaStartTomcat</code>-type task that starts the local Tomcat server installed by the <link linkend="build.gradle_setupTomcat">setupTomcat</link> task. This task is automatically added to the project when you add the <structname>cuba</structname> plugin, so you don’t need to declare it in   <filename>build.gradle</filename>.</para>
          </listitem>
          <listitem id="build.gradle_stop">
            <para><code>stop</code> – the  <code>CubaStopTomcat</code> type task that stops the local Tomcat server installed by the  <link linkend="build.gradle_setupTomcat">setupTomcat</link>  task. This task is automatically added to the project when you include the  <structname>cuba</structname> plugin, so you don’t need to declare it in <filename>build.gradle</filename>.</para>
          </listitem>
          <listitem id="build.gradle_restart">
            <para><code>restart</code> – the task that stops the local Tomcat server, runs  <link linkend="fast_deployment">fast deployment</link>, and starts the server once again.</para>
          </listitem>
        </itemizedlist></para>
    </section>
    <section id="build_task_start">
      <title lang="en">Starting Build Tasks</title>
      <para>Gradle tasks described in  build scripts can be launched  in the following ways:<itemizedlist>
          <listitem>
            <para>If you are working with the project in  <application>CUBA Studio</application>, you can use the  <guimenu>Build</guimenu> and  <guimenu>Run</guimenu> menu items to connect to the Gradle daemon (launched at the start of Studio server), which will perform the corresponding tasks.</para>
          </listitem>
          <listitem>
            <para>Alternatively, you can use the executable  <filename>gradlew</filename> script (Gradle wrapper) included in the project. The script should be located in the project root directory and can be created in Studio using the  <guimenu>Build</guimenu> &gt; <guimenu>Create Gradle wrapper</guimenu> command.</para>
          </listitem>
          <listitem>
            <para>One more way is to use the manually installed Gradle version   <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="../../var/gradleVersion.txt" encoding="UTF-8" parse="text"/>. In this case, the executable   <filename>gradle</filename> script located in the  <filename>bin</filename> subdirectory of the installed Gradle, is used.</para>
          </listitem>
        </itemizedlist></para>
      <tip lang="en">
        <para>It is recommended to run the <literal>gradlew</literal> or  <literal>gradle</literal> commands with the <literal>--daemon</literal> key; in this case the Gradle daemon is retained in memory, which significantly accelerates the subsequent execution.

</para>
        <para>To remove the daemon from memory, you can use the  <literal>--stop</literal> key. </para>
      </tip>
      <para>For example, in order to compile the Java files and build the JAR files for project artifacts, you need to run the following command:</para>
      <para><prompt>gradlew --daemon assemble</prompt></para>
      <para>Typical build tasks in their normal usage sequence are provided below.</para>
      <itemizedlist>
        <listitem>
          <para><code>idea</code> – create <application>IntelliJ IDEA</application> project files. When this task is executed, dependencies with their source code are loaded from the artifact repository to the local Gradle cache.</para>
        </listitem>
        <listitem>
          <para><code>cleanIdea</code> – remove IntelliJ IDEA project files.</para>
        </listitem>
        <listitem>
          <para><code>assemble</code> –  compile Java files and build JARs for project artifacts in the  <filename>build</filename> subdirectories of the modules.</para>
        </listitem>
        <listitem>
          <para><code>clean</code> – remove  <filename>build</filename> subdirectories of all project modules.</para>
        </listitem>
        <listitem>
          <para><link linkend="build.gradle_setupTomcat">setupTomcat</link> – setup the  <application>Tomcat</application> server to the path that is specified by the  <code>ext.tomcatDir</code> property of the  <filename>build.gradle</filename> script. </para>
        </listitem>
        <listitem>
          <para><link linkend="build.gradle_deploy">deploy</link> – deploy the application to the Tomcat server that has been pre-installed by the <code>setupTomcat</code> task.</para>
        </listitem>
        <listitem>
          <para><link linkend="build.gradle_createDb">createDb</link> – create an application database and run the corresponding  <link linkend="db_scripts">scripts</link>.</para>
        </listitem>
        <listitem>
          <para><link linkend="build.gradle_updateDb">updateDb</link> – update the existing application database by running the corresponding  <link linkend="db_scripts">scripts</link>.</para>
        </listitem>
        <listitem>
          <para><link linkend="build.gradle_start">start</link> – start the Tomcat server.</para>
        </listitem>
        <listitem>
          <para><link linkend="build.gradle_stop">stop</link> – stop the running Tomcat server.</para>
        </listitem>
        <listitem>
          <para><link linkend="build.gradle_restart">restart</link> – sequentially run the  <code>stop</code>, <code>deploy</code>, <code>start</code> tasks. </para>
        </listitem>
      </itemizedlist>
    </section>
    <section id="build_on_ci">
      <title>Building on a Continuous Integration Server</title>
      <para>The CUBA Gradle plugin requires interactive accepting of the CUBA license agreement if this is the first
        build for the current user. This is impossible for an automatic build on a CI server. There are two ways to
        bypass this interactive step:
        <orderedlist>
          <listitem>
            <para>Create file <code>${user.home}/.haulmont/license.properties</code>, where
              <code>${user.home}</code>
              is the home directory of the user that CI-server is running as, and add the following content:
              <programlisting>accepted=true</programlisting></para>
          </listitem>
          <listitem>
            <para>If creating the file in the user home is not desired, specify the following Gradle command line parameter:
              <programlisting>-PlicenseAgreementAccepted=true</programlisting>
            </para>
          </listitem>
        </orderedlist>
      </para>
    </section>
  </section>
  <section id="project_creation">
    <title lang="en">Creating a Project</title>
    <para>The recommended way to create a new project is to use   <application>CUBA Studio</application>.
      An example can be found in the <link linkend="qs_create_project">Quick Start</link> chapter of this manual.</para>
    <para>Once the project is created, you can keep developing it in the Studio, or create <application>IntelliJ IDEA</application> or
      <application>Eclipse</application> project files and open the project in the IDE.</para>
  </section>
  <section id="db_dev">
    <title>Designing the Database</title>
    <para>This section provides practical advice on working with a database during application development.</para>
    <para>Recommendations for working with a database in production are provided in <xref linkend="db_update_in_prod"/>.</para>
    <section id="db_update_in_dev">
      <title>Creating the DB Schema</title>
      <para>In the process of  application development you need to create and maintain the database schema that corresponds to the model entities. The platform offers an approach based on  <link linkend="db_scripts">DB create and update scripts</link> to solve this task. The practical steps to apply this approach are provided below.</para>
      <para>The task to create and maintain the DB schema consists of two parts: creating the scripts and executing them.</para>
      <para>Scripts can be created both manually and using Studio. The process of creating scripts in Studio is provided below. Run the <guibutton>Generate DB scripts</guibutton> command  in the  <guilabel>Entities</guilabel> section. In this case, Studio will connect to the database defined on the <guilabel>Project properties</guilabel> page and compare the available DB schema with the current data model.</para>
      <para>If the database does not exist or does not have <database>SYS_DB_CHANGELOG</database> and <database>SEC_USER</database> tables, the system generates only DB initialization scripts. Otherwise, update scripts are created as well. Then, a page with the generated scripts is opened.</para>
      <para>Update scripts are displayed on the  <guilabel>Update scripts</guilabel> tab. Scripts with the  <guilabel>new</guilabel> status reflect the difference between the current state of the data model and the DB schema. A separate script is created for each new or modified table. Some scripts also contain sets of referential integrity constraints. When the page is closed by clicking <guibutton>OK</guibutton>, the scripts are saved in the <filename>db/update/{db_type}</filename> directory of the <structname>core</structname> module.</para>
      <para>Scripts that  exist in the project and have been applied to the DB before are displayed with the  <guilabel>applied</guilabel> status. They cannot be edited or removed.</para>
      <para>The  <guilabel>Update scripts</guilabel> tab can also display scripts with  <guilabel>to be deleted</guilabel> status. These are the scripts available in the project, but not  applied to the DB yet. These scripts are removed when you close the page by clicking OK. This is the standard behavior in case the scripts are created during previous scripts generation, but not applied  by invoking <guibutton>Update database</guibutton>. In this case, you don&apos;t need them any longer, because the current difference between the DB schema and the data model is reflected in newly generated scripts. However, if  the scripts were authored by another developer and retrieved from a version control system, you should cancel the saving and  apply the other party’s scripts to your DB first, and then generate new ones.</para>
      <para>The  <guilabel>Init tables</guilabel>, <guilabel>Init constraints</guilabel> and <guilabel>Init data</guilabel> tabs display DB <emphasis>create</emphasis> scripts that are located in the  <filename>db/init/{db_type}</filename> directory of the  <structname>core</structname> module.</para>
      <para>The  <guilabel>Init tables</guilabel> tab displays the  <filename>10.create-db.sql</filename> script that creates the tables. The code related to one and the same table is separated by  <code>begin {table_name} ... end {table_name}</code> comments. When an entity in the model is changed, Studio will replace code only for the corresponding table between the comments, while leaving the rest of the code, where manual changes could have been made, untouched.  Therefore, do not remove these comments when editing the code manually, otherwise Studio will not be able to properly apply the changes to the existing files.</para>
      <para>The  <guilabel>Init constraints</guilabel> tab displays the  <filename>20.create-db.sql</filename> script that creates integrity constraints. It also has table-separating comments that you should not remove.</para>
      <para>The  <guilabel>Init data</guilabel> tab displays the <filename>30.create-db.sql</filename> script designed to provide additional information when initializing the DB. These may be, for example, functions, triggers or DML operators to fill the database with the necessary data. The contents of this script are created manually, if necessary.</para>
      <tip>
        <para>At the initial stage of application development, when the data model is being actively changed, we recommend using only the DB  <emphasis>creation</emphasis> scripts (located in the  <guilabel>Init tables</guilabel>, <guilabel>Init constraints</guilabel>, <guilabel>Init data</guilabel>) tabs) and removing the update scripts in the  <guilabel>Update scripts</guilabel> tab immediately after invoking the <guibutton>Generate DB scripts</guibutton> command. This is the most simple and reliable way to keep the DB up to date. Of course, it has a major drawback, since  applying these scripts recreates the DB from scratch, and all data are lost. You can partially compensate this drawback at the development stage by adding commands to the <guilabel>Init data</guilabel> script that will create primary data upon initialization.</para>
        <para><emphasis>Update</emphasis> scripts become a convenient and necessary tool for developing and maintaining the DB at a later stage, when the data model is relatively stable, and the development and production databases have the data that cannot not be lost as a result of recreating the DB from scratch.</para>
      </tip>
      <para>Use  <link linkend="db_update_gradle">DB script execution by Gradle tasks</link> to apply scripts:  invoke   <guimenu>Run</guimenu> &gt; <guimenu>Create database</guimenu>  to recreate the database and  <guimenu>Run</guimenu> &gt; <guimenu>Update database</guimenu> to apply the scripts. Please note that these items are available only if the application server is stopped. Of course, you can invoke the corresponding Gradle tasks (<code>createDb</code> and <code>updateDb</code>) at any time from the command line, but if the database or any of its objects are locked, script execution may fail.</para>
    </section>
    <section id="db_hsql_connect">
      <title>Connecting to HSQLDB with External Tools</title>
      <para><application>HSQLDB</application>, also called  <application>HyperSQL</application>, is a convenient DBMS for application prototyping that does not require installation and is started automatically within CUBA Studio if the project has been configured to work with this DBMS. This section describes the ways of connecting to HSQLDB with external tools that allow working with DB schema and data directly via SQL.</para>
      <section><title>Connecting with Squirrel SQL</title><para><application>SQuirreL SQL Client</application> is an open-source Java application that allows working with databases via JDBC. You can download Squirrel SQL here:  <ulink url="http://squirrel-sql.sourceforge.net">http://squirrel-sql.sourceforge.net</ulink>.</para><para>Start  <application>Squirrel SQL</application> and go to  <guilabel>Drivers</guilabel>. Right-click  <guilabel>HSQLDB Server</guilabel> in the drivers list, and choose  <guilabel>Modify Driver</guilabel>.</para><figure>
          <title/>
          <mediaobject>
            <imageobject>
              <imagedata align="center" fileref="img/dev_modifyDriver.png"/>
            </imageobject>
          </mediaobject>
        </figure><para>Go to the  <guilabel>Extra Class Path</guilabel> tab in the  window that appears, and click the  <guibutton>Add</guibutton> button to add the  <filename>.jar</filename> file with the driver. </para><figure>
          <title/>
          <mediaobject>
            <imageobject>
              <imagedata align="center" fileref="img/dev_addDriver.png"/>
            </imageobject>
          </mediaobject>
        </figure><para>Then you need to select the  <filename>hsqldb-x.x.x.jar</filename>, driver, which you should download from  <ulink url="http://hsqldb.org/">HSQLDB</ulink>  website  in advance. If you are using <application>HyperSQL</application> only for CUBA development, then you can add the driver supplied as part of CUBA Studio (it is located in the  <filename>lib</filename> subfolder).</para><figure>
          <title/>
          <mediaobject>
            <imageobject>
              <imagedata align="center" fileref="img/dev_selectDriver.png"/>
            </imageobject>
          </mediaobject>
        </figure>Next, create the alias for connection to the application database.<figure>
          <title/>
          <mediaobject>
            <imageobject>
              <imagedata align="center" fileref="img/dev_createAlias.png"/>
            </imageobject>
          </mediaobject>
        </figure><para>Fill in the connection properties in the  window that appears: Database URL, username and password. The default user name is &quot;sa&quot;, the password is empty. The database URL can be copied from the  <guilabel>Project properties</guilabel> tab in CUBA Studio, or from the  <filename>modules/core/web/META-INF/context.xml</filename> file of the project.</para><figure>
          <title/>
          <mediaobject>
            <imageobject>
              <imagedata align="center" fileref="img/dev_setAliasProperties.png"/>
            </imageobject>
          </mediaobject>
        </figure></section>
      <section><title>Connecting with IntelliJ IDEA Ultimate</title><para><application>IntelliJ IDEA Ultimate Edition</application> offers convenient tools for working with databases. To connect to  <application>HSQLDB</application>, start  <application>IDEA</application> and open the  <guilabel>Database</guilabel> panel on the right.</para>
        <para>If you cannot find the panel, open <guimenu>View</guimenu> -&gt; <guimenu>Tool Windows</guimenu> -&gt; <guimenu>Database</guimenu>.</para>Create a new data source using the context menu.<figure>
          <title/>
          <mediaobject>
            <imageobject>
              <imagedata align="center" fileref="img/dev_idea_createDataSource.png"/>
            </imageobject>
          </mediaobject>
        </figure><para>In the appeared window select the  <filename>hsqldb-x.x.x.jar</filename> driver that you downloaded from  <ulink url="http://hsqldb.org/">HSQLDB</ulink> website in advance. If you are using <application>Hyper SQL</application> only for CUBA development,  you can just add the driver supplied as part of CUBA Studio (it is located in the <filename>lib</filename> subfolder).</para><figure>
          <title/>
          <mediaobject>
            <imageobject>
              <imagedata align="center" fileref="img/dev_idea_selectDriver.png"/>
            </imageobject>
          </mediaobject>
        </figure><figure>
          <title/>
          <mediaobject>
            <imageobject>
              <imagedata align="center" fileref="img/dev_idea_selectDriver2.png"/>
            </imageobject>
          </mediaobject>
        </figure><para>Then you should configure data source properties: dаtabase URL, username and password. Database URL can be copied from the  <guilabel>Project properties</guilabel> properties tab in CUBA Studio or the  <filename>modules/core/web/META-INF/context.xml</filename> project file. The default username is “sa”, the password is empty.</para><figure>
          <title/>
          <mediaobject>
            <imageobject>
              <imagedata align="center" fileref="img/dev_idea_setDbProperties.png"/>
            </imageobject>
          </mediaobject>
        </figure><tip>
          <para>If you are using  <application>PostgreSQL</application> as the DBMS and   <sgmltag>uuid</sgmltag> as the identifier,  editing data with  <application>IDEA</application> may result in an error:
            <userinput>ERROR: operator does not exist: uuid = character varying</userinput>
          </para>
          <para>To solve this problem, go to the  <guilabel>Advanced</guilabel> tab in the data source settings and set   <property>stringtype</property> to  <literal>unspecified</literal>.</para>
          <figure>
            <title/>
            <mediaobject>
              <imageobject>
                <imagedata align="center" fileref="img/dev_idea_setStringtype.png"/>
              </imageobject>
            </mediaobject>
          </figure>
        </tip></section>
    </section>
    <section id="db_postgres_features">
      <title>PostgreSQL Specifics</title>
      <para>To create a PostgreSQL database on an Ubuntu-like system, you should install the <application>postgresql-contrib</application> package with the UUID generation function.</para>
    </section>
    <section id="db_mssql_features">
      <title>MS SQL Server Specifics</title>
      <para><application>Microsoft SQL Server</application> uses cluster indexes for tables.</para>
      <para>By default, a cluster index is based on the table’s primary key, however <code>UUID</code>-type keys used by CUBA-applications are poorly suited for clustered index. That is why you should correctly select and create a clustered index for each table. The clustered index field should be relatively small and strictly ascending, following  the general rules:<itemizedlist>
          <listitem>
            <para>For most tables, you can use the  <database>CREATE_TS</database> field. With this field, the records will be physically stored according to their creation order.</para>
          </listitem>
          <listitem>
            <para>For composite entities, if reading prevails over writing, it makes sense to use an owner key. In this case, the records will be grouped by owner and their loading together with an owner will be faster.</para>
          </listitem>
          <listitem>
            <para>For small (&lt; 100 records) and rarely changing tables, the type of clustered index is not important and you can keep using <database>ID</database>. </para>
          </listitem>
          <listitem>
            <para>For tables of the entities, inherited via   <code>JOINED</code> strategy, that do not have the  <database>CREATE_TS</database> field, you can create it manually with the   <literal>current_timestamp</literal> parameter. </para>
          </listitem>
        </itemizedlist></para>
      <para>Example:<programlisting>create table SALES_CUSTOMER (
    ID uniqueidentifier not null,
    CREATE_TS datetime,
    ...
    primary key nonclustered (ID)
)^

create clustered index IDX_SALES_CUSTOMER_CREATE_TS on SALES_CUSTOMER (CREATE_TS)^</programlisting></para>
      <para>Example of a composite entity:<programlisting>create table SALES_ITEM (
    ID uniqueidentifier not null,
    CREATE_TS datetime,
    ...
    ORDER_ID uniqueidentifier,
    ...
    primary key nonclustered (ID),
    constraint FK_SALES_ITEM_ORDER foreign key (ORDER_ID) references SALES_ORDER(ID)
)^

create clustered index IDX_SALES_ITEM_ORDER on SALES_ITEM (ORDER_ID)^</programlisting></para>
      <para>Example of an inherited entity:<programlisting>create table SALES_DOC (
    CARD_ID uniqueidentifier,
    CREATE_TS datetime default current_timestamp,
    NUMBER varchar(50),
    primary key nonclustered (CARD_ID),
    constraint FK_SALES_DOC_CARD foreign key (CARD_ID) references WF_CARD (ID)
)^

create clustered index IDX_SALES_DOC_CREATE_TS on SALES_DOC (CREATE_TS)^

create index IDX_SALES_DOC_CARD on SALES_DOC (CARD_ID)^</programlisting></para>
    </section>
    <section id="db_oracle_features">
      <title>Oracle Database Specifics</title>
      <para>Due to the distribution policy of Oracle JDBC driver, it can only be downloaded manually from  <ulink url="http://www.oracle.com/technetwork/database/features/jdbc/index-091264.html">http://www.oracle.com/technetwork/database/features/jdbc/index-091264.html</ulink>. After downloading, copy <filename>ojdbc6.jar</filename> file into the  <filename>lib</filename> subfolder in  <application>Studio</application> and the  <filename>lib</filename> subfolder of the installed  <application>Tomcat</application> server. Then you need to stop Studio, stop Gradle daemon by executing <code>gradle --stop</code> in the command line, then start Studio again.</para>
    </section>
  </section>
  <section id="logging">
    <title>Logging</title>
    <para>The platform uses  <application>Apache Log4j</application> version 1.2 for logging.</para>
    <para>We recommend using logging via the <application>Commons Logging</application> API and getting a logger based on the current class name. Example of creating a logger and writing to it:<programlisting language="java">import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

public class ...

    private Log log = LogFactory.getLog(getClass()); // create logger

    private void someMethod() {
        log.debug(&quot;someMethod invoked&quot;); // output message with DEBUG level
    }</programlisting> </para>
    <para>Logs for the Middleware, Web Client and Web Portal <link linkend="app_tiers">blocks</link> are configured at the application server level;  in  <link linkend="fast_deployment">fast deployment</link> mode the server is Tomcat. Logs for the Desktop Client block are configured separately.</para>
    <section id="logging_setup_tomcat">
      <title lang="en">Setting up Logging in Tomcat</title>
      <para>Running Gradle  <link linkend="build.gradle_setupTomcat">setupTomcat</link> task installs the Tomcat server into the project directory and performs its additional configuration. Particularly, <filename>setenv.bat</filename> and <filename>setenv.sh</filename> files are created in the   <filename>tomcat/bin</filename> subfolder, and <filename>log4j.xml</filename> is created in the  <filename>tomcat/conf</filename> subfolder.</para>
      <para>Among other things, the  <filename>setenv.*</filename> files define loading parameters for the <filename>log4j.xml</filename> configuration file using the <code>CATALINA_OPTS</code> variable.</para>
      <para><filename>log4j.xml</filename> defines logging configuration. The file has the following structure:<itemizedlist>
          <listitem>
            <para><sgmltag>appender</sgmltag> elements define the &quot;output device&quot; for the log. The main appenders are <code>FILE</code> and <code>CONSOLE</code>. The  <code>Threshold</code> parameter of the appender defines the message threshold. By default,  it is <code>DEBUG</code> for a file and <code>INFO</code> for console. It means that  <code>ERROR</code>, <code>WARN</code>, <code>INFO</code> and  <code>DEBUG</code> messages are written to a file, while  <code>ERROR</code>, <code>WARN</code> and  <code>INFO</code> are written to console.</para>
            <para>The path to the log file for the file appender is defined in the  <code>File</code> parameter; <code>Append</code> flag defines if the file should be flushed or appended to at server restart. The default settings are <filename>tomcat/logs/app.log</filename>  and   flush at restart. When an application is in production, we recommend setting <code>Append</code> to  <code>true</code>.</para>
            <para>By default, the file appender is implemented by the  <code>org.apache.log4j.DailyRollingFileAppender</code> class, which renames the log file to a previous date and starts a new file daily at 00:00:00. This helps avoiding excessively large log files.</para>
          </listitem>
          <listitem>
            <para><sgmltag>category</sgmltag> elements define the logger parameters that are used to send messages from the program code. Category names are hierarchical, i.e. the settings of the  <code>com.company.sample</code> category have effect on the  <code>com.company.sample.core.CustomerServiceBean</code> and <code>com.company.sample.web.CustomerBrowse</code> loggers, if the loggers do not explicitly override the settings with their own.</para>
            <para>Minimum logging level is defined by the <sgmltag>priority</sgmltag> element. For example, if  the category is   <code>INFO</code>, then <code>DEBUG</code> and  <code>TRACE</code> messages will not be logged. It should be kept in mind that message logging is also affected by the level threshold set in the appender.</para>
          </listitem>
        </itemizedlist></para>
      <para>You can quickly change category levels and appender thresholds for a running server using the <guimenu> Administration</guimenu> &gt; <guimenu>Server log</guimenu> screen available in the web client. Any changes to the logging settings are effective only during server runtime and are not saved to a file. The screen also allows viewing and loading log files from the server  <link linkend="log_dir">logs folder</link> (<filename>tomcat/logs</filename>). </para>
      <para>The platform automatically adds the following information to the messages written to a log:<itemizedlist>
          <listitem>
            <para><userinput>[application]</userinput> – the name of the Tomcat-deployed web application whose code has logged the message. This information allows identifying messages from different application blocks  (Middleware, Web Client), since they are written into the same file.</para>
          </listitem>
          <listitem>
            <para><userinput>[user]</userinput> – login name of the user who invoked the code logging the message. This helps to track activity of a certain user in the common log. If the code that logged a message was not invoked within a specific user session, the user information is not added.</para>
          </listitem>
        </itemizedlist></para>
      <para>For example, the following message has been written to the log by the code of the Middleware block (<userinput>app-core</userinput>), running under the  <userinput>admin</userinput> user:<programlisting>2013-12-19 18:48:17,282 DEBUG [com.haulmont.cuba.core.app.DataManagerBean] [app-core] [admin] loadList: metaClass=sec$User, view=com.haulmont.cuba.security.entity.User/user.browse, query=select u from sec$User u, max=100</programlisting></para>
    </section>
    <section id="logging_setup_desktop">
      <title lang="en">Setting up Logging in The Desktop Client</title>
      <para>For the desktop client, the  <filename>log4j.xml</filename> file should be located in the source files directory of the project’s <structname>desktop</structname> module. When an application is built, it is packed into the corresponding JAR file and is accessible in CLASSPATH.</para>
      <para>Make the following steps to set up logging for your project:<itemizedlist>
          <listitem>
            <para>Create a new file, for example <filename>sample-log4j.xml</filename>, in the   <filename>src</filename> directory of the  <structname>desktop</structname> module, and copy the contents of  <filename>cuba-log4j.xml</filename> to this new file.  <filename>cuba-log4j.xml</filename> file is located in one of the platform’s JAR files and can be easily found using search in the IDE, given that the base projects are configured properly.</para>
          </listitem>
          <listitem>
            <para>Define path to a log file in the  <code>File</code> parameter of the <code>FILE</code> appender.</para>
          </listitem>
          <listitem>
            <para>Add settings for category loggers in your project.</para>
          </listitem>
          <listitem>
            <para>In the <link linkend="gui_desktop">inheritor class</link> of <code>com.haulmont.cuba.desktop.App</code> of your project, for example  <code>SampleApp</code>, override the  <code>getDefaultLog4jConfig()</code> method and use it to return the path to your log file relative to the CLASSPATH root. For example:<programlisting language="java">public class SampleApp extends App {
...
    @Override
    protected String getDefaultLog4jConfig() {
        return &quot;sample-log4j.xml&quot;;
    }</programlisting></para>
          </listitem>
          <listitem>
            <para>If necessary, you can override the location of the configuration file at application start using  <link linkend="log4j.configuration">log4j.configuration</link> system property.</para>
          </listitem>
        </itemizedlist></para>
    </section>
  </section>
  <section id="debug_and_testing">
    <title lang="en">Debugging and Testing</title>
    <para>This section covers various aspects of testing and debugging CUBA applications.</para>
    <section id="debug_setup">
      <title lang="en">Connecting a Debugger</title>
      <para>You can start Tomcat server in debug mode by either running the build command</para>
      <para><prompt>gradle start</prompt></para>
      <para>or by running the  <filename>bin/debug.*</filename> command file of the installed  <application>Tomcat</application>.</para>
      <para>After this, the server will accept debugger connections over port 8787. Port number can be changed in the  <filename>bin/setenv.*</filename> file, in the  <code>JPDA_OPTS</code> variable.</para>
      <para>For debugging in  <application>Intellij IDEA</application> you need to create a new <guilabel>Remote</guilabel> type    <guilabel>Run/Debug Configuration</guilabel> element in the application project and set its  <guilabel>Port</guilabel>  property to 8787.</para>
    </section>
    <section id="testing">
      <title lang="en">Testing</title>
        <para>This section covers various means of testing CUBA applications on different layers.</para>
      <section id="unit_tests">
        <title>Unit Tests</title>
        <para>Unit tests can be created and run both at the Middleware and the Client <link linkend="app_tiers">tiers</link>. The platform includes <ulink url="http://junit.org">JUnit</ulink> and  <ulink url="http://jmockit.github.io/">JMockit</ulink> frameworks for this purpose.</para>
        <para>Let us assume you have the following  screen controller:<programlisting language="java">public class OrderEditor extends AbstractEditor {

    @Named(&quot;itemsTable.add&quot;)
    protected AddAction addAction;

    @Override
    public void init(Map&lt;String, Object&gt; params) {
        addAction.setWindowId(&quot;sales$Product.lookup&quot;);
        addAction.setHandler(new Lookup.Handler() {
            @Override
            public void handleLookup(Collection items) {
                // some code
            }
        });
    }
}</programlisting></para>
        <para>You can write the following test checking the <code>init()</code> method:<programlisting language="java">public class OrderEditorTest {

    OrderEditor editor;

    @Mocked
    Window.Editor frame;

    @Mocked
    AddAction addAction;

    @Before
    public void setUp() throws Exception {
        editor = new OrderEditor();
        editor.setWrappedFrame(frame);
        editor.addAction = addAction;
    }

    @Test
    public void testInit() {
        editor.init(Collections.&lt;String, Object&gt;emptyMap());
        editor.setItem(new Order());

        new Verifications() {
            {
                addAction.setWindowId(&quot;sales$Product.lookup&quot;);
                addAction.setHandler(withInstanceOf(Window.Lookup.Handler.class));
            }
        };
    }
}</programlisting></para>
      </section>
      <section id="integration_tests_mw">
        <title>Middleware Integration Tests</title>
        <para>At the middle tier, you can create integration tests which are run in a fully functional  <application>Spring</application> container connected to the database. In such tests you can run code from any layer of  the  Middleware, from services to ORM. </para>
        <para>To create integration tests, the application’s <structname>core</structname> module should contain a base class derived from  <code>CubaTestCase</code>. This class should override the methods for data access initialization and configuration files list retrieval. For example:<programlisting language="java">public class SalesTestCase extends CubaTestCase {

    @Override
    protected void initDataSources() throws Exception {
        Class.forName(&quot;org.postgresql.Driver&quot;);
        TestDataSource ds = new TestDataSource(&quot;jdbc:postgresql://localhost/sales_test&quot;, &quot;cuba&quot;, &quot;cuba&quot;);
        TestContext.getInstance().bind(&quot;java:comp/env/jdbc/CubaDS&quot;, ds);
    }

    @Override
    protected List&lt;String&gt; getTestAppProperties() {
        String[] files = {
                &quot;cuba-app.properties&quot;,
                &quot;app.properties&quot;,
                &quot;test-app.properties&quot;,
        };
        return Arrays.asList(files);
    }
}</programlisting></para>
        <para>We recommend using a separate test DB, which can be created, for example, with the help of the following task in  <filename>build.gradle</filename>: <programlisting>configure(coreModule) {
...
    task createTestDb(dependsOn: assemble, description: &apos;Creates local Postgres database for tests&apos;, type: CubaDbCreation) {
        dbms = &apos;postgres&apos;
        dbName = &apos;sales_test&apos;
        dbUser = &apos;cuba&apos;
        dbPassword = &apos;cuba&apos;
    }</programlisting></para>
        <para><code>CubaTestCase</code> class contains the following fields and methods that can be used in the test code:<itemizedlist>
            <listitem>
              <para><code>persistence</code> – a reference to the   <link linkend="persistence">Persistence</link> interface.</para>
            </listitem>
            <listitem>
              <para><code>metadata</code> – a reference to the    <link linkend="metadata">Metadata</link> interface.</para>
            </listitem>
            <listitem>
              <para><code>deleteRecord()</code> – a method that can be conveniently used in <code>tearDown()</code> to delete test objects from DB.</para>
            </listitem>
          </itemizedlist></para>
        <para>An example of a test that checks loading entities from the database:<programlisting language="java">public class CustomerLoadTest extends SalesTestCase {

    private UUID customerId;

    @Override
    public void setUp() throws Exception {
        super.setUp();
        persistence.createTransaction().execute(new Transaction.Runnable() {
            @Override
            public void run(EntityManager em) {
                Customer customer = new Customer();
                customerId = customer.getId();
                customer.setName(&quot;testCustomer&quot;);
                em.persist(customer);
            }
        });
    }

    @Override
    public void tearDown() throws Exception {
        deleteRecord(&quot;SALES_CUSTOMER&quot;, customerId);
        super.tearDown();
    }

    public void test() {
        Transaction tx = persistence.createTransaction();
        try {
            EntityManager em = persistence.getEntityManager();
            TypedQuery&lt;Customer&gt; query = em.createQuery(
                &quot;select c from sales$Customer c&quot;, Customer.class);
            List&lt;Customer&gt; list = query.getResultList();
            tx.commit();
            assertTrue(list.size() &gt; 0);
        } finally {
            tx.end();
        }
    }
}</programlisting></para>
      </section>
      <section id="integration_tests_client">
        <title>Client Tier Integration Tests</title>
        <para>Client tier integration tests can be implemented using  <ulink url="http://jmockit.github.io/">JMockit</ulink> framework. It helps isolating the tests from the  Middleware and creating the required infrastructure objects.</para>
        <para>Client integration test class should be inherited from <code>CubaClientTestCase</code>. In the  <code>@Before</code> method, you should call the inherited methods  <code>addEntityPackage()</code>, <code>setViewConfig()</code> and then  <code>setupInfrastructure()</code> to create   <link linkend="metadata">Metadata</link> and  <link linkend="configuration">Configuration</link> objects and deploy metadata for selected entities. Then, in the   <code>@Before</code> method, you can extend the infrastructure with required mock objects using <code>Expectations</code> or <code>NonStrictExpectations</code>. </para>
        <para>An example of an initialized  <code>@Before</code> method from one of the platform tests:<programlisting language="java">@Before
public void setUp() throws Exception {
    addEntityPackage(&quot;com.haulmont.cuba.security.entity&quot;);
    addEntityPackage(&quot;com.haulmont.cuba.core.entity&quot;);
    addEntityPackage(&quot;com.haulmont.cuba.gui.data.impl.testmodel1&quot;);
    setViewConfig(&quot;/com/haulmont/cuba/gui/data/impl/testmodel1/test-views.xml&quot;);
    setupInfrastructure();

    metadataSession = metadata.getSession();
    dataSupplier = new TestDataSupplier();

    dataSupplier.commitCount = 0;

    new NonStrictExpectations() {
        @Mocked ClientConfig clientConfig;
        @Mocked PersistenceHelper persistenceHelper;
        {
            configuration.getConfig(ClientConfig.class); result = clientConfig;

            clientConfig.getCollectionDatasourceDbSortEnabled(); result = true;

            persistenceManager.getMaxFetchUI(anyString); result = 10000;

            PersistenceHelper.isNew(any); result = false;
        }
    };
}</programlisting></para>
      </section>
    </section>
  </section>
  <section id="dev_recipes">
    <title lang="en">Development Recipes</title>
    <para>This section provides solutions for certain practical tasks.</para>
    <section id="getting_messages">
      <title lang="en">Getting Localized Messages</title>
      <para>This section covers ways of getting  <link linkend="localization">localized messages</link> in different application components.</para>
      <itemizedlist>
        <listitem>
          <para>In screen  <link linkend="screen_xml">XML-descriptors</link>, component attributes for displaying static text (such as <link linkend="gui_attr_basic_caption">caption</link>)  can address localized messages using the rules of <link linkend="messageTools.loadString">MessageTools.loadString()</link> method. For example:<itemizedlist>
              <listitem>
                <para><code>caption=&quot;msg://roleName&quot;</code> –  gets a message defined by the  <code>roleName</code> key in the message pack of the current screen. Screen message pack is defined by the <code>messagesPack</code> attribute of the root   <code>window</code> element.</para>
              </listitem>
              <listitem>
                <para><code>caption=&quot;msg://com.company.sample.entity/Role.name&quot;</code> – gets a message defined by the <code>Role.name</code> key in the  <code>com.company.sample.entity</code> message pack.</para>
              </listitem>
            </itemizedlist></para>
        </listitem>
        <listitem>
          <para>In  <link linkend="screen_controller">screen controllers</link>, localized strings can be retrieved in the following ways:<itemizedlist>
              <listitem>
                <para>From the current screen message pack:<itemizedlist>
                    <listitem>
                      <para>Using  <code>getMessage()</code> method inherited from the  <link linkend="abstractFrame">AbstractFrame</link> base class. For example:<programlisting language="java">String msg = getMessage(&quot;warningMessage&quot;);</programlisting></para>
                    </listitem>
                    <listitem>
                      <para>Using <code>formatMessage()</code> method inherited from the <code>AbstractFrame</code> base class. In this case, the extracted message is used to format submitted parameters according to the rules of  <code>String.format()</code> method. For example:</para>
                      <para>messages.properties:<programlisting>warningMessage = Invalid email address: &apos;%s&apos;</programlisting></para>
                      <para>Java controller:<programlisting language="java">String msg = formatMessage(&quot;warningMessage&quot;, email);</programlisting></para>
                    </listitem>
                  </itemizedlist></para>
              </listitem>
              <listitem>
                <para>From an arbitrary messages pack via an injection of  <link linkend="messages">Messages</link> infrastructure interface. For example:<programlisting language="java">@Inject
private Messages messages;

@Override
public void init(Map&lt;String, Object&gt; params) {
    String msg = messages.getMessage(getClass(), &quot;warningMessage&quot;);
    ...
} </programlisting></para>
              </listitem>
            </itemizedlist></para>
        </listitem>
        <listitem>
          <para>For components managed by a Spring container  (<link linkend="managed_beans">managed beans</link>, <link linkend="services">services</link>, <link linkend="jmx_beans">JMX-beans</link>,  Spring MVC controllers of the <structname>portal</structname> module), localized messages can be retrieved with the help of the <link linkend="messages">Messages</link> infrastructure interface injection:<programlisting language="java">@Inject
protected Messages messages;
...
String msg = messages.getMessage(getClass(), &quot;warningMessage&quot;);</programlisting></para>
        </listitem>
        <listitem>
          <para>In application code where injection is not possible, the  <code>Messages</code> interface can be obtained using the static <code>get()</code> method of the  <code>AppBeans</code> class:<programlisting language="java">protected Messages messages = AppBeans.get(Messages.class);
...
String msg = messages.getMessage(getClass(), &quot;warningMessage&quot;);</programlisting></para>
        </listitem>
      </itemizedlist>
    </section>
    <section id="init_values">
      <title>Assigning Initial Values</title>
      <para>There are different ways to assign initial values to the attributes of new entity instances.</para>
      <section id="init_values_in_class">
        <title>Entity Fields Initialization</title><para>Simple attributes (<code>Boolean</code>, <code>Integer</code>
        etc.) can be initialized in the declaration of the corresponding field of an entity class, for example:
        <programlisting language="java">public class User extends StandardEntity {
...
    @Column(name = &quot;ACTIVE&quot;)
    protected Boolean active = true;
...
}</programlisting></para>
        Additionally, a specific initialization method with a
        <link linkend="postConstruct_entity_annotation">@PostConstruct</link> annotation can be created in the entity
        class. In this case, any global <link linkend="infrastructure_interfaces">infrastructure interfaces</link> and
        <link linkend="managed_beans">beans</link> can be invoked during initialization, for example:
        <programlisting language="java">public class MyEntity extends StandardEntity {
...
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = &quot;USER_ID&quot;)
    protected User creator;
...
    @PostConstruct
    protected void init() {
       setCreator(AppBeans.get(UserSessionSource.class).getUserSession().getUser());
    }
}</programlisting></section>
      <section id="init_values_in_CreateAction">
        <title>Initialization Using CreateAction</title>
        <para>If the initial value of an attribute depends on the data of the invoking screen, you can use  <code>setInitialValues()</code> method of the  <link linkend="createAction">CreateAction</link> class.</para>
        <para>Let us look at the example of two linked entities:<mediaobject>
            <imageobject>
              <imagedata align="center" fileref="img/init_values_recipe_1.png"/>
            </imageobject>
          </mediaobject></para>
        <para>A fragment of a screen XML descriptor showing the lists of two entities simultaneously:<programlisting language="xml">&lt;dsContext&gt;
    &lt;collectionDatasource id=&quot;typesDs&quot;
                          class=&quot;com.haulmont.sample.entity.DeviceType&quot;
                          view=&quot;_local&quot;&gt;
        &lt;query&gt;
            select e from sample$DeviceType e
        &lt;/query&gt;
    &lt;/collectionDatasource&gt;
    &lt;collectionDatasource id=&quot;descriptionsDs&quot;
                          class=&quot;com.haulmont.sample.entity.DeviceDescription&quot;
                          view=&quot;_local&quot;&gt;
        &lt;query&gt;
            select e from sample$DeviceDescription e where e.deviceType.id = :ds$typesDs
        &lt;/query&gt;
    &lt;/collectionDatasource&gt;
&lt;/dsContext&gt;
&lt;layout&gt;
...
        &lt;table id=&quot;typeTable&quot;&gt;
            &lt;actions&gt;
                &lt;action id=&quot;create&quot;/&gt;
                &lt;action id=&quot;edit&quot;/&gt;
                &lt;action id=&quot;remove&quot;/&gt;
            &lt;/actions&gt;
            &lt;columns&gt;
                &lt;column id=&quot;name&quot;/&gt;
            &lt;/columns&gt;
            &lt;rows datasource=&quot;typesDs&quot;/&gt;
        &lt;/table&gt;
...
        &lt;table id=&quot;descriptionTable&quot;&gt;
            &lt;actions&gt;
                &lt;action id=&quot;create&quot;/&gt;
                &lt;action id=&quot;edit&quot;/&gt;
                &lt;action id=&quot;remove&quot;/&gt;
            &lt;/actions&gt;
            &lt;columns&gt;
                &lt;column id=&quot;description&quot;/&gt;
            &lt;/columns&gt;
            &lt;rows datasource=&quot;descriptionsDs&quot;/&gt;
        &lt;/table&gt;
    &lt;/split&gt;
&lt;/layout&gt;</programlisting></para>
        <para>The screen controller:<programlisting language="java">public class DeviceTypeBrowse extends AbstractLookup {

    @Inject
    private CollectionDatasource&lt;DeviceType, UUID&gt; typesDs;

    @Named(&quot;descriptionTable.create&quot;)
    private CreateAction descrCreateAction;

    @Override
    public void init(Map&lt;String, Object&gt; params) {
        typesDs.addListener(new CollectionDsListenerAdapter&lt;DeviceType&gt;() {
            @Override
            public void itemChanged(Datasource&lt;DeviceType&gt; ds, @Nullable DeviceType prevItem, @Nullable DeviceType item) {
                descrCreateAction.setInitialValues(Collections.&lt;String, Object&gt;singletonMap(&quot;deviceType&quot;, item));
            }
        });
    }
}</programlisting></para>
        <para>A listener is added in the controller for selected record change event in the <code>typesDs</code> datasource. When the selected record is changed, the system invokes the action’s  <code>setInitialValues()</code> method and submits a map with one element whose key is the attribute name (<code>deviceType</code>)  and value (the selected instance of <code>DeviceType</code>). Thus, during the execution of <code>CreateAction</code>, the   <code>deviceType</code> attribute of the new  <code>DeviceDescription</code> instance will contain the instance of the  <code>DeviceType</code> that was selected in the table.</para>
      </section>
      <section id="init_values_in_initNewItem">
        <title lang="en">Using initNewItem Method</title>
        <para>Initial values can also be defined  in the  <link linkend="initNewItem">initNewItem()</link> method of the screen  controller of the created entity.</para>
        <para>Assume we have the following task: a project has an  <code>Employee</code> entity that should be linked one-to-one to a platform entity (<code>User</code>). When a new employee instance is being created, a new user instance should be created as well.<mediaobject>
            <imageobject>
              <imagedata align="center" fileref="img/init_values_recipe_2.png"/>
            </imageobject>
          </mediaobject></para>
        <para>To achieve this, we  declare the data source for the employee instance and the nested data source for the linked user in the employee edit screen XML descriptor:<programlisting language="xml">&lt;dsContext&gt;
    &lt;datasource id=&quot;employeeDs&quot;
                class=&quot;com.haulmont.sample.entity.Employee&quot;
                view=&quot;employee-edit&quot;&gt;
        &lt;datasource id=&quot;userDs&quot;
                    property=&quot;user&quot;/&gt;
    &lt;/datasource&gt;
&lt;/dsContext&gt;</programlisting></para>
        <para>In the employee edit screen controller, we declare:<programlisting language="java">@Inject
private Metadata metadata;

private Group defaultGroup;
private Role defaultRole;

@Override
protected void initNewItem(Employee item) {
    User user = metadata.create(User.class);
    user.setGroup(defaultGroup);
    final UserRole userRole = metadata.create(UserRole.class);
    userRole.setUser(user);
    userRole.setRole(defaultRole);
    getDsContext().addListener(new DsContext.CommitListenerAdapter() {
        @Override
        public void beforeCommit(CommitContext context) {
            context.getCommitInstances().add(userRole);
        }
    });
    item.setUser(user);
}</programlisting></para>
        <para>Here, in the  <code>initNewItem()</code> method, the new  <code>User</code> instance is created and assigned the  <code>defaultGroup</code>. Association with the  <code>defaultRole</code> is set up using the new instance of  <code>UserRole</code> entity. To save this relationship to the DB during screen commit the <code>UserRole</code> instance is added to the saved entities collection in the  <code>beforeCommit()</code> method of   <link linkend="dsContext">DsContext.CommitListener</link>. </para>
        <para>The new instance of  <code>User</code> is assigned to the corresponding attribute of the edited  <code>Employee</code> entity and is thus included in the nested data source  <code>userDs</code>.  This gives us an opportunity to edit necessary user attributes in the employee screen and also leads to automatic saving of the user instance in the same transaction with the other entities when the screen is committed.</para>
      </section>
    </section>
    <section id="composition_recipe" lang="en">
      <title lang="en">Editing Composite Entities</title>
      <para>CUBA platform supports two types of relationship between entities: association and composition. They are called ASSOCIATION and COMPOSITION respectively in the <application>CUBA Studio</application> interface. Association is a relationship between the objects that can exist separately from each other. Composition, on the other hand, is used for “master-detail” relations, when the detail instances can exist only as part of the master. A case of an airport and its terminals may be considered an example of composition: a terminal that does not belong to any airport does not make sense.</para>
      <para>Typically, the entities belonging to a composition are edited together since it is more convenient. For example, a user opens the airport editing screen and sees the list of terminals, so he can create and edit them, but all changes both for the airport and the terminals are saved to the database together in one transaction, and only after the user confirms saving of the master entity (the airport).</para>
      <section lang="en">
        <title lang="en">Implementing a Composition</title>
        <para>Let us implement a composition using the  <code>Airport</code> and the  <code>Terminal</code> entities as an example:<mediaobject>
            <imageobject>
              <imagedata align="center" fileref="img/composition_recipe_1.png"/>
            </imageobject>
          </mediaobject></para>
        <orderedlist>
          <listitem>
            <para>The  <code>Terminal</code> entity contains a mandatory link to the  <code>Airport</code>:<programlisting language="java">@Entity(name = &quot;sample$Terminal&quot;)
@Table(name = &quot;SAMPLE_TERMINAL&quot;)
public class Terminal extends StandardEntity {
...    
    @ManyToOne(optional = false, fetch = FetchType.LAZY)
    @JoinColumn(name = &quot;AIRPORT_ID&quot;)
    private Airport airport;

    public Airport getAirport() {
        return airport;
    }

    public void setAirport(Airport airport) {
        this.airport = airport;
    }
}</programlisting></para>
          </listitem>
          <listitem>
            <para>The  <code>Airport</code> entity contains one-to-many collection of terminals. The corresponding field is annotated with <link linkend="composition_annotation">@Composition</link> in order to implement composition, and  <link linkend="onDelete_annotation">@OnDelete</link> for cascaded soft delete:<programlisting language="java">@Entity(name = &quot;sample$Airport&quot;)
@Table(name = &quot;SAMPLE_AIRPORT&quot;)
public class Airport extends StandardEntity {
...
    @OneToMany(fetch = FetchType.LAZY, mappedBy = &quot;airport&quot;)
    @OnDelete(DeletePolicy.CASCADE)
    @Composition
    protected List&lt;Terminal&gt; terminals;

    public List&lt;Terminal&gt; getTerminals() {
        return terminals;
    }

    public void setTerminals(List&lt;Terminal&gt; terminals) {
        this.terminals = terminals;
    }
}</programlisting></para>
          </listitem>
          <listitem>
            <para> The <link linkend="views">view</link> of the  airport editing screen should contain the   <code>terminals</code> attributes collection:<programlisting language="xml">&lt;view entity=&quot;sample$Airport&quot; name=&quot;airport-edit&quot; extends=&quot;_local&quot;&gt;
    &lt;property name=&quot;terminals&quot; view=&quot;_local&quot;/&gt;
&lt;/view&gt;</programlisting></para>
            <para>For the  <code>Terminal</code> entity, we are using the  <code>_local</code> view, although it contains the <code>airport</code>   link attribute (a link to an airport). The  <code>airport</code> attribute is set only at the creation of a new  <code>Terminal</code> instance and never changes after that, so we do not need to load it.</para>
          </listitem>
          <listitem>
            <para>Next, we define the datasources for the  <code>Airport</code> instance and its terminals in the  XML descriptor of the airport editor:<programlisting language="xml">&lt;dsContext&gt;
    &lt;datasource id=&quot;airportDs&quot;
                class=&quot;com.haulmont.sample.entity.Airport&quot;
                view=&quot;airport-edit&quot;&gt;
        &lt;collectionDatasource id=&quot;terminalsDs&quot; property=&quot;terminals&quot;/&gt;
    &lt;/datasource&gt;
&lt;/dsContext&gt;</programlisting></para>
          </listitem>
          <listitem>
            <para>Define a table displaying terminals and <link linkend="list_actions">standard actions</link> for it in the  XML descriptor of the airport editor:<programlisting language="xml">&lt;table id=&quot;terminalsTable&quot;&gt;
    &lt;actions&gt;
        &lt;action id=&quot;create&quot;/&gt;
        &lt;action id=&quot;edit&quot;/&gt;
        &lt;action id=&quot;remove&quot;/&gt;
    &lt;/actions&gt;
    &lt;buttonsPanel&gt;
        &lt;button action=&quot;terminalsTable.create&quot;/&gt;
        &lt;button action=&quot;terminalsTable.edit&quot;/&gt;
        &lt;button action=&quot;terminalsTable.remove&quot;/&gt;
    &lt;/buttonsPanel&gt;
    &lt;columns&gt;
        &lt;column id=&quot;code&quot;/&gt;
        &lt;column id=&quot;name&quot;/&gt;
        &lt;column id=&quot;address&quot;/&gt;
    &lt;/columns&gt;
    &lt;rows datasource=&quot;terminalsDs&quot;/&gt;
&lt;/table&gt;</programlisting></para>
          </listitem>
          <listitem>
            <para>It is sufficient to define the standard elements in the terminal editor: <code>datasource</code> for the  <code>Terminal</code> instance and visual components related to this  <code>datasource</code> for editing terminal attributes.</para>
          </listitem>
        </orderedlist>
        <para>As a result, editing of an airport instance works as follows:<itemizedlist>
            <listitem>
              <para>The airport edit screen shows a list of terminals.</para>
            </listitem>
            <listitem>
              <para>A user can pick a terminal and open its editor. When  <guibutton>OK</guibutton> is clicked in the terminal editor, the updated instance of the terminal is not saved to the database, but to the  <code>terminalsDs</code> datasource of the airport editor. </para>
            </listitem>
            <listitem>
              <para>The user can create new terminals and delete existing ones. All changes will be saved to the  <code>terminalsDs</code> datasource.</para>
            </listitem>
            <listitem>
              <para>When a user clicks OK in the airport edit screen, the updated   <code>Airport</code> instance together with all the updated <code>Terminal</code> instances is submitted  to the  <link linkend="dataManager">DataManager</link>.commit() method on the Middleware and saved in the database within a single transaction.</para>
            </listitem>
          </itemizedlist></para>
      </section>
      <section>
        <title>Deep Composition</title>
        <para>Composition can be deeper, with several nested levels. Let’s extend the example above by adding a  <code>MeetingPoint</code> entity describing a meeting point at an airport terminal:<mediaobject>
            <imageobject>
              <imagedata align="center" fileref="img/composition_recipe_2.png"/>
            </imageobject>
          </mediaobject></para>
        <para>The  <code>Terminal</code> entity contains the  <code>meetingPoints</code> attribute – a collection of the  <code>MeetingPoint</code> instances. In order for all three entities to become a single composition and be edited together, you should do the following in addition to the steps described above:<orderedlist>
            <listitem>
              <para>Mark the  <code>meetingPoints</code> attribute of the  <code>Terminal</code> class as  <code>@Composition</code> and  <code>@OnDelete</code> similarly to the  <code>terminals</code> attribute of the <code>Airport</code> class.</para>
            </listitem>
            <listitem>
              <para>Create a new view for the  <code>Terminal</code>:<programlisting language="xml">&lt;view entity=&quot;sample$Terminal&quot; name=&quot;terminal-edit&quot; extends=&quot;_local&quot;&gt;
    &lt;property name=&quot;meetingPoints&quot; view=&quot;_local&quot;/&gt;
&lt;/view&gt;</programlisting></para>
              <para>Use it in the <code>Airport</code> view instead of  <code>_local</code>:<programlisting language="xml">&lt;view entity=&quot;sample$Airport&quot; name=&quot;airport-edit&quot; extends=&quot;_local&quot;&gt;
    &lt;property name=&quot;terminals&quot; view=&quot;terminal-edit&quot;/&gt;
&lt;/view&gt;</programlisting></para>
            </listitem>
            <listitem>
              <para>Define datasources for an instance of the <code>Airport</code> and nested entities for the entire composition depth in the  <code>Airport</code> edit screen XML descriptor:<programlisting language="xml">&lt;dsContext&gt;
    &lt;datasource id=&quot;airportDs&quot;
                class=&quot;com.haulmont.sample.entity.Airport&quot;
                view=&quot;airport-edit&quot;&gt;
        &lt;collectionDatasource id=&quot;terminalsDs&quot; property=&quot;terminals&quot;&gt;
            &lt;collectionDatasource id=&quot;meetingPointsDs&quot; property=&quot;meetingPoints&quot;/&gt;
        &lt;/collectionDatasource&gt;  
    &lt;/datasource&gt;
&lt;/dsContext&gt;</programlisting></para>
              <para>Here, the  <code>meetingPointsDs</code> datasource is not associated with any visual components, however it is needed for correct operation of joint editing of the composition.</para>
            </listitem>
            <listitem>
              <para>Define the nested data source and a corresponding table for the  <code>meetingPoints</code> collection in the terminal edit screen XML descriptor.</para>
            </listitem>
          </orderedlist></para>
        <para>As a result, the updated instances of the <code>MeetingPoint</code>,  as well as the  <code>Terminal</code> instances, will be saved to the database only with the  <code>Airport</code> instance in the same transaction.</para>
      </section>
    </section>
    <section id="app_start_recipe" lang="en">
      <title lang="en">Running Code at Application Start</title>
      <para>Sometimes you may need to run certain code immediately after the application start at the moment when all application functionality is already initialized and ready to work. For this, you can use the  <link linkend="appContext">AppContext.Listener</link>.</para>
      <para>Assume we have the following task: a project has an  <code>Employee</code> entity that should be linked one-to-one to a platform entity (<code>User</code>).<mediaobject>
          <imageobject>
            <imagedata align="center" fileref="img/init_values_recipe_2.png"/>
          </imageobject>
        </mediaobject></para>
      <para>If the  <code>name</code> attribute of the  <code>User</code> entity is changed, for example, through a standard user management screen, the  <code>name</code> attribute of the related  <code>Employee</code> should change as well. This is a common task for &quot;denormalized&quot; data, which is typically solved using <link linkend="entity_listeners">entity listeners</link>. Our case is more complex, since we need to track changes of the platform’s  <code>User</code> entity, and thus we cannot add an entity listener using  <link linkend="listeners_annotation">@Listeners</link> annotation. However, we can add a listener dynamically using the  <code>EntityListenerManager</code> bean, and it is better to do this on application start.</para>
      <para>Let us create the  <code>AppLifecycle</code> bean implementing the  <code>AppContext.Listener</code> interface in the application <structname>core</structname> module and register it by invoking  <code>AppContext.addListener()</code> method in the object constructor:<programlisting language="java">@ManagedBean(&quot;sample_AppLifecycle&quot;)
public class AppLifecycle implements AppContext.Listener {

    @Inject
    private EntityListenerManager entityListenerManager;

    public AppLifecycle() {
        AppContext.addListener(this);
    }

    @Override
    public void applicationStarted() {
        entityListenerManager.addListener(User.class, UserEntityListener.class);
    }

    @Override
    public void applicationStopped() {
    }

    public static class UserEntityListener implements BeforeUpdateEntityListener&lt;User&gt; {
        @Override
        public void onBeforeUpdate(User user) {
            Persistence persistence = AppBeans.get(Persistence.class);
            if (persistence.getTools().getDirtyFields(user).contains(&quot;name&quot;)) {
                EntityManager em = persistence.getEntityManager();
                TypedQuery&lt;Employee&gt; query = em.createQuery(
                        &quot;select e from sample$Employee e where e.user.id = ?1&quot;, Employee.class);
                query.setParameter(1, user.getId());
                Employee employee = query.getFirstResult();
                if (employee != null) {
                    employee.setName(user.getName());
                }
            }
        }
    }
}</programlisting></para>
      <para>As a result, the <code>applicationStarted()</code> method of this bean will be invoked immediately after the start of the Middleware   <link linkend="app_tiers">block</link>. In this method, the internal <code>UserEntityListener</code> class is registered as an entity listener for the   <code>User</code> entity. </para>
      <para>The  <code>onBeforeUpdate()</code> method of the  <code>UserEntityListener</code> class will be invoked every time before the changes in the   <code>User</code> instances are saved to the database. The method checks if the  <code>name</code> attribute exists among the updated attributes. If yes, a related <code>Employee</code> instance is loaded and its <code>name</code> is updated with the new value.</para>
    </section>
    <section id="images_recipe">
      <title lang="en">Loading and Displaying Images</title>
      <para>Let us consider a task of loading, storing and displaying employee photos:<itemizedlist>
          <listitem>
            <para>An employee is represented by  <code>Employee</code> entity.</para>
          </listitem>
          <listitem>
            <para>Image files are stored in the  <link linkend="file_storage">FileStorage</link>. The  <code>Employee</code> entity contains a link to the corresponding  <code>FileDescriptor</code>.</para>
          </listitem>
          <listitem>
            <para>The  <code>Employee</code> edit screen shows the picture and also supports uploading, downloading and clearing the picture.</para>
          </listitem>
        </itemizedlist></para>
      <para>Entity class with a link to the image file:<programlisting language="java">@Table(name = &quot;SAMPLE_EMPLOYEE&quot;)
@Entity(name = &quot;sample$Employee&quot;)
public class Employee extends StandardEntity {
...
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = &quot;IMAGE_FILE_ID&quot;)
    protected FileDescriptor imageFile;

    public void setImageFile(FileDescriptor imageFile) {
        this.imageFile = imageFile;
    }

    public FileDescriptor getImageFile() {
        return imageFile;
    }
}</programlisting></para>
      <para>A fragment of the  <code>Employee</code> edit screen XML descriptor:<programlisting language="xml">&lt;groupBox caption=&quot;Photo&quot; spacing=&quot;true&quot;
          height=&quot;250px&quot; width=&quot;250px&quot; expand=&quot;embeddedImage&quot;&gt;
        &lt;embedded id=&quot;embeddedImage&quot; width=&quot;100%&quot;
                  align=&quot;MIDDLE_CENTER&quot;/&gt;
    &lt;hbox align=&quot;BOTTOM_LEFT&quot;
          spacing=&quot;true&quot;&gt;
        &lt;upload id=&quot;uploadField&quot;/&gt;
        &lt;button id=&quot;downloadImageBtn&quot;
                caption=&quot;Download&quot;
                invoke=&quot;onDownloadImageBtnClick&quot;/&gt;
        &lt;button id=&quot;clearImageBtn&quot;
                caption=&quot;Clear&quot;
                invoke=&quot;onClearImageBtnClick&quot;/&gt;
    &lt;/hbox&gt;
&lt;/groupBox&gt;</programlisting></para>
      <para>Components used to display, upload and download images are contained within the  <link linkend="gui_GroupBoxLayout">groupBox</link> container. Its top part shows a picture using the  <link linkend="gui_Embedded">Embedded</link> component, while its bottom part from left to right contains an <link linkend="gui_FileUploadField">upload</link> component and a   <link linkend="gui_Button">buttons</link> to download and clear the image. As a result, this part of the screen should look like this:<mediaobject>
          <imageobject>
            <imagedata align="center" fileref="img/images_recipe.png"/>
          </imageobject>
        </mediaobject></para>
      <para>Now, let us have a look at the  <link linkend="abstractEditor">edit screen controller</link>.<programlisting language="java" lang="">public class EmployeeEdit extends AbstractEditor&lt;Employee&gt; {

    private Log log = LogFactory.getLog(EmployeeEdit.class);

    @Inject
    private DataSupplier dataSupplier;
    @Inject
    private FileStorageService fileStorageService;
    @Inject
    private FileUploadingAPI fileUploading;
    @Inject
    private ExportDisplay exportDisplay;

    @Inject
    private Embedded embeddedImage;
    @Inject
    private FileUploadField uploadField;
    @Inject
    private Button downloadImageBtn;
    @Inject
    private Button clearImageBtn;
    @Inject
    private Datasource&lt;Employee&gt; employeeDs;

    private static final int IMG_HEIGHT = 190;
    private static final int IMG_WIDTH = 220;

    @Override
    public void init(Map&lt;String, Object&gt; params) {
        uploadField.addListener(new FileUploadField.ListenerAdapter() {
            @Override
            public void uploadSucceeded(Event event) {
                FileDescriptor fd = uploadField.getFileDescriptor();
                try {
                    fileUploading.putFileIntoStorage(uploadField.getFileId(), fd);
                } catch (FileStorageException e) {
                    throw new RuntimeException(e);
                }
                getItem().setImageFile(dataSupplier.commit(fd, null));
                displayImage();
            }

            @Override
            public void uploadFailed(Event event) {
                showNotification(&quot;Upload failed&quot;, NotificationType.HUMANIZED);
            }
        });

        employeeDs.addListener(new DsListenerAdapter&lt;Employee&gt;() {
            @Override
            public void valueChanged(Employee source, String property, 
                                     @Nullable Object prevValue, @Nullable Object value) {
                if (&quot;imageFile&quot;.equals(property)) {
                    updateImageButtons(value != null);
                }
            }
        });
    }

    @Override
    protected void postInit() {
        displayImage();
        updateImageButtons(getItem().getImageFile() != null);
    }

    public void onDownloadImageBtnClick(Component source) {
        if (getItem().getImageFile() != null)
            exportDisplay.show(getItem().getImageFile(), ExportFormat.OCTET_STREAM);
    }

    public void onClearImageBtnClick(Component source) {
        getItem().setImageFile(null);
        displayImage();
    }

    private void updateImageButtons(boolean enable) {
        downloadImageBtn.setEnabled(enable);
        clearImageBtn.setEnabled(enable);
    }

    private void displayImage() {
        byte[] bytes = null;
        if (getItem().getImageFile() != null) {
            try {
                bytes = fileStorageService.loadFile(getItem().getImageFile());
            } catch (FileStorageException e) {
                log.error(&quot;Unable to load image file&quot;, e);
                showNotification(&quot;Unable to load image file&quot;, NotificationType.HUMANIZED);
            }
        }
        if (bytes != null) {
            embeddedImage.setSource(getItem().getImageFile().getName(), new ByteArrayInputStream(bytes));
            embeddedImage.setType(Embedded.Type.IMAGE);
            BufferedImage image;
            try {
                image = ImageIO.read(new ByteArrayInputStream(bytes));
                int width = image.getWidth();
                int height = image.getHeight();

                if (((double) height / (double) width) &gt; ((double) IMG_HEIGHT / (double) IMG_WIDTH)) {
                    embeddedImage.setHeight(String.valueOf(IMG_HEIGHT));
                    embeddedImage.setWidth(String.valueOf(width * IMG_HEIGHT / height));
                } else {
                    embeddedImage.setWidth(String.valueOf(IMG_WIDTH));
                    embeddedImage.setHeight(String.valueOf(height * IMG_WIDTH / width));
                }
            } catch (IOException e) {
                log.error(&quot;Unable to resize image&quot;, e);
            }
            // refresh image
            embeddedImage.setVisible(false);
            embeddedImage.setVisible(true);
        } else {
            embeddedImage.setVisible(false);
        }
    }
}</programlisting></para>
      <itemizedlist>
        <listitem>
          <para>The  <code>init()</code> method first initializes the  <code>uploadField</code> field component intended for new images upload. In case of a successful upload, a new  <code>FileDescriptor</code> instance is retrieved from the component and the corresponding files are sent from the temporary storage to the persistent one by invoking  <code>FileUploadingAPI.putFileIntoStorage()</code>. After that, the  <code>FileDescriptor</code> is saved to the DB by invoking the  <link linkend="dataSupplier">DataSupplier.commit()</link>, and the saved instance is set as the value of the <code>imageFile</code> attribute of the edited  <code>Employee</code> entity. Then, the controller&apos;s <code>displayImage()</code> method is invoked to display the uploaded image.</para>
          <para>After that  a listener is added in the  <code>init()</code> method to the datasource containing an <code>Employee</code> instance.  The listener enables or locks download and clear  buttons, depending on the fact whether the  file has been loaded or not.</para>
        </listitem>
        <listitem>
          <para><code>postInit()</code> method performs file display and refreshes the button states, depending on the existence of a loaded file.</para>
        </listitem>
        <listitem>
          <para><code>onDownloadImageBtnClick()</code> is invoked when the <code>downloadImageBtn</code> button is clicked; it downloads the file using the <link linkend="file_download">ExportDisplay</link> interface.</para>
        </listitem>
        <listitem>
          <para><code>onClearImageBtnClick()</code> is invoked when the  <code>clearImageBtn</code> is clicked; it clears the <code>imageFile</code> attribute of the <code>Employee</code> entity. The file is not deleted from storage.</para>
        </listitem>
        <listitem>
          <para><code>displayImage()</code> loads the file from storage into a byte array, sets the content of the  <code>embeddedImage</code> component and recalculates its size to preserve image height to width ratio.</para>
          <para>It should be noted that loading files into byte arrays is acceptable for small files only. If the file size is not predictable, you should download it using  <link linkend="file_download">ExportDisplay</link>, which sends the file through input and output streams and never keeps the entire file in memory.</para>
        </listitem>
      </itemizedlist>
    </section>
    <section id="own_component_samples">
      <title>Creating Custom Visual Components</title>
      <para>This section covers the examples of creating and using custom visual components.</para>
      <section id="vaadin_addon_sample">
        <title>Example of Using a Third-party Vaadin Component </title>
        <para>Integration of third-party Vaadin components is described in  <xref linkend="vaadin_addon"/>.</para>
        <para>Below is the example of using the <application>Stepper</application> component, available at <ulink url="http://vaadin.com/addon/stepper">http://vaadin.com/addon/stepper</ulink>. This component allows changing text field value in steps using the keyboard, mouse scroll or built-in up/down buttons.</para>
        <itemizedlist>
          <listitem>
            <para>Assuming that the project has a  <code>Customer</code> entity with a String-type <code>name</code> attribute. An editor screen (<filename>customer-edit.xml</filename> ) was created in the <structname>web</structname> module with the following layout:<programlisting language="xml">&lt;layout expand=&quot;windowActions&quot;
        spacing=&quot;true&quot;&gt;
    &lt;fieldGroup id=&quot;fieldGroup&quot;
                datasource=&quot;customerDs&quot;&gt;
        &lt;column width=&quot;250px&quot;&gt;
            &lt;field id=&quot;name&quot;/&gt;
        &lt;/column&gt;
    &lt;/fieldGroup&gt;
    &lt;iframe id=&quot;windowActions&quot;
            screen=&quot;editWindowActions&quot;/&gt;
&lt;/layout&gt;</programlisting></para>
            <para>Our task is to add an <code>Integer</code>-type  <code>score</code> attribute for step editing to the screen.</para>
          </listitem>
          <listitem>
            <para>Add the  <code>score</code> attribute to the <code>Customer</code> entity in <application>CUBA Studio</application>: <programlisting language="java">@Column(name = &quot;SCORE&quot;)
protected Integer score;

public void setScore(Integer score) {
    this.score = score;
}
public Integer getScore() {
    return score;
}</programlisting></para>
            <para>Generate DB scripts and run the database update.</para>
          </listitem>
          <listitem>
            <para>Run the  <guibutton>Create web toolkit module</guibutton> command from the  <guilabel>Project properties</guilabel> section of the Studio navigation panel.</para>
          </listitem>
          <listitem>
            <para>Add a dependency on the component add-on to the <structname>web</structname> module in the project’s   <link linkend="build.gradle">build.gradle</link>:<programlisting>configure(webModule) {
    ...
    dependencies {
        ...
        compile(&quot;org.vaadin.addons:stepper:2.1.2&quot;)
    }</programlisting></para>
          </listitem>
          <listitem>
            <para>Re-create the IDE project files (<guimenu>Create or update IDEA project files</guimenu> menu item).</para>
          </listitem>
          <listitem>
            <para>Include the add-on widget set in the  <filename>AppWidgetSet.gwt.xml</filename> of the project’s  <structname>web-toolkit</structname> module after the platform widget set:<programlisting language="xml">&lt;module&gt;
    &lt;inherits name=&quot;com.haulmont.cuba.web.toolkit.ui.WidgetSet&quot; /&gt;
    
    &lt;inherits name=&quot;org.vaadin.risto.stepper.widgetset.StepperWidgetset&quot; /&gt;

    &lt;set-property name=&quot;user.agent&quot; value=&quot;safari&quot; /&gt;</programlisting></para>
            <para>Building of widgets can be accelerated by setting the  <code>user.agent</code> property. In this example, the widget set will be built only for WebKit-based browsers: Chrome, Safari, etc.</para>
          </listitem>
          <listitem>
            <para>Add a custom <code>score</code> field to the <link linkend="gui_FieldGroup">fieldGroup</link> component in the   <filename>customer-edit.xml</filename> descriptor:<programlisting language="xml">&lt;fieldGroup id=&quot;fieldGroup&quot;
            datasource=&quot;customerDs&quot;&gt;
    &lt;column width=&quot;250px&quot;&gt;
        &lt;field id=&quot;name&quot;/&gt;
        &lt;field id=&quot;score&quot; custom=&quot;true&quot; caption=&quot;Score&quot;/&gt;
    &lt;/column&gt;
&lt;/fieldGroup&gt;</programlisting></para>
          </listitem>
          <listitem>
            <para>Add the following code to the  <code>CustomerEdit</code> screen controller:<programlisting language="java">public class CustomerEdit extends AbstractEditor&lt;Customer&gt; {

    @Inject
    private ComponentsFactory componentsFactory;
    @Inject
    private FieldGroup fieldGroup;

    private IntStepper stepper = new IntStepper();

    @Override
    public void init(Map&lt;String, Object&gt; params) {
        fieldGroup.addCustomField(&quot;score&quot;, new FieldGroup.CustomFieldGenerator() {
            @Override
            public Component generateField(final Datasource datasource, final String propertyId) {
                Component box = componentsFactory.createComponent(BoxLayout.VBOX);
                com.vaadin.ui.Layout layout = WebComponentsHelper.unwrap(box);
                layout.addComponent(stepper);
                stepper.setSizeFull();

                stepper.addValueChangeListener(new Property.ValueChangeListener() {
                    @Override
                    public void valueChange(Property.ValueChangeEvent event) {
                        datasource.getItem().setValue(propertyId, event.getProperty().getValue());
                    }
                });

                return box;
            }
        });
    }

    @Override
    protected void postInit() {
        stepper.setValue(getItem().getScore());
    }
}</programlisting></para>
            <para>An instance of the component from the add-on is created in the  <code>stepper</code> field. The  <code>init()</code> method initializes the custom <code>score</code> field. The  <code>ComponentsFactory</code> creates an instance of  <link linkend="gui_BoxLayout">BoxLayout</link>, retrieves a link to the Vaadin container via  <link linkend="webComponentsHelper">WebComponentsHelper</link>, and adds the new component to it. The <code>BoxLayout</code> is then returned to be used in the custom field.</para>
            <para>Component data binding is implemented by setting its current value from the edited  <code>Customer</code> in the   <code>postInit()</code> method. Additionally, the corresponding entity attribute is updated through the implemented value change listener, when the user changes the value. </para>
          </listitem>
          <listitem>
            <para>The new component can be used in any part of the screen outside of the  <code>FieldGroup</code>. In order to do this, declare a container in the XML-descriptor:<programlisting language="xml">&lt;hbox id=&quot;scoreBox&quot;
      spacing=&quot;true&quot;&gt;
    &lt;label value=&quot;Score&quot;/&gt;
&lt;/hbox&gt;</programlisting></para>
            <para>Inject the container in the screen controller, retrieve a link to the Vaadin container and add the component to it:<programlisting language="java">public class CustomerEdit extends AbstractEditor&lt;Customer&gt; {

    @Inject
    private BoxLayout scoreBox;

    private IntStepper stepper = new IntStepper();

    @Override
    public void init(Map&lt;String, Object&gt; params) {
        com.vaadin.ui.Layout box = WebComponentsHelper.unwrap(scoreBox);
        box.addComponent(stepper);

        stepper.addValueChangeListener(new Property.ValueChangeListener() {
            @Override
            public void valueChange(Property.ValueChangeEvent event) {
                getItem().setValue(&quot;score&quot;, event.getProperty().getValue());
            }
        });
    }

    @Override
    protected void postInit() {
        stepper.setValue(getItem().getScore());
    }
}</programlisting></para>
            <para>Data binding is implemented in the same way as described above.</para>
          </listitem>
          <listitem>
            <para>To adapt the component style, create a theme extension in the project. Run the  <guibutton>Create theme extension</guibutton> command in the <guilabel>Project properties</guilabel> section of the Studio navigation panel. After that, open the  <filename>themes/havana/havana-ext.scss</filename> file in the web module and add the following code:<programlisting language="css">@import &quot;../havana/havana&quot;; 
 
@mixin havana-ext { 
  @include havana; 
 
  /* Basic styles for stepper */
  .v-stepper { 
    /* Use box-sizing: border-box; for all browsers */
    @include box-defaults; 
 
    height: 25px; 
    border: 0; 
 
    /* Use theme fonts */
    font-family: $theme_fonts; 
  } 
 
  /* Basic styles for inner text box */
  .v-stepper input[type=&quot;text&quot;] { 
    /* Use box-sizing: border-box; for all browsers */
    @include box-defaults; 
 
    height: 25px; 
    padding: 1px; 
    outline: 0; 
    margin: 0; 
 
    /* Use border color from theme */
    border: 1px solid $theme_fieldBorderColor; 
  } 
 
  /* Focused styles */
  .v-stepper.v-stepper input[type=&quot;text&quot;]:focus { 
    /* Use focused border color from theme */
    border-color: $theme_fieldFocusedBorderColor; 
    /* hide default focus outline */
    outline: 0; 
  } 
 
  /* Readonly styles */
  .v-readonly.v-stepper input[type=&quot;text&quot;], 
  .v-readonly.v-stepper input[type=&quot;text&quot;]:focus { 
    /* Use readonly border color from theme */
    border-color: $theme_fieldReadonlyBorderColor; 
  } 
}</programlisting></para>
          </listitem>
        </itemizedlist>
      </section>
      <section id="own_gui_component_sample">
        <title>Example of Integrating a Vaadin Component into the Generic UI</title>
        <para><xref linkend="own_gui_component"/> covers the basics of native components integration into the Generic UI, which allows them to be declared in XML-descriptors and associated with data.</para>
        <para>In the <link linkend="vaadin_addon_sample">previous section</link>, we have included the third-party Stepper component in the project. Integration of the IntStepper component, which implements incremental change of   <code>int</code> numerical values, is described below.<itemizedlist>
            <listitem>
              <para>Definition of component interface in the <structname>gui</structname> module:<programlisting language="java">package com.company.myproject.gui.components;

import com.haulmont.cuba.gui.components.Field;

public interface IntStepper extends Field {

    String NAME = &quot;intStepper&quot;;

    boolean isManualInputAllowed();
    void setManualInputAllowed(boolean value);

    boolean isMouseWheelEnabled();
    void setMouseWheelEnabled(boolean value);

    int getStepAmount();
    void setStepAmount(int amount);

    int getMaxValue();
    void setMaxValue(int maxValue);

    int getMinValue();
    void setMinValue(int minValue);
}</programlisting></para>
              <para>The chosen base interface for the component is  <code>Field</code>, which allows  data binding, i.e. the ability to view and edit an entity attribute.</para>
            </listitem>
            <listitem>
              <para>Component  implementation in the  <structname>web</structname> module:<programlisting language="java">package com.company.myproject.web.components;

import com.company.myproject.gui.components.IntStepper;
import com.haulmont.cuba.web.gui.components.WebAbstractField;

public class WebIntStepper 
        extends WebAbstractField&lt;org.vaadin.risto.stepper.IntStepper&gt; 
        implements IntStepper {

    public WebIntStepper() {
        component = new org.vaadin.risto.stepper.IntStepper();
    }

    @Override
    public boolean isManualInputAllowed() {
        return component.isManualInputAllowed();
    }
    @Override
    public void setManualInputAllowed(boolean value) {
        component.setManualInputAllowed(value);
    }

    @Override
    public boolean isMouseWheelEnabled() {
        return component.isMouseWheelEnabled();
    }
    @Override
    public void setMouseWheelEnabled(boolean value) {
        component.setMouseWheelEnabled(value);
    }

    @Override
    public int getStepAmount() {
        return component.getStepAmount();
    }
    @Override
    public void setStepAmount(int amount) {
        component.setStepAmount(amount);
    }

    @Override
    public int getMaxValue() {
        return component.getMaxValue();
    }
    @Override
    public void setMaxValue(int maxValue) {
        component.setMaxValue(maxValue);
    }

    @Override
    public int getMinValue() {
        return component.getMinValue();
    }
    @Override
    public void setMinValue(int minValue) {
        component.setMinValue(minValue);
    }
}</programlisting></para>
              <para>The chosen base class is  <code>WebAbstractField</code>. The base class implements the <link linkend="datasources">datasource binding</link>  <code>Field</code> logic and other methods of the <code>Field</code> interface.</para>
            </listitem>
            <listitem>
              <para>Implementation of XML loader in the  <structname>gui</structname> module:<programlisting language="java">package com.company.myproject.gui.loaders;

import com.company.myproject.gui.components.IntStepper;
import com.haulmont.cuba.gui.components.Component;
import com.haulmont.cuba.gui.xml.layout.*;
import com.haulmont.cuba.gui.xml.layout.loaders.AbstractFieldLoader;
import org.dom4j.Element;

public class IntStepperLoader extends AbstractFieldLoader {

    public IntStepperLoader(Context context, LayoutLoaderConfig config, ComponentsFactory factory) {
        super(context, config, factory);
    }

    @Override
    public Component loadComponent(ComponentsFactory factory, Element element, Component parent) {
        IntStepper component = (IntStepper) super.loadComponent(factory, element, parent);

        String manualInput = element.attributeValue(&quot;manualInput&quot;);
        if (manualInput != null) {
            component.setManualInputAllowed(Boolean.valueOf(manualInput));
        }
        String mouseWheel = element.attributeValue(&quot;mouseWheel&quot;);
        if (mouseWheel != null) {
            component.setMouseWheelEnabled(Boolean.valueOf(mouseWheel));
        }
        String stepAmount = element.attributeValue(&quot;stepAmount&quot;);
        if (stepAmount != null) {
            component.setStepAmount(Integer.valueOf(stepAmount));
        }
        String maxValue = element.attributeValue(&quot;maxValue&quot;);
        if (maxValue != null) {
            component.setMaxValue(Integer.valueOf(maxValue));
        }
        String minValue = element.attributeValue(&quot;minValue&quot;);
        if (minValue != null) {
            component.setMinValue(Integer.valueOf(minValue));
        }
        return component;
    }
}</programlisting></para>
              <para>The <code>AbstractFieldLoader</code> class contains the loading logic for the basic properties of the  <code>Field</code> component. It is sufficient to load the specific properties of the <code>IntStepper</code> component only.</para>
            </listitem>
            <listitem>
              <para>Implementation of component palette in the  <structname>web</structname> module:<programlisting language="java">package com.company.myproject.web;

import com.company.myproject.gui.components.IntStepper;
import com.company.myproject.gui.loaders.IntStepperLoader;
import com.company.myproject.web.components.WebIntStepper;
import com.haulmont.cuba.gui.ComponentPalette;
import com.haulmont.cuba.gui.components.Component;
import com.haulmont.cuba.gui.xml.layout.ComponentLoader;
import java.util.HashMap;
import java.util.Map;

public class AppComponentPalette implements ComponentPalette {

    @Override
    public Map&lt;String, Class&lt;? extends ComponentLoader&gt;&gt; getLoaders() {
        Map&lt;String, Class&lt;? extends ComponentLoader&gt;&gt; loaders = new HashMap&lt;&gt;();
        loaders.put(IntStepper.NAME, IntStepperLoader.class);
        return loaders;
    }

    @Override
    public Map&lt;String, Class&lt;? extends Component&gt;&gt; getComponents() {
        Map&lt;String, Class&lt;? extends Component&gt;&gt; components = new HashMap&lt;&gt;();
        components.put(IntStepper.NAME, WebIntStepper.class);
        return components;
    }
}</programlisting></para>
            </listitem>
            <listitem>
              <para>Registration of the component palette in the  <code>App</code> class of the <structname>web</structname> module:<programlisting language="java">package com.company.myproject.web;

import com.haulmont.cuba.web.DefaultApp;
import com.haulmont.cuba.web.gui.WebUIPaletteManager;

public class App extends DefaultApp {

    static {
        WebUIPaletteManager.registerPalettes(new AppComponentPalette());
    }
}</programlisting></para>
            </listitem>
            <listitem>
              <para>Definition of the component XSD in the  <structname>gui</structname> module:<programlisting language="xml">&lt;xs:schema targetNamespace=&quot;http://schemas.company.com/app/0.1/app-components.xsd&quot;
           xmlns:xs=&quot;http://www.w3.org/2001/XMLSchema&quot;
           xmlns=&quot;http://schemas.company.com/app/0.1/app-components.xsd&quot;
           elementFormDefault=&quot;qualified&quot;
           attributeFormDefault=&quot;unqualified&quot;&gt;

    &lt;xs:element name=&quot;intStepper&quot;&gt;
        &lt;xs:complexType&gt;
            &lt;xs:attribute name=&quot;id&quot; type=&quot;xs:string&quot;/&gt;
            &lt;xs:attribute name=&quot;caption&quot; type=&quot;xs:string&quot;/&gt;
            &lt;xs:attribute name=&quot;width&quot; type=&quot;xs:string&quot;/&gt;
            &lt;xs:attribute name=&quot;height&quot; type=&quot;xs:string&quot;/&gt;
            &lt;xs:attribute name=&quot;datasource&quot; type=&quot;xs:string&quot;/&gt;
            &lt;xs:attribute name=&quot;property&quot; type=&quot;xs:string&quot;/&gt;
            &lt;xs:attribute name=&quot;manualInput&quot; type=&quot;xs:boolean&quot;/&gt;
            &lt;xs:attribute name=&quot;mouseWheel&quot; type=&quot;xs:boolean&quot;/&gt;
            &lt;xs:attribute name=&quot;stepAmount&quot; type=&quot;xs:int&quot;/&gt;
            &lt;xs:attribute name=&quot;maxValue&quot; type=&quot;xs:int&quot;/&gt;
            &lt;xs:attribute name=&quot;minValue&quot; type=&quot;xs:int&quot;/&gt;
        &lt;/xs:complexType&gt;
    &lt;/xs:element&gt;

&lt;/xs:schema&gt;</programlisting></para>
            </listitem>
            <listitem>
              <para>Example of using the component inside  a container:<programlisting language="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;no&quot;?&gt;
&lt;window xmlns=&quot;http://schemas.haulmont.com/cuba/5.5/window.xsd&quot;
        xmlns:app=&quot;http://schemas.company.com/app/0.1/app-components.xsd&quot;
        caption=&quot;msg://editCaption&quot;
        class=&quot;com.company.myproject.web.customer.CustomerEdit&quot;
        datasource=&quot;customerDs&quot;
        focusComponent=&quot;fieldGroup&quot;
        messagesPack=&quot;com.company.myproject.web.customer&quot;&gt;
    &lt;dsContext&gt;
        &lt;datasource id=&quot;customerDs&quot;
                    class=&quot;com.company.myproject.entity.Customer&quot;
                    view=&quot;_local&quot;/&gt;
    &lt;/dsContext&gt;
    &lt;layout expand=&quot;windowActions&quot;
            spacing=&quot;true&quot;&gt;
        &lt;app:intStepper id=&quot;stepper&quot; datasource=&quot;customerDs&quot; property=&quot;score&quot; caption=&quot;Score&quot;
                        minValue=&quot;1&quot; maxValue=&quot;20&quot;/&gt;
        &lt;iframe id=&quot;windowActions&quot;
                screen=&quot;editWindowActions&quot;/&gt;
    &lt;/layout&gt;
&lt;/window&gt;</programlisting></para>
              <para>In the example above, the  <code>intStepper</code> component is associated with the  <code>score</code> attribute of the  <code>Customer</code> entity, an instance of which is contained within the  <code>customerDs</code> data source.</para>
            </listitem>
            <listitem>
              <para>Example of using the component in a <link linkend="gui_FieldGroup">FieldGroup</link>:<programlisting language="xml">&lt;dsContext&gt;
    &lt;datasource id=&quot;customerDs&quot;
                class=&quot;com.company.myproject.entity.Customer&quot;
                view=&quot;_local&quot;/&gt;
&lt;/dsContext&gt;
&lt;layout expand=&quot;windowActions&quot;
        spacing=&quot;true&quot;&gt;
    &lt;fieldGroup id=&quot;fieldGroup&quot;
                datasource=&quot;customerDs&quot;&gt;
        &lt;column width=&quot;250px&quot;&gt;
            &lt;field id=&quot;name&quot;/&gt;
            &lt;field id=&quot;score&quot; custom=&quot;true&quot; caption=&quot;Score&quot;/&gt;
        &lt;/column&gt;
    &lt;/fieldGroup&gt;
...</programlisting><programlisting language="java">@Inject
private ComponentsFactory componentsFactory;
@Inject
private FieldGroup fieldGroup;

@Override
public void init(Map&lt;String, Object&gt; params) {
    fieldGroup.addCustomField(&quot;score&quot;, new FieldGroup.CustomFieldGenerator() {
        @Override
        public Component generateField(final Datasource datasource, final String propertyId) {
            IntStepper stepper = componentsFactory.createComponent(IntStepper.NAME);
            stepper.setDatasource(datasource, propertyId);
            stepper.setWidth(&quot;100%&quot;);
            return stepper;
        }
    });
}</programlisting></para>
            </listitem>
          </itemizedlist> </para>
      </section>
    </section>
  </section>
</chapter>
