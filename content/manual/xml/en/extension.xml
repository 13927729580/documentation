<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE section PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<section id="extension">
  <title>Functionality Extension</title>
  <para>The platform enables extending and overriding the following aspects of its functionality in applications:<itemizedlist>
      <listitem>
        <para>Extending entity attributes set.</para>
      </listitem>
      <listitem>
        <para>Extending screens functionality. </para>
      </listitem>
      <listitem>
        <para>Extending and overriding business logic contained in  <application>Spring</application> beans.</para>
      </listitem>
    </itemizedlist></para>
  <para>Below is an example of  the first two operations, illustrated by adding the &quot;Address&quot; field to the  <code>User</code> entity of the platform <link linkend="users">security subsystem</link>.</para>
  <section id="entity_extension">
    <title>Extending an Entity</title>
    <para>In the application project, derive an entity class  from <code>com.haulmont.cuba.security.entity.User</code> and add the required attribute with the corresponding access methods:<programlisting language="java">@Entity(name = &quot;sales$User&quot;)
@Extends(User.class)
public class ExtUser extends User {

  @Column(name = &quot;ADDRESS&quot;, length = 100)
  private String address;

  public String getAddress() {
      return address;
  }

  public void setAddress(String address) {
      this.address = address;
  }
}</programlisting></para>
    <para>The new name of the entity should be specified in the   <link linkend="entity_annotation">@Entity</link> annotation. Since the parent entity does not declare the  <link linkend="inheritance_annotation">inheritance strategy</link>, it is assumed to be <code>SINGLE_TABLE</code> by default. It means that the child entity will be stored in the same table as the parent one, and the   <link linkend="table_annotation">@Table</link> annotation is not required. Other parent entity annotations ( <link linkend="namePattern">@NamePattern</link>,  <link linkend="listeners_annotation">@Listeners</link>, etc.)  are automatically applied to the child entity, but can be overridden in its class. </para>
    <para>An important element of the new entity class is the <code>@Extends</code> annotation, which takes the parent class  as a parameter. It enables creating a registry of  child entities and forces the platform mechanisms to use them everywhere instead of the parent ones. The registry is implemented by the  <code>ExtendedEntities</code> class, which is a  <application>Spring</application> bean named <code>cuba_ExtendedEntities</code>, and is also accessible via the  <link linkend="metadata">Metadata</link> interface.</para>
    <para>Add a localized name of the new attribute to the <code>com.sample.sales.entity</code> <link linkend="message_packs">package</link>: </para>
    <para><filename>messages.properties</filename><programlisting>ExtUser.address=Address</programlisting></para>
    <para><filename>messages_ru.properties</filename><programlisting>ExtUser.address=Адрес</programlisting></para>
    <para>Register the new entity in the   <link linkend="persistence.xml">persistence.xml</link> file of the project:<programlisting language="xml">&lt;class&gt;com.sample.sales.entity.ExtUser&lt;/class&gt;</programlisting></para>
    <para>Add the update script for the corresponding table to the  <link linkend="db_scripts">database create and update scripts</link>:<programlisting>alter table SEC_USER add ADDRESS varchar(100)</programlisting></para>
  </section>
  <section id="screen_extension">
    <title>Extending Screens</title>
    <para>The platform supports creating new  <link linkend="screen_xml">XML descriptors</link> by inheriting them from the existing ones.</para>
    <para>XML inheritance is implemented by specifying the parent descriptor path in the <sgmltag>extends</sgmltag> attribute of the root   <sgmltag>window</sgmltag> element.</para>
    <para>XML screen elements overriding rules:<itemizedlist>
        <listitem>
          <para>If the extending descriptor has a certain element, the corresponding element will be searched for in the parent descriptor using the following algorithm:<itemizedlist>
              <listitem>
                <para>If the overriding element is a  <sgmltag>view</sgmltag>, the corresponding element will be searched by the  <sgmltag>name</sgmltag>, <sgmltag>class</sgmltag> and <sgmltag>entity</sgmltag> attributes.</para>
              </listitem>
              <listitem>
                <para>If the overriding element is a  <sgmltag>property</sgmltag>, the corresponding element will be searched by the  <sgmltag>name</sgmltag> attribute.</para>
              </listitem>
              <listitem>
                <para>In other cases, if the overrinding element has the <code>id</code> attribute, the corresponding element with the same  <sgmltag>id</sgmltag>  will be searched for. </para>
              </listitem>
              <listitem>
                <para role="bold">If the search is successful, the found  element is  <emphasis role="bold">overridden</emphasis>.</para>
              </listitem>
              <listitem>
                <para>Otherwise, the platform determines how many elements with the provided path and name are contained  in the parent descriptor. If there is only one element, it is  <emphasis role="bold">overridden</emphasis>.</para>
              </listitem>
              <listitem>
                <para>If search yields no result and there is either zero or more than one element with the given path and name in the parent descriptor, a new element is <emphasis role="bold">added</emphasis>.</para>
              </listitem>
            </itemizedlist></para>
        </listitem>
        <listitem>
          <para>The text for the overridden or added element is copied from the extending element. </para>
        </listitem>
        <listitem>
          <para>All attributes from the extending element are copied to the overridden or added element. If attribute names match, the value is taken from the extending element.</para>
        </listitem>
        <listitem>
          <para>By default, the new element is added to the end of the list of adjacent elements. In order to add a new element to the beginning or with an arbitrary index, you can do the following: <itemizedlist>
              <listitem>
                <para>Define an additional namespace in the extending descriptor: <code>xmlns:ext=&quot;http://schemas.haulmont.com/cuba/5.3/window-ext.xsd&quot;</code>.</para>
              </listitem>
              <listitem>
                <para>Add the  <sgmltag>ext:index</sgmltag> attribute with a desired index, for example:  <code>ext:index=&quot;0&quot;</code>  to the extending element.</para>
              </listitem>
            </itemizedlist></para>
        </listitem>
      </itemizedlist></para>
    <para>In order to debug the descriptor conversion, you can output the resulting XML to the server log by specifying the  <code>TRACE</code> level for the <code>com.haulmont.cuba.gui.xml.XmlInheritanceProcessor</code> logger in the <application>Log4j</application> configuration file:<programlisting language="xml">&lt;appender name=&quot;FILE&quot; ...
      &lt;param name=&quot;Threshold&quot; value=&quot;TRACE&quot;/&gt;
...
&lt;category name=&quot;com.haulmont.cuba.gui.xml.XmlInheritanceProcessor&quot;&gt;
  &lt;priority value=&quot;TRACE&quot;/&gt;
&lt;/category&gt;</programlisting></para>
    <para>Below is an example descriptor of the <code>ExtUser</code> entities browser screen:<programlisting language="xml">&lt;window xmlns=&quot;http://schemas.haulmont.com/cuba/5.3/window.xsd&quot;
      xmlns:ext=&quot;http://schemas.haulmont.com/cuba/5.3/window-ext.xsd&quot;
      extends=&quot;/com/haulmont/cuba/gui/app/security/user/browse/user-browse.xml&quot;&gt;
  &lt;layout&gt;
      &lt;groupTable id=&quot;usersTable&quot;&gt;
          &lt;columns&gt;
              &lt;column id=&quot;address&quot; ext:index=&quot;2&quot;/&gt;
          &lt;/columns&gt;
      &lt;/groupTable&gt;
  &lt;/layout&gt;
&lt;/window&gt;</programlisting></para>
    <para>In this example, the descriptor is inherited from the  standard  <code>User</code> entities browser of the platform. The  <code>address</code> column is added to the table with index  <code>2</code>, so it is displayed after  <code>login</code> and <code>name</code>.</para>
    <para>If you register a new screen in   <link linkend="screens.xml">screens.xml</link> with the same identifiers that were used for the parent screen, the new screen will be invoked everywhere instead of the old one.<programlisting language="xml">&lt;screen id=&quot;sec$User.browse&quot;
      template=&quot;com/sample/sales/gui/extuser/extuser-browse.xml&quot;/&gt;
&lt;screen id=&quot;sec$User.lookup&quot;
      template=&quot;com/sample/sales/gui/extuser/extuser-browse.xml&quot;/&gt;</programlisting></para>
    <para>Similarly, let us create an edit screen:<programlisting language="xml">&lt;window xmlns=&quot;http://schemas.haulmont.com/cuba/5.3/window.xsd&quot;
      xmlns:ext=&quot;http://schemas.haulmont.com/cuba/5.3/window-ext.xsd&quot;
      extends=&quot;/com/haulmont/cuba/gui/app/security/user/edit/user-edit.xml&quot;&gt;
  &lt;layout&gt;
      &lt;fieldGroup id=&quot;fieldGroup&quot;&gt;
          &lt;column id=&quot;fieldGroupColumn2&quot;&gt;
              &lt;field id=&quot;address&quot; ext:index=&quot;4&quot;/&gt;
          &lt;/column&gt;
      &lt;/fieldGroup&gt;
  &lt;/layout&gt;
&lt;/window&gt;</programlisting></para>
    <para>Register it in  <filename>screens.xml</filename> with the identifier of the parent screen:<programlisting language="xml">&lt;screen id=&quot;sec$User.edit&quot;
      template=&quot;com/sample/sales/gui/extuser/extuser-edit.xml&quot;/&gt;</programlisting></para>
    <para>Once all the  abovementioned actions are completed, the application will use <code>ExtUser</code> with the corresponding screens instead of the standard  <code>User</code> entity of the platform.</para>
    <para>Screen controller can be extended by creating a new class that is inherited from the base screen controller. Class name is specified in the  <sgmltag>class</sgmltag> attribute of the root element of the extending XML descriptor; the usual rules of inheriting XML described above will apply.</para>
  </section>
  <section id="bean_extension">
    <title>Extending Business Logic</title>
    <para>The main part of platform business logic is contained in  <application>Spring</application> beans. This enables to easily extend or override it in the application.</para>
    <para>To substitute a bean implementation, you should create your own class that implements the interface or extends the base platform class and register it in <link linkend="spring.xml">spring.xml</link> of the application. You cannot apply the  <code>@ManagedBean</code> annotation to the extending class;  overriding beans is possible only in the XML configuration.</para>
    <para>Below is an example of adding a method to the  <link linkend="persistenceTools">PersistenceTools</link> bean.</para>
    <para>First, create a class with the necessary method:<programlisting language="java">public class ExtPersistenceTools extends PersistenceTools {

  public Entity reloadInSeparateTransaction(final Entity entity, final String... viewNames) {
      Entity result = persistence.createTransaction().execute(new Transaction.Callable&lt;Entity&gt;() {
          @Override
          public Entity call(EntityManager em) {
              return em.reload(entity, viewNames);
          }
      });
      return result;
  }
}</programlisting></para>
    <para>Register the class in  <filename>spring.xml</filename> of the project  <structname>core</structname> module with the same identifier as the platform bean:<programlisting language="xml">&lt;bean id=&quot;cuba_PersistenceTools&quot; class=&quot;com.sample.sales.core.ExtPersistenceTools&quot;/&gt;</programlisting></para>
    <para>After that, the  <application>Spring</application> context will always return    <code>ExtPersistenceTools</code> instead of the base<code>PersistenceTools</code> instance. A checking code example:<programlisting language="java">Persistence persistence;
PersistenceTools tools;

persistence = AppBeans.get(Persistence.class);
tools = persistence.getTools();
assertTrue(tools instanceof ExtPersistenceTools);

tools = AppBeans.get(PersistenceTools.class);
assertTrue(tools instanceof ExtPersistenceTools);

tools = AppBeans.get(PersistenceTools.NAME);
assertTrue(tools instanceof ExtPersistenceTools);</programlisting></para>
  </section>
</section>
