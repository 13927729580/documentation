<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE section PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<section id="gui_framework" xmlns:xi="http://www.w3.org/2001/XInclude">
  <title>Generic User Interface</title>
  <para>Generic user interface (Generic UI, GUI) subsystem allows you to create UI screens using XML and Java. The screens created using this approach work identically in both standard client  <link linkend="app_tiers">blocks</link>: Web Client и Desktop Client. </para>
  <figure>
    <title>The Structure of Generic User Interface </title>
    <mediaobject>
      <imageobject>
        <imagedata align="center" fileref="img/ClientStructure.png"/>
      </imageobject>
    </mediaobject>
  </figure>
  <para>Main components of Generic UI screens are marked as green:<itemizedlist>
      <listitem>
        <para><link linkend="screen_xml">XML-descriptors</link> – XML files containing information about datasources and screen layout.</para>
      </listitem>
      <listitem>
        <para><link linkend="screen_controller">Controllers</link> – Java classes containing logic for screen initialization and handling of events generated by UI controls.</para>
      </listitem>
    </itemizedlist></para>
  <para>The code of application screens included in the <structname>gui</structname> <link linkend="app_modules">module</link> interacts with visual component interfaces (VCL Interfaces) implemented separately in the  <structname>web</structname> and <structname>desktop</structname> modules of the  <structname>cuba</structname> <link linkend="base_projects">base project</link>. For Web Client the implementation is based on the <application>Vaadin</application> framework, for Desktop Client on the  <application>Java Swing</application> framework.</para>
  <para><link linkend="gui_vcl">Visual Components Library</link> (VCL)
contains a large set of ready-to-use components.</para>
  <para><link linkend="datasources">Datasources</link>  mechanism provides a unified interface that ensures functioning of data-aware visual components.</para>
  <para>Client’s infrastructure (Infrastructure) includes main application window, mechanisms for display and interaction of UI screens and means of interaction with the middleware.</para>
  <section id="screens">
    <title>Screens</title>
    <para>A generic UI screen is defined by an  <link linkend="screen_xml">XML-descriptor</link> and a  <link linkend="screen_controller">controller</link> class. The descriptor has a link to the controller class.</para>
    <para>In order to be able to invoke the screen from the main menu or from Java code (e.g. from controller of a different screen) the XML-descriptor should be registered in the project’s <link linkend="screens.xml">screens.xml</link>  file.</para>
    <para>The main menu of an application is generated separately for the Web Client and the Desktop Client based on the  <link linkend="menu.xml">menu.xml</link> files, located in the project’s  <structname>web</structname> and <structname>desktop</structname> modules.</para>
    <section id="screen_types">
      <title>Screen Types</title>
      <para>This section describes the following basic types of screens:
<itemizedlist>
          <listitem>
            <para><link linkend="frame">Frame</link></para>
          </listitem>
          <listitem>
            <para><link linkend="screen_simple">Simple Screen</link></para>
          </listitem>
          <listitem>
            <para><link linkend="screen_lookup">Lookup Screen</link></para>
          </listitem>
          <listitem>
            <para><link linkend="screen_edit">Edit Screen</link></para>
          </listitem>
        </itemizedlist></para>
      <section id="frame">
        <title>Frame</title>
        <para>Frames are parts of the screen intended for decomposition and reuse.</para>
        <para>The <link linkend="gui_IFrame">iframe</link> element of the screen’s XML is used to add a frame to the screen. It defines either path to the frame’s XML descriptor, or its identifier, if the frame is registered in <link linkend="screens.xml">screens.xml</link>.</para>
        <para>A frame controller should be derived from the <code>AbstractFrame</code> class.</para>
        <para>Rules for interaction between a screen and its enclosed frame are the following:</para>
        <itemizedlist>
          <listitem>
            <para>Frame components can be referenced from a screen using a dot: <code>frame_id.component_id</code></para>
          </listitem>
          <listitem>
            <para>List of screen components can be obtained from a frame controller by invoking  <code>getComponent(component_id)</code> method but only  if there is no component with the same name in the frame itself. I.e. frame components mask screen components.</para>
          </listitem>
          <listitem>
            <para>Screen  <link linkend="datasources">datasource</link> can be obtained from a frame by invoking <code>getDsContext().get(ds_id)</code> method or <link linkend="screen_controller_injection">injection</link>, or using <code>ds$ds_id</code> in <link linkend="datasource_query">query</link>, but only  if the data source with a matching name is not declared in the frame itself (same as for components).</para>
          </listitem>
          <listitem>
            <para>From a screen, frame data source can be obtained  only by iterating   <code>getDsContext().getChildren()</code> collection.</para>
          </listitem>
        </itemizedlist>
        <para>Screen commit also causes commits of modified datasources of the frame it uses.</para>
      </section>
      <section id="screen_simple">
        <title>Simple Screen</title>
        <para>Simple screens allow display and editing of arbitrary information including individual instances and lists of entities. This screen type has only core functionality to display it in the application’s main window, close it and to work with  <link linkend="datasources">datasources</link>.</para>
        <para>Screen identifier in  <link linkend="screens.xml">screens.xml</link>  may have an arbitrary format.</para>
        <para>Controller of a simple screen should be inherited from the  <code>AbstractWindow</code> class. </para>
      </section>
      <section id="screen_lookup">
        <title>Lookup Screen</title>
        <para>When a lookup screen is invoked by  <code>openLookup()</code> method, it displays a panel at the bottom with the buttons designed to pass an instance of the currently selected entity to the calling code. That’s the main difference between lookup and simple screen. When being invoked by  <code>openWindow()</code> method or, for example, from the main menu, the panel with the buttons is not displayed.</para>
        <para>Lookup screens are recommended to be used to display lists of entities. Visual components intended to display and edit links between entities (such as <link linkend="gui_PickerField">PickerField</link>, <link linkend="gui_LookupPickerField">LookupPickerField</link>, <link linkend="gui_SearchPickerField">SearchPickerField</link>)  invoke lookup screens to find related entities. </para>
        <para>For  <link linkend="standard_actions">standard actions</link> to work correctly, an identifier of a lookup screen in  <link linkend="screens.xml">screens.xml</link> should have the format of  <literal>{entity_name}.lookup</literal>, for example,  <literal>sales$Customer.lookup</literal>.</para>
        <para>Controller of a lookup screen should be inherited from the  <code>AbstractLookup</code> class. The  <code>lookupComponent</code> attribute of the screen’s XML should refer to the component (for example  <link linkend="gui_Table">Table</link>), from which the selected entity instance should be taken as result of lookup.</para>
      </section>
      <section id="screen_edit">
        <title>Edit Screen</title>
        <para>Edit screen is designed to display and edit entity instances. It initializes the instance being edited and supports  <link linkend="gui_Action">actions</link> for committing changes to the database. Edit screen should be opened by the  <code>openEditor()</code> method passing an entity instance as an argument.</para>
        <para>For  <link linkend="standard_actions">standard actions</link> to work correctly, an identifier of an edit screen in<link linkend="screens.xml">screens.xml</link> should have the format of <literal>{entity_name}.edit</literal>, for example, <literal>sales$Customer.edit</literal>.</para>
        <para>Edit screen controller should be inherited from the <code>AbstractEditor</code> class. The  <sgmltag>datasource</sgmltag> attribute of a screen’s XML should refer to a data source containing the edited entity instance. The following standard button frames in the XML can be used to display actions that commit or cancel changes:<itemizedlist>
            <listitem>
              <para><literal>editWindowActions</literal> (file  <filename>com/haulmont/cuba/gui/edit-window.actions.xml</filename>) – contains  <guibutton>OK</guibutton> and <guibutton>Cancel</guibutton> buttons</para>
            </listitem>
            <listitem>
              <para><literal>extendedEditWindowActions</literal> (file  <filename>com/haulmont/cuba/gui/extended-edit-window.actions.xml</filename>) – contains <guibutton>OK &amp; Close</guibutton>, <guibutton>OK</guibutton> and <guibutton>Cancel</guibutton></para>
            </listitem>
          </itemizedlist></para>
        <para>The following actions are implicitly initialized in the edit screen:<itemizedlist>
            <listitem>
              <para><literal>windowCommitAndClose</literal> (corresponds to the <code>Window.Editor.WINDOW_COMMIT_AND_CLOSE</code> constant) – an action committing changes to the database and closing the screen. The action is initialized if the screen has a visual component with <literal>windowCommitAndClose</literal> identifier. The action is displayed as an <guibutton>OK &amp; Close</guibutton> button when the mentioned above standard <literal>extendedEditWindowActions</literal> frame is used.</para>
            </listitem>
            <listitem>
              <para><literal>windowCommit</literal> (corresponds to the  <code>Window.Editor.WINDOW_COMMIT</code> constant) – an action which commits  changes to the database. In  absence of <literal>windowCommitAndClose</literal> action, closes the screen after committing. The action is always displayed as an  <guibutton>OK</guibutton> button if the screen has the abovementioned  standard frames.</para>
            </listitem>
            <listitem>
              <para><literal>windowClose</literal> (corresponds to the  <code>Window.Editor.WINDOW_CLOSE</code> constant) – which closes the screen without committing any changes. The action is always initialized.  If the screen has the abovementioned standard frames, it is displayed as <guibutton>Cancel</guibutton> button.</para>
            </listitem>
          </itemizedlist></para>
        <para>Thus, if the screen contains an  <literal>editWindowActions</literal> frame, the  <guibutton>OK</guibutton> button commits the changes and closes the screen, and the <guibutton>Cancel</guibutton> button – closes the screen without committing the changes. If the screen contains an <literal>extendedEditWindowActions</literal> frame, the  <guibutton>OK</guibutton> button only commits the changes,  <guibutton>OK &amp; Close</guibutton> button commits the changes and closes the screen, and the  <guibutton>Cancel</guibutton> button closes the screen without committing the changes.</para>
        <para>Instead of standard frames actions can be visualized using arbitrary components, for example, <link linkend="gui_LinkButton">LinkButton</link>. </para>
      </section>
    </section>
    <section id="screen_xml">
      <title>XML-Descriptor</title>
      <para>XML-descriptor is a file in XML format describing  <link linkend="datasources">datasources</link> and screen layout.</para>
      <para><para>XML schema is available at <ulink url="http://schemas.haulmont.com/cuba/5.0/window.xsd">http://schemas.haulmont.com/cuba/5.0/window.xsd</ulink>.</para></para>
      <para>Descriptor has the following structure:</para>
      <para><sgmltag>window</sgmltag> −  root element.</para>
      <para><sgmltag>window</sgmltag> attributes:<itemizedlist>
          <listitem>
            <para><property>
                <sgmltag>class</sgmltag>
              </property> − name of a  <link linkend="screen_controller">controller</link> class.</para>
          </listitem>
          <listitem>
            <para><sgmltag>messagesPack</sgmltag> − a default <link linkend="message_packs">message pack</link> for the screen. It is used to obtain localized messages in the controller using <code>getMessage()</code> method and in the XML descriptor using message key without specifying the pack.</para>
          </listitem>
          <listitem>
            <para><sgmltag>caption</sgmltag> − window caption, can contain a  <link linkend="messageTools.loadString">link to a message</link> from the above mentioned pack, for example, <programlisting>caption=&quot;msg://credits&quot;</programlisting></para>
          </listitem>
          <listitem>
            <para><sgmltag>focusComponent</sgmltag> − identifier of a component which should get input focus when the screen is displayed.</para>
          </listitem>
          <listitem>
            <para><sgmltag>lookupComponent</sgmltag> – mandatory attribute for a  <link linkend="screen_lookup">lookup screen</link>; defines the identifier of a visual component that the entity instance should be selected from. Supports the following types of components (and their subclasses):<itemizedlist>
                <listitem>
                  <para><code>Table</code></para>
                </listitem>
                <listitem>
                  <para><code>Tree</code></para>
                </listitem>
                <listitem>
                  <para><code>LookupField</code></para>
                </listitem>
                <listitem>
                  <para><code>PickerField</code></para>
                </listitem>
                <listitem>
                  <para><code>OptionsGroup</code></para>
                </listitem>
              </itemizedlist></para>
          </listitem>
          <listitem>
            <para><sgmltag>datasource</sgmltag> – mandatory attribute for an  <link linkend="screen_edit">edit screen</link> which defines the identifier of the  <link linkend="datasources">data source</link> containing the edited entity instance.</para>
          </listitem>
        </itemizedlist></para>
      <para><sgmltag>window</sgmltag> elements:<itemizedlist>
          <listitem>
            <para><sgmltag>metadataContext</sgmltag> − the element initializing the  <link linkend="views">views</link> required for the screen. It is recommended to define all views in a single <link linkend="views.xml">views.xml</link> file, because all view descriptors are deployed into a common repository, so it is difficult to ensure unique names if the descriptors are scattered across multiple files.</para>
          </listitem>
          <listitem>
            <para><sgmltag>dsContext</sgmltag> − defines <link linkend="datasources">data source</link> for the screen.</para>
          </listitem>
          <listitem>
            <para><sgmltag>actions</sgmltag> – defines the list of  <link linkend="gui_Action">actions</link> for the screen.</para>
          </listitem>
          <listitem>
            <para><sgmltag>timers</sgmltag> – defines the list of timers for the screen.</para>
          </listitem>
          <listitem>
            <para><sgmltag>companions</sgmltag> – defines the list of <link linkend="companions">companion</link> classes for the screen controller.</para>
            <para>Elements of  <sgmltag>companions</sgmltag>:<itemizedlist>
                <listitem>
                  <para><sgmltag>web</sgmltag> – defines a companion implemented in the  <structname>web</structname> module.</para>
                </listitem>
                <listitem>
                  <para><sgmltag>desktop</sgmltag> – defines a companion implemented in the  <structname>desktop</structname> module.</para>
                </listitem>
              </itemizedlist></para>
            <para>Each of these elements contains  <sgmltag>class</sgmltag> attribute defining the companion class.</para>
          </listitem>
          <listitem>
            <para><sgmltag>layout</sgmltag> − root element of the screen layout, a container with a vertical layout of components, similar to  <link linkend="gui_BoxLayout">vbox</link>.</para>
            <para>Attributes of  <sgmltag>layout</sgmltag>:<itemizedlist>
                <listitem>
                  <para><link linkend="gui_attr_basic_spacing">spacing</link></para>
                </listitem>
                <listitem>
                  <para><link linkend="gui_attr_basic_margin">margin</link></para>
                </listitem>
                <listitem>
                  <para><link linkend="gui_attr_basic_expand">expand</link></para>
                </listitem>
                <listitem>
                  <para><link linkend="gui_attr_basic_stylename">stylename</link></para>
                </listitem>
                <listitem>
                  <para><link linkend="gui_attr_basic_height">height</link></para>
                </listitem>
                <listitem>
                  <para><link linkend="gui_attr_basic_width">width</link></para>
                </listitem>
              </itemizedlist></para>
          </listitem>
        </itemizedlist></para>
    </section>
    <section id="screen_controller">
      <title>Screen Controller</title>
      <para>Screen controller is a Java or Groovy class, linked to an  <link linkend="screen_xml">XML-descriptor</link> and containing screen initialization and events handling logic.</para>
      <para>Controller should be inherited from one of the following base classes:</para>
      <itemizedlist>
        <listitem>
          <para><link linkend="abstractFrame">AbstractFrame</link> − for implementation of  <link linkend="frame">frames</link>.</para>
        </listitem>
        <listitem>
          <para><link linkend="abstractWindow">AbstractWindow</link> − for implementation of  <link linkend="screen_simple">simple screens</link>.</para>
        </listitem>
        <listitem>
          <para><link linkend="abstractLookup">AbstractLookup</link> − for implementation of  <link linkend="screen_lookup">lookup screens</link>.</para>
        </listitem>
        <listitem>
          <para><link linkend="abstractEditor">AbstractEditor</link> − for implementation of  <link linkend="screen_edit">edit screens</link>.</para>
        </listitem>
      </itemizedlist>
      <tip>
        <para>If a screen does not need additional logic, it can use the base class itself as a controller –  <code>AbstractWindow</code>, <code>AbstractLookup</code> или <code>AbstractEditor</code>, by specifying it in the XML-descriptor (these classes are not actually abstract in a sense of impossibility of instantiating). For frames, controller class can be omitted.</para>
      </tip>
      <para>Controller class should be registered in  <sgmltag>class</sgmltag> attribute of the root element <sgmltag>window</sgmltag> in a screen’s XML descriptor.</para>
      <figure>
        <title>Controller Base Classes</title>
        <mediaobject>
          <imageobject>
            <imagedata align="center" fileref="img/Controllers.png"/>
          </imageobject>
        </mediaobject>
      </figure>
      <section id="abstractFrame">
        <title>AbstractFrame</title>
        <para><code>AbstractFrame</code> is the root of the controller class hierarchy. Below is the description of its main methods:</para>
        <itemizedlist>
          <listitem>
            <para><code>init()</code> is called by the framework after creating components tree described by an XML-descriptor, but before a screen is displayed.</para>
            <para><methodname>init()</methodname> method accepts a map of parameters that can be used in controller. These parameters can be passed both from the controller of the calling screen (using  <code>openWindow()</code>, <code>openLookup() </code>or  <code>openEditor()</code> methods) or defined in the screen registration file  <link linkend="screens.xml">screens.xml</link>.</para>
            <para><code>init()</code> method should be implemented if it is necessary to initialize screen components, for example:
                <programlisting language="java"><xi:include href="../../source/gui/abstractframe_1.java" encoding="UTF-8" parse="text"/></programlisting>
            </para>
          </listitem>
          <listitem>
            <para><code>getMessage()</code>, <code>formatMessage()</code> – methods for retrieving localized messages from a <link linkend="message_packs">pack</link>, defined for a screen in the XML-descriptor. They work as shortcuts for calling the corresponding methods of the <link linkend="messages">Messages</link> interface.</para>
          </listitem>
          <listitem>
            <para><code>getDialogParams()</code> – returns a <code>DialogParams</code> object to set up dialog window display properties (height, width, etc.). The values defined in this object affect the next screen opened as a modal dialog (<code>WindowManager.OpenType.DIALOG</code>). The settings are reset to defaults after the dialog has been displayed.</para>
            <para>Thus, the properties of <code>DialogParams</code> object should be set immediately before opening another modal screen using <code>openWindow()</code>, <code>openLookup()</code>, <code>openEditor()</code>. For example:
                <programlisting language="java"><xi:include href="../../source/gui/abstractframe_2.java" encoding="UTF-8" parse="text"/></programlisting>
            </para>
            <para>If the current screen itself is modal it is possible to adjust its display properties by changing <code>DialogParams</code> object in its  <code>init()</code> method. Please note that the properties defined in  <code>init()</code> method have priority over the ones defined in the calling code.</para>
          </listitem>
          <listitem>
            <para><code>openFrame()</code> – loads a frame according to an identifier registered in <link linkend="screens.xml">screens.xml</link> file. If the method receives a container component from the invoking code, the frame is shown within the container. The method returns  frame controller. For example:
                <programlisting language="java"><xi:include href="../../source/gui/abstractframe_3.java" encoding="UTF-8" parse="text"/></programlisting>
            </para>
            <para>It is not required to pass the container immediately via  <code>openFrame()</code> method, instead it is possible to load the frame first and then add it to the necessary container:
                <programlisting language="java"><xi:include href="../../source/gui/abstractframe_4.java" encoding="UTF-8" parse="text"/></programlisting>
            </para>
          </listitem>
          <listitem>
            <para><code>openWindow()</code>, <code>openLookup()</code>, <code>openEditor()</code> – open a simple screen, a lookup screen, or an edit screen respectively. Methods return a controller of the created screen.</para>
            <para><code>CloseListener</code> can be added in order to perform actions after the invoked screen closes, for example:
                <programlisting language="java"><xi:include href="../../source/gui/abstractframe_5.java" encoding="UTF-8" parse="text"/></programlisting>
            </para>
          </listitem>
          <listitem>
            <para><code>showMessageDialog()</code> – shows a dialog box with a message.</para>
          </listitem>
          <listitem>
            <para><code>showOptionDialog()</code> – shows a dialog box with a message and an option for user to invoke certain actions. Actions are defined by an array of  <link linkend="gui_Action">Action</link> type items displayed as buttons in the dialog.</para>
            <para><code>DialogAction</code> objects a recommended to be used for display of standard buttons such as <guibutton>OK</guibutton>, <guibutton>Cancel</guibutton> and other, for example:
                <programlisting language="java"><xi:include href="../../source/gui/abstractframe_6.java" encoding="UTF-8" parse="text"/></programlisting>
            </para>
          </listitem>
          <listitem>
            <para><code>showNotification()</code> – shows a pop up notification.</para>
          </listitem>
          <listitem>
            <para><code>showWebPage()</code> – opens specified web page in a browser.</para>
          </listitem>
        </itemizedlist>
      </section>
      <section id="abstractWindow">
        <title>AbstractWindow</title>
        <para><code>AbstractWindow</code> is a subclass of <link linkend="abstractFrame">AbstractFrame</link> and defines the following methods:</para>
        <itemizedlist>
          <listitem>
            <para><code>validateAll()</code> – validates a screen. The default implementation calls <code>validate()</code> for all screen components implementing the <code>Component.Validatable</code> interface, collects information about exceptions and displays corresponding message. Method returns  <code>false</code>, if any exceptions were found; and   <code>true</code> otherwise.</para>
            <para>This method should be overridden only if it is required to override screen validation procedure completely. It is sufficient to implement a special template method –  <code>postValidate()</code>, if validation should be just supplemented.</para>
          </listitem>
          <listitem>
            <para><code>postValidate()</code> –  a template method that can be implemented in controller for additional screen validation. The method stores validation errors information in <code>ValidationErrors</code> object which is passed to  it. Afterwards this information is displayed together with the errors of standard validation. For example:
                <programlisting language="java"><xi:include href="../../source/gui/abstractwindow_1.java" encoding="UTF-8" parse="text"/></programlisting>
            </para>
          </listitem>
          <listitem>
            <para><code>close()</code> – closes this screen. </para>
            <para>The method accepts string value, which is then passed to  <code>preClose()</code> template method and  to  <code>CloseListener</code> listeners. Thus, the information about the reason why the window was closed can be obtained from the code that initiated the closing event. It is recommended to use the following constants for closing edit screens: <code>Window.COMMIT_ACTION_ID</code> after committing changes,  <code>Window.CLOSE_ACTION_ID</code> – without committing changes.</para>
            <para>If any of the datasources contains unsaved changes, a dialog with a corresponding message will be displayed before the screen is closed. Notification type may be adjusted using the <link linkend="cuba.gui.useSaveConfirmation">cuba.gui.useSaveConfirmation</link> application property.</para>
            <para>A variant of  <code>close()</code> method with  <code>force = true</code> parameter closes the screen without calling <code>preClose()</code> and without a notification regardless of any unsaved changes.</para>
            <para><code>close()</code> method returns  <code>true</code>, if the screen is closed successfully, and  <code>false</code> – if closing procedure was interrupted.</para>
          </listitem>
          <listitem>
            <para><code>preClose()</code>  is a template method which can be implemented in a controller to intercept the moment when the window closes. The method receives a string value provided by the closing initiator when invoking  <code>close()</code> method.</para>
            <para>If the  <code>preClose()</code> method returns  <code>false</code>, the window closing process is interrupted.</para>
          </listitem>
        </itemizedlist>
      </section>
      <section id="abstractLookup">
        <title>AbstractLookup</title>
        <para><code>AbstractLookup</code> is the base class for <link linkend="screen_lookup">lookup screen</link> controllers. It is a subclass  of <link linkend="abstractWindow">AbstractWindow</link> and defines the following own methods:</para>
        <itemizedlist>
          <listitem>
            <para><code>setLookupComponent()</code> – sets the component, which will be used to select entity instances.</para>
            <para>As a rule, component for selection is defined in screen XML-descriptor  and there is no need to call this method in the application code.</para>
          </listitem>
          <listitem>
            <para><code>setLookupValidator()</code> – sets  <code>Window.Lookup.Validator</code> object to the screen, which <code>validate()</code> method is invoked by the framework before returning selected entity instances. If  <code>validate()</code> method returns  <code>false</code>, the lookup and window closing process is interrupted.</para>
            <para>By default, the validator is not set.</para>
          </listitem>
        </itemizedlist>
      </section>
      <section id="abstractEditor">
        <title>AbstractEditor</title>
        <para><code>AbstractEditor</code> is the base class for <link linkend="screen_edit">edit screen</link> controller. It is a subclass of <link linkend="abstractWindow">AbstractWindow</link>.</para>
        <para>When creating a controller class, it is recommended to parameterize <code>AbstractEditor</code> with the edited entity class. This enables  <code>getItem()</code> and <code>initItem()</code> methods work with the specified entity type and application code does not need to do additional type conversion. For example:
          <programlisting language="java"><xi:include href="../../source/gui/abstracteditor_1.java" encoding="UTF-8" parse="text"/></programlisting>
        </para>
        <para><code>AbstractEditor</code> defines the following own methods:</para>
        <itemizedlist>
          <listitem>
            <para><code>getItem()</code> – returns an instance of the entity being edited, which is set in the main <link linkend="datasources">data source</link> of the screen (i.e. specified in the <sgmltag>datasource</sgmltag> attribute of the root element of the  XML-descriptor).</para>
            <para>If the instance being edited is not a new one, screen opening procedure will reload the instance from the database with the required  <link linkend="views">view</link> as set for the main data source.</para>
            <para>Changes made to the instance returned by  <code>getItem()</code>, are reflected in the state of the data source and will be sent to the Middleware at commit.</para>
            <warning>
              <para>It should be considered that  <code>getItem()</code> returns a value only after screen is initialized with  <code>setItem()</code> method. Until this moment,  this method returns <code>null</code>, for instance when calling from inside <code>init()</code> or  <code>initItem()</code>. </para>
              <para>However, in the <code>init()</code> method, an instance of an entity passed to  <code>openEditor()</code> can be retrieved from  parameters using the following approach:
                  <programlisting language="java"><xi:include href="../../source/gui/abstracteditor_2.java" encoding="UTF-8" parse="text"/></programlisting>
              </para>
              <para><code>initItem()</code> method requires an instance to be passed explicitly and of an appropriate type.</para>
              <para>In both cases the obtained entity instance will be reloaded afterwards unless it is a new one. Therefore you should not change it or save it in a field for future use.</para>
            </warning>
          </listitem>
          <listitem>
            <para><code>setItem()</code> –  invoked by the framework when a window is opened using <code>openEditor()</code> to set the instance being edited to the main data source. By the moment of invocation all screen components and datasources will have been created and the controller’s <code>init()</code> method will have been executed.</para>
            <para>It is recommended to use template methods <code>initNewItem()</code> and <code>postInit()</code>, instead of overriding <code>setItem()</code> in order to initialize a screen. </para>
          </listitem>
          <listitem id="initNewItem">
            <para><code>initNewItem()</code> – a template method invoked by the framework before setting the edited entity instance  into the main data source. </para>
            <para>The <code>initNewItem()</code> method is called for newly created entity instances only. The method is not called for <link linkend="entity_states">detached</link> instances. This method can be implemented in the controller, if new entity instances must be initialized before setting them in the data source. For example:
                <programlisting language="java"><xi:include href="../../source/gui/abstracteditor_3.java" encoding="UTF-8" parse="text"/></programlisting>
            </para>
            <para>A more complex example of using the <code>initNewItem()</code> method can be found in <link linkend="dev_recipes">development recipes</link> section. </para>
          </listitem>
          <listitem>
            <para><code>postInit()</code> – a template method invoked by the framework immediately after the edited entity instance is set to the main data source. In this method,  <code>getItem()</code> can be called to return a new entity instance or an instance re-loaded during screen initialization.</para>
            <para>This method can be implemented in controller for final screen initialization, for example:
                <programlisting language="java"><xi:include href="../../source/gui/abstracteditor_4.java" encoding="UTF-8" parse="text"/></programlisting>
            </para>
          </listitem>
          <listitem>
            <para><code>commit()</code> – validates the  screen and submits changes to the Middleware via <link linkend="dataSupplier">DataSupplier</link>.</para>
            <para>If a method is used with  <code>validate = false</code>, commit does not perform a validation.</para>
            <para>It is recommended to use specialized template methods –  <code>postValidate()</code>, <code>preCommit()</code> and <code>postCommit()</code> instead of overriding this method.</para>
          </listitem>
          <listitem>
            <para><code>commitAndClose()</code> – validates the screen, submits changes to the Middleware and closes the screen. The value of the <code>Window.COMMIT_ACTION_ID</code> will be passed to the   <code>preClose()</code> method and registered  <code>CloseListener</code> listeners.  </para>
            <para>It is recommended to use specialized template methods –  <code>postValidate()</code>, <code>preCommit()</code> и <code>postCommit()</code> instead of overriding this method.</para>
          </listitem>
          <listitem>
            <para><code>preCommit()</code> – a template method invoked by the framework during the commit process, after a successful validation, but before the data is submitted to the Middleware.</para>
            <para>This method can be implemented in controller. If the method returns <code>false</code>, commit process gets interrupted, as well as window closing process (if  <code>commitAndClose()</code> was invoked). For example:
                <programlisting language="java"><xi:include href="../../source/gui/abstracteditor_5.java" encoding="UTF-8" parse="text"/></programlisting>
            </para>
          </listitem>
          <listitem>
            <para><code>postCommit()</code> – a template method invoked by the framework at the final stage of committing changes. Method parameters are:<itemizedlist>
                <listitem>
                  <para><code>committed</code> – set to  <code>true</code>, if the screen had changes and they have been submitted to Middleware.</para>
                </listitem>
                <listitem>
                  <para><code>close</code> – set to  <code>true</code>, if the screen should be closed after the changes are committed.</para>
                </listitem>
              </itemizedlist></para>
            <para>If the screen does not close the default implementation of this method displays a message about successful commit and invokes  <code>postInit()</code>.</para>
            <para>This method can be overridden in controller in order to perform additional actions after successful commit, for example:
                <programlisting language="java"><xi:include href="../../source/gui/abstracteditor_6.java" encoding="UTF-8" parse="text"/></programlisting>
            </para>
          </listitem>
        </itemizedlist>
        <para>The diagrams below show initialization sequence and different ways to commit changes for an edit screen.</para>
        <figure>
          <title>Edit Screen Initialization</title>
          <mediaobject>
            <imageobject>
              <imagedata align="center" fileref="img/EditorInit.png"/>
            </imageobject>
          </mediaobject>
        </figure>
        <figure>
          <title>Committing And Closing a Window With an editWindowActions Frame</title>
          <mediaobject>
            <imageobject>
              <imagedata align="center" fileref="img/EditorCommit.png" contentwidth="900"/>
            </imageobject>
          </mediaobject>
        </figure>
        <figure>
          <title>Committing a Screen With an extendedEditWindowActions Frame</title>
          <mediaobject>
            <imageobject>
              <imagedata align="center" fileref="img/ExtendedEditorCommit.png"/>
            </imageobject>
          </mediaobject>
        </figure>
        <figure>
          <title>Committing a Screen With an extendedEditWindowActions Frame</title>
          <mediaobject>
            <imageobject>
              <imagedata align="center" fileref="img/ExtendedEditorCommitAndClose.png" contentwidth="900"/>
            </imageobject>
          </mediaobject>
        </figure>
      </section>
      <section id="screen_controller_injection">
        <title>Controller Dependency Injection</title>
        <para>Dependency Injection in controllers can be used to acquire references to utilized objects. For this purpose it is required to declare either a field of the corresponding type or a write access method (setter) with an appropriate parameter type and with one of the following annotations:<itemizedlist>
            <listitem>
              <para><code>@Inject</code> – the simplest option, where an object for injection will be found according to the field/method type and the name of the field or attribute corresponding to the method according to JavaBeans rules.</para>
            </listitem>
            <listitem>
              <para><code>@Named(&quot;someName&quot;)</code> – explicitly defines the name of the target object.</para>
            </listitem>
          </itemizedlist></para>
        <para>The following objects can be injected into controllers: <itemizedlist>
            <listitem>
              <para>This screen’s visual components defined in the XML-descriptor. If the attribute type is derived from <code>Component</code>, the system will search for a component with the corresponding name within the current screen. </para>
            </listitem>
            <listitem>
              <para>Actions defined in the XML-descriptor – see <xref linkend="gui_Action"/>.</para>
            </listitem>
            <listitem>
              <para><link linkend="datasources">Datasources</link> defined in the XML-descriptor. If the attribute type is derived from <code>Datasource</code>, the system will search for a data source with the corresponding name in the current screen.</para>
            </listitem>
            <listitem>
              <para><code>UserSession</code>. If the attribute type is  <link linkend="userSession">UserSession</link>, the system will inject an object of the current user session.</para>
            </listitem>
            <listitem>
              <para><code>DsContext</code>. If the attribute type is  <code>DsContext</code>, the system will inject the  <code>DsContext</code> of the current screen.</para>
            </listitem>
            <listitem>
              <para><code>WindowContext</code>. If the attribute type is <code>WindowContext</code>, the system will inject the <code>WindowContext</code> of the current screen. </para>
            </listitem>
            <listitem>
              <para><code>DataSupplier</code>. If the attribute type is  <link linkend="dataSupplier">DataSupplier</link>, the corresponding instance will be injected.</para>
            </listitem>
            <listitem>
              <para>Any bean defined in the context of a given client block, including:<itemizedlist>
                  <listitem>
                    <para> Middleware  <link linkend="services">services</link> imported by Client</para>
                  </listitem>
                  <listitem>
                    <para><code>ComponentsFactory</code></para>
                  </listitem>
                  <listitem>
                    <para><code>WindowConfig</code></para>
                  </listitem>
                  <listitem>
                    <para><code>ExportDisplay</code></para>
                  </listitem>
                  <listitem>
                    <para><link linkend="background_tasks">BackgroundWorker</link></para>
                  </listitem>
                </itemizedlist></para>
            </listitem>
            <listitem>
              <para>If nothing of the mentioned above is appropriate and the controller has  <link linkend="companions">companions</link>, a companion for the current client type will be injected, if the types match. </para>
              <para>It is possible to inject the parameters passed in the map to the <code>init()</code> method into the controller using special annotation <code>@WindowParam</code>. The annotation has a <code>name</code> attribute which contains the parameter name (a key in the map) and an optional required attribute.  If <code>required = true</code> and the map does not contain the corresponding parameter a <code>WARNING</code> message is added to the log.
An example of an injection of a Job-type object passed to the controller’s <code>init()</code> method:
                <programlisting language="java"><xi:include href="../../source/gui/cdi_1.java" encoding="UTF-8" parse="text"/></programlisting>
              </para>
            </listitem>
          </itemizedlist></para>
      </section>
      <section id="companions">
        <title>Controller Companions</title>
        <para>Controller base classes are located in the  <structname>gui </structname><link linkend="app_modules">module</link> of the  <structname>cuba</structname> <link linkend="base_projects">base project</link> and do not contain references to implementation of visual component classes  (<application>Swing</application> or <application>Vaadin</application>). This  allows you to use them in both types of clients. Instead, base controller classes implement an additional interface – <code>Window.Wrapper</code> – and delegate execution to the wrapped window.</para>
        <para>At the same time concrete controller classes may be contained in <structname>gui</structname>, <structname>web</structname> or <structname>desktop</structname> modules, depending on screen specifics and client  client  <link linkend="app_tiers">blocks</link> used in the project. If controller is universal and additional functionality is required for different client types it can be implemented in so-called <firstterm>companion classes</firstterm>.</para>
        <para>Companion class is located in client module of the corresponding client type (web or desktop) and implements an interface defined in the controller which uses the companion class. A companion class should be defined in the <code>companions</code> element of the screen XML-descriptor. Controller can retrieve a reference to the companion instance using injection or by invoking <code>getCompanion()</code>, and then pass control to the companion instance when appropriate, e.g. for extended initialization of visual components in a way specific to a given client type.</para>
      </section>
    </section>
  </section>
  <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="gui_vcl.xml" encoding="UTF-8"/>
  <section id="datasources">
    <title>Datasources</title>
    <para>Datasources provide work of data-aware components.</para>
    <para>Visual components themselves do not access <structname>Middleware</structname> and get entity instances from related datasources. Furthermore, one data source can work with multiple visual components if they need the same instance or set of instances.</para>The link between a visual component and a data source consists of the following:
    <itemizedlist>
      <listitem>
        <para>When the user changes the value in the component, the new value is set for the entity attribute in the data source</para>
      </listitem>
      <listitem>
        <para>When the entity attribute is modified in the code, the new value is set and displayed in the visual component </para>
      </listitem>
      <listitem>
        <para>User input can be monitored both by the <link linkend="datasource_listeners">datasource listener</link> and the value listener of the component – they are fired sequentially. </para>
      </listitem>
      <listitem>
        <para>To read or write the value of an attribute in the application code, it is recommended to use the data
          source, rather than the component. Below is an example of reading the attribute:
          <programlisting language="java"><xi:include href="../../source/gui/datasources_1.java" encoding="UTF-8" parse="text"/></programlisting>
        </para>
        <para>As can be seen, working entity attribute values through the component requires type casting and, in case of the  <link linkend="gui_FieldGroup">FieldGroup</link>, specifying the attribute name as a string. At the same time, if the instance is obtained from the datasource via the  <code>getItem()</code> method, the values of attributes can be read and modified directly. </para>
      </listitem>
    </itemizedlist><warning>
      <para>Typically, the visual component is bound to the attribute that directly belongs to the entity in the data source. In the example above, the component is bound to the  <code>customer</code> attribute of the  <code>Order</code> entity. </para>
      <para>A component can be associated with an attribute of a related entity, for example,  <code>customer.name</code>. In this case, the component will display the value of the name attribute, however when the user changes the value, the datasource listeners will not be invoked and the changes will not be saved. Therefore, it makes sense to bind the component to second-order entity attributes only if they are intended for display. For example in a  <link linkend="gui_Label">Label</link>, a  <link linkend="gui_Table">Table</link> column, or in a  <link linkend="gui_TextField">TextField</link>, where  <code>editable = false</code>.</para>
    </warning><para>datasources also track changes in entities contained therein and can send modified instances back to <structname>Middleware</structname> for storing in a database.</para><para>The basic sources of interfaces are described below.</para><figure>
      <title>Data source interfaces</title>
      <mediaobject>
        <imageobject>
          <imagedata align="center" fileref="img/Datasources.png"/>
        </imageobject>
      </mediaobject>
    </figure><itemizedlist>
      <listitem>
        <para><code>Datasource</code> is a simple data source designed to work with one entity instance. The instance is set by the <code>setItem()</code> method and is accessed via <code>getItem()</code>. </para>
        <para><code>DatasourceImpl</code> class is the standard implementation of such source, which is used, for instance, as a main data source on entity <link linkend="screen_edit">edit screens</link>.</para>
      </listitem>
      <listitem>
        <para><code>CollectionDatasource</code> is a data source designed to work with a collection of entity instances. The collection is loaded with the invocation of the <code>refresh()</code> method, instance keys are accessible through the <code>getItemIds()</code> method. The <code>setItem()</code> method sets the “current” instance of the collection and <code>getItem()</code> returns it, i.e., for example, the one that corresponds to the currently selected table row.</para>
        <para>The way to load collections is determined by implementation. The most typical one is loading from Middleware via <link linkend="dataManager">DataManager</link>; in this case, <code>setQuery()</code>, <code>setQueryFilter()</code> are used to form a JPQL query.</para>
        <para><code>CollectionDatasourceImpl</code> class is the standard implementation of such sources, which is used on screens with entity lists.</para>
        <itemizedlist>
          <listitem>
            <para><code>GroupDatasource</code> is a subtype of <code>CollectionDatasource</code>, designed to work with the <link linkend="gui_GroupTable">GroupTable</link> component.</para>
            <para>Standard implementation is the <code>GroupDatasourceImpl</code> class.</para>
          </listitem>
          <listitem>
            <para><code>HierarchicalDatasource</code> is a subtype of <code>CollectionDatasource</code>, designed to work with the <link linkend="gui_Tree">Tree</link> and <link linkend="gui_TreeTable">TreeTable</link> components.</para>
            <para>Standard implementation is the <code>HierarchicalDatasourceImpl</code> class.</para>
          </listitem>
        </itemizedlist>
      </listitem>
      <listitem>
        <para><code>NestedDatasource</code> is a data source designed to work with instances that are loaded in an attribute of another entity. In this case, a source that contains a parent entity is accessible via <code>getMaster()</code>, and <link linkend="metaProperty">meta property</link> that corresponds to the parent attribute containing instances of this source is accessible via <code>getProperty()</code>.</para>
        <para>For example an entity instance <code>Order</code> which contains a reference to the <code>Customer</code> instance is set in the <code>dsOrder</code> source. Then, to link the <code>Customer</code> instance with visual components, it is enough to create <code>NestedDatasource</code> with <code>dsOrder as parent</code> and meta property to point to the <code>Order.customer</code> attribute.</para>
        <itemizedlist>
          <listitem>
            <para><code>PropertyDatasource</code> is a subtype of <code>NestedDatasource</code>, designed to work with one instance or collection of related entities that are not embedded.</para>
            <para>Standard implementations: for working with one instance – <code>PropertyDatasourceImpl</code>, with a collection – <code>CollectionPropertyDatasourceImpl</code>, <code>GroupPropertyDatasourceImpl</code>, <code>HierarchicalPropertyDatasourceImpl</code>. The latter also implement the <code>CollectionDatasource</code> interface, however some of its irrelevant methods associated with loading like <code>setQuery()</code> throw <code>UnsupportedOperationException</code>.</para>
          </listitem>
          <listitem>
            <para><code>EmbeddedDatasource</code> is a subtype of <code>NestedDatasource</code>, which contains an instance of an embedded entity.</para>
            <para>Standard implementation is the <code>EmbeddedDatasourceImpl class</code>.</para>
          </listitem>
        </itemizedlist>
      </listitem>
      <listitem>
        <para><code>RuntimePropsDatasource</code> is a specific source, designed to work with <link linkend="dynamic_attributes">dynamic attributes</link> of entities.</para>
      </listitem>
    </itemizedlist><para>Typically, datasources are declared in the <code>dsContext</code> section of a <link linkend="screen_xml">screen descriptor</link>.</para><section>
      <title>Creating Datasources</title>
      <para>Data source objects can be created both declaratively, using an XML screen descriptor, and programmatically in a controller. Typically, standard implementation of sources is used, however, you can create your own class that is inherited from a standard one, if necessary.</para>
      <section>
        <title>Declarative Creation</title>
        <para>Typically, datasources are declared in the <code>dsContext</code> element of a screen descriptor. Depending on the relative position of declaration elements, sources of two varieties are created:<itemizedlist>
            <listitem>
              <para>if an element is located directly in <code>dsContext</code>, a normal <code>Datasource</code> or <code>CollectionDatasource</code>, which contains an independently loaded entity or collection, is created;</para>
            </listitem>
            <listitem>
              <para>if an element is located inside an element of another source, <code>NestedDatasource</code> is created and the external source becomes its parent.</para>
            </listitem>
          </itemizedlist></para>
        <para>Below is an example of declaring a data source:
            <programlisting language="xml"><xi:include href="../../source/gui/datasources_2.xml" encoding="UTF-8" parse="text"/></programlisting>
        </para>
        <para>In the example above, <code>carDs</code> contains one entity instance, <code>Car</code>, and nested <code>allocationsDs</code> and <code>repairsDs</code> contain collections of related entities from the <code>Car.driverAllocations</code> and <code>Car.repairs</code> attributes, respectively. The <code>Car</code> instance together with related entities is set into the data source from the outside. If this screen is an <link linkend="screen_edit">edit screen</link>, it happens automatically when opening the screen. The <code>colorsDs</code> data source contains a collection of instances of the <code>Color</code> entity, which is loaded by the source itself using the specified JPQL <link linkend="datasource_query">query</link> with the _local <link linkend="views">view</link>.</para>
        <para>Below is the XML scheme. </para>
        <para><sgmltag>dsContext</sgmltag> – root element.</para>
        <para><code>dsContext</code> elements:<itemizedlist>
            <listitem>
              <para><code>datasource</code> – defines a data source that contains a single entity instance.</para>
              <para>Attributes:<itemizedlist>
                  <listitem>
                    <para><code>id</code> – source identifier, must be unique for this <code>DsContext</code>.</para>
                  </listitem>
                  <listitem>
                    <para><code>class</code> – Java class of an entity that will be contained in this source.</para>
                  </listitem>
                  <listitem>
                    <para><code>view</code> – name of entity <link linkend="views">view</link>. If the source itself loads instances, then this view will be used during loading. Otherwise, this view makes signals to external mechanisms on how to load an entity for this source.</para>
                  </listitem>
                  <listitem>
                    <para><code>allowCommit</code> – if set to <code>false</code>, the <code>isModified()</code> method of this source always returns <code>false</code> and the <code>commit()</code> method does nothing. Thus, changes in entities that are contained in the source are ignored. By default, it is set to <code>true</code>, i.e., changes are traced and can be saved.</para>
                  </listitem>
                  <listitem>
                    <para><code>datasourceClass</code> is a custom class of data source implementation, if necessary.</para>
                  </listitem>
                </itemizedlist></para>
            </listitem>
            <listitem>
              <para><code>collectionDatasource</code> – defines a data source that contains a collection of instances.</para>
              <para><code>collectionDatasource</code> attributes:<itemizedlist>
                  <listitem>
                    <para><code>refreshMode</code> – a source update mode, default is <code>ALWAYS</code>. In the <code>NEVER</code> mode, when <code>refresh()</code> method is invoked, the source does not load data and only changes its state to <code>Datasource.State.VALID</code>, notifies listeners and sorts available instances. The <code>NEVER</code> mode is useful if you need to programmatically fill <code>CollectionDatasource</code> with preloaded or created entities. For example:
                        <programlisting language="java"><xi:include href="../../source/gui/datasources_3.java" encoding="UTF-8" parse="text"/></programlisting>
                    </para>
                  </listitem>
                  <listitem>
                    <para><code>softDeletion</code> – the false value disables the <link linkend="soft_deletion">soft deletion</link> mode when loading entities, i.e., deleted instances will also be loaded. Default value is <code>true</code>.</para>
                  </listitem>
                </itemizedlist></para>
              <para><code>collectionDatasource</code> elements:<itemizedlist>
                  <listitem>
                    <para><code>query</code> – query to load entities</para>
                  </listitem>
                </itemizedlist></para>
            </listitem>
            <listitem>
              <para><code>groupDatasource</code> – completely similar to <code>collectionDatasource</code>, but creates data source implementation that is suitable to use in conjunction with the <link linkend="gui_GroupTable">GroupTable</link> component.</para>
            </listitem>
            <listitem>
              <para><code>hierarchicalDatasource</code> – similar to <code>collectionDatasource</code>, and creates data source implementation that is suitable to use in conjunction with the <link linkend="gui_Tree">Tree</link> and <link linkend="gui_TreeTable">TreeTable</link> components.</para>
              <para><code>hierarchyProperty</code> is a specific attribute. It specifies an attribute name, upon which a hierarchy is built.</para>
            </listitem>
          </itemizedlist></para>
        <para>A source implementation class is selected implicitly based on the name of the XML element and, as mentioned above, the mutual arrangement of elements. However, if you need to apply a custom data source, you can explicitly specify its class in the <code>datasourceClass</code> attribute.</para>
      </section>
      <section>
        <title>Programmatic Creation</title>
        <para>If you need to create a data source in the Java code, it is recommended to use a special class, <code>DsBuilder</code>.</para>
        <para>The <code>DsBuilder</code> instance is parameterized by an invocation chain of its methods in the fluent interface style. If the <code>master</code> and <code>property</code> parameters are set, then <code>NestedDatasource</code> will be created, otherwise – <code>Datasource</code> or <code>CollectionDatasource</code>.</para>
        <para>Example:
            <programlisting language="java"><xi:include href="../../source/gui/datasources_4.java" encoding="UTF-8" parse="text"/></programlisting>
        </para>
      </section>
      <section>
        <title>Proper Implementation Classes</title>
        <para>Typically, custom implementation of a data source is required to change the loading process of a collection of entities. When creating a class of this source it should be inherited from <code>CollectionDatasourceImpl</code>, or from <code>GroupDatasourceImpl</code>, or <code>HierarchicalDatasourceImpl</code>, and the <code>loadData()</code> method should be overridden.</para>
        <para>Example:
            <programlisting language="java"><xi:include href="../../source/gui/datasources_5.java" encoding="UTF-8" parse="text"/></programlisting>
        </para>
        <para>In the example above, <code>data</code> is a base class field that stores a collection of loaded instances. The base class methods, <code>detachListener()</code> and <code>attachListener()</code>, control the assignment of a listener to loaded entities. The listener notifies the data source on changes in instance fields.</para>
        <para>To create a custom data source declaratively, a class in the <code>datasourceClass</code> attribute of an XML element should be specified. In case of programmatic creation via <code>DsBuilder</code>, a source class is specified by invoking <code>setDsClass()</code>.</para>
      </section>
    </section><section id="datasource_query">
      <title>CollectionDatasourceImpl Queries</title>
      <para>The <code>CollectionDatasourceImpl</code> class and its inheritors, <code>GroupDatasourceImpl</code>, <code>HierarchicalDatasourceImpl</code> are standard implementation of datasources that work with collections of independent entity instances. These sources load data via <code>DataManager</code> by sending a JPQL query to <structname>Middleware</structname>. The format of these queries is described below.</para>
      <section id="datasource_query_results">
        <title>Returned values</title>
        <para>A query should return entities of the type which is specified at the moment of creating a data source. In case of declarative creation, the entity type is specified in the <sgmltag>class</sgmltag> attribute of an XML element, if <code>DsBuilder</code> is used – in the <code>setJavaClass()</code> or <code>setMetaClass()</code> method.</para>
        <para>Furthermore, the object type in the <code>from</code> query statement should match the source type. This is necessary for automatic query transformations if security limitations, etc. are applied.</para>
        <para>For example, a query of the data source of the <code>Customer</code> type may look as follows:<programlisting>select c from sales$Customer c</programlisting></para>
        <para>Below are examples of invalid queries for a source of the <code>Customer</code> type:<programlisting>select c.id, c.name from sales$Customer c /* invalid – returns single fields, not the whole Customer object */

select o.customer from sales$Order o /* invalid – the &apos;from&apos; type (Order) is different from the resulting type  (Customer) */</programlisting></para>
      </section>
      <section id="datasource_query_params">
        <title>Query Parameters</title>
        <para>A JPQL query in a data source may contain parameters of several types. A parameter type is determined by a prefix of a parameter name. A prefix is a part of the name before the $ character. The interpretation of the name after $ is described below.</para>
        <itemizedlist>
          <listitem id="datasource_query_params_ds">
            <para>The <code>ds</code> prefix</para>
            <para>The parameter value is data from another data source that is registered in the same <code>DsContext</code>. For example:
                <programlisting language="xml"><xi:include href="../../source/gui/datasources_6.xml" encoding="UTF-8" parse="text"/></programlisting>
            </para>
            <para>In the example above, a query parameter of the <code>ordersDs</code> data source will be a current entity instance located in the <code>customersDs</code> data source.</para>
            <para>If parameters with the <code>ds</code> prefix are used, dependencies between datasources are created automatically. They lead to updating the source if its parameter are changed. In the example above, if the selected Customer is changed, the list of its Orders is changed automatically. </para>
            <para>Please note that in the example of the parameterized query, the left part of the comparison operator is the value of the <code>o.customer.id</code> identifier, and the right part – the <code>Customer</code> instance that is contained in the <code>customersDs</code> source. This comparison is valid since when running a query at <structname>Middleware</structname>, the implementation of the <link linkend="query">Query</link> interface, by assigning values to query parameters, automatically adds entity ID instead of a passed entity instance.</para>
            <para>A path through the entity graph to an attribute (from which the value should be used) can be specified in the parameter name after the prefix and name of a source, for example:
                <programlisting language="xml"><xi:include href="../../source/gui/datasources_7.xml" encoding="UTF-8" parse="text"/></programlisting>
            </para>
            <para>or
                <programlisting language="xml"><xi:include href="../../source/gui/datasources_8.xml" encoding="UTF-8" parse="text"/></programlisting>
            </para>
          </listitem>
          <listitem>
            <para>The <code>custom</code> prefix. </para>
            <para>A parameter value will be taken from the <code>Map&lt;String, Object&gt;</code> object that is passed into the <code>refresh()</code> method of a data source. For example:
                <programlisting language="xml"><xi:include href="../../source/gui/datasources_9.xml" encoding="UTF-8" parse="text"/></programlisting>
                <programlisting language="java"><xi:include href="../../source/gui/datasources_10.java" encoding="UTF-8" parse="text"/></programlisting>
            </para>
            <para>Bringing an instance to its identifier, if necessary, is performed similarly to parameters with the <code>ds</code> prefix. The path through the entity graph in the parameter name is not supported in this case.</para>
          </listitem>
          <listitem>
            <para>The <code>param</code> prefix.</para>
            <para>A parameter value is taken from the <code>Map&lt;String, Object&gt;</code> object that is passed into the <code>init()</code> method of a <link linkend="screen_controller">controller</link>. </para>
            <para>Bringing an instance to its identifier, if necessary, is performed similarly to parameters with the <code>ds</code> prefix. The path through the entity graph in the parameter name is supported in this case. </para>
          </listitem>
          <listitem>
            <para>The <code>component</code> prefix.</para>
            <para>A parameter value will be a current value of a visual component, which path is specified in the parameter name. For example:
                <programlisting language="xml"><xi:include href="../../source/gui/datasources_11.xml" encoding="UTF-8" parse="text"/></programlisting>
            </para>
            <para>The path to a component should include all nested <link linkend="frame">frames</link>.</para>
            <para>Bringing an instance to its identifier, if necessary, is similar to <code>ds</code> parameters. The path through the entity graph in the parameter name is supported as the continuation of the path to a component in this case. </para>
          </listitem>
          <listitem>
            <para>The <code>session</code> prefix. </para>
            <para>A parameter value will be a value of the <link linkend="userSession">user session</link> attribute specified in the parameter name.</para>
            <para>The value is extracted by the <code>UserSession.getAttribute()</code> method, so predefined names of session attributes are also supported. <itemizedlist>
                <listitem>
                  <para><code>userId</code> – ID of the currently registered or substituted user;</para>
                </listitem>
                <listitem>
                  <para><code>userLogin</code> – login of the currently registered or substituted user in lowercase.</para>
                </listitem>
              </itemizedlist></para>
            <para>Example:
                <programlisting language="xml"><xi:include href="../../source/gui/datasources_12.xml" encoding="UTF-8" parse="text"/></programlisting>
            </para>
            <para>Bringing an instance to its identifier, if necessary, is similar to <code>ds</code> parameters. In this case, the path through the entity graph in the parameter name is not supported.</para>
          </listitem>
          <warning>
            <para>If the value is not found by the rules given by the prefix for this parameter, the parameter value is set to <code>null</code>. For example, if the query has a parameter <code>param$some_name</code>, and the parameter map does not have the  <code>some_name</code> key, then  <code>param$some_name</code> is set to  <code>null</code>.</para>
          </warning>
        </itemizedlist>
      </section>
      <section id="datasource_query_filter">
        <title>Query Filter</title>
        <para>A data source query can be modified during the work of the application, depending on conditions entered by the user. This allows you to efficiently filter data at the level of selection from DB.</para>
        <para>The easiest way to provide such ability is to connect a special visual component, <link linkend="gui_Filter">Filter</link>, to a data source.</para>
        <para>If by any reason the use of a universal filter is unwanted, a special XML markup can be embedded into a query text. This will allow to create a resulting query based on values entered by the user into any visual components of the screen.</para>
        <para>In this filter the following elements can be used:<itemizedlist>
            <listitem>
              <para><code>filter</code> – a root element of the filter. It can directly contain only one condition.<itemizedlist>
                  <listitem>
                    <para><sgmltag>and</sgmltag>, <sgmltag>or</sgmltag> – logical conditions, may contain any number of other conditions and statements. </para>
                  </listitem>
                  <listitem>
                    <para><sgmltag>c</sgmltag> – JPQL statement, which is added into the <code>where</code> section. It contains only the text and an optional <sgmltag>join</sgmltag> attribute, which value will be added into a corresponding place of the query. </para>
                  </listitem>
                </itemizedlist></para>
            </listitem>
          </itemizedlist></para>
        <para>Conditions and statements are added into the resulting query only if parameters inside contain values, i.e., they are not <code>null</code>.</para>
        <para>Example:
            <programlisting language="xml"><xi:include href="../../source/gui/datasources_13.xml" encoding="UTF-8" parse="text"/></programlisting>
        </para>
        <para>In this case, if <code>state</code> and <code>initiator</code> parameters are passed into the <code>refresh()</code> method of a data source, and a visual component, <code>barCodeFilterField</code>, has some value specified, then the resulting query will be as follows:<programlisting>select distinct d from app$GeneralDoc d, app$DocRole dr
where
(
  (dr.doc.id = d.id and d.processState = :custom$state)
  and
  (d.barCode like :component$barCodeFilterField)
)
or
(dr.doc.id = d.id and dr.user.id = :custom$initiator)</programlisting></para>
        <para>If, for example, the <code>barCodeFilterField</code> component is empty and only one parameter, initiator, was passed into the <code>refresh()</code> method, the query will be as follows:<programlisting>select distinct d from app$GeneralDoc d, app$DocRole dr
where
(dr.doc.id = d.id and dr.user.id = :custom$initiator)</programlisting></para>
        <warning>
          <para>Do not use <link linkend="datasource_query_params_ds">ds-parameters</link> in query filters.
            They are intended for linking datasources and treated in a special way.
          </para>
        </warning>
      </section>
      <section id="datasource_query_case_insensitive">
        <title>Case-Insensitive Search for a Substring</title>
        <para>It is possible to use a special feature of JPQL queries execution in datasources, described for the <link linkend="query">Query</link> interface of the <structname>Middleware</structname> level: for easy creation of case-insensitive search condition of any substring, <code>(?i)</code> prefix can be used. However, due to the fact that the query value is usually passed implicitly, the following differences take place:<itemizedlist>
            <listitem>
              <para>The <code>(?i)</code> prefix should be specified before a parameter name and not inside the value.</para>
            </listitem>
            <listitem>
              <para>The parameter value will be automatically converted to lowercase.</para>
            </listitem>
            <listitem>
              <para>If the parameter value does not have <code>%</code> characters, they will be added to the beginning and the end.</para>
            </listitem>
          </itemizedlist></para>
        <para>Below is an example of how to process the following query:<programlisting>select c from sales$Customer c where c.name like :(?i)component$customerNameField</programlisting></para>
        <para>In this case, the parameter value taken from the <code>customerNameField</code> component will be converted to lowercase and will be framed with <code>%</code> characters, and then an SQL query with a <code>lower(C.NAME) like ?</code> condition will be executed in the database.</para>
        <para>Please note that with this search, an index created in the DB by the <code>NAME</code> field, will not be used. </para>
      </section>
    </section><section id="datasource_listeners">
      <title>Data Source Listeners</title>
      <para>With <link linkend="datasources">datasource listeners</link> it&apos;s possible to receive notifications about changes in data source states and entity instances located inside them.</para>
      <para>To register listeners, the <code>Datasource.addListener()</code>, <code>Datasource.removeListener()</code> methods are used. Below is an example of registering a listener in a <link linkend="screen_controller">screen controller</link>:
          <programlisting language="java"><xi:include href="../../source/gui/datasources_14.java" encoding="UTF-8" parse="text"/></programlisting>
      </para>
      <para>There are two listener interfaces of datasources: <code>DatasourceListener</code> and <code>CollectionDatasourceListener</code>. The first can be used for registration in any of datasources, the second – only in those implementing <code>CollectionDatasource</code>. Typically, in practice, it&apos;s not necessary to receive all notifications from a listener. That&apos;s why it is convenient to use class-adapters, <code>DsListenerAdapter</code> and <code>CollectionDsListenerAdapter</code>, instead of implementation of listener interfaces, which contain empty implementations of all methods of corresponding interfaces.</para>
      <para><code>DatasourceListener</code> methods are provided below:<itemizedlist>
          <listitem>
            <para><code>valueChanged()</code> – declaration of this method is inherited from the base interface, <code>ValueListener</code>. This listener method is invoked if an attribute value of some entity that is currently located in the source has changed. The modified instance itself, the name of changed attribute, old and new values are passed into the method.</para>
            <para><code>valueChanged()</code> notification can be used to respond to user changes in an entity from the UI, i.e., editing input fields. In the example below, a hypothetical method, <code>updateSettings()</code>, will be invoked when the value of the <code>active</code> attribute is changed, and a new attribute value will be passed into this method:
                <programlisting language="java"><xi:include href="../../source/gui/datasources_15.java" encoding="UTF-8" parse="text"/></programlisting>
            </para>
          </listitem>
          <listitem><para><code>itemChanged()</code> – is invoked when a selected instance returned by the <code>getItem()</code> method is changed.</para><para>For <code>Datasource</code>, it happens when another instance (or <code>null</code>) is set with <code>setItem()</code> method.</para><para>For <code>CollectionDatasource</code>, this notification is invoked when a selected element is changed in a linked visual component. For example, it may be a selected table row, tree element or item in a drop-down list.</para>Below is an example of the <code>itemChanged()</code>notification to control the state of an action of the table:
              <programlisting language="java"><xi:include href="../../source/gui/datasources_16.java" encoding="UTF-8" parse="text"/></programlisting>
          </listitem>
          <listitem>
            <para><code>stateChanged()</code> – is invoked when a state of the data source is changed. The data source can be in one of three states corresponding to the <code>Datasource.State</code> enumeration:<itemizedlist>
                <listitem>
                  <para><code>NOT_INITIALIZED</code> – source has just been created.</para>
                </listitem>
                <listitem>
                  <para><code>INVALID</code> – the whole <link linkend="dsContext">DsContext</link>, which this source is related to, is created.</para>
                </listitem>
                <listitem>
                  <para><code>VALID</code> – data source is in working state: <code>Datasource</code> contains an entity instance or null, <code>CollectionDatasource</code> – collection of instances or an empty collection.</para>
                </listitem>
              </itemizedlist></para>
            <para>Receiving a notification about changes in source state may be important for complex <link linkend="screen_edit">editors</link>, which consist of several <link linkend="frame">frames</link> where it is difficult to trace the moment of putting an edited entity into the source. In this case, <code>stateChanged()</code> notification for the delayed initialization of certain screen elements can be used:
                <programlisting language="java"><xi:include href="../../source/gui/datasources_17.java" encoding="UTF-8" parse="text"/></programlisting>
            </para>
          </listitem>
        </itemizedlist></para>
      <para>The <code>CollectionDatasourceListener</code> interface adds one more method: <itemizedlist>
          <listitem>
            <para><code>collectionChanged()</code> – is invoked when a entity collection, which is stored in the data source, is changed. One of the following type of changes is passed into the method: <code>REFRESH</code>, <code>CLEAR</code>, <code>ADD</code>, <code>REMOVE</code>, <code>UPDATE</code>.</para>
            <para>Below is an example of a listener that invokes the recalculation of a journey cost in case of the address of a stop (the <code>Stop</code> entity) or the number of stops is changed:
                <programlisting language="java"><xi:include href="../../source/gui/datasources_18.java" encoding="UTF-8" parse="text"/></programlisting>
            </para>
          </listitem>
        </itemizedlist></para>
    </section><section id="dsContext">
      <title>DsContext</title>
      <para>All datasources that are created declaratively are registered in the <code>DsContext</code> object of a screen. A reference to <code>DsContext</code> can be obtained using the <code>getDsContext()</code> method of a screen controller or with an injection into a class field.</para>
      <para><code>DsContext</code> solves the following tasks:<orderedlist>
          <listitem>
            <para>Organizes dependencies between datasources when with a navigation to one source (i.e. when changing a &quot;current&quot; instance with the <code>setItem()</code> method) a related source is updated. Using these dependencies it&apos;s quite easy to organize master-detail connections among visual components on screens.</para>
            <para>Dependencies between sources are organized using <link linkend="datasource_query">query parameters</link> with the <code>ds$</code> prefix.</para>
          </listitem>
          <listitem>
            <para>Collects all changed entity instances and sends them to <structname>Middleware</structname> in a single invocation of <code>DataManager.commit()</code>, i.e. to save them into a data base using a single transaction. </para>
            <para>As an example, let&apos;s assume that some screen allows a user to edit an instance of the <code>Order</code>
                entity and a collection of <code>OrderLine</code> instances belonging to it. The <code>Order</code>
                instance is located in <code>Datasource</code>; the <code>OrderLine</code> collection – in nested
                <code>CollectionDatasource</code>, which is created using the <code>Order.lines</code> attribute. If
                user changes some attribute of <code>Order</code> and creates a new instance, <code>OrderLine</code>.
                Then, when a screen is committed to <link linkend="dataManager">DataManager</link>, two instances –
                changed <code>Order</code> and new <code>OrderLine</code> – will be sent simultaneously. After that,
                they will together get into one <link linkend="entityManager">persistent context</link> and will be
                saved into the DB with transaction commit. The <code>OrderLine</code> instance is also contained in
                the <code>Order.lines</code> collection, but if it&apos;s not passed into persistent context
                independently, the cascade saving between <code>Order</code> and <code>OrderLines</code> at the ORM
                level should be set. Tight cascade relations at the ORM level sometimes cause unwanted consequences in
                unexpected places, so it will be better to avoid them, as described in the <code>DsContext</code>
                mechanism.</para>
            <para>As a result of committing transaction, <code>DsContext</code> receives a set of saved instances from <structname>Middleware</structname> (in case of optimistic blocking they at least have an increased value of the <code>version</code> attribute), and sets these instances in datasources instead of outdated ones. This allows you to work with latest instances immediately after committing without an extra data source refresh that is related to queries to <structname>Middleware</structname> and the database.</para>
          </listitem>
          <listitem>
            <para>Declares a listener, <code>DsContext.CommitListener</code>, which allows to receive notifications before and after committing modified instances. Before the commit it&apos;s possible to supplement a collection of instances sent to <link linkend="dataManager">DataManager</link> at <structname>Middleware</structname> which will lead to saving arbitrary entities in the same transaction. A collection of saved instances that are returned from <code>DataManager</code> can be obtained after commit.</para>
            <para>This mechanism is required if some entities, with which a screen works, are not under control of datasources, but are created and changed directly in the controller code. For example, a visual component, <link linkend="gui_FileUploadField">
                <code>FileUploadField</code>
              </link>, after uploading a file, creates a new entity instance, <code>FileDescriptor</code>, which can be saved together with other screen entities by adding to <code>CommitContext</code> in the <code>DsContext.CommitListener.beforeCommit()</code> method..</para>
            <para><code>DsContext.CommitListener</code> has the <code>DsContext.CommitListenerAdapter</code> adapter, which is useful when it&apos;s needed to define only one method.</para>
            <para>In the following example, a new instance, <code>Customer</code> will be sent to <structname>Middleware</structname> and saved to the DB together with other modified screen entities when it is committed:
                <programlisting language="java"><xi:include href="../../source/gui/dscontext_1.java" encoding="UTF-8" parse="text"/></programlisting>
            </para>
          </listitem>
        </orderedlist></para>
    </section><section id="dataSupplier">
      <title>DataSupplier</title>
      <para><code>DataSupplier</code> – interface, through which the datasources refer to Middleware for loading and
          saving entities. The standard implementation simply delegates to <link linkend="dataManager">DataManager</link>.
          A screen can define its implementation of the <code>DataSupplier</code> in <code>dataSupplier</code> attribute
          of the <code>window</code> element. Such own implementation may, for example, call an additional middleware
          block for loading data for the screen from different database.</para>
      <para>A reference to <code>DataSupplier</code> can be obtained either by injection into a screen controller or
          through the <code>DsContext</code> or <code>Datasource</code> instances. In both cases, an own implementation
          is returned if defined for the screen.</para>
    </section></section>
  <section id="gui_Action">
    <title>Actions. The Action Interface</title>
      <para>
          <code>Action</code> is an interface that abstracts an action (in other words, some function) from a visual
          component. It is particularly useful when the same action can be invoked from different visual components ((for example, from
          button and table context menu). In addition, this interface allows you to provide the action with additional
          properties, such as name, flags of accessibility and visibility, etc.
      </para>
    <para>Below are the   <code>Action</code> interface methods:<itemizedlist>
        <listitem>
          <para><code>actionPerform()</code> is invoked by a visual component associated with this action. An instance of the caller is passed to the method.</para>
        </listitem>
        <listitem>
          <para><code>getId()</code> returns an identifier of the action. The identifier is usually set by a constructor of a class that implements  <code>Action</code> and does not change throughout the lifecycle of the created action object.</para>
        </listitem>
        <listitem>
          <para>Methods for getting and setting  <code>caption</code>, <code>description</code>, <code>shortcut</code>, <code>icon</code>, <code>enabled</code>, <code>visible</code> properties. Typically, all these properties are used by related visual components to set their own corresponding properties.</para>
        </listitem>
        <listitem>
          <para><code>addPropertyChangeListener()</code>, <code>removePropertyChangeListener()</code> methods used to add and remove listeners which handle changes to the abovementioned properties. A listener receives notification of <code>java.beans.PropertyChangeEvent</code> type, which contains the name of the changed property, its old and new values.</para>
        </listitem>
        <listitem>
          <para><code>refreshState()</code> - a method that can be implemented in a particular action class to initialize the abovementioned properties in accordance to some external factors, such as user rights. It is usually invoked in constructors of implementing classes or from related visual components.</para>
        </listitem>
        <listitem>
          <para><code>addOwner()</code>, <code>removeOwner()</code>, <code>getOwner()</code>, <code>getOwners()</code> – methods used to control relation between the action and visual components.</para>
        </listitem>
      </itemizedlist></para>
    <para>It is recommended to implement actions using the  <link linkend="declarative_actions">declarative creation</link>
        or by inheriting from the  <link linkend="baseAction">BaseAction</link> class. Furthermore, there is a set of
        <link linkend="standard_actions">standard actions</link> applicable for tables and picker components. You can
        also derive action classes from standard actions to modify their behavior or to intercept events.</para>
    <para>Visual components associated with an action  can be of two types:<itemizedlist>
        <listitem>
          <para>Visual component with a single action implements the   <code>Component.ActionOwner</code> interface. These are  <link linkend="gui_Button">Button</link> and <link linkend="gui_LinkButton">LinkButton</link>.</para>
          <para>Action is linked to the component by the invocation of the <code>ActionOwner.setAction()</code> component method. At this point, the component replaces its properties with corresponding properties of the action (see components overview for details).</para>
        </listitem>
        <listitem>
          <para>Visual component containing several actions implements the <code>Component.ActionsHolder</code> interface. These are  <code>Window</code>, <code>IFrame</code>, <link linkend="gui_Table">Table</link> and its inheritors,  <link linkend="gui_Tree">Tree</link>, <link linkend="gui_PopupButton">PopupButton</link>, <link linkend="gui_PickerField">PickerField</link>, <link linkend="gui_LookupPickerField">LookupPickerField</link>.</para>
          <para>The <code>ActionsHolder.addAction()</code> method is used to add actions to the component. Implementation of this method in the component checks whether it already contains an action with the same identifier. If yes, then the existing action will be replaced with the new one. Therefore, it is possible, for example, to declare a standard action in a screen descriptor and then create a new one in the controller with overridden methods and add it to the component.</para>
        </listitem>
      </itemizedlist></para>
    <section id="declarative_actions">
      <title>Declarative Creation of Actions</title>
      <para>You can specify a set of <link linkend="gui_Action">actions</link> in an XML screen descriptor for any component that implements the  <code>Component.ActionsHolder</code> interface, including the entire screen or frame. This is done in the   <code>actions</code> element, which contains nested  <code>action</code> elements.</para>
      <para>The  <code>action</code> element can have the following attributes:<itemizedlist>
          <listitem>
            <para><code>id</code> − identifier, which should be unique within the <code>ActionsHolder</code> component.</para>
          </listitem>
          <listitem>
            <para><code>caption</code> – action name.</para>
          </listitem>
          <listitem>
            <para><code>description</code> – action description.</para>
          </listitem>
          <listitem>
            <para><code>enable</code> – accessibility flag  (<code>true</code> / <code>false</code>).</para>
          </listitem>
          <listitem>
            <para><code>icon</code> – action icon.</para>
          </listitem>
          <listitem>
            <para><code>invoke</code> - name of the controller method to be invoked. The method should be   <code>public</code> <code>void</code>, and either not have arguments or have one argument of the <code>Component</code> type. If the method has a  <code>Component</code> argument, then an instance of the visual component that launches this action will be passed to it when invoked.</para>
          </listitem>
          <listitem>
            <para><code>shortcut</code> - keyboard shortcut for invocation. Possible modifiers,  <code>ALT</code>, <code>CTRL</code>, <code>SHIFT</code>, are separated by the  &quot;-&quot; character. For example:
<keycap>ALT-CTRL-C</keycap>.</para>
          </listitem>
          <listitem>
            <para><code>visible</code> – visibility flag   (<code>true</code> / <code>false</code>).</para>
          </listitem>
        </itemizedlist></para>
      <para>The examples of declaration are provided below.<itemizedlist>
          <listitem>
            <para>Declaring actions at the screen level:
                <programlisting language="xml"><xi:include href="../../source/gui/actions_1.xml" encoding="UTF-8" parse="text"/></programlisting>
                <programlisting language="java"><xi:include href="../../source/gui/actions_2.java" encoding="UTF-8" parse="text"/></programlisting>In the example above, an action with  <code>sayHelloAction</code> identifier and a name from  <link linkend="message_packs">message pack</link> is declared. This action is bound with a button, which caption will be set to the action name. The action will invoke the <code>sayHello()</code> controller method when clicking on the button, or when pressing the   <keycap>ALT-T</keycap> shortcut if at that moment the screen has input focus.</para>
          </listitem>
          <listitem>
            <para>Declaring actions for  <link linkend="gui_PopupButton">PopupButton</link>:
                <programlisting language="xml"><xi:include href="../../source/gui/actions_3.xml" encoding="UTF-8" parse="text"/></programlisting>
            </para>
          </listitem>
          <listitem>
            <para>Declaring actions for  <link linkend="gui_Table">Table</link>:
                <programlisting language="xml"><xi:include href="../../source/gui/actions_4.xml" encoding="UTF-8" parse="text"/></programlisting>
                In this example <code>copy</code> and <code>changePassw</code> actions are declared in addition to <code>create</code> and <code>edit</code> standard actions of the table. These actions invoke corresponding methods of the controller. In addition, the  <code>trackSelection=&quot;true&quot;</code> attribute is specified for them, which means that the action and corresponding button become disabled if no row is selected in the table. It is useful if the action is intended to be executed over a currently selected table row.</para>
            <para>An optional <code>openType</code> attribute can be specified  for create and edit actions to define edit screen opening mode, as described for the <code>setOpenType()</code> method of the  <link linkend="createAction">CreateAction</link> class.</para>
          </listitem>
          <listitem>
            <para>Declaring  <link linkend="gui_PickerField">PickerField</link> actions:
                <programlisting language="xml"><xi:include href="../../source/gui/actions_5.xml" encoding="UTF-8" parse="text"/></programlisting>
                In the example above, the standard <code>lookup</code>  action and an additional <code>show</code> action invoking the <code>showColour()</code> method of the controller, are declared for the <code>PickerField</code> component. Since <code>PickerField</code> buttons that display actions use icons instead of captions, the caption attribute is explicitly set to an empty string, otherwise action name and button caption would be set to the action identifier. The <code>description</code> attribute allows you to display a tooltip when hovering over the action button.</para>
          </listitem>
        </itemizedlist></para>
      <para>You can obtain references to any declared actions in the screen controller either directly by   <link linkend="screen_controller_injection">injection</link>, or from components that implement the <code>Component.ActionsHolder</code> interface. This can be useful to set action properties programmatically. For example:
          <programlisting language="java"><xi:include href="../../source/gui/actions_6.java" encoding="UTF-8" parse="text"/></programlisting>
      </para>
    </section>
    <section id="standard_actions">
      <title>Standard Actions</title>
      <para>Standard   <link linkend="gui_Action">actions</link> are classes that implement the <code>Action</code> interface and are intended to solve common tasks, such as invocation of an edit screen for an entity selected in a table. Standard actions have strictly defined identifiers; therefore, for the declaration of a standard action in XML, it is enough to specify its identifier.</para>
      <para>There are two types of standard actions:<itemizedlist>
          <listitem>
            <para><link linkend="list_actions">Actions over collections</link> of entities that are displayed in tables or trees.</para>
          </listitem>
          <listitem>
            <para><link linkend="picker_actions">Picker field actions</link>.</para>
          </listitem>
        </itemizedlist></para>
      <section id="list_actions">
        <title>Standard Actions over Collection</title>
        <para>For inheritors of  <code>ListComponent</code> (<link linkend="gui_Table">Table</link>, <link linkend="gui_GroupTable">GroupTable</link>, <link linkend="gui_TreeTable">TreeTable</link> and <link linkend="gui_Tree">Tree</link>) the set of standard actions is defined in   <code>ListActionType</code> enumeration; their implementation classes are located in <code>com.haulmont.cuba.gui.components.actions</code> package. </para>
        <para>The example of using standard actions in a table:
          <programlisting language="xml"><xi:include href="../../source/gui/listActions_1.xml" encoding="UTF-8" parse="text"/></programlisting>
        </para>
        <para>These actions are described in details below.</para>
        <section id="createAction">
          <title>CreateAction</title>
          <para><code>CreateAction</code> – action with   <emphasis role="bold">create</emphasis> identifier. It is intended to create new entity instance and open its edit screen. If the edit screen successfully commits a new instance to the database, <code>CreateAction</code> adds this new instance to the table data source and makes it selected.</para>
          <para>The following specific methods are defined in the <code>CreateAction</code> class:
            <itemizedlist>
              <listitem>
                <para><code>setOpenType()</code> allows you to specify new entity edit screen open mode.  <code>THIS_TAB</code> by default. </para>
                <para>Since it is quite often required to open edit screens in another mode (typically, <code>DIALOG</code>), you can specify an <code>openType</code> attribute with desired value in the    <code>action</code> element when using declarative creation of the    <code>create</code> action. This eliminates the need to obtain action reference in the controller and set this property programmatically. For example:
                  <programlisting language="xml"><xi:include href="../../source/gui/createAction_1.xml" encoding="UTF-8" parse="text"/></programlisting></para>
              </listitem>
              <listitem>
                <para><code>setWindowId()</code> allows you to specify the identifier of the entity edit screen. By default,   <code>{entity_name}.edit</code> is used, for example <code>sales$Customer.edit</code>.</para>
              </listitem>
              <listitem>
                <para><code>setWindowParams()</code> allows you to set edit screen parameters passed into its  <code>init()</code> method.</para>
              </listitem>
              <listitem>
                <para><code>setInitialValues()</code> allows you to set initial values of attributes of the entity being created. It takes a <code>Map</code> object, where keys are attribute names, and values are attribute values. For example:
                  <programlisting language="java"><xi:include href="../../source/gui/createAction_2.java" encoding="UTF-8" parse="text"/></programlisting></para>
                <para>An example of  <code>setInitialValues()</code> usage is also provided in the section of    <link linkend="init_values_in_CreateAction">development recipes</link>.</para>
              </listitem>
              <listitem>
                <para><code>afterCommit()</code> is invoked by the action after the new entity has been successfully
                  committed and the edit screen has been closed. This method does not have implementation and can
                  be overridden in inheritors to handle this event.</para>
              </listitem>
              <listitem>
                <para><code>setAfterCommitHandler()</code> allows you to provide a handler which will be called
                  after the new entity has been successfully committed and the edit screen has been closed. This handler
                  can be used instead of overriding <code>afterCommit()</code> to avoid creating the action subclass.
                  For example:
                  <programlisting language="java"><xi:include href="../../source/gui/createAction_3.java" encoding="UTF-8" parse="text"/></programlisting>
                </para>
              </listitem>
              <listitem>
                <para><code>afterWindowClosed()</code> is the last method invoked by the action after closing the
                  edit screen regardless of whether the new entity has been committed or not. This method does not
                  have implementation and can be overridden in inheritors to handle this event.</para>
              </listitem>
              <listitem>
                <para><code>setAfterWindowClosedHandler()</code> allows you to provide a handler which will be called
                  after closing the edit screen regardless of whether the new entity has been committed or not.
                  This handler can be used instead of overriding <code>afterWindowClosed()</code> to avoid creating the
                  action subclass.</para>
              </listitem>
            </itemizedlist>
          </para>
        </section>
        <section id="editAction">
          <title>EditAction</title>
          <para><code>EditAction</code> is an action with <emphasis role="bold">edit</emphasis> identifier, intended to open an edit screen for a selected entity instance. If the edit screen successfully commits the instance to the database, then <code>EditAction</code> updates this instance in the table data source.</para>
          <para>The following specific methods are defined in the  <code>EditAction</code> class:
            <itemizedlist>
              <listitem>
                <para><code>setOpenType()</code> allows you to specify entity edit screen open mode.  <code>THIS_TAB</code> by default. </para>
                <para>Since it is quite often required to open edit screens in another mode (typically   <code>DIALOG</code>), you can specify  <code>openType</code> attribute with desired value in the   <code>action</code> element when creating the action declaratively. This eliminates the need to obtain action reference in the controller and set this property programmatically. For example:
                  <programlisting language="xml"><xi:include href="../../source/gui/editAction_1.xml" encoding="UTF-8" parse="text"/></programlisting>
                </para>
              </listitem>
              <listitem>
                <para><code>setWindowId()</code> allows you to specify entity edit screen identifier.  <code>{entity_name}.edit</code> is used by default, for example,  <code>sales$Customer.edit</code>.</para>
              </listitem>
              <listitem>
                <para><code>setWindowParams()</code> allows you to set edit screen parameters, passed to its   <code>init()</code> method.</para>
              </listitem>
              <listitem>
                <para>
                  <code>afterCommit()</code>
                  is invoked by the action after the entity has been successfully committed and the edit screen has
                  been closed. This method does not have implementation and can be overridden in inheritors to
                  handle this event.
                </para>
              </listitem>
              <listitem>
                <para><code>setAfterCommitHandler()</code> allows you to provide a handler which will be called
                  after the new entity has been successfully committed and the edit screen has been closed. This handler
                  can be used instead of overriding <code>afterCommit()</code> to avoid creating the action subclass.
                  For example:
                  <programlisting language="java"><xi:include href="../../source/gui/editAction_2.java" encoding="UTF-8" parse="text"/></programlisting>
                </para>
              </listitem>
              <listitem>
                <para>
                  <code>afterWindowClosed()</code>
                  is the last method invoked by the action after closing the edit screen regardless of whether the
                  edited entity has been committed or not. This method does not have implementation and can be
                  overridden in inheritors to handle this event.
                </para>
              </listitem>
              <listitem>
                <para><code>setAfterWindowClosedHandler()</code> allows you to provide a handler which will be called
                  after closing the edit screen regardless of whether the new entity has been committed or not.
                  This handler can be used instead of overriding <code>afterWindowClosed()</code> to avoid creating the
                  action subclass.</para>
              </listitem>
            </itemizedlist>
          </para>
        </section>
        <section id="removeAction">
          <title>RemoveAction</title>
          <para><code>RemoveAction</code> - action with <emphasis role="bold">remove</emphasis> identifier, intended to remove a selected entity instance.</para>
          <para>The following specific methods are defined in the  <code>RemoveAction</code> class:
            <itemizedlist>
              <listitem>
                <para><code>setAutocommit()</code> allows you to control the moment of entity removal from the database. By default <code>commit()</code> method is invoked after triggering the action and removing the entity from the data source. As result, the entity is removed from the database. You can set <code>autocommit</code> property into false using <code>setAutocommit()</code> method or corresponding parameter of the constructor. In this case you will need to explicitly invoke the data source <code>commit()</code> method to confirm the removal after removing the entity from the data source.</para>
                <para>The value of <code>autocommit</code> does not affect datasources in the   <code>Datasource.CommitMode.PARENT</code> mode, i.e. the datasources that provide <link linkend="composition_annotation">composite</link> entities editing.</para>
              </listitem>
              <listitem>
                <para><code>setConfirmationMessage()</code> allows you to set message text for the removal confirmation dialog.</para>
              </listitem>
              <listitem>
                <para><code>setConfirmationTitle()</code> allows you to set removal confirmation dialog title.</para>
              </listitem>
              <listitem>
                <para>
                  <code>afterRemove()</code>
                  is invoked by the action after the entity has been successfully removed. This method does not have
                  implementation and can be overridden.
                </para>
              </listitem>
              <listitem>
                <para><code>setAfterRemoveHandler()</code> allows you to provide a handler which will be called
                  after the new entity has been successfully removed.
                  This handler can be used instead of overriding <code>afterRemove()</code> to avoid creating the
                  action subclass. For example:
                  <programlisting language="java"><xi:include href="../../source/gui/removeAction_1.java" encoding="UTF-8" parse="text"/></programlisting>
                </para>
              </listitem>
            </itemizedlist>
          </para>
        </section>
        <section id="refreshAction">
          <title>RefreshAction</title>
          <para><code>RefreshAction</code> - an action with <emphasis role="bold">refresh</emphasis> identifier. It is intended to update (reload) entities collection. When triggered, it invokes   <code>refresh()</code> method of a <link linkend="datasources">data source</link> associated with the corresponding component. </para>
          <para>The following specific methods are defined in the  <code>RefreshAction</code> class:<itemizedlist>
              <listitem>
                <para><code>setRefreshParams()</code> allows you to set parameters passed into the <code>CollectionDatasource.refresh()</code> method to be used in the   <link linkend="datasource_query">query</link>. By default, no parameters are passed.</para>
              </listitem>
            </itemizedlist></para>
        </section>
        <section id="addAction">
          <title>AddAction</title>
          <para><code>AddAction</code> – action with  <emphasis role="bold">add</emphasis> identifier, intended for selecting an existing entity instance and adding it to the collection. When triggered, opens entities  <link linkend="screen_lookup">lookup screen</link>.</para>
          <para>The following specific methods are defined in the  <code>AddAction</code> class:<itemizedlist>
              <listitem>
                <para><code>setOpenType()</code> allows you to specify entity selection screen open mode.   <code>THIS_TAB</code> by default.</para>
                <para>Since it is often required to open the lookup screens in a different mode (usually <code>DIALOG</code>), the <code>openType</code> attribute can be specified in the action element, when creating the <code>add</code> action declaratively. This eliminates the need to get a reference to the action in the controller and set this property programmatically. For example:</para>
                <programlisting language="xml">&lt;table id=&quot;usersTable&quot;&gt;
&lt;actions&gt;
  &lt;action id=&quot;add&quot; openType=&quot;DIALOG&quot;/&gt;</programlisting>
              </listitem>
              <listitem>
                <para><code>setWindowId()</code> allows you to specify entity selection screen identifier.  <code>{entity_name}.lookup</code> by default, for example,  <code>sales$Customer.lookup</code>.  If such screen does not exist, attempts to open <code>{entity_name}.browse</code> screen, for example, <code>sales$Customer.browse</code>.</para>
              </listitem>
              <listitem>
                <para><code>setWindowParams()</code> allows you to set selection screen parameters, passed into its  <code>init()</code> method.</para>
              </listitem>
              <listitem>
                <para><code>setHandler()</code> allows you to set an object implementing   <code>Window.Lookup.Handler</code> interface which will be passed to the selection screen. By default, <code>AddAction.DefaultHandler</code> object is used.</para>
              </listitem>
            </itemizedlist></para>
        </section>
        <section id="excludeAction">
          <title>ExcludeAction</title>
          <para><code>ExcludeAction</code> - an action with <emphasis role="bold">exclude</emphasis> identifier. It allows a user to exclude entity instances from a collection without removing them from the database. The class of this action is an inheritor of    <code>RemoveAction</code>, however, when triggered it invokes <code>excludeItem()</code> of <code>CollectionDatasource</code> instead of <code>removeItem()</code>. In addition, for an entity in a nested datasource, the <code>ExcludeAction</code> disconnects the link with the parent entity. Therefore this action can be used for editing one-to-many associations.</para>
          <para>The following specific methods are defined in the  <code>ExcludeAction</code> class in addition to <code>RemoveAction</code>:<itemizedlist>
              <listitem>
                <para><code>setConfirm()</code> – flag to show the removal confirmation dialog. You can also set this property via the action constructor. By default it is set to   <code>false</code>.</para>
              </listitem>
            </itemizedlist></para>
        </section>
        <section id="excelAction">
          <title>ExcelAction</title>
          <para><code>ExcelAction</code> - an action with <emphasis role="bold">excel</emphasis> identifier, intended to export table data into XLS and download the resulting file. You can add this action only to   <link linkend="gui_Table">Table</link>, <link linkend="gui_GroupTable">GroupTable</link> and <link linkend="gui_TreeTable">TreeTable</link> components.</para>
          <para>When creating the action programmatically, you can set the following constructor parameters:<itemizedlist>
              <listitem>
                <para><code>display</code> – <code>ExportDisplay</code> interface implementation for file download. Standard implementation is used by default..</para>
              </listitem>
              <listitem>
                <para><code>parameterized</code> - if set to true, the action shows a special window with <code>excelExport</code> identifier, which allows user to choose table columns for export.</para>
              </listitem>
            </itemizedlist></para>
        </section>
      </section>
      <section id="picker_actions">
        <title>Standard Actions of the Picker Field</title>
        <para>For <link linkend="gui_PickerField">PickerField</link>,
          <link linkend="gui_LookupPickerField">LookupPickerField</link> and
          <link linkend="gui_SearchPickerField">SearchPickerField</link>
          components, a set of standard actions is defined in the <code>PickerField.ActionType</code>
          enumeration. Implementations are inner classes of the <code>PickerField</code>
          interface, which are described in details below.
        </para>
        <para>The example of standard actions usage in a picker component:
          <programlisting language="xml"><xi:include href="../../source/gui/pickerActions_1.xml" encoding="UTF-8" parse="text"/></programlisting>
        </para>
        <section id="lookupAction">
          <title>LookupAction</title>
          <para><code>LookupAction</code> – action with <emphasis role="bold">lookup</emphasis> identifier, intended for selecting an entity instance and setting it as the component&apos;s value. When triggered, it opens an entities  <link linkend="screen_lookup">lookup screen</link>.</para>
          <para>The following specific methods are defined in the  <code>LookupAction</code> class:<itemizedlist>
              <listitem>
                <para><code>setLookupScreenOpenType()</code> allows you to specify entity selection screen open mode.   <code>THIS_TAB</code> by default.</para>
              </listitem>
              <listitem>
                <para><code>setLookupScreenDialogParams()</code> allows you to set the window properties for a lookup screen that is opened in the <code>DIALOG</code> mode (see previous method). Other modes are not affected. </para>
              </listitem>
              <listitem>
                <para><code>setLookupScreen()</code> allows you to specify entity selection screen identifier.  <code>{entity_name}.lookup</code> by default, for example,  <code>sales$Customer.lookup</code>. If such screen does not exist, attempts to open <code>{entity_name}.browse</code> screen, for example, <code>sales$Customer.browse</code>.</para>
              </listitem>
              <listitem>
                <para><code>setLookupScreenParams()</code> allows you to set selection screen parameters, passed into its  <code>init()</code> method.</para>
              </listitem>
              <listitem>
                <para><code>afterSelect()</code>  is invoked by the action after the selected instance is set as the component&apos;s value. This method does not have implementation and can be overridden.</para>
              </listitem>
              <listitem>
                <para><code>afterCloseLookup()</code> is the last method invoked by the action after closing the lookup screen regardless of whether an instance has been selected or not. This method does not have implementation and can be overridden.</para>
              </listitem>
            </itemizedlist></para>
        </section>
        <section id="clearAction">
          <title>ClearAction</title>
          <para><code>ClearAction</code> - an action with <emphasis role="bold">clear</emphasis>
            identifier, intended for clearing (i.e. for setting to<code>null</code>) the value of the component.
          </para>
        </section>
        <section id="openAction">
          <title>OpenAction</title>
          <para><code>OpenAction</code> - action with <emphasis role="bold">open</emphasis> identifier, intended for opening an edit screen for the entity instance which is the current value of the component.</para>
          <para>The following specific methods are defined in the  <code>OpenAction</code> class:<itemizedlist>
              <listitem>
                <para><code>setEditScreenOpenType()</code> allows you to specify entity selection screen open mode.   <code>THIS_TAB</code> by default.</para>
              </listitem>
              <listitem>
                <para><code>setEditScreenDialogParams()</code> allows you to set the window properties for an edit screen that is opened in the <code>DIALOG</code> mode (see previous method). Other modes are not affected. </para>
              </listitem>
              <listitem>
                <para><code>setEditScreen()</code> allows you to specify entity edit screen identifier.   <code>{entity_name}.edit</code> screen is used by default, for example,  <code>sales$Customer.edit</code>. </para>
              </listitem>
              <listitem>
                <para><code>setEditScreenParams()</code> allows you to set edit screen parameters, passed to its  <code>init()</code>method.</para>
              </listitem>
              <listitem>
                <para><code>afterWindowClosed()</code>  is invoked by the action after closing the edit screen. This method does not have implementation and can be overridden in inheritors to handle this event.</para>
              </listitem>
            </itemizedlist>
          </para>
        </section>
      </section>
    </section>
    <section id="baseAction">
      <title>BaseAction</title>
      <para><code>BaseAction</code> is a base class for   <link linkend="gui_Action">actions</link> implementation.
          It is recommended to derive custom actions from it when   <link linkend="declarative_actions">declarative
          actions creation</link> functionality is insufficient.</para>
      <para>When creating a custom action class, you should implement <code>actionPerform()</code> method and pass
          action identifier to the <code>BaseAction</code> constructor. You can override any property
          getters: <code>getCaption()</code>, <code>getDescription()</code>, <code>getIcon()</code>,
          <code>getShortcut()</code>, <code>isEnabled()</code>, <code>isVisible()</code>. Standard implementations of
          these methods return values set by setter methods, except the <code>getCaption()</code> method. If the action
          name is not explicitly set by <code>setCaption()</code> method, it retrieves message using action identifier
          as key from the  the <link linkend="message_packs">localized message pack</link> corresponding to the action
          class package. If there is no message with such key, then the key itself, i.e. the action identifier,
          is returned.</para>
      <para><code>BaseAction</code> can change its <code>enabled</code> and <code>visible</code> properties depending on
          user <link linkend="permissions">permissions</link> and current context.</para>
      <para><code>BaseAction</code> is visible if the following conditions are met:
        <itemizedlist>
            <listitem><para><code>setVisible(false)</code> method was not called;</para></listitem>
            <listitem><para>there is no <userinput>hide</userinput> UI permission for this action.</para></listitem>
        </itemizedlist>
      </para>
      <para>The action is enabled if the following conditions are met:
          <itemizedlist>
              <listitem><para><code>setEnabled(false)</code> method was not called;</para></listitem>
              <listitem><para>there are no <userinput>hide</userinput> or <userinput>read-only</userinput> UI permissions
                  for this action;</para></listitem>
              <listitem><para><code>isPermitted()</code> method returns true;</para></listitem>
              <listitem><para><code>isApplicable()</code> method returns true.</para></listitem>
          </itemizedlist>
      </para>
      <para>Usage examples:<itemizedlist>
          <listitem>
            <para><link linkend="gui_Button">Button</link> action:
                <programlisting language="java"><xi:include href="../../source/gui/baseAction_1.java" encoding="UTF-8" parse="text"/></programlisting>
                In this example, the <code>helloBtn</code> button caption will be set to the string located in the message
                pack with the <code>hello</code> key.  You can override the <code>getCaption()</code> action method to
                initialize button name in a different way.</para>
          </listitem>
          <listitem>
            <para>Action of a programmatically created   <link linkend="gui_PickerField">PickerField</link>:
                <programlisting language="java"><xi:include href="../../source/gui/baseAction_2.java" encoding="UTF-8" parse="text"/></programlisting>
                In this example an anonymous <code>BaseAction</code> derived class is used to set the action of the
                picker field button. The button caption is not displayed, as an icon with a description, which pops up
                when hovering mouse cursor, is used instead.</para>
          </listitem>
          <listitem>
            <para><link linkend="gui_Table">Table</link> action:
                <programlisting language="java"><xi:include href="../../source/gui/baseAction_3.java" encoding="UTF-8" parse="text"/></programlisting>
                In this example, the <code>HelloAction</code> class is declared, and its instance is added to the table's
                actions list. The action is enabled for users who have <userinput>myapp.allow-greeting</userinput>
                security permission and only when a single table row is selected. The latter is possible because
                BaseAction's <code>target</code> property is automatically assigned to the action when it is
                added to a <code>ListComponent</code> descendant (<code>Table</code> or <code>Tree</code>).</para>
          </listitem>
          <listitem>
            <para>If you need an action, which becomes enabled when one or more table rows are selected, use BaseAction's
                descendant - <code>ItemTrackingAction</code>, which adds default implementation of <code>isApplicable()</code>
                method:
                <programlisting language="java"><xi:include href="../../source/gui/baseAction_4.java" encoding="UTF-8" parse="text"/></programlisting>
                </para>
          </listitem>
        </itemizedlist></para>
    </section>
  </section>
  <section id="dialogs_and_notifications">
    <title>Dialogs and Notifications</title>
    <para>Dialogs and notifications can be used to display messages to  users.</para>
    <para>Dialogs have a title with a closing button and are always displayed in the center of the application main window. Notifications can be displayed both in the center and in the corner of the window, and can automatically disappear.</para>
    <section id="dialogs">
      <title>Dialogs</title>
      <para>Dialogs are invoked by    <code>showMessageDialog()</code> and <code>showOptionDialog()</code> methods of the <code>IFrame</code> interface. This interface is implemented by   <link linkend="screen_controller">screen controller</link>,  so these methods can be invoked directly in the controller code. </para>
      <itemizedlist>
        <listitem>
          <para><code>showMessageDialog()</code> is intended to display a message. The method has the following parameters:<itemizedlist>
              <listitem>
                <para><code>title</code> – dialog title.</para>
              </listitem>
              <listitem>
                <para><code>message</code> - message. For HTML type (see below), you can use HTML tags for formatting the
                    message. When using HTML, make sure you escape data loaded from the database to avoid code injection
                    in web client. You can use <code>\n</code> characters for line breaks in non-HTML messages.</para>
              </listitem>
              <listitem><para><code>messageType</code> – message type. Possible types:<itemizedlist>
                    <listitem>
                      <para><code>CONFIRMATION</code>, <code>CONFIRMATION_HTML</code> – confirmation dialog. </para>
                    </listitem>
                    <listitem>
                      <para><code>WARNING</code>, <code>WARNING_HTML</code> – warning dialog.</para>
                    </listitem>
                  </itemizedlist></para>The difference in message types is reflected in desktop user interface only.</listitem>
            </itemizedlist>An example of showing a dialog:<programlisting language="java">showMessageDialog(&quot;Warning&quot;, &quot;Something is wrong&quot;, MessageType.WARNING);</programlisting></para>
        </listitem>
        <listitem>
          <para><code>showOptionDialog()</code> is intended to display a message and buttons for user actions. In addition to parameters described for <code>showMessageDialog()</code>, the method takes an array or a list of actions. A button is created for each dialog action. After a button is clicked, the dialog  closes invoking <code>actionPerform()</code> method of the corresponding action.</para>
          <para>It is convenient to use anonymous classes derived from <code>DialogAction</code> for buttons with standard names and icons. Five types of actions defined by the <code>DialogAction.Type</code> enum are supported: <code>OK</code>, <code>CANCEL</code>, <code>YES</code>, <code>NO</code>, <code>CLOSE</code>. Names of corresponding buttons are extracted from the  <link linkend="main_message_pack">mаin message pack</link>.</para>
          <para>Below is an example of a dialog invocation with <code>Yes</code> and <code>No</code> buttons and with a caption and messages taken from the message pack of the current screen:<programlisting language="java">showOptionDialog(
      getMessage(&quot;confirmCopy.title&quot;),
      getMessage(&quot;confirmCopy.msg&quot;),
      MessageType.CONFIRMATION,
      new Action[]{
              new DialogAction(DialogAction.Type.YES) {
                  public void actionPerform(Component component) {
                      copySettings();
                  }
              },
              new DialogAction(DialogAction.Type.NO)
      }
);</programlisting></para>
        </listitem>
      </itemizedlist>
    </section>
    <section id="notifications">
      <title>Notifications</title>
      <para>Notifications can be invoked using  <code>showNotification()</code> method of the  <code>IFrame</code> interface. This interface is implemented by  <link linkend="screen_controller">screen controlller</link>,  so this method can be invoked directly from the controller code.</para>
      <para><code>showNotification()</code> method takes the following parameters:<itemizedlist>
          <listitem>
            <para><code>caption</code> - notification text. In case of HTML-type (see below), you can format message
                text using HTML-tags. When using HTML, don’t forget to escape data to prevent code injection in the
                web-client. You can use <code>\n</code> characters for line breaks in non-HTML messages.</para>
          </listitem>
          <listitem>
            <para><code>description</code> – an optional description displayed under the caption. You can also use
                <code>\n</code> character or HTML-formatting.</para>
          </listitem>
          <listitem>
            <para><code>type</code> – notification type. Possible values:<itemizedlist>
                <listitem>
                  <para><code>TRAY</code>, <code>TRAY_HTML</code> - a notification is displayed in the bottom right corner of the application and disappears automatically.</para>
                </listitem>
                <listitem>
                  <para><code>HUMANIZED</code>, <code>HUMANIZED_HTML</code> – a standard notification displayed in the center of the screen, disappears automatically.</para>
                </listitem>
                <listitem>
                  <para><code>WARNING</code>, <code>WARNING_HTML</code> – a warning. Disappears when clicked.</para>
                </listitem>
                <listitem>
                  <para><code>ERROR</code>, <code>ERROR_HTML</code> – a notification about an error. Disappears when clicked.</para>
                </listitem>
              </itemizedlist></para>
          </listitem>
        </itemizedlist></para>
      <para>Examples of invoking a notification:<programlisting language="java">showNotification(getMessage(&quot;selectBook.text&quot;), NotificationType.HUMANIZED);

showNotification(&quot;Validation error&quot;, &quot;&lt;b&gt;Date&lt;/b&gt; is incorrect&quot;, NotificationType.TRAY_HTML);</programlisting></para>
    </section>
  </section>
  <section id="background_tasks">
    <title>Background Tasks</title>
    <para>Background tasks can be used at the client tier to perform tasks asynchronously without locking the user interface.</para>
    <section><title>Using Background Tasks</title><orderedlist>
        <listitem>
          <para>A task is defined as an inheritor of an abstract class  <code>BackgroundTask</code>. A link to a screen controller which will be associated with the task and the task timeout should be passed to the task constructor.</para>
          <para>Closing the screen will interrupt the tasks associated with it. Additionally, the task will be interrupted automatically after the specified timeout.</para>
          <para>Actual actions performed by the task are implemented in the  <code>run()</code> method.</para>
        </listitem>
        <listitem>
          <para>An object of &quot;<code>BackgroundTaskHandler</code>&quot; class controlling the task is created by passing a task instance to the  <code>handle()</code> method of the  <code>BackgroundWorker</code> bean. A link to a <code>BackgroundWorker</code> can be obtained by an injection in a  <link linkend="screen_controller">screen controller</link>, or a static method of the <code>AppBeans</code> class.</para>
        </listitem>
      </orderedlist>Example:<programlisting language="java">@Inject
protected BackgroundWorker backgroundWorker;

@Override
public void init(Map&lt;String, Object&gt; params) {
  // Create task with 10 sec timeout and this screen as owner
  BackgroundTask&lt;Integer, Void&gt; task = new BackgroundTask&lt;Integer, Void&gt;(10, this) {
      @Override
      public Void run(TaskLifeCycle&lt;Integer&gt; taskLifeCycle) throws Exception {
          // Do something in background thread
          for (int i = 0; i &lt; 5; i++) {
              TimeUnit.SECONDS.sleep(1); // time consuming computations
              taskLifeCycle.publish(i); // publish current progress to show it in progress() method
          }
          return null;
      }

      @Override
      public void canceled() {
          // Do something in UI thread if the task is canceled
      }

      @Override
      public void done(Void result) {
          // Do something in UI thread when the task is done
      }

      @Override
      public void progress(List&lt;Integer&gt; changes) {
          // Show current progress in UI thread
      }
  };
  // Get task handler object and run the task
  BackgroundTaskHandler taskHandler = backgroundWorker.handle(task);
  taskHandler.execute();
}</programlisting><para>Detailed information about methods is provided in JavaDocs for <code>BackgroundTask</code>, <code>TaskLifeCycle</code>, <code>BackgroundTaskHandler</code> classes. </para><para>Please note the following:</para><itemizedlist>
        <listitem>
          <para><code>BackgroundTask&lt;T, V&gt;</code> is a parameterized class:</para>
          <itemizedlist>
            <listitem>
              <para><code>T</code> − the type of objects displaying task progress. Objects of this type are passed to the task&apos;s  <code>progress()</code> method during an invocation of  <code>TaskLifeCycle.publish()</code> in the working thread.</para>
            </listitem>
            <listitem>
              <para><code>V</code> − task result type passed to the <code>done()</code> method. It can also be obtained by invoking   <code>BackgroundTaskHandler.getResult()</code> method, which will wait for a task to complete.</para>
            </listitem>
          </itemizedlist>
        </listitem>
        <listitem>
          <para><code>canceled()</code> method is invoked only during a controlled cancelation of a task, i.e. when  <code>cancel()</code> is invoked in the  <code>TaskHandler</code>.</para>
        </listitem>
        <listitem>
          <para>If task timeout expires, or a window where it was running closes, the task is stopped without notifications. In the <structname>Web Client</structname> block, timeout-based interruption is performed with a delay specified in the <link linkend="cuba.backgroundWorker.maxClientLatencySeconds">cuba.backgroundWorker.maxClientLatencySeconds</link> application property.</para>
        </listitem>
        <listitem>
          <para><code>run()</code> method of a task should support external interruptions. To ensure this, we recommend checking the <code>TaskLifeCycle.isInterrupted()</code> flag periodically during long processes and stopping execution when needed. Additionally, you should not silently discard <code>InterruptedException</code> (or any other exceptions) - instead you should either exit the method correctly or not handle the exception at all.</para>
        </listitem>
        <listitem>
          <para><code>BackgroundTask</code> objects are stateless. If you did not create fields for temporary data when implementing task class, you can start several parallel processes using a single task instance.</para>
        </listitem>
        <listitem>
          <para><code>BackgroundHandler</code> object (its  <code>execute()</code> method) can only be started once. If you need to restart a task frequently, use  <code>BackgroundTaskWrapper</code> class.</para>
        </listitem>
        <listitem>
          <para>Use  <code>BackgroundWorkWindow</code> or  <code>BackgroundWorkProgressWindow</code> classes with a set of static methods to show a modal window with progress indicator and <guibutton>Cancel</guibutton> button. You can define progress indication type and allow or prohibit cancellation of the background task for the window.</para>
        </listitem>
        <listitem>
          <para>If you need to use certain values of visual components in the task thread, you should implement their acquisition in <code>getParams()</code> method, which runs in the UI thread once, when a task starts. In the   <methodname>run()</methodname> method, these parameters will be accessible via the  <code>getParams()</code> method of the <code>TaskLifeCycle</code> object.</para>
        </listitem>
        <listitem>
          <para>If any exception occurs, the framework invokes  <code>BackgroundTask.handleException()</code> method  in the UI thread, which can be used to display the error.</para>
        </listitem>
      </itemizedlist></section>
    <section>
      <title>Setting Up Environment </title>
      <para>In order for background tasks to work correctly, the following configuration should be performed for the application project:</para>
      <itemizedlist>
        <listitem>
          <para>Timeout-based task interruption is implemented by the  <code>WatchDog</code> bean. To ensure that it is invoked periodically, you should add the following declaration to the <link linkend="spring.xml">spring.xml</link> files of the  <structname>Web Client </structname>and  <structname>Desktop Client</structname> blocks:<programlisting language="xml">&lt;bean id=&quot;backgroundWorkerScheduler&quot; class=&quot;org.springframework.scheduling.concurrent.ThreadPoolTaskScheduler&quot;&gt;
  &lt;property name=&quot;daemon&quot; value=&quot;true&quot;/&gt;
  &lt;property name=&quot;poolSize&quot; value=&quot;1&quot;/&gt;
&lt;/bean&gt;

&lt;task:scheduled-tasks scheduler=&quot;backgroundWorkerScheduler&quot;&gt;
  &lt;task:scheduled ref=&quot;cuba_BackgroundWorker_WatchDog&quot; method=&quot;cleanupTasks&quot; fixed-delay=&quot;2000&quot;/&gt;
&lt;/task:scheduled-tasks&gt; </programlisting></para>
        </listitem>
        <listitem>
          <para>In the  <structname>Web Client</structname> block task state polling is initiated by the client code running in web-browser. Polling interval is defined by the  <link linkend="cuba.backgroundWorker.uiCheckInterval">cuba.backgroundWorker.uiCheckInterval</link> application property; the default value is 2 seconds.</para>
          <para>Additionally, background tasks running in the  <structname>Web Client</structname> block are affected by <link linkend="cuba.backgroundWorker.maxActiveTasksCount">cuba.backgroundWorker.maxActiveTasksCount</link> and <link linkend="cuba.backgroundWorker.maxClientLatencySeconds">cuba.backgroundWorker.maxClientLatencySeconds</link> application properties.</para>
        </listitem>
      </itemizedlist>
    </section>
  </section>
  <section id="gui_themes">
    <title>Creating Application Themes</title>
    <para>Theme is used to manage visual presentation of an application.</para>
    <section id="web_theme">
      <title>Themes in Web Applications</title>
      <para>A theme consists of SCSS files and other resources like images.</para>
      <section id="web_theme_usage">
        <title>Using Existing Themes</title>
        <para>The platform includes two ready to use themes:  Halo and Havana. By default, the application will use the one specified in the <link linkend="cuba.web.theme">cuba.web.theme</link> application property. The user may select the other theme in the standard  <guimenu>Help</guimenu> &gt; <guimenu>Settings</guimenu> screen. If you want to disable the option to select new themes for users, register the  <code>settings</code> screen in the  <link linkend="screens.xml">web-screens.xml</link> file of your project and set the  <code>changeThemeEnabled = false</code> parameter for it:
        <programlisting language="xml">&lt;screen id=&quot;settings&quot; template=&quot;/com/haulmont/cuba/web/app/ui/core/settings/settings-window.xml&quot;&gt;
  &lt;param name=&quot;changeThemeEnabled&quot; value=&quot;false&quot;/&gt;
&lt;/screen&gt;          </programlisting></para>
        <para>Some branding parameters can be configured for default themes, such as icons, login and main application window captions, and the website icon (<filename>favicon.ico</filename>). This can be done in the following way:<orderedlist>
            <listitem>
              <para>Create the following files structure in the   <filename>modules/web</filename> directory of the project:<programlisting>VAADIN/
themes/
  havana/
    branding/
      myapp-login.png
      myapp-menu.png
    favicon.ico</programlisting></para>
              <para>Here, <filename>havana</filename> is the directory of the theme,  <filename>favicon.ico</filename> is the website icon, <filename>myapp-login.png</filename> - login window logo image,  <filename>myapp-menu.png</filename> - main window logo image. </para>
            </listitem>
            <listitem>
              <para>Open <guimenu>Project properties</guimenu> &gt; <guimenu>Edit</guimenu> in <application>CUBA Studio</application> and click <guibutton>Branding</guibutton> at the bottom of the page.  Set the paths to icon files for application and login window using <guibutton>Set application logo image</guibutton> and <guibutton>Set login window logo image</guibutton> links. The path is specified relatively to the theme directory. Other links can be used to set window captions and the login window welcome text.</para>
              <para>These parameters are saved in the  <link linkend="main_message_pack">main message pack</link> of the   <structname>gui</structname> module (i.e the  <filename>modules/gui/&lt;root_package&gt;/gui/messages.properties</filename> file and its variants for different locales). Message packs allow you to use different image files for different user locales. A sample <filename>messages.properties</filename> file:<programlisting>application.caption = MyApp
application.logoImage = branding/myapp-menu.png

loginWindow.caption = MyApp Login
loginWindow.welcomeLabel = Welcome to MyApp!
loginWindow.logoImage = branding/myapp-login.png</programlisting></para>
              <para>You should not specify the path to  <code>favicon.ico</code>, since it must be located in the root directory of the theme.</para>
            </listitem>
          </orderedlist>Image files that will be used in the <link linkend="gui_attr_basic_icon">icon</link> properties for  <link linkend="gui_Action">actions</link> and visual components, e.g.  <link linkend="gui_Button">Button</link>, can be also added to default themes. </para>
        <para>For example, to add an icon to the Havana theme, you just have to add the image file to the  <filename>modules/web/VAADIN/themes/havana</filename> directory described above (it is recommended to create a subfolder): <programlisting>VAADIN/
themes/
  havana/
    images/
      address-book.png</programlisting>After that, you can use the icon in the application by specifying the path relatively to the theme directory in the <code>icon</code> property:<programlisting language="xml">&lt;action id=&quot;adresses&quot;
      icon=&quot;images/address-book.png&quot;/&gt;</programlisting></para>
        <para>Font elements of  <ulink url="http://fortawesome.github.io/Font-Awesome">Font Awesome</ulink> can be used instead of icons. You should just specify the name of the required constant of the  <code>com.vaadin.server.FontAwesome</code> in the <code>icon</code> property with a  <code>font-icon:</code> prefix, for example:<programlisting language="xml">&lt;action id=&quot;adresses&quot;
      icon=&quot;font-icon:BOOK&quot;/&gt;</programlisting></para>
        <para>Images used for standard actions and screens of the platform can be replaced in the project. To replace a Havana theme icon, you should just copy the required image file to the  <filename>modules/web/VAADIN/themes/havana/icons</filename> directory of the project. For example, <filename>create.png</filename> file should be created to replace the icon for the standard   <code>create</code> action (the file name can be easily identified by URL of the corresponding <code>img</code> HTML-element in the running application):<programlisting>VAADIN/
themes/
  havana/
    icons/
      create.png</programlisting></para>
        <para>In Halo theme, Font Awesome icons are used for standard actions and platform screens by default (if <link linkend="cuba.web.useFontIcons">cuba.web.useFontIcons</link> is enabled). In this case, you can replace a standard icon only by creating a custom theme based on Halo (see  <link linkend="web_theme_creation">below</link>) and setting the required correlation between the icon and the font element name in <filename>&lt;your_theme&gt;-theme.properties</filename> file:<programlisting>cuba.web.icons.create.png = PLUS</programlisting></para>
        <para>If  <code>cuba.web.useFontIcons</code> property is disabled, the icons for standard actions and screens are loaded similar to Havana theme - from image files in the  <filename>icons</filename> subfolder. They can be replaced in the manner described for Havana.</para>
        <para>Halo theme supports the  <link linkend="cuba.web.useInverseHeader">cuba.web.useInverseHeader</link> property, which controls the colour of the application header. By deafult, this property is set to <code>true</code>, which sets a dark (inverse) header.You can make a light header without any changes to the theme, simply by setting this property to  <code>false</code>.</para>
      </section>
      <section id="web_theme_extension">
        <title>Extending an Existing Theme</title>
        <para>A platform theme can be modified in the project. Themes are described in <ulink url="http://sass-lang.com">SCSS</ulink> files,  that is why the simplest way to modify the theme is to modify the base SCSS variables that control application background colour, component size, or margins. Changing specific component parameters requires some expertise in CSS.</para>
        <para>To adapt (extend) a theme in the project, you should create a specific file structure in the  <structname>web</structname> module. A convenient way to do this is to use <application>CUBA Studio</application>: open the  <guimenu>Project properties</guimenu> section and click  <guibutton>Create theme extension</guibutton>. Select the theme you want to extend in the popup window. As a result, a directory structure, similar to the one described in the  <link linkend="web_theme_usage">previous</link> section, will be created. Apart from that, the <link linkend="build.gradle">build.gradle</link> script will be complemented with the <code>buildScssThemes</code> task,  which is executed automatically each time the <structname>web</structname> module is built.</para>
        <para>Below is the example of a Halo theme extension, since it is based on <ulink url="https://vaadin.com/valo">Valo</ulink> theme from <application>Vaadin</application>, and provides the widest range of options for customization. </para>
        <para>The  <filename>themes/halo/halo-ext-defaults.scss</filename> file is intended for theme variables. Most of the Halo variables correspond to those described in the  <ulink url="https://vaadin.com/api/valo">Valo documentation</ulink>. Below are the most common variables:<programlisting language="">$v-background-color: #fafafa;        /* component background colour */
$v-app-background-color: #e7ebf2;    /* application background colour */
$v-panel-background-color: #fff;     /* panel background colour */
$v-focus-color: #3b5998;             /* focused element colour */
$v-error-indicator-color: #ed473b;   /* empty required fields colour */

$v-line-height: 1.35;                /* line height */
$v-font-size: 14px;                  /* font size */
$v-font-weight: 400;                 /* font weight */
$v-unit-size: 30px;                  /* base theme size, defines the height for buttons, fields and other elements */

$v-font-size--h1: 24px;              /* h1-style Label size */
$v-font-size--h2: 20px;              /* h2-style Label size */
$v-font-size--h3: 16px;              /* h3-style Label size */

/* margins for containers */
$v-layout-margin-top: 10px;
$v-layout-margin-left: 10px;
$v-layout-margin-right: 10px;
$v-layout-margin-bottom: 10px;

/* spacing between components in a container (if enabled) */
$v-layout-spacing-vertical: 10px;
$v-layout-spacing-horizontal: 10px;

/* basic table dimensions */
$v-table-row-height: 30px;
$v-table-header-font-size: 13px;
$v-table-cell-padding-horizontal: 7px;

/* input field focus style */
$v-focus-style: inset 0px 0px 5px 1px rgba($v-focus-color, 0.5);
/* required fields focus style */
$v-error-focus-style: inset 0px 0px 5px 1px rgba($v-error-indicator-color, 0.5);

/* animation for elements is enabled by default */
$v-animations-enabled: true;
/* popup window animation is disabled by default */
$v-window-animations-enabled: false;

/* inverse header is controlled by cuba.web.useInverseHeader property */
$v-support-inverse-menu: true;</programlisting></para>
        <para>A sample <filename>halo-ext-defaults.scss</filename> for a theme with a dark background and slightly minimized margins is provided below:<programlisting>$v-background-color: #444D50;

$v-font-size--h1: 22px;
$v-font-size--h2: 18px;
$v-font-size--h3: 16px;

$v-layout-margin-top: 8px;
$v-layout-margin-left: 8px;
$v-layout-margin-right: 8px;
$v-layout-margin-bottom: 8px;

$v-layout-spacing-vertical: 8px;
$v-layout-spacing-horizontal: 8px;

$v-table-row-height: 25px;
$v-table-header-font-size: 13px;
$v-table-cell-padding-horizontal: 5px;

$v-support-inverse-menu: false;</programlisting>To modify parameters for specific components, you should add the corresponding CSS code to <code>@mixin halo-ext {...}</code> block of the  <filename>halo-ext.scss</filename> file. For example, to display the application menu items in bold, the contents of the <filename>halo-ext.scss</filename> file should be as follows:<programlisting language="">@import &quot;../halo/halo&quot;;

@mixin halo-ext {
@include halo;

.v-menubar-menuitem-caption {
  font-weight: bold;
}
}</programlisting></para>
      </section>
      <section id="web_theme_creation">
        <title>Creating a Custom Theme</title>
        <para>You can create one or several application themes in the project and give the users an opportunity to select the most appropriate one. Creating new themes also allows you to override the variables in the  <filename>*-theme.properties</filename> files, which set a few server-side parameters: <itemizedlist>
            <listitem>
              <para>Default dialog window size.</para>
            </listitem>
            <listitem>
              <para>Default input field width.</para>
            </listitem>
            <listitem>
              <para>Dimensions of some components (<link linkend="gui_Filter">Filter</link>, <link linkend="gui_FileMultiUploadField">FileMultiUploadField</link>).</para>
            </listitem>
            <listitem>
              <para>Correlation between icon names and constants of the <code>com.vaadin.server.FontAwesome</code> enumeration for using <application>Font Awesome</application> in standard actions and screens of the platform, if   <link linkend="cuba.web.useFontIcons">cuba.web.useFontIcons</link> is enabled.</para>
            </listitem>
          </itemizedlist></para>
        <para>Below is the example of creating a Halo-based Facebook theme, which resembles the interface of a popular social network.<orderedlist>
            <listitem>
              <para>Open <guimenu>Project properties</guimenu> section in <application>CUBA Studio</application> and click <guibutton>Create theme extension</guibutton>. Select  <code>halo</code> and click <guibutton>Create</guibutton>. A Halo theme extension will be created in the project as described in the previous section.</para>
            </listitem>
            <listitem>
              <para>Rename the  <filename>themes/halo</filename> directory in the <structname>web</structname> module to  <filename>themes/facebook</filename>, then rename the  <filename>halo-ext.scss</filename> file inside it to  <filename>facebook.scss</filename>, and  <filename>halo-ext-defaults.scss</filename> to  <filename>facebook-defaults.scss</filename>.</para>
            </listitem>
            <listitem>
              <para>Edit the  <filename>styles.scss</filename> file by changing the  <code>halo-ext</code> imports and the  <code>halo</code> root selector:<programlisting language="">@import &quot;halo-defaults&quot;;
@import &quot;facebook-defaults&quot;;
@import &quot;facebook&quot;;

.facebook {
@include facebook;
}

.v-theme-version {
display: none;
}</programlisting></para>
            </listitem>
            <listitem>
              <para>Edit the   <filename>facebook.scss</filename> file and replace  <code>@mixin halo-ext</code>:<programlisting language="">@import &quot;../halo/halo&quot;;

@mixin facebook {
@include halo;
}</programlisting></para>
            </listitem>
            <listitem>
              <para>Copy the following variables to  <filename>facebook-defaults.scss</filename>:<programlisting>$v-background-color: #fafafa;
$v-app-background-color: #e7ebf2;
$v-panel-background-color: #fff;
$v-focus-color: #3b5998;

$v-border-radius: 0;
$v-textfield-border-radius: 0;

$v-font-family: Helvetica, Arial, &apos;lucida grande&apos;, tahoma, verdana, arial, sans-serif;
$v-font-size: 14px;
$v-font-color: #37404E;
$v-font-weight: 400;

$v-link-text-decoration: none;
$v-shadow: 0 1px 0 (v-shade 0.2);
$v-bevel: inset 0 1px 0 v-tint;
$v-unit-size: 30px;
$v-gradient: v-linear 12%;
$v-overlay-shadow: 0 3px 8px v-shade, 0 0 0 1px (v-shade 0.7);
$v-shadow-opacity: 20%;
$v-selection-overlay-padding-horizontal: 0;
$v-selection-overlay-padding-vertical: 6px;
$v-selection-item-border-radius: 0;

$v-line-height: 1.35;
$v-font-size: 14px;
$v-font-weight: 400;
$v-unit-size: 25px;

$v-font-size--h1: 22px;
$v-font-size--h2: 18px;
$v-font-size--h3: 16px;

$v-layout-margin-top: 8px;
$v-layout-margin-left: 8px;
$v-layout-margin-right: 8px;
$v-layout-margin-bottom: 8px;

$v-layout-spacing-vertical: 8px;
$v-layout-spacing-horizontal: 8px;

$v-table-row-height: 25px;
$v-table-header-font-size: 13px;
$v-table-cell-padding-horizontal: 5px;

$v-focus-style: inset 0px 0px 1px 1px rgba($v-focus-color, 0.5);
$v-error-focus-style: inset 0px 0px 1px 1px rgba($v-error-indicator-color, 0.5);</programlisting></para>
            </listitem>
            <listitem>
              <para>Create a  <filename>facebook-theme.properties</filename> file in the   <filename>src</filename> directory of the <structname>web</structname> module:<programlisting>@include=halo-theme.properties</programlisting></para>
              <para>If necessary, you can use this file to override server-side theme variables from the <filename>halo-theme.properties</filename> file of the platform.</para>
            </listitem>
            <listitem>
              <para>Add the following properties to the  <filename>web-app.properties</filename>  file:<programlisting>cuba.web.theme = facebook
cuba.themeConfig = havana-theme.properties halo-theme.properties facebook-theme.properties</programlisting></para>
            </listitem>
            <listitem>
              <para>Rebuild the application and start the server. Now the user will see the application in Facebook theme on first login, and will be able to choose between Facebook, Halo and Havana in the  <guimenu>Help</guimenu> &gt; <guimenu>Settings</guimenu> menu.</para>
            </listitem>
          </orderedlist></para>
      </section>
    </section>
    <section id="desktop_theme">
      <title>Themes in Desktop Applications</title>
      <para>The base theme for desktop applications is  <code>Nimbus</code>.</para>
      <para>To add any changes to the standard theme, you need to create a   <code>res.nimbus</code> package in the <code>com.sample.sales.desktop</code> package of the  <structname>desktop</structname> module. Theme files will be stored in the  <code>res.nimbus</code> package.</para>
      <figure>
        <title/>
        <mediaobject>
          <imageobject>
            <imagedata align="center" fileref="img/gui_themes_desktop_structure.png"/>
          </imageobject>
        </mediaobject>
      </figure>
      <para>The  <code>icons</code> folder contains icon files, the  <filename>nimbus.xml</filename> file contains the description of the theme style.</para>
      <para>The  <link linkend="app_properties">properties file</link> of a desktop application should have <property>cuba.desktop.resourceLocations</property> property defined (defines a set of folders containing the style files):<programlisting>cuba.desktop.resourceLocations = \
com/haulmont/cuba/desktop/res \
com/sample/sales/desktop/res</programlisting></para>
      <para><emphasis role="bold">Examples</emphasis></para>
      <orderedlist>
        <listitem>
          <para>Adding an icon.</para>
          <para>If you need to add a new icon to a desktop application, for example an icon for a button, you should create a <code>res.nimbus.icons</code> package within the  <code>com.sample.sales.desktop </code>package of the  <structname>desktop</structname> module and put the corresponding icon there.</para>
          <figure>
            <title/>
            <mediaobject>
              <imageobject>
                <imagedata align="center" fileref="img/gui_themes_example4.png"/>
              </imageobject>
            </mediaobject>
          </figure>
          <para>Description of a  <link linkend="gui_Button">button</link> in the  <link linkend="screen_xml_glossentry">descriptor</link> with a path to an icon set in the  <link linkend="gui_attr_basic_icon">icon</link> attribute:</para>
          <programlisting language="xml">&lt;button id=&quot;button1&quot; caption=&quot;Attention&quot;  icon=&quot;icons/attention.png&quot;/&gt;</programlisting>
          <para>Below you can see a button with the  <filename>attention.png</filename> icon.</para>
          <figure>
            <title/>
            <mediaobject>
              <imageobject>
                <imagedata align="center" fileref="img/gui_themes_example5.png"/>
              </imageobject>
            </mediaobject>
          </figure>
        </listitem>
        <listitem>
          <para>Redefining default values of theme properties. </para>
          <para>For example, let us change text field background color for mandatory fields.</para>
          <para>The  <filename>nimbus.xml</filename> file with the following content should be created in the  <code>res.nimbus</code> package:<programlisting language="xml">&lt;theme xmlns=&quot;http://schemas.haulmont.com/cuba/5.5/desktop-theme.xsd&quot;&gt;
  &lt;ui-defaults&gt;
      &lt;color property=&quot;cubaRequiredBackground&quot; value=&quot;#f78260&quot;/&gt;
  &lt;/ui-defaults&gt;
&lt;/theme&gt;</programlisting></para>
          <para>The  <sgmltag>ui-defaults</sgmltag> element redefines the values of platform theme properties set by default.</para>
          <para>The  <sgmltag>ui-defaults</sgmltag> element includes both the properties contained in a standard <code>Nimbus</code> (<ulink url="http://docs.oracle.com/javase/tutorial/uiswing/lookandfeel/_nimbusDefaults.html">http://docs.oracle.com/javase/tutorial/uiswing/lookandfeel/_nimbusDefaults.html</ulink>) theme and the properties created in the CUBA platform.</para>
          <para>In this example, we redefined the value of the CUBA property –   <sgmltag>cubaRequiredBackground</sgmltag>, which stores the background color for required fields. This change will affect all required input fields.</para>
        </listitem>
        <listitem>
          <para>Creating a style for an element using standard tools.</para>
          <para>Let’s consider an example of highlighting a text in bold.</para>
          <para>To create a style like that you need to define <sgmltag>style</sgmltag> element in the theme file  <filename>nimbus.xml</filename> in the following way:<programlisting language="xml">&lt;theme xmlns=&quot;http://schemas.haulmont.com/cuba/5.5/desktop-theme.xsd&quot;&gt;
  &lt;style name=&quot;boldlabel&quot;&gt;
      &lt;font style=&quot;bold&quot;/&gt;
  &lt;/style&gt;
&lt;/theme&gt;</programlisting></para>
          <para><sgmltag>style</sgmltag> element can also contain other elements which can define different properties: <sgmltag>background</sgmltag>, <sgmltag>foreground</sgmltag>, <sgmltag>icon</sgmltag>.</para>
          <para>You should add <link linkend="gui_attr_basic_stylename">stylename</link> attribute   with the name of the created style into the description of the corresponding label in an <link linkend="screen_xml_glossentry">xml-descriptor</link>.<programlisting language="xml">&lt;label id=&quot;label1&quot; value=&quot;msg://labelVal&quot; stylename=&quot;boldlabel&quot;/&gt;</programlisting></para>
          <para>In such way the style will be applied only to the labels that have  <link linkend="gui_attr_basic_stylename">stylename</link> attribute with the value of  <literal>boldlabel</literal>.</para>
        </listitem>
        <listitem><para>Creating a custom style.</para>If standard style adjustment capabilities are insufficient, you can create a custom style.<para>Let us create a custom style that will be applied to the  <link linkend="gui_Label">Label</link> component. With this style, the content of the   <link linkend="gui_Label">Label</link> will be displayed as underlined..</para><para>First, let us create a decorator class  <code>UnderlinedLabelDecorator</code>:<programlisting language="java">public class UnderlinedLabelDecorator implements ComponentDecorator {

  @Override
  @SuppressWarnings(&quot;unchecked&quot;)
  public void decorate(Object component, Set&lt;String&gt; state) {
      DesktopLabel item = (DesktopLabel) component;
      JLabel jlabel = item.getComponent();

      Font originalFont = jlabel.getFont();
      Map attributes = originalFont.getAttributes();
      attributes.put(TextAttribute.UNDERLINE, TextAttribute.UNDERLINE_ON);
      jlabel.setFont(originalFont.deriveFont(attributes));
  }
}</programlisting></para><para>Let us define a custom style in <filename>nimbus.xml</filename>:<programlisting language="xml">&lt;theme xmlns=&quot;http://schemas.haulmont.com/cuba/5.5/desktop-theme.xsd&quot;&gt;
  &lt;style name=&quot;label-underlined&quot; component=&quot;com.haulmont.cuba.desktop.gui.components.DesktopLabel&quot;&gt;
      &lt;custom class=&quot;com.sample.sales.desktop.gui.decorators.UnderlinedLabelDecorator&quot;/&gt;
  &lt;/style&gt;
&lt;/theme&gt;</programlisting></para><para>The  <sgmltag>component</sgmltag> attribute of the   <sgmltag>style</sgmltag> element contains the name of the component that the style with the name <literal>label-underlined</literal> can be applied to.</para><para>The  <sgmltag>custom</sgmltag> element should contain path to the decorator class defined above.</para><para>When describing a label element that should be affected by the custom style, you should specify the style name in the <sgmltag>stylename</sgmltag> attribute:<programlisting language="xml">&lt;label id=&quot;label1&quot; stylename=&quot;label-underlined&quot; value=&quot;Label&quot;/&gt;</programlisting></para><figure>
            <title>A label component with a custom style</title>
            <mediaobject>
              <imageobject>
                <imagedata align="center" fileref="img/gui_themes_example6.png"/>
              </imageobject>
            </mediaobject>
          </figure></listitem>
      </orderedlist>
    </section>
  </section>
  <section id="gui_web">
    <title>Web Client Specifics</title>
    <para>Implementation of the generic user interface of the  <structname>Web Client</structname> <link linkend="app_tiers">block</link> is based on the  <application>Vaadin</application> framework. The main classes available in the web client infrastructure are described below.<figure>
        <title>Classes of the Web Client Infrastructure</title>
        <mediaobject>
          <imageobject>
            <imagedata align="center" fileref="img/WebClientInfrastructure.png"/>
          </imageobject>
        </mediaobject>
      </figure></para>
    <itemizedlist>
      <listitem>
        <para><code>App</code> - the central class of the application infrastructure. Contains links to  <code>Connection</code>, <code>AppWindow</code> and other infrastructure objects. Only one instance of  <code>App</code> exists for a given HTTP-session.</para>
        <para>Each application typically has its own <code>App</code> class class inherited from the   <code>DefaultApp</code> and thus from the basic abstract  <code>App</code> class of the platform. It allows you to override <code>createAppWindow()</code> and <code>createLoginWindow()</code> methods to create custom implementations of the main window and the login window.</para>
        <para>The  <code>App</code> class of an application should be registered in the  <code>application</code> parameter of the  <code>app_servlet</code> in the  <link linkend="web.xml">web.xml</link> file of the  <structname>web</structname> module.</para>
      </listitem>
      <listitem>
        <para><code>Connection</code> is the interface providing functionality of connecting to middleware and storing <link linkend="userSession">user sessions</link>. <code>DefaultConnection</code> is a standard implementation of this interface.</para>
      </listitem>
      <listitem>
        <para><code>AppUI</code> is a platform class inherited from  <code>com.vaadin.ui.UI</code> class. There is one instance of this class for each open tab of a web browser. Contains a link to the <code>UIView</code> object – either a  <code>LoginWindow</code> or  <code>AppWindow</code>.</para>
        <para><code>AppUI</code> application class should be registered in the <code>UI</code> parameter of the  <code>app_servlet</code> in the <filename>web/WEB-INF/web.xml</filename> file of the  <structname>web</structname> module. In most cases, standard platform class is used.</para>
      </listitem>
      <listitem>
        <para><code>LoginWindow</code> –  the window displayed before a user logs in. In your application you can create an inheritor of  <code>LoginWindow</code> and redefine the  <code>createLoginWindow()</code> method of the  <code>App</code> class to use it.</para>
      </listitem>
      <listitem>
        <para><code>AppWindow</code> – main application window displayed after a user logs in. In your application, you can create an inheritor of  <code>AppWindow</code> and override the  <code>createAppWindow()</code> method of the  <code>App</code> class to use it.</para>
        <para><code>onHistoryBackPerformed()</code> method allows you to handle browser <guibutton>Back</guibutton> button.
          This method is invoked instead of standard browser behavior if
          <link linkend="cuba.web.allowHandleBrowserHistoryBack">cuba.web.allowHandleBrowserHistoryBack</link> application
          property is true.</para>
        <para>You can control certain main window parameters without creating  <code>AppWindow</code> inheritor, using the following application properties:<itemizedlist>
            <listitem>
              <para><link linkend="cuba.web.useLightHeader">cuba.web.useLightHeader</link> - switches on compact window header - logo, menu bar, user name and log out button in one line. When switched off, <code>AppWindow.createTitleLayout()</code> method creates additional area at the top.</para>
            </listitem>
            <listitem>
              <para><link linkend="cuba.web.foldersPaneEnabled">cuba.web.foldersPaneEnabled</link> - allows creation of  <link linkend="folders_pane">folders pane</link> by <code>AppWindow.createFoldersPane()</code> method.</para>
            </listitem>
            <listitem>
              <para><link linkend="cuba.web.appWindowMode">cuba.web.appWindowMode</link> – sets default mode for the main window: tabbed or single screen  (<code>TABBED</code> или <code>SINGLE</code>). Users can change the mode later using <guimenu>Help</guimenu> &gt; <guimenu>Settings</guimenu> screen.</para>
            </listitem>
            <listitem>
              <para><link linkend="cuba.web.maxTabCount">cuba.web.maxTabCount</link> – when the main window is in the tabbed mode, this property sets the maximum number of tabs that a user can open. The default value is 7.</para>
            </listitem>
          </itemizedlist></para>
      </listitem>
      <listitem>
        <para><code>WindowManager</code> - the central class implementing application screens management logic.  <code>openWindow()</code>, <code>openEditor()</code>, <code>showMessageDialog()</code> and other methods of the  <code>IFrame</code> interface implemented by screen <link linkend="screen_controller">controllers</link> delegate to the window manager.   <code>WindowManager</code> class is located in the platform’s common  <structname>gui</structname> module and is abstract. The  <structname>web</structname> module has a dedicated <code>WebWindowManager</code> class that implements web client specifics.</para>
        <para>Normally, the  <code>WindowManager</code> is not used in the application code directly.</para>
      </listitem>
      <listitem>
        <para><code>ExceptionHandlers</code> - contains a collection of <link linkend="exceptionHandlers">client-level exception handlers</link>.</para>
      </listitem>
    </itemizedlist>
    <section id="webComponentsHelper">
      <title>Working with Vaadin Components </title>
      <para>In order to work directly with Vaadin components implementing interfaces of the <link linkend="gui_vcl">visual components library</link> in the <structname>Web Client</structname>  <link linkend="app_tiers">block</link> you should use the <code>WebComponentsHelper</code> class. It has two static methods to retrieve links to Vaadin components:<itemizedlist>
          <listitem>
            <para><code>unwrap</code> – retrieves a Vaadin component for a given CUBA component.</para>
          </listitem>
          <listitem>
            <para><code>getComposition</code> - retrieves a Vaadin component that is the outmost external container in the implementation of a given CUBA component. For simple components, such as   <link linkend="gui_Button">Button</link> this method returns the same object as <code>unwrap()</code> - <code>com.vaadin.ui.Button</code>. For complex components, such as  <link linkend="gui_Table">Table</link>, <code>unwrap()</code> will return the corresponding object -   <code>com.vaadin.ui.Table</code>, while  <code>getComposition()</code> will return  <code>com.vaadin.ui.VerticalLayout</code>, which contains the table together with <link linkend="gui_ButtonsPanel">ButtonsPanel</link> and  <code>RowsCount</code> defined with it.</para>
          </listitem>
        </itemizedlist></para>
      <para>Please note that if a screen is located in the project’s <structname>gui</structname> module, you can only work with generalized interfaces of CUBA components. In order to use  <code>WebComponentsHelper.unwrap()</code> you should either put the entire screen into the  <structname>web</structname> module, or use the mechanism of <link linkend="companions">controller companions</link>.</para>
    </section>
    <section id="main_window_layout">
          <title>Main Window Layout</title>
      <para>The mechanism described below allows you to design the application main window layout with CUBA
        Generic UI technology by creating an XML-descriptor and Java controller, and using
        <link linkend="gui_vcl">UI components</link> and <link linkend="datasources">data sources</link>.
      </para>
      <para>The main window is defined by a specific screen with
        <code>mainWindow</code> identifier. Its controller should be derived from the <code>AbstractMainWindow</code>
        class.
      </para>
      <para>The following special components may be used in the main window in addition to the standard UI components:</para>
      <itemizedlist>
        <listitem>
          <para><code>AppMenu</code> - main application menu.</para>
        </listitem>
        <listitem>
          <para><code>FoldersPane</code> - application and search <link linkend="folders_pane">folders panel</link>.</para>
        </listitem>
        <listitem>
          <para>
            <code>AppWorkArea</code> - work area, the required component for opening screens in the
            <code>THIS_TAB</code>, <code>NEW_TAB</code> and <code>NEW_WINDOW</code> modes.
          </para>
        </listitem>
        <listitem>
          <para><code>UserIndicator</code> - the field which displays the name of the current user, as well as enables
            selecting substituted users, if any.</para>
        </listitem>
        <listitem>
          <para><code>NewWindowButton</code> - the button which opens a new main window in a separate browser tab.</para>
        </listitem>
        <listitem>
          <para><code>LogoutButton</code> - the application logout button.</para>
        </listitem>
        <listitem>
          <para><code>TimeZoneIndicator</code> - the label displaying the current user's
            <link linkend="timeZone">time zone</link>.</para>
        </listitem>
        <listitem>
          <para><code>FtsField</code> - the full text search field.</para>
        </listitem>
      </itemizedlist>
      <para>In order to define the special components, add the
        <code>xmlns:main</code> namespace to the screen:
      </para>
      <programlisting language="xml"><xi:include href="../../source/gui/main_window_1.xml" encoding="UTF-8" parse="text"/></programlisting>
      <para>The <code>AppWorkArea</code> component is designed to show application screens.
        If the <link linkend="cuba.web.appWindowMode">cuba.web.appWindowMode</link> application property is
        <code>TABBED</code> (default), the work area shows a TabSheet with open screens. Otherwise a single open screen is shown.
        When no screens are opened, the work area shows components defined in the <code>initialLayout</code> internal
        element:
        <programlisting language="xml"><xi:include href="../../source/gui/main_window_2.xml" encoding="UTF-8" parse="text"/></programlisting>
      </para>
      <para>The initial screen layout (<code>initialLayout</code>) is removed from
        <code>AppWorkArea</code> when the first application screen is opened, and added back when all screens
        are closed. You can add <code>AppWorkArea.StateChangeListener</code> to handle changing the work area between
        the initial layout and application screens. Such listener can, for example, refresh the initial layout data.
      </para>
      <para>The platform includes the standard main window implementation in
        <filename>/com/haulmont/cuba/web/app/mainwindow/mainwindow.xml</filename> XML descriptor and corresponding
        <code>AppMainWindow</code> controller class. The standard implementation can be extended in the project,
        like any other application screen. Example of an extending screen:
        <programlisting language="xml"><xi:include href="../../source/gui/main_window_3.xml" encoding="UTF-8" parse="text"/></programlisting>
        This screen should be registered in <link linkend="screens.xml">screens.xml</link> with the
        <code>mainWindow</code> identifier.
      </para>
      <para>The standard main window implementation may be fully replaced with a custom one. For example:
        <programlisting language="xml"><xi:include href="../../source/gui/main_window_4.xml" encoding="UTF-8" parse="text"/></programlisting>
      </para>
      <para>The resulting main window is shown below:
        <mediaobject><imageobject><imagedata fileref="img/main_window_1.png" align="center"/></imageobject></mediaobject>
      </para>
      <para>The same main window with an open screen:
        <mediaobject><imageobject><imagedata fileref="img/main_window_2.png" align="center"/></imageobject></mediaobject>
      </para>
      <para>The <link linkend="cuba.web.showBreadCrumbs">cuba.web.showBreadCrumbs</link> application property
        allows you to hide the navigation panel (breadcrumbs) above the opened screen.
      </para>
    </section>
  </section>
  <section id="gui_desktop">
    <title>Desktop Client Specifics</title>
    <para>Implementation of the generic user interface in the <structname>Desktop Client</structname>  <link linkend="app_tiers">block</link> is based on   <application>Java Swing</application>. The main classes available in the desktop client infrastructure are described below.<figure>
        <title>Classes of the Desktop Client Infrastructure</title>
        <mediaobject>
          <imageobject>
            <imagedata align="center" fileref="img/DesktopClientInfrastructure.png"/>
          </imageobject>
        </mediaobject>
      </figure></para>
    <itemizedlist>
      <listitem>
        <para><code>App</code> – central class of the desktop application infrastructure. Contains links to   <code>Connection</code> and main <code>TopLevelFrame</code>, as well as methods for initialization and retrieval of application settings. </para>
        <para>In your application, you should create a custom class – inheritor of  <code>App</code> and override the following methods:<itemizedlist>
            <listitem>
              <para><code>getDefaultAppPropertiesConfig()</code> - should return a string where all <link linkend="app_properties_files">application properties files</link> should be listed separated by spaces:<programlisting language="java">@Override
protected String getDefaultAppPropertiesConfig() {
  return &quot;/cuba-desktop-app.properties /desktop-app.properties&quot;;
}</programlisting></para>
            </listitem>
            <listitem>
              <para><code>getDefaultHomeDir()</code> - should return path to the folder, where temporary and work files should be stored. For example:<programlisting language="java">@Override
protected String getDefaultHomeDir() {
  return System.getProperty(&quot;user.home&quot;) + &quot;/.mycompany/sales&quot;;
}</programlisting></para>
            </listitem>
            <listitem>
              <para><code>getDefaultLog4jConfig()</code> -  should return name of the <application>Log4J</application> file, if it is defined for the project. For example<programlisting language="java">@Override
protected String getDefaultLog4jConfig() {
  return &quot;sales-log4j.xml&quot;;
}</programlisting></para>
            </listitem>
          </itemizedlist></para>
        <para>Additionally, for your custom class inheriting from the  <code>App</code> you should define <code>main()</code> method in the following way:<programlisting language="java">public static void main(final String[] args) {
  SwingUtilities.invokeLater(new Runnable() {
      public void run() {
          app = new App();
          app.init(args);
          app.show();
          app.showLoginDialog();
      }
  });
}</programlisting></para>
      </listitem>
      <listitem>
        <para><code>Connection</code> - is a class that provides the functionality of connecting to middleware and storing a <link linkend="userSession">user session</link>. </para>
      </listitem>
      <listitem>
        <para><code>LoginDialog</code> – the dialog to enter credentials. In your application you can create an inheritor of  <code>LoginDialog</code> and redefine the  <code>createLoginDialog()</code> method of the  <code>App</code> class to use it.</para>
      </listitem>
      <listitem>
        <para><code>TopLevelFrame</code> – inheritor of  <code>JFrame</code>, which is the top level window. The application has at least one instance of this class created when application is started and containing the main menu. This instance is returned by the  <code>getMainFrame()</code> method of the  <code>App</code> class.</para>
        <para>When a user detaches tabs from the main window or a  <link linkend="gui_TabSheet">TabSheet</link> (see  <code>detachable</code> attribute), additional instances of  <code>TopLevelFrame</code> that do not contain main menu are created.</para>
      </listitem>
      <listitem>
        <para><code>WindowManager</code> - the central class implementing application screens management logic.  <code>openEditor()</code>, <code>showMessageDialog()</code> and other methods of the  <code>IFrame</code> interface implemented by screen  <link linkend="screen_controller">controllers</link> delegate to the window manager.   <code>WindowManager</code> class is located in the platform’s common  <structname>gui</structname> module and is abstract. The <structname>desktop</structname> desktop module has a dedicated  <code>DesktopWindowManager</code> class that implements desktop client specifics.</para>
        <para>Typically, <code>WindowManager</code> is not used in the application code directly.</para>
      </listitem>
      <listitem>
        <para><code>ExceptionHandlers</code> - contains a collection of  <link linkend="exceptionHandlers">client-level exception handlers</link>.</para>
      </listitem>
    </itemizedlist>
    <section id="desktopComponentsHelper">
      <title>Working with Swing Components </title>
      <para> <code>DesktopComponentsHelper</code> class should be used to work directly with Swing components that implement interfaces of the <link linkend="gui_vcl">visual components library</link> in the <structname>Desktop Client</structname>  <link linkend="app_tiers">block</link>. It has two static methods to retrieve links to Swing components:<itemizedlist>
          <listitem>
            <para><code>unwrap</code> – retrieves a Swing component for a given CUBA component.</para>
          </listitem>
          <listitem>
            <para><code>getComposition</code> - retrieves a Swing component that is the outmost external container in the implementation of a given CUBA component. For simple components, such as   <link linkend="gui_Button">Button</link>,  this method returns the same object as <code>unwrap()</code> - <code>javax.swing.JButton</code>. For complex components, such as  <link linkend="gui_Table">Table</link>, <code>unwrap()</code> will return the corresponding   <code>org.jdesktop.swingx.JXTable</code>  instance, while  <code>getComposition()</code> will return an instance of <code>javax.swing.JPanel</code>, which contains a table together with  <link linkend="gui_ButtonsPanel">ButtonsPanel</link> and <code>RowsCount</code> defined with it.</para>
          </listitem>
        </itemizedlist></para>
      <para>Please note that if a screen is located in the project’s  <structname>gui</structname> module, you can only work with generalized interfaces of CUBA-components. In order to use <code>DesktopComponentsHelper.unwrap()</code> you should either put the entire screen in the <structname>desktop</structname> module, or use the mechanism of  <link linkend="companions">companion controllers</link>.</para>
    </section>
  </section>
  <section id="own_components">
    <title>Creating Custom Components</title>
    <para>This section covers the process of creating and using custom visual components in the application. To begin with, we will take a third  party component available as Vaadin add-on, include it in the project and use it directly in the screen. Then we will perform a tighter integration, by creating a new  <link linkend="gui_framework">GUI</link> interface and an XML loader for the component, which will allow us to use it in the same way as other platform components.  </para>
    <section id="vaadin_addon">
      <title>Using Third-Party Vaadin Components</title>
      <para>You can use third-party Vaadin components, distributed as add-ons, in the Web Client. Currently, the Vaadin library <ulink url="https://vaadin.com/directory">https://vaadin.com/directory</ulink> has over 200 CUBA-compatible visual components. The main requirement for compatibility is  the component’s  support of Vaadin 7+. </para>
      <para>The following should be done to integrate a third-party component into the project:<orderedlist>
          <listitem>
            <para>Add <structname>web-toolkit</structname> module to the project. This module integrates with the client (browser) part of Vaadin components. The easiest way to do this is to run the  <guibutton>Create web toolkit module</guibutton> command on the  <guilabel>Project properties</guilabel> panel of the <link linkend="cubaStudio_install">CUBA Studio</link> navigator.  </para>
          </listitem>
          <listitem>
            <para>Add the add-on dependency to the <structname>web</structname> module in the project’s   <link linkend="build.gradle">build.gradle</link>. For example:<programlisting>configure(webModule) {
  ...
  dependencies {
      ...
      compile(&quot;org.vaadin.addons:some-addon:1.2.3&quot;)
  }</programlisting></para>
          </listitem>
          <listitem>
            <para>Include the add-on widget set to the  <filename>AppWidgetSet.gwt.xml</filename> file, created in Step 1:<programlisting>&lt;module&gt;
  ...
  &lt;inherits name=&quot;org.vaadin.someaddon.widgetset.SomeAddonWidgetset&quot; /&gt;</programlisting></para>
          </listitem>
          <listitem>
            <para>In a  <structname>web</structname> module screen (or in a corresponding  <link linkend="companions">companion</link>), get a link to the Vaadin container using the <link linkend="webComponentsHelper">WebComponentsHelper</link> class, create a new component instance  and add it to the container.
</para>
          </listitem>
          <listitem>
            <para>To change the component’s look, create a  <link linkend="web_theme">theme extension</link> and make the required changes in the <filename>&lt;theme&gt;-ext.scss</filename> file. The easiest way to create a theme file is to run the <guibutton>Create theme extension</guibutton> command on the <guilabel>Project properties</guilabel> panel of the Studio navigator.</para>
          </listitem>
        </orderedlist></para>
      <para><xref linkend="vaadin_addon_sample"/> covers the process of including and using the <application>Stepper</application> add-on, which allows stepping through the values. </para>
    </section>
    <section id="own_gui_component">
      <title>Integration with Generic UI</title>
      <para>Integration of a native component into the generic user interface allows using such component in a large number of screens with little effort,  just like the basic platform components. Full integration requires the following steps:<orderedlist>
          <listitem>
            <para>Create the component interface. Interfaces are usually located in the GUI module, available to both client types – <structname>Web</structname> and <structname>Desktop</structname>. If the component should be implemented for one client type only, it can be placed in the <structname>Web</structname> or <structname>Desktop</structname> module directly. The example below implements the component for <structname>Web Client</structname> only. </para>
            <para>The component interface should be derived from  <code>com.haulmont.cuba.gui.components.Component</code> or any of its inheritors, for example  <code>DatasourceComponent</code> or <code>Field</code>:<programlisting language="java">package com.company.myproject.gui.components;

import com.haulmont.cuba.gui.components.Component;

public interface MyComponent extends Component {

  String NAME = &quot;myComponent&quot;;

  int getSomeParameter();
  void setSomeParameter(int value);
}</programlisting></para>
            <para>It is recommended to define the <code>NAME</code> constant in the interface. The constant should define the name of the component as a string, used for obtaining  the component through the  <code>ComponentsFactory</code>. This is also used as  the name of the component’s XML element in  the XML screen descriptors.</para>
          </listitem>
          <listitem>
            <para>Create the component implementation class in the  <structname>web</structname> module.</para>
            <para>It is recommended to derive the class from <code>com.haulmont.cuba.web.gui.components.WebAbstractComponent</code> or one of its inheritors, for example <code>WebAbstractField</code>. A native component instance should be created in the class constructor, and the GUI interface calls should be delegated to it:<programlisting language="java">package com.company.myproject.web.components;

import com.company.myproject.gui.components.MyComponent;
import com.haulmont.cuba.web.gui.components.WebAbstractComponent;

public class WebMyComponent
      extends WebAbstractComponent&lt;org.vaadin.someaddon.SomeComponent&gt;
      implements MyComponent {

  public WebMyComponent() {
      component = new org.vaadin.someaddon.SomeComponent();
  }

  @Override
  public int getSomeParameter() {
      return component.getSomeParameter();
  }

  @Override
  public void setSomeParameter(boolean value) {
      component.setSomeParameter(value);
  }
}</programlisting></para>
          </listitem>
          <listitem>
            <para>Create a class implementing the  <code>ComponentPalette</code> interface and return a map of custom components and their implementation classes from the  <code>getComponents()</code> method:<programlisting language="java">package com.company.myproject.web;

import com.company.myproject.gui.components.MyComponent;
import com.company.myproject.web.components.WebMyComponent;
import com.haulmont.cuba.gui.ComponentPalette;
import com.haulmont.cuba.gui.components.Component;
import com.haulmont.cuba.gui.xml.layout.ComponentLoader;
import java.util.HashMap;
import java.util.Map;

public class AppComponentPalette implements ComponentPalette {

  @Override
  public Map&lt;String, Class&lt;? extends Component&gt;&gt; getComponents() {
      Map&lt;String, Class&lt;? extends Component&gt;&gt; components = new HashMap&lt;&gt;();
      components.put(MyComponent.NAME, WebMyComponent.class);
      return components;
  }

  @Override
  public Map&lt;String, Class&lt;? extends ComponentLoader&gt;&gt; getLoaders() {
      return Collections.emptyMap();
  }
}</programlisting></para>
            <para>The instance of the component palette must be registered in the application. This can be done in the  <link linkend="gui_web">App</link> class initialization block: <programlisting language="java">package com.company.myproject.web;

import com.haulmont.cuba.web.DefaultApp;
import com.haulmont.cuba.web.gui.WebUIPaletteManager;

public class App extends DefaultApp {

  static {
      WebUIPaletteManager.registerPalettes(new AppComponentPalette());
  }
}</programlisting></para>
          </listitem>
          <listitem>
            <para>At this point, the new GUI component can be retrieved via the <code>ComponentsFactory</code>:<programlisting language="java" lang="">@Inject
private BoxLayout box;
@Inject
private ComponentsFactory componentsFactory;

@Override
public void init(Map&lt;String, Object&gt; params) {
  MyComponent myComponent = componentsFactory.createComponent(MyComponent.NAME);
  box.addComponent(myComponent);
  ...
}</programlisting></para>
          </listitem>
          <listitem>
            <para>In order to support component declaration in screen XML-descriptors, create a component loader class, implementing <code>com.haulmont.cuba.gui.xml.layout.ComponentLoader</code>. It is recommended to derive the loader class from <code>com.haulmont.cuba.gui.xml.layout.loaders.ComponentLoader</code> or any of its inheritors. The loader operates with the component GUI interface only, so it is common for all client types, and can be located in the  <structname>gui</structname> module. The minimal implementation should call the  <code>loadComponent()</code> method, which creates the component instance and sets its common properties, such as ID or size, taken from XML. Any custom component properties can be initialized afterwards:<programlisting language="java">package com.company.myproject.gui.loaders;

import com.company.myproject.gui.components.MyComponent;
import com.haulmont.cuba.gui.components.Component;
import com.haulmont.cuba.gui.xml.layout.*;
import org.dom4j.Element;

public class MyComponentLoader extends ComponentLoader {

  public MyComponentLoader(Context context, LayoutLoaderConfig config, ComponentsFactory factory) {
      super(context, config, factory);
  }

  @Override
  public Component loadComponent(ComponentsFactory factory, Element element, Component parent) {
      MyComponent component = (MyComponent) super.loadComponent(factory, element, parent);

      String someParameter = element.attributeValue(&quot;someParameter&quot;);
      if (someParameter != null) {
          component.setSomeParameter(Integer.valueOf(someParameter));
      }
      return component;
  }
}</programlisting></para>
            <para>The loader must be registered by the  <code>getLoaders()</code> method of the previously created component palette:<programlisting language="java">public class AppComponentPalette implements ComponentPalette {
  ...

  @Override
  public Map&lt;String, Class&lt;? extends ComponentLoader&gt;&gt; getLoaders() {
      Map&lt;String, Class&lt;? extends ComponentLoader&gt;&gt; loaders = new HashMap&lt;&gt;();
      loaders.put(MyComponent.NAME, MyComponentLoader.class);
      return loaders;
  }
}</programlisting></para>
          </listitem>
          <listitem>
            <para>Now the component can be used in XML-descriptors of your project:<programlisting language="xml">&lt;layout&gt;
  &lt;myComponent id=&quot;someId&quot; width=&quot;100%&quot; someParameter=&quot;10&quot;/&gt;
&lt;/layout&gt;</programlisting></para>
            <para>In order to enable autocomplete for component name and attributes in IDE, define your own XSD and include it in the screens:<programlisting language="xml">&lt;window xmlns=&quot;http://schemas.haulmont.com/cuba/5.5/window.xsd&quot;
      xmlns:app=&quot;http://schemas.company.com/app/0.1/app-components.xsd&quot;
      ...&gt;

  &lt;layout&gt;
      &lt;app:myComponent id=&quot;someId&quot; width=&quot;100%&quot; someParameter=&quot;10&quot;/&gt;
  &lt;/layout&gt;</programlisting></para>
          </listitem>
        </orderedlist></para>
      <para><xref linkend="own_gui_component_sample"/> covers the process of integrating the <application>IntStepper</application> component, used for changing integer values incrementally. </para>
    </section>
  </section>
  <section id="shortcuts">
    <title>Keyboard Shortcuts</title>
    <para>This section provides a list of keyboard shortcuts used in the generic user interface of the application. All the  <link linkend="app_properties">application properties</link> listed below belong to the  <code>ClientConfig</code> interface and can be used in Web Client and Desktop Client application blocks. </para>
    <itemizedlist>
      <listitem>
        <para>Main application window.</para>
        <itemizedlist>
          <listitem>
            <para><keycap>CTRL-SHIFT-PAGE_DOWN</keycap> – switch to the next tab. Defined by the  <code>cuba.gui.nextTabShortcut</code> property.</para>
          </listitem>
          <listitem>
            <para><keycap>CTRL-SHIFT-PAGE_UP</keycap> – switch to the previous tab. Defined by the  <code>cuba.gui.previousTabShortcut</code> property.</para>
          </listitem>
        </itemizedlist>
      </listitem>
      <listitem>
        <para>Screens.</para>
        <itemizedlist>
          <listitem>
            <para><keycap>ESCAPE</keycap> – close the current  <link linkend="abstractWindow">screen</link>. Defined by the  <code>cuba.gui.closeShortcut</code> property.</para>
          </listitem>
          <listitem>
            <para><keycap>CTRL-ENTER</keycap> – close the current  <link linkend="abstractEditor">editor</link> and save the changes. Defined by the  <code>cuba.gui.commitShortcut</code> property.</para>
          </listitem>
        </itemizedlist>
      </listitem>
      <listitem>
        <para>Standard actions for list components (<link linkend="gui_Table">Table</link>, <link linkend="gui_GroupTable">GroupTable</link>, <link linkend="gui_TreeTable">TreeTable</link>, <link linkend="gui_Tree">Tree</link>). In addition to these application properties, a shortcut for a particular action can be set by calling it’s <code>setShortcut()</code> method.</para>
        <itemizedlist>
          <listitem>
            <para><keycap>CTRL-INSERT</keycap> – call the  <link linkend="createAction">CreateAction</link>. Defined by the <code>cuba.gui.tableInsertShortcut</code> property. </para>
          </listitem>
          <listitem>
            <para><keycap>CTRL-ALT-INSERT</keycap> – call the <link linkend="addAction">AddAction</link>. Defined by the  <code>cuba.gui.tableAddShortcut</code> property.</para>
          </listitem>
          <listitem>
            <para><keycap>ENTER</keycap> – call the  <link linkend="editAction">EditAction</link>. Defined by the <code>cuba.gui.tableEditShortcut</code> property.</para>
          </listitem>
          <listitem>
            <para><keycap>CTRL-DELETE</keycap> – call the  <link linkend="removeAction">RemoveAction</link> and  <link linkend="excludeAction">ExcludeAction</link>. Defined by the  <code>cuba.gui.tableRemoveShortcut</code> property.</para>
          </listitem>
        </itemizedlist>
      </listitem>
      <listitem>
        <para>Standard actions for lookup fields  (<link linkend="gui_PickerField">PickerField</link>, <link linkend="gui_LookupPickerField">LookupPickerField</link>, <link linkend="gui_SearchPickerField">SearchPickerField</link>). In addition to these application properties, a shortcut for a particular action can be set by calling its  <code>setShortcut()</code> method.</para>
        <itemizedlist>
          <listitem>
            <para><keycap>CTRL-ALT-L</keycap> – call the  <link linkend="lookupAction">LookupAction</link>. Defined by the  <code>cuba.gui.pickerShortcut.lookup</code>.</para>
          </listitem>
          <listitem>
            <para><keycap>CTRL-ALT-O</keycap> – call the  <link linkend="openAction">OpenAction</link>. Defined by the <code>cuba.gui.pickerShortcut.open</code> property.</para>
          </listitem>
          <listitem>
            <para><keycap>CTRL-ALT-C</keycap> – call the <link linkend="clearAction">ClearAction</link>. Defined by the  <code>cuba.gui.pickerShortcut.clear</code> property.</para>
          </listitem>
        </itemizedlist>
        <para>In addition to these shortcuts, lookup fields support action calls with <keycap>CTRL-ALT-1</keycap>, <keycap>CTRL-ALT-2</keycap> and so on, depending on the number of actions. If you click  <keycap>CTRL-ALT-1</keycap> the first action in the list will be called; clicking  <keycap>CTRL-ALT-2</keycap> calls the second action, etc. The  <keycap>CTRL-ALT</keycap> combination can be replaced with any other combination specified in <code>cuba.gui.pickerShortcut.modifiers</code> property.</para>
      </listitem>
      <listitem>
        <para><link linkend="gui_Filter">Filter</link> component.</para>
        <itemizedlist>
          <listitem>
            <para><keycap>SHIFT-BACKSPACE</keycap> – open the filter selection popup. Defined by the <code>cuba.gui.filterSelectShortcut</code> property.</para>
          </listitem>
          <listitem>
            <para><keycap>SHIFT-ENTER</keycap> – apply the selected filter. Defined by the  <code>cuba.gui.filterApplyShortcut</code> property.</para>
          </listitem>
        </itemizedlist>
      </listitem>
    </itemizedlist>
  </section>
</section>
