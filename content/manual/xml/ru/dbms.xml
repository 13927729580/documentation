<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE section PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" []>
<section id="dbms">
  <title>Компоненты работы с базой данных</title>
  <para>В данном разделе приведена информация о возможных типах СУБД приложений на платформе CUBA. Кроме того, описан механизм на основе скриптов, с помощью которого можно создать новую базу данных, и в дальнейшем поддерживать ее в актуальном состоянии на протяжении всего цикла разработки и эксплуатации приложения. </para>
  <para>Компоненты работы с базой данных принадлежат <link linkend="app_tiers">блоку</link> <structname>Middleware</structname>, другие блоки приложения не имеют прямого доступа к БД. </para>
  <para>Дополнительная практическая  информация по работе с базой данных приведена в <xref linkend="db_dev"/> и <xref linkend="db_update_in_prod"/>.</para>
  <section id="dbms_types">
    <title>Типы СУБД</title>
    <para>Тип используемой СУБД определяется свойствами приложения <property>
        <link linkend="cuba.dbmsType">cuba.dbmsType</link>
      </property> и (опционально) <link linkend="cuba.dbmsVersion">cuba.dbmsVersion</link>, а также настройкой источника данных <code>javax.sql.DataSource</code>, через который производится обращение к базе данных. Экземпляр источника данных извлекается из JNDI по имени, заданному в свойстве приложения <property>
        <link linkend="cuba.dataSourceJndiName">cuba.dataSourceJndiName</link>
      </property>. Конфигурационный файл для <application>Tomcat</application>, определяющий источник данных, описан в <xref linkend="context.xml"/></para>
    <para>Платформа &quot;из коробки&quot; поддерживает следующие СУБД:<informaltable frame="all">
        <tgroup cols="3">
          <colspec colname="c1"/>
          <colspec colname="c2"/>
          <colspec colname="c3"/>
          <thead>
            <row>
              <entry/>
              <entry>cuba.dbmsType</entry>
              <entry>cuba.dbmsVersion</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>HSQLDB</entry>
              <entry>hsql</entry>
              <entry/>
            </row>
            <row>
              <entry>PostgreSQL 8.4+</entry>
              <entry>postgres</entry>
              <entry/>
            </row>
            <row>
              <entry>Microsoft SQL Server 2005, 2008</entry>
              <entry>mssql</entry>
              <entry/>
            </row>
            <row>
              <entry>Microsoft SQL Server 2012+</entry>
              <entry>mssql</entry>
              <entry>2012</entry>
            </row>
            <row>
              <entry>Oracle Database 11g</entry>
              <entry>oracle</entry>
              <entry/>
            </row>
          </tbody>
        </tgroup>
      </informaltable></para>
    <para>Таблица ниже описывает рекомендованное соответствие типов данных между атрибутами сущностей в Java и колонками таблиц различных СУБД. Эти типы автоматически выбираются Studio при генерации скриптов создания и обновления БД, и для них гарантируется работоспособность всех механизмов платформы. </para>
    <informaltable frame="all">
      <tgroup cols="5">
        <colspec colnum="1" colname="c0"/>
        <colspec colnum="2" colname="cgen2"/>
        <colspec colnum="3" colname="c1"/>
        <colspec colnum="4" colname="c2"/>
        <colspec colnum="5" colname="cgen1"/>
        <thead>
          <row>
            <entry>Java</entry>
            <entry>HSQL</entry>
            <entry>PostgreSQL</entry>
            <entry>MS SQL Server</entry>
            <entry>Oracle</entry>
          </row>
        </thead>
        <tbody>
          <row>
            <entry>UUID</entry>
            <entry>varchar(36)</entry>
            <entry>uuid</entry>
            <entry>uniqueidentifier</entry>
            <entry>varchar2(32)</entry>
          </row>
          <row>
            <entry>Date</entry>
            <entry>timestamp</entry>
            <entry>timestamp</entry>
            <entry>datetime</entry>
            <entry>timestamp</entry>
          </row>
          <row>
            <entry>java.sql.Date</entry>
            <entry>timestamp</entry>
            <entry>date</entry>
            <entry>datetime</entry>
            <entry>date</entry>
          </row>
          <row>
            <entry>java.sql.Time</entry>
            <entry>timestamp</entry>
            <entry>time</entry>
            <entry>datetime</entry>
            <entry>timestamp</entry>
          </row>
          <row>
            <entry>BigDecimal</entry>
            <entry>decimal(p, s)</entry>
            <entry>decimal(p, s)</entry>
            <entry>decimal(p, s)</entry>
            <entry>number(p, s)</entry>
          </row>
          <row>
            <entry>Double</entry>
            <entry>double precision</entry>
            <entry>double precision</entry>
            <entry>double precision</entry>
            <entry>float</entry>
          </row>
          <row>
            <entry>Long</entry>
            <entry>bigint</entry>
            <entry>bigint</entry>
            <entry>bigint</entry>
            <entry>number(19)</entry>
          </row>
          <row>
            <entry>Integer</entry>
            <entry>integer</entry>
            <entry>integer</entry>
            <entry>integer</entry>
            <entry>integer</entry>
          </row>
          <row>
            <entry>Boolean</entry>
            <entry>boolean</entry>
            <entry>boolean</entry>
            <entry>tinyint</entry>
            <entry>char(1)</entry>
          </row>
          <row>
            <entry>String (limited)</entry>
            <entry>varchar(n)</entry>
            <entry>varchar(n)</entry>
            <entry>varchar(n)</entry>
            <entry>varchar2(n)</entry>
          </row>
          <row>
            <entry>String (unlimited)</entry>
            <entry>longvarchar</entry>
            <entry>text</entry>
            <entry>varchar(max)</entry>
            <entry>clob</entry>
          </row>
          <row>
            <entry>byte[]</entry>
            <entry>longvarbinary</entry>
            <entry>bytea</entry>
            <entry>image</entry>
            <entry>blob</entry>
          </row>
        </tbody>
      </tgroup>
    </informaltable>
    <para>Как правило, всю работу по преобразованию данных между БД и кодом Java выполняет <link linkend="orm">слой ORM</link> совместно с соответствующим JDBC драйвером. Это означает, что при работе с данными через методы <link linkend="entityManager">EntityManager</link> и <link linkend="query">запросы на JPQL</link> никакой ручной конвертации выполнять не нужно - вы просто используете типы Java, перечисленные в левой колонке таблицы.</para>
    <para>При использовании native SQL через <code>EntityManager.<link linkend="nativeQuery">createNativeQuery</link>()</code> или через <code>
        <link linkend="queryRunner">QueryRunner</link>
      </code> для разных типов СУБД некоторые типы данных в Java коде будут отличаться от приведенных. В первую очередь это касается атрибутов типа <code>UUID</code> - только драйвер PostgreSQL возвращает значения соответствующих колонок в этом типе, для других серверов это будет <code>String</code>. Для обеспечения независимости кода от используемой СУБД рекомендуется конвертировать типы параметров и результатов запросов с помощью интерфейса <code>
        <link linkend="dbTypeConverter">DbTypeConverter</link>
      </code>.</para>
    <section id="arbitrary_dbms">
      <title>Поддержка произвольных СУБД</title>
      <para>На уровне прикладного проекта можно реализовать работу с любой СУБД, поддерживаемой фреймворком <link linkend="orm">ORM</link> (OpenJPA). Для этого достаточно выполнить следующее:<itemizedlist>
          <listitem>
            <para>Указать тип СУБД в виде произвольного кода в свойстве <link linkend="cuba.dbmsType">cuba.dbmsType</link>. Код должен отличаться от используемых в платформе кодов <code>hsql</code>, <code>postgres</code>, <code>mssql</code>, <code>oracle</code>.</para>
          </listitem>
          <listitem>
            <para>Реализовать интерфейсы <code>DbmsFeatures</code>, <code>SequenceSupport</code>, <code>DbTypeConverter</code> классами с именами соответственно  <code>TypeDbmsFeatures</code>, <code>TypeSequenceSupport</code>, <code>TypeDbTypeConverter</code>, где <code>Type</code> - код типа СУБД. Пакет класса имплементации должен быть таким же, как у интерфейса.</para>
          </listitem>
          <listitem>
            <para>Если проект включает базовый проект <structname>Workflow</structname>, необходимо переопределить бин <code>CubaJbpmSpringHelper</code> и его метод <code>getHibernateDialectName()</code> для выбора диалекта Hibernate, используемого в jBPM.</para>
          </listitem>
          <listitem>
            <para>Создать скрипты инициализации и обновления БД в каталогах с кодом СУБД. Скрипты инициализации должны включать создание всех объектов БД, необходимых для сущностей платформы (их можно скопировать из имеющихся в каталоге <code>10-cuba</code> и др. скриптов и исправить для данной СУБД).</para>
          </listitem>
          <listitem>
            <para>Для создания и обновления БД задачами Gradle в build.gradle необходимо для этих задач указать дополнительные параметры:<programlisting language="java">task createDb(dependsOn: assemble, type: CubaDbCreation) {
  dbms = &apos;my&apos;                                            // DBMS code
  driver = &apos;net.my.jdbc.Driver&apos;                          // JDBC driver class
  dbUrl = &apos;jdbc:my:myserver://192.168.47.45/mydb&apos;        // Database URL
  masterUrl = &apos;jdbc:my:myserver://192.168.47.45/master&apos;  // URL of a master DB to connect to for creating the application DB
  dropDbSql = &apos;drop database mydb;&apos;                      // Drop database statement
  createDbSql = &apos;create database mydb;&apos;                  // Create database statement
  timeStampType = &apos;datetime&apos;                             // Date and time datatype - needed for SYS_DB_CHANGELOG table creation
  dbUser = &apos;sa&apos;
  dbPassword = &apos;saPass1&apos;
}

task updateDb(dependsOn: assemble, type: CubaDbUpdate) {
  dbms = &apos;my&apos;                                            // DBMS code
  driver = &apos;net.my.jdbc.Driver&apos;                          // JDBC driver class
  dbUrl = &apos;jdbc:my:myserver://192.168.47.45/mydb&apos;        // Database URL
  dbUser = &apos;sa&apos;
  dbPassword = &apos;saPass1&apos;
}</programlisting></para>
          </listitem>
        </itemizedlist></para>
    </section>
    <section id="dbms_version">
      <title>Версия СУБД</title>
      <para>В дополнение к свойству приложения <link linkend="cuba.dbmsType">cuba.dbmsType</link> существует опциональное свойство <link linkend="cuba.dbmsVersion">cuba.dbmsVersion</link>. Оно влияет на выбор имплементаций интерфейсов <code>DbmsFeatures</code>, <code>SequenceSupport</code>, <code>DbTypeConverter</code>, и на поиск скриптов создания и обновления БД.</para>
      <para>Имя класса имплементации интеграционного интерфейса формируется следующим образом: <code>TypeVersionName</code>. Здесь <code>Type</code> - значение <code>cuba.dbmsType</code> с заглавной буквы, <code>Version</code> - значение <code>cuba.dbmsVersion</code>, <code>Name</code> - имя интерфейса. Пакет класса должен быть таким же, как у интерфейса. Если класс с таким именем отсутствует, предпринимается попытка найти класс с именем без версии: <code>TypeName</code>. Если и такого класса нет, выдается исключение.</para>
      <para>Например, в платформе определен класс <code>com.haulmont.cuba.core.sys.persistence.Mssql2012SequenceSupport</code>, который вступит в силу, если в проекте указаны следующие свойства:<programlisting>cuba.dbmsType = mssql
cuba.dbmsVersion = 2012</programlisting></para>
      <para>При поиске <link linkend="db_scripts">скриптов создания и обновления БД</link> каталог с именем <code>type-version</code> имеет приоритет над каталогом с именем <code>type</code>. Это значит, что скрипты каталога <code>type-version</code> заменяют одноименные скрипты каталога <code>type</code>. В каталоге <code>type-version</code> могут быть и скрипты с собственными именами, они будут также добавлены в общий набор скриптов для выполнения. Сортировка скриптов производится по пути начиная с каталога, вложенного в <code>type</code> или <code>type-version</code>, то есть без учета того, в каком каталоге (с версией или без) находится скрипт.</para>
      <para>Например, следующим образом можно определить скрипты создания БД для Microsoft SQL Server для версий ниже и выше 2012:<programlisting>modules/core/db/init/
   mssql/
       10.create-db.sql
       20.create-db.sql
       30.create-db.sql
   mssql-2012/
       10.create-db.sql </programlisting></para>
    </section>
  </section>
  <section id="db_scripts">
    <title>Скрипты создания и обновления БД</title>
    <para>Проект CUBA-приложения всегда содержит два набора  скриптов:<itemizedlist>
        <listitem>
          <para>Скрипты <emphasis>создания</emphasis> БД, предназначенные для создания базы данных с нуля. Они содержат набор DDL и DML операторов, после выполнении которых на пустой БД  схема базы данных полностью соответствует текущему состоянию <link linkend="data_model">модели данных</link> приложения. Скрипты создания могут также наполнять БД необходимыми первичными данными.</para>
        </listitem>
        <listitem>
          <para>Скрипты <emphasis>обновления</emphasis> БД - предназначены для поэтапного приведения структуры БД к текущему состоянию модели данных.</para>
        </listitem>
      </itemizedlist></para>
    <para>При изменении модели данных необходимо отразить соответствующее изменение схемы БД и в скриптах содания, и в скриптах обновления. Например, при добавлении атрибута <code>address</code> в сущность <code>Customer</code>, нужно:<orderedlist>
        <listitem>
          <para>Изменить оператор создания таблицы в скрипте создания:<programlisting>create table SALES_CUSTOMER (
  ID varchar(36) not null ,
  CREATE_TS timestamp,
  CREATED_BY varchar(50),
  --
  NAME varchar(100),
  ADDRESS varchar(200), -- added column
  --
  primary key (ID)
)</programlisting></para>
        </listitem>
        <listitem>
          <para>Добавить скрипт обновления, содержащий оператор модификации таблицы:<programlisting>alter table SALES_CUSTOMER add ADDRESS varchar(200)</programlisting></para>
        </listitem>
      </orderedlist></para>
    <para>Скрипты создания располагаются в каталоге <filename>/db/init</filename> модуля <structname>core</structname>. Для каждого типа СУБД, поддерживаемой приложением, создается свой набор скриптов и располагается в подкаталоге с именем, соответствующим свойству приложения <property>
        <link linkend="cuba.dbmsType">cuba.dbmsType</link>
      </property>, например, <filename>/db/init/postgres</filename>. Имена скриптов создания должны иметь вид <filename>{optional_prefix}create-db.sql</filename>.</para>
    <para>Скрипты обновления располагаются в каталоге <filename>/db/update</filename> модуля <structname>core</structname>. Для каждого типа СУБД, поддерживаемой приложением,  создается свой набор скриптов и располагается в подкаталоге с именем, соответствующим свойству приложения <property>
        <link linkend="cuba.dbmsType">cuba.dbmsType</link>
      </property>, например, <filename>/db/update/postgres</filename>. </para>
    <para>Скрипты обновления могут быть двух типов: с расширением <filename>*.sql</filename> или с расширением <filename>*.groovy</filename>. SQL-скрипты являются основным средством  обновления базы данных. Groovy-скрипты выполняются только <link linkend="db_update_server">механизмом запуска скриптов БД сервером</link>, поэтому применяются в основном на этапе эксплуатации приложения - как правило, это процессы миграции или импорта данных, которые невозможно реализовать на SQL. </para>
    <para>Скрипты обновления должны иметь имена, которые при сортировке в алфавитном порядке образуют правильную последовательность их выполнения (обычно это хронологическая последовательность их создания). Поэтому при ручном создании рекомендуется задавать имя скрипта обновления в виде <filename>{yymmdd}-{description}.sql</filename>, где <literal>yy</literal> - год, <literal>mm</literal> - месяц, <literal>dd</literal> - день, <literal>description</literal> - краткое описание скрипта. Например, <filename>121003-addCodeToCategoryAttribute.sql</filename>. Studio при автоматической генерации скриптов также придерживается этого формата.</para>
    <para>Скрипты обновления можно группировать в подкаталоги, главное, чтобы путь к скрипту с учетом подкаталога не нарушал хронологической последовательности. Например, можно создавать подкаталоги по номеру года или по году и месяцу.</para>
    <para>В развернутом приложении скрипты создания и обновления БД располагаются в специальном <link linkend="db_dir">каталоге скриптов базы данных</link>, задаваемым свойством приложения <property>
        <link linkend="cuba.dbDir">cuba.dbDir</link>
      </property>.</para>
    <section>
      <title>Структура SQL-скриптов</title>
      <para>SQL-скрипты создания и обновления представляют собой текстовые файлы с набором DDL и DML команд, разделенных символом &quot;<literal>^</literal>&quot;. Символ &quot;<literal>^</literal>&quot; применяется для того, чтобы можно было применять разделитель &quot;<literal>;</literal>&quot; в составе сложных команд, например, при создании функций или триггеров. Механизм исполнения скриптов разделяет входной файл на команды по разделителю &quot;<literal>^</literal>&quot; и выполняет  каждую команду в отдельной транзакции. Это означает, что при необходимости можно сгруппировать несколько простых операторов (например, <literal>insert</literal>), разделенных точкой с запятой, и обеспечить их выполнение  в одной транзакции.</para>
      <para>Пример SQL-скрипта обновления:<programlisting>create table LIBRARY_COUNTRY (
  ID varchar(36) not null,
  CREATE_TS time,
  CREATED_BY varchar(50),
  --
  NAME varchar(100) not null,
  --
  primary key (ID)
)^

alter table LIBRARY_TOWN add column COUNTRY_ID varchar(36) ^
alter table LIBRARY_TOWN add constraint FK_LIBRARY_TOWN_COUNTRY_ID foreign key (COUNTRY_ID) references LIBRARY_COUNTRY(ID)^
create index IDX_LIBRARY_TOWN_COUNTRY on LIBRARY_TOWN (COUNTRY_ID)^</programlisting></para>
    </section>
    <section>
      <title>Структура Groovy-скриптов</title>
      <para>Groovy-скрипты обновления  имеют следующую структуру:<itemizedlist>
          <listitem>
            <para><emphasis>Основная</emphasis> часть, содержащая код, выполняемый до старта <link linkend="appContext">контекста приложения</link>. В этой части можно использовать любые классы Java, Groovy и блока <structname>Middleware</structname> приложения, но при этом необходимо иметь в виду, что никакие бины,  интерфейсы инфраструктуры и прочие объекты приложения еще не инстанциированы, и с ними работать нельзя.</para>
            <para>Основная часть предназначена в первую очередь, как и обычные SQL-скрипты,  для обновления схемы данных.</para>
          </listitem>
          <listitem>
            <para><emphasis>PostUpdate</emphasis> часть - набор замыканий, которые будут выполнены после завершения процесса обновления и после старта контекста приложения. Внутри этих замыканий можно оперировать любыми объектами <structname>Middleware</structname> приложения.</para>
            <para>В этой части скрипта удобно, напимер, выполнять импорт данных, так как в ней можно использовать интерфейс <link linkend="persistence">Persistence</link> и объекты модели данных.</para>
          </listitem>
        </itemizedlist></para>
      <para>На вход Groovy-скриптов механизм выполнения передает следующие переменные:<itemizedlist>
          <listitem>
            <para><code>ds</code> - экземпляр <code>javax.sql.DataSource</code> для базы данных приложения.</para>
          </listitem>
          <listitem>
            <para><code>log</code> - экземпляр <code>org.apache.commons.logging.Log</code> для вывода сообщений в журнал сервера</para>
          </listitem>
          <listitem>
            <para><code>postUpdate</code> - объект, содержащий метод <code>add(Closure closure)</code> для добавления замыканий, выполняющихся после старта контекста сервера.</para>
          </listitem>
        </itemizedlist></para>
      <warning>
        <para>Groovy-скрипты выполняются только <link linkend="db_update_server">механизмом запуска скриптов БД сервером</link>.</para>
      </warning>
      <para>Пример Groovy-скрипта обновления:<programlisting language="java">import com.haulmont.cuba.core.Persistence
import com.haulmont.cuba.core.global.AppBeans
import com.haulmont.refapp.core.entity.Colour
import groovy.sql.Sql

log.info(&apos;Executing actions in update phase&apos;)

Sql sql = new Sql(ds)
sql.execute &quot;&quot;&quot;
alter table MY_COLOR add DESCRIPTION varchar(100);
&quot;&quot;&quot;

// Add post update action
postUpdate.add({
  log.info(&apos;Executing post update action using fully functioning server&apos;)

  def p = AppBeans.get(Persistence.class)
  def tr = p.createTransaction()
  try {
      def em = p.getEntityManager()

      Colour c = new Color()
      c.name = &apos;yellow&apos;
      c.description = &apos;a description&apos;

      em.persist(c)
      tr.commit()
  } finally {
      tr.end()
  }
})</programlisting></para>
    </section>
  </section>
  <section id="db_update_gradle">
    <title>Выполнение скриптов БД задачами Gradle</title>
    <para>Данный механизм применяется обычно разработчиками приложения для собственного экземпляра базы данных. Выполнение скриптов в этом случае сводится к запуску специальных задач Gradle, описанных в скрипте сборки <filename>
        <link linkend="build.gradle">build.gradle</link>
      </filename>. Это можно сделать как из командной строки, так и с помощью интерфейса Studio.</para>
    <para>Для запуска скриптов <emphasis>создания</emphasis> БД служит задача <code>createDb</code>. В Studio ей соответствует команда главного меню <guimenu>Run</guimenu> -&gt; <guimenu>Create database</guimenu>. При запуске задачи происходит следующее:<orderedlist>
        <listitem>
          <para>В каталоге <filename>modules/core/build/db</filename> собираются скрипты <link linkend="base_projects">базовых проектов</link> платформы и скрипты <filename>db/**/*.sql</filename> модуля <structname>core</structname> текущего проекта. Наборы скриптов базовых проектов располагаются в подкаталогах с числовыми префиксами начиная с 10, скрипты текущего проекта - в подкаталоге с префиксом 50. Числовые префиксы необходимы для соблюдения алфавитного порядка выполнения скриптов - сначала выполняются скрипты <structname>cuba</structname>, затем других базовых проектов, затем текущего проекта.</para>
        </listitem>
        <listitem>
          <para>Если БД существует, она полностью очищается. Если не существует, то создается новая пустая БД.</para>
        </listitem>
        <listitem>
          <para>Последовательно в алфавитном порядке выполняются все скрипты создания <filename>modules/core/build/db/init/**/*create-db.sql</filename>, и их имена вместе с путем относительно каталога <filename>db</filename> регистрируются в таблице <database>SYS_DB_CHANGELOG</database>.</para>
        </listitem>
        <listitem>
          <para>В таблице <database>SYS_DB_CHANGELOG</database> аналогично регистрируются все имеющиеся на данный момент скрипты обновления <filename>modules/core/build/db/update/**/*.sql</filename>. Это необходимо для будущего инкрементального обновления БД новыми скриптами. </para>
        </listitem>
      </orderedlist></para>
    <para>Для запуска скриптов <emphasis>обновления</emphasis> БД служит задача <code>updateDb</code>. В Studio ей соответствует команда главного меню <guimenu>Run</guimenu> -&gt; <guimenu>Update database</guimenu>. При запуске задачи происходит следующее:<orderedlist>
        <listitem>
          <para>Производится сборка скриптов аналогично описанному выше.</para>
        </listitem>
        <listitem>
          <para>В каталогах <filename>modules/core/build/db/update/**</filename> производится поиск скриптов обновления, не зарегистрированных в таблице <database>SYS_DB_CHANGELOG</database>, то есть не выполненных ранее и содержимое которых не отражено в БД при ее инициализации.</para>
        </listitem>
        <listitem>
          <para>Последовательно в алфавитном порядке выполняются все найденные на предыдущем шаге скрипты, и их имена вместе с путем относительно каталога <filename>db</filename> регистрируются в таблице <database>SYS_DB_CHANGELOG</database>. </para>
        </listitem>
      </orderedlist></para>
  </section>
  <section id="db_update_server">
    <title>Выполнение скриптов БД сервером</title>
    <para>Механизм выполнения скриптов  сервером предназначен для приведения БД в актуальное состояние на старте сервера приложения, и активируется во время инициализации  блока <structname>Middleware</structname>. Понятно, что при этом приложение должно быть собрано и развернуто на сервере, будь то собственный  Tomcat разработчика или сервер в режиме эксплуатации.</para>
    <para>Данный механизм в зависимости от описанных ниже условий выполняет либо скрипты создания, либо скрипты обновления, то есть он может и инициализировать БД с нуля, и обновлять ее. Однако, в отличие от описанной в предыдущем разделе задачи Gradle <code>createDb</code>, для выполнения инициализации базы она должна существовать - сервер не создает БД автоматически, а только прогоняет на ней скрипты.</para>
    <para>Механизм выполнения скриптов сервером действует следующим образом:<itemizedlist>
        <listitem>
          <para>Скрипты извлекаются из <link linkend="db_dir">каталога скриптов базы данных</link>, определяемого свойством приложения <link linkend="cuba.dbDir">
              <property>cuba.dbDir</property>
            </link>. В стандартном варианте развертывания в Tomcat это  <filename>tomcat/webapps/app-core/WEB-INF/db</filename>.</para>
        </listitem>
        <listitem>
          <para>Если в БД отсутствует таблица <database>SEC_USER</database>, то считается, что база данных пуста, и запускается полная инициализация с помощью скриптов создания БД. После выполнения инициализирующих скриптов их имена запоминаются в таблице <database>SYS_DB_CHANGELOG</database>. Кроме того, там же сохраняются имена всех доступных скриптов обновления, <emphasis>без их выполнения</emphasis>.</para>
        </listitem>
        <listitem>
          <para>Если в БД имеется таблица <database>SEC_USER</database>, но отсутствует таблица <database>SYS_DB_CHANGELOG</database> (это случай, когда в первый раз запускается описываемый механизм на имеющейся рабочей БД), никакие скрипты <emphasis>не запускаются</emphasis>. Вместо этого создается таблица <database>SYS_DB_CHANGELOG</database> и в ней сохраняются имена всех доступных на данный момент скриптов создания и обновления. </para>
        </listitem>
        <listitem>
          <para>Если в БД имеются и таблица <database>SEC_USER</database> и таблица <database>SYS_DB_CHANGELOG</database>, то производится запуск скриптов обновления, и их имена запоминаются в таблице <database>SYS_DB_CHANGELOG</database>. Причем запускаются только те скрипты, имен которых до этого не было в таблице <database>SYS_DB_CHANGELOG</database>, т.е. не запускавшиеся ранее.
Последовательность запуска скриптов определяется 2-мя факторами: приоритетом базового проекта (см. содержимое <link linkend="db_dir">каталога скриптов базы данных</link>: <filename>10-cuba</filename>, <filename>20-workflow</filename>, ...) и именем файла скрипта (с учетом подкаталогов внутри каталога <filename>update</filename>) в алфавитном порядке.</para>
        </listitem>
      </itemizedlist></para>
    <para>Механизм выполнения скриптов на старте сервера  включается свойством приложения <property>
        <link linkend="cuba.automaticDatabaseUpdate">cuba.automaticDatabaseUpdate</link>
      </property>.</para>
    <para>В запущенном приложении механизм выполнения скриптов можно стартовать с помощью  JMX-бина <code>app-core.cuba:type=PersistenceManager</code>, вызвав его метод <code>updateDatabase()</code> с параметром <userinput>update</userinput>. Понятно, что таким способом можно только обновить БД, а не проинициализировать новую, так как войти в систему для запуска метода JMX-бина при пустой БД невозможно. При этом следует иметь в виду, что если на старте <structname>Middleware</structname> или при входе пользователя в систему начнется инициализация той части модели данных, которая уже не соответствует устаревшей схеме БД, то произойдет ошибка, и продолжение работы станет невозможным. Именно поэтому универсальным является только автоматическое обновление БД на старте сервера перед инициализацией модели данных.</para>
    <para>JMX-бин <code>app-core.cuba:type=PersistenceManager</code> имеет еще один метод, относящийся к механизму обновления БД: <code>findUpdateDatabaseScripts()</code>. Он возвращает список новых скриптов обновления, имеющихся в каталоге и не зарегистрированных в БД.</para>
    <para>Практические рекомендации по использованию механизма  обновления БД сервером приведены в <xref linkend="db_update_in_prod"/>.</para>
  </section>
</section>
