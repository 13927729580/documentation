<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE section PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" []>
<section id="gui_framework" xmlns:xi="http://www.w3.org/2001/XInclude">
  <title>Универсальный пользовательский интерфейс</title>
  <para>Подсистема универсального пользовательского интерфейса (Generic UI, GUI) позволяет разрабатывать экраны пользовательского интерфейса, используя  XML и Java. Созданные таким образом экраны одинаково работоспособны в двух
стандартных клиентских <link linkend="app_tiers">блоках</link>: <structname>Web Client</structname> и <structname>Desktop Client</structname>. </para>
  <figure>
    <title>Структура универсального пользовательского интерфейса </title>
    <mediaobject>
      <imageobject>
        <imagedata align="center" fileref="img/ClientStructure.png"/>
      </imageobject>
    </mediaobject>
  </figure>
  <para>Здесь в центре изображены основные составляющие  экранов универсального пользовательского интерфейса:<itemizedlist>
      <listitem>
        <para><link linkend="screen_xml">XML-дескрипторы</link> - файлы XML, содержащие информацию об источниках данных и компоновке
экрана</para>
      </listitem>
      <listitem>
        <para><link linkend="screen_controller">Контроллеры</link> - классы Java, содержащие логику инициализации экрана
и обработки событий от элементов пользовательского интерфейса.</para>
      </listitem>
    </itemizedlist></para>
  <para>Код экранов приложения, расположенный в <link linkend="app_modules">модуле</link> <structname>gui</structname>,  взаимодействует с интерфейсами визуальных
компонентов (VCL Interfaces), реализованными по-отдельности в модулях <structname>web</structname>  и <structname>desktop</structname> <link linkend="base_projects">базового проекта</link> <structname>cuba</structname>. Для <structname>Web Client</structname> реализация основана на фреймворке <application>Vaadin</application>, для <structname>Desktop Client</structname> – на фреймворке <application>Java Swing</application>.</para>
  <para><link linkend="gui_vcl">Библиотека визуальных компонентов</link> (Visual Components Library, VCL)
содержит большой набор готовых компонентов для отображения данных.</para>
  <para>Механизм <link linkend="datasources">источников данных</link>  (Datasources) предоставляет унифицированный
интерфейс, обеспечивающий
функционирование
связанных
с
данными визуальных компонентов.</para>
  <para>Инфраструктура клиента  (Infrastructure) включает в себя главное окно приложения,
механизмы отображения и взаимодействия  экранов UI, а также средства
взаимодействия со средним слоем.</para>
  <section id="screens">
    <title>Экраны</title>
    <para>Экран универсального пользовательского интерфейса состоит из <link linkend="screen_xml">XML-дескриптора</link> и класса <link linkend="screen_controller">контроллера</link>. Дескриптор содержит ссылку на класс контроллера. </para>
    <para>Для того чтобы экран можно было вызывать из главного меню или из Java кода (например, из контроллера другого экрана), XML-дескриптор должен быть зарегистрирован в файле <link linkend="screens.xml">
        <filename>screens.xml</filename>
      </link> проекта.</para>
    <para>Главное меню приложения формируется отдельно для <structname>Web Client</structname> и <structname>Desktop Client</structname> на основе файлов <filename>
        <link linkend="menu.xml">menu.xml</link>
      </filename>, расположенных соответственно в модулях <structname>web</structname> и <structname>desktop</structname> проекта.</para>
    <section>
      <title>Типы экранов</title>
      <para>В данном разделе рассматриваются основные типы экранов:<itemizedlist>
          <listitem>
            <para><link linkend="frame">Фрейм</link></para>
          </listitem>
          <listitem>
            <para><link linkend="screen_simple">Простой экран</link></para>
          </listitem>
          <listitem>
            <para><link linkend="screen_lookup">Экран выбора</link></para>
          </listitem>
          <listitem>
            <para><link linkend="screen_edit">Экран редактирования</link></para>
          </listitem>
        </itemizedlist></para>
      <section id="frame">
        <title>Фрейм</title>
        <para>Фреймы представляют собой части экранов, которые применяются для декомпозиции и многократного использования.</para>
        <para>Для подключения фрейма в XML экрана используется элемент <link linkend="gui_IFrame">
            <sgmltag>iframe</sgmltag>
          </link> c указанием либо пути к файлу XML фрейма, либо идентификатора фрейма, если он зарегистрирован в  <link linkend="screens.xml">
            <filename>screens.xml</filename>
          </link>.</para>
        <para>Контроллер фрейма должен быть унаследован от класса <link linkend="abstractFrame">AbstractFrame</link>.</para>
        <para>Правила взаимодействия экрана и вложенного в него фрейма:</para>
        <itemizedlist>
          <listitem>
            <para>Из экрана обращаться к компонентам фрейма можно через точку: <code>frame_id.component_id</code></para>
          </listitem>
          <listitem>
            <para>Из контроллера фрейма получить компонент экрана  можно обычным вызовом <code>getComponent(component_id)</code>, но только в том случае, если компонент с таким именем не объявлен в самом фрейме. То есть компоненты фрейма маскируют компоненты экрана.</para>
          </listitem>
          <listitem>
            <para>Из фрейма получить <link linkend="datasources">источник данных</link> экрана можно простым вызовом <code>getDsContext().get(ds_id)</code> или <link linkend="screen_controller_injection">инжекцией</link>, либо в <link linkend="datasource_query">запросе</link> <code>ds$ds_id</code>, но только в том случае, если источник данных с таким именем не объявлен в самом фрейме (аналогично компонентам).</para>
          </listitem>
          <listitem>
            <para>Из экрана получить источник данных фрейма можно только через итерацию по <code>getDsContext().getChildren()</code></para>
          </listitem>
        </itemizedlist>
        <para>При коммите экрана вызывается также коммит измененных источников  данных фрейма.</para>
      </section>
      <section id="screen_simple">
        <title>Простой экран</title>
        <para>Простой экран предназначен для отображения и редактирования произвольной информации, в том числе отдельных экземпляров и списков сущностей. Данный тип экрана имеет только базовую функциональность, позволяющую отобразить его в главном окне системы, закрыть, а также работать с <link linkend="datasources">источниками данных</link>.</para>
        <para>Идентификатор экрана в файле <link linkend="screens.xml">
            <filename>screens.xml</filename>
          </link> может быть произвольного вида.</para>
        <para>Контроллер простого экрана должен быть унаследован от класса <link linkend="abstractWindow">AbstractWindow</link>. </para>
      </section>
      <section id="screen_lookup">
        <title>Экран выбора</title>
        <para>Экран выбора (lookup) отличается от простого экрана тем, что при вызове методом <code>openLookup()</code> отображает внизу панель с кнопками, позволяющими передать вызывающему коду экземпляр выбранной в данный момент в списке сущности. При вызове методом <code>openWindow()</code> или, например, из главного меню, панель с кнопками выбора не отображается.</para>
        <para>В метод <code>openLookup()</code> передается объект с интерфейсом <code>Window.Lookup.Handler</code>. Метод <code>handleLookup()</code> этого объекта вызывается экраном, и ему передается коллекция выбранных пользователем экземпляров сущности. Тем самым вызывающий код получает из экрана выбранные экземпляры. </para>
        <para>Экраны  выбора рекомендуется использовать для отображения списков сущностей. Визуальные компоненты, предназначенные для отображения и редактирования ссылок между сущностями (такие как <code>
            <link linkend="gui_PickerField">PickerField</link>
          </code>, <code>
            <link linkend="gui_LookupPickerField">LookupPickerField</link>
          </code>, <code>
            <link linkend="gui_SearchPickerField">SearchPickerField</link>
          </code>), вызывают экраны выбора для поиска связанных сущностей. </para>
        <para>Для корректной работы <link linkend="standard_actions">стандартных действий</link> идентификатор экрана выбора  в файле <link linkend="screens.xml">
            <filename>screens.xml</filename>
          </link> должен иметь вид <literal>{имя_сущности}.lookup</literal>, например, <literal>sales$Customer.lookup</literal>.</para>
        <para>Контроллер экрана выбора должен быть унаследован от класса <link linkend="abstractLookup">AbstractLookup</link>. В XML экрана в атрибуте <sgmltag>lookupComponent</sgmltag> должен быть указан компонент (например, <code>
            <link linkend="gui_Table">Table</link>
          </code>), из которого будет взят экземпляр сущности при выборе.</para>
      </section>
      <section id="screen_edit">
        <title>Экран редактирования</title>
        <para>Экран редактирования предназначен для отображения и редактирования  экземпляра сущности. Поддерживает функциональность установки редактируемого экземпляра и <link linkend="gui_Action">действия</link> по  коммиту изменений в базу данных. Экран редактирования должен вызываться методом <code>openEditor()</code> с передачей экземпляра сущности.</para>
        <para>Для корректной работы <link linkend="standard_actions">стандартных действий</link> идентификатор экрана редактирования в файле <link linkend="screens.xml">
            <filename>screens.xml</filename>
          </link> должен иметь вид <literal>{имя_сущности}.edit</literal>, например, <literal>sales$Customer.edit</literal>.</para>
        <para>Контроллер экрана редактирования  должен быть унаследован от класса <link linkend="abstractEditor">AbstractEditor</link>. В XML экрана в атрибуте <sgmltag>datasource</sgmltag> указывается источник данных, в который проставляется редактируемый экземпляр сущности. Для отображения действий, выполняющих коммит или отмену изменений, в XML можно использовать следующие стандартные фреймы с кнопками:<itemizedlist>
            <listitem>
              <para><literal>editWindowActions</literal> (файл <filename>com/haulmont/cuba/gui/edit-window.actions.xml</filename>) - содержит кнопки <guibutton>OK</guibutton> и <guibutton>Cancel</guibutton></para>
            </listitem>
            <listitem>
              <para><literal>extendedEditWindowActions</literal> (файл <filename>com/haulmont/cuba/gui/extended-edit-window.actions.xml</filename>) - содержит кнопки <guibutton>OK &amp; Close</guibutton>, <guibutton>OK</guibutton> и <guibutton>Cancel</guibutton></para>
            </listitem>
          </itemizedlist></para>
        <para>В экране редактирования неявно создаются следующие действия:<itemizedlist>
            <listitem>
              <para><literal>windowCommitAndClose</literal> (соответствует константе <code>Window.Editor.WINDOW_COMMIT_AND_CLOSE</code>) - действие, выполняющее коммит изменений в базу данных и закрывающее экран. Создается  при наличии в экране визуального компонента с идентификатором <literal>windowCommitAndClose</literal>, в частности, при использовании вышеописанного стандартного фрейма <literal>extendedEditWindowActions</literal> отображается кнопкой <guibutton>OK &amp; Close</guibutton>.</para>
            </listitem>
            <listitem>
              <para><literal>windowCommit</literal> (соответствует константе <code>Window.Editor.WINDOW_COMMIT</code>) - действие, выполняющее коммит изменений в базу данных. При отсутствии действия <literal>windowCommitAndClose</literal> после коммита закрывает экран. Создается всегда, и при наличии в экране  вышеописанных стандартных фреймов отображается кнопкой <guibutton>OK</guibutton>.</para>
            </listitem>
            <listitem>
              <para><literal>windowClose</literal> (соответствует константе <code>Window.Editor.WINDOW_CLOSE</code>) - действие, закрывающее экран без коммита изменений. Создается всегда, и при наличии в экране  вышеописанных стандартных фреймов отображается кнопкой <guibutton>Cancel</guibutton>.</para>
            </listitem>
          </itemizedlist></para>
        <para>Таким образом, если  в экран добавлен фрейм <literal>editWindowActions</literal>, то кнопка <guibutton>OK</guibutton> коммитит изменения и закрывает экран, а кнопка <guibutton>Cancel</guibutton> - закрывает без коммита. Если же добавлен фрейм <literal>extendedEditWindowActions</literal>, то кнопка <guibutton>OK</guibutton> только коммитит изменения, оставляя экран открытым, кнопка <guibutton>OK &amp; Close</guibutton> коммитит и закрывает экран, кнопка <guibutton>Cancel</guibutton> - закрывает без коммита.</para>
        <para>Вместо стандартных фреймов для отображения действий можно использовать произвольные компоненты, например, <code>
            <link linkend="gui_LinkButton">LinkButton</link>
          </code>.</para>
      </section>
    </section>
    <section id="screen_xml">
      <title>XML-дескриптор</title>
      <para>XML-дескриптор - это файл формата XML, описывающий <link linkend="datasources">источники данных</link> и расположение визуальных компонентов экрана.</para>
      <para>Схема XML доступна по адресу <ulink url="http://schemas.haulmont.com/cuba/5.5/window.xsd">http://schemas.haulmont.com/cuba/5.5/window.xsd</ulink></para>
      <para>Рассмотрим структуру дескриптора.</para>
      <para><sgmltag>window</sgmltag> − корневой элемент.</para>
      <para>Атрибуты <sgmltag>window</sgmltag>:<itemizedlist>
          <listitem>
            <para><property>
                <sgmltag>class</sgmltag>
              </property> − имя класса <link linkend="screen_controller">контроллера</link></para>
          </listitem>
          <listitem>
            <para><sgmltag>messagesPack</sgmltag> −  <link linkend="message_packs">пакет сообщений</link> данного экрана, который будет использован при получении локализованных строк  без указания  пакета из XML-дескриптора и из контроллера методом <code>getMessage()</code></para>
          </listitem>
          <listitem>
            <para><sgmltag>caption</sgmltag> − заголовок экрана, может содержать <link linkend="messageTools.loadString">ссылку на сообщение</link> из вышеуказанного пакета, например, <programlisting>caption=&quot;msg://caption&quot;</programlisting></para>
          </listitem>
          <listitem>
            <para><sgmltag>focusComponent</sgmltag> − идентификатор компонента, который получит фокус ввода при отображении экрана</para>
          </listitem>
          <listitem>
            <para><sgmltag>lookupComponent</sgmltag> - обязательный для <link linkend="screen_lookup">экрана выбора</link> атрибут, задающий идентификатор визуального компонента, из которого будет выбран экземпляр сущности. Поддерживаются компоненты следующих типов (и их наследников):<itemizedlist>
                <listitem>
                  <para><code>Table</code></para>
                </listitem>
                <listitem>
                  <para><code>Tree</code></para>
                </listitem>
                <listitem>
                  <para><code>LookupField</code></para>
                </listitem>
                <listitem>
                  <para><code>PickerField</code></para>
                </listitem>
                <listitem>
                  <para><code>OptionsGroup</code></para>
                </listitem>
              </itemizedlist></para>
          </listitem>
          <listitem>
            <para><sgmltag>datasource</sgmltag> - обязательный для <link linkend="screen_edit">экрана редактирования</link> атрибут, задающий идентификатор <link linkend="datasources">источника данных</link>, в который будет проставлен экземпляр редактируемой сущности.</para>
          </listitem>
        </itemizedlist></para>
      <para>Элементы <sgmltag>window</sgmltag>:<itemizedlist>
          <listitem>
            <para><sgmltag>metadataContext</sgmltag> −  элемент для инициализации <link linkend="views">представлений</link> (views), необходимых данному экрану. Предпочтительным является определение всех представлений в одном общем файле <filename>
                <link linkend="views.xml">views.xml</link>
              </filename>, так как все описатели представлений разворачиваются в один общий репозиторий, и при рассредоточении описателей по разным файлам трудно обеспечить уникальность имен.</para>
          </listitem>
          <listitem>
            <para><sgmltag>dsContext</sgmltag> −  определяет <link linkend="datasources">источники данных</link> данного экрана.</para>
          </listitem>
          <listitem>
            <para><sgmltag>actions</sgmltag> -  определяет список <link linkend="gui_Action">действий</link> данного экрана.</para>
          </listitem>
          <listitem>
            <para><sgmltag>timers</sgmltag> -  определяет список таймеров данного экрана.</para>
          </listitem>
          <listitem>
            <para><sgmltag>companions</sgmltag> -  определяет список классов-<link linkend="companions">компаньонов</link> данного контроллера</para>
            <para>Элементы <sgmltag>companions</sgmltag>:<itemizedlist>
                <listitem>
                  <para><sgmltag>web</sgmltag> - задает компаньон, реализованный в модуле <structname>web</structname></para>
                </listitem>
                <listitem>
                  <para><sgmltag>desktop</sgmltag> - задает компаньон, реализованный в модуле <structname>desktop</structname></para>
                </listitem>
              </itemizedlist></para>
            <para>Каждый из этих элементов содержит атрибут <sgmltag>class</sgmltag>, задающий класс компаньона.</para>
          </listitem>
          <listitem>
            <para><sgmltag>layout</sgmltag> − корневой элемент компоновки экрана. Является сам по себе контейнером с вертикальным расположением компонентов, аналогичным <link linkend="gui_BoxLayout">
                <sgmltag>vbox</sgmltag>
              </link>.</para>
            <para>Атрибуты <sgmltag>layout</sgmltag>:<itemizedlist>
                <listitem>
                  <para><link linkend="gui_attr_basic_spacing">
                      <sgmltag>spacing</sgmltag>
                    </link></para>
                </listitem>
                <listitem>
                  <para><link linkend="gui_attr_basic_margin">
                      <sgmltag>margin</sgmltag>
                    </link></para>
                </listitem>
                <listitem>
                  <para><link linkend="gui_attr_basic_expand">
                      <sgmltag>expand</sgmltag>
                    </link></para>
                </listitem>
                <listitem>
                  <para><link linkend="gui_attr_basic_stylename">
                      <sgmltag>stylename</sgmltag>
                    </link></para>
                </listitem>
                <listitem>
                  <para><link linkend="gui_attr_basic_height">
                      <sgmltag>height</sgmltag>
                    </link></para>
                </listitem>
                <listitem>
                  <para><link linkend="gui_attr_basic_width">
                      <sgmltag>width</sgmltag>
                    </link></para>
                </listitem>
              </itemizedlist></para>
          </listitem>
        </itemizedlist></para>
    </section>
    <section id="screen_controller">
      <title>Контроллер экрана</title>
      <para>Контроллер экрана - это <code>Java</code> или <code>Groovy</code> класс, связанный с <link linkend="screen_xml">XML-дескриптором</link>, и содержащий логику инициализации и обработки событий экрана.</para>
      <para>Контроллер должен быть унаследован от одного из следующих базовых классов:</para>
      <itemizedlist>
        <listitem>
          <para><code>
              <link linkend="abstractFrame">AbstractFrame</link>
            </code> − предназначен для реализации <link linkend="frame">фреймов</link>.</para>
        </listitem>
        <listitem>
          <para><code>
              <link linkend="abstractWindow">AbstractWindow</link>
            </code> − предназначен для реализации <link linkend="screen_simple">простых экранов</link>.</para>
        </listitem>
        <listitem>
          <para><code>
              <link linkend="abstractLookup">AbstractLookup</link>
            </code> − предназначен для реализации <link linkend="screen_lookup">экранов выбора</link>.</para>
        </listitem>
        <listitem>
          <para><code>
              <link linkend="abstractEditor">AbstractEditor</link>
            </code> − предназначен для реализации <link linkend="screen_edit">экранов редактирования</link>.</para>
        </listitem>
      </itemizedlist>
      <tip>
        <para>Если экрану не нужна никакая дополнительная логика, то в качестве контроллера можно использовать сам базовый класс <code>AbstractWindow</code>, <code>AbstractLookup</code> или <code>AbstractEditor</code>, указав его в XML-дескрипторе (эти классы на самом деле не являются абстрактными в смысле невозможности создания экземпляров). Для фрейма класс контроллера можно не указывать вообще.</para>
      </tip>
      <para>Класс контроллера должен быть зарегистрирован в XML-дескрипторе экрана в атрибуте <sgmltag>class</sgmltag> корневого элемента <sgmltag>window</sgmltag>.</para>
      <figure>
        <title>Базовые классы контроллеров</title>
        <mediaobject>
          <imageobject>
            <imagedata align="center" fileref="img/Controllers.png"/>
          </imageobject>
        </mediaobject>
      </figure>
      <section id="abstractFrame">
        <title>AbstractFrame</title>
        <para><code>AbstractFrame</code> является корнем иерархии классов контроллеров. Рассмотрим его основные методы:</para>
        <itemizedlist>
          <listitem id="abstractFrame.init">
            <para><code>init()</code> - вызывается фреймворком после создания всего дерева компонентов, описанного XML-дескриптором, но до отображения экрана.</para>
            <para>В метод <methodname>init()</methodname> из вызывающего кода передается мэп параметров, которые могут быть использованы  внутри контроллера. Эти параметры могут быть переданы как из кода контроллера вызывающего экрана (в методе <code>openWindow()</code>, <code>openLookup()</code> или <code>openEditor()</code>), так и установлены в файле регистрации экранов <filename>
                <link linkend="screens.xml">screens.xml</link>
              </filename>.</para>
            <para>Метод <code>init()</code> следует имплементировать при необходимости  инициализации компонентов экрана, например:<programlisting language="java">@Inject
private Table someTable;

@Override
public void init(Map&lt;String, Object&gt; params) {
  someTable.addGeneratedColumn(&quot;someColumn&quot;, new Table.ColumnGenerator&lt;Colour&gt;() {
      @Override
      public Component generateCell(Colour entity) {
          ...
      }
  });
}</programlisting></para>
          </listitem>
          <listitem>
            <para><code>getMessage()</code>, <code>formatMessage()</code> - методы получения локализованных сообщений из <link linkend="message_packs">пакета</link>, заданного для экрана в XML-дескрипторе. Представляют собой просто короткие варианты вызова одноименных методов интерфейса <code>
                <link linkend="messages">Messages</link>
              </code>.</para>
          </listitem>
          <listitem>
            <para><code>getDialogParams()</code> - получить объект <code>DialogParams</code> для установки параметров отображения диалоговых окон (высота, ширина и пр.). Значения, установленные в этом объекте, влияют на следующий экран, открываемый в режиме модального диалога (<code>WindowManager.OpenType.DIALOG</code>). После отображения диалога они сбрасываются в значения по умолчанию.</para>
            <para>Таким образом,  устанавливать значения в <code>DialogParams</code> необходимо непосредственно перед вызовом другого экрана в режиме диалога методами <code>openWindow()</code>, <code>openLookup()</code>, <code>openEditor()</code>. Например:<programlisting language="java">getDialogParams().setWidth(400);
openEditor(&quot;sales$Customer.edit&quot;, customer, WindowManager.OpenType.DIALOG);</programlisting></para>
            <para>Если же сам текущий экран открывается в режиме модального диалога, то можно управлять параметрами его отображения, устанавливая параметры <code>DialogParams</code>  в его методе <code>init()</code>. При этом установленные в <code>init()</code> параметры имеют приоритет над установленными в вызывающем коде.</para>
          </listitem>
          <listitem>
            <para><code>openFrame()</code> - загрузить фрейм по идентификатору, зарегистрированному в <filename>
                <link linkend="screens.xml">screens.xml</link>
              </filename>, и, если в метод передан компонент-контейнер, отобразить его внутри контейнера. Возвращается контроллер фрейма. Например:<programlisting language="java">@Inject
private BoxLayout container;

@Override
public void init(Map&lt;String, Object&gt; params) {
  SomeFrame frame = openFrame(container, &quot;someFrame&quot;);
  frame.setHeight(&quot;100%&quot;);
  frame.someInitMethod();
}</programlisting></para>
            <para>Контейнер не обязательно сразу передавать в метод <code>openFrame()</code>, вместо этого можно загрузить фрейм, а затем добавить его  в нужный контейнер:<programlisting language="java">@Inject
private BoxLayout container;

@Override
public void init(Map&lt;String, Object&gt; params) {
  SomeFrame frame = openFrame(null, &quot;someFrame&quot;);
  frame.setHeight(&quot;100%&quot;);
  frame.someInitMethod();
  container.add(frame);
}</programlisting></para>
          </listitem>
          <listitem>
            <para><code>openWindow()</code>, <code>openLookup()</code>, <code>openEditor()</code> - открыть соответственно простой экран, экран выбора или редактирования. Методы возвращают контроллер созданного экрана.</para>
            <para>Для выполнения действий после закрытия вызываемого экрана необходимо добавить слушатель типа <code>CloseListener</code>, например:<programlisting language="java">CustomerEdit editor = openEditor(&quot;sales$Customer.edit&quot;, customer, WindowManager.OpenType.THIS_TAB);
editor.addListener(new CloseListener() {
  @Override
  public void windowClosed(String actionId) {
      // do something
  }
});</programlisting></para>
          </listitem>
          <listitem>
            <para><code>showMessageDialog()</code> - отобразить диалоговое окно с сообщением.</para>
          </listitem>
          <listitem>
            <para><code>showOptionDialog()</code> - отобразить диалоговое окно с сообщением и возможностью выбора пользователем некоторых действий. Действия задаются массивом объектов типа <code>
                <link linkend="gui_Action">Action</link>
              </code>, которые в диалоге отображаются посредством соответствующих кнопок.</para>
            <para>Для отображения стандартных кнопок типа <guibutton>OK</guibutton>, <guibutton>Cancel</guibutton> и других рекомендуется использовать объекты типа <code>DialogAction</code>, например:<programlisting language="java">showOptionDialog(&quot;PLease confirm&quot;, &quot;Are you sure?&quot;,
      MessageType.CONFIRMATION,
      new Action[] {
              new DialogAction(DialogAction.Type.YES) {
                  @Override
                  public void actionPerform(Component component) {
                      // do something
                  }
              },
              new DialogAction(DialogAction.Type.NO);
      });</programlisting></para>
          </listitem>
          <listitem>
            <para><code>showNotification()</code> - отобразить всплывающее окно с сообщением.</para>
          </listitem>
          <listitem>
            <para><code>showWebPage()</code> - открыть указанную веб-страницу в браузере.</para>
          </listitem>
        </itemizedlist>
      </section>
      <section id="abstractWindow">
        <title>AbstractWindow</title>
        <para><code>AbstractWindow</code> является наследником <code>
            <link linkend="abstractFrame">AbstractFrame</link>
          </code>, и определяет следующие собственные методы:</para>
        <itemizedlist>
          <listitem id="abstractWindow.ready">
            <para><code>ready()</code> - шаблонный метод, который можно имплементировать в контроллере для перехвата момента открытия экрана. Метод <code>ready()</code> вызывается фреймворком после метода <link linkend="abstractFrame.init">init()</link> непосредственно перед показом экрана в главном окне приложения.</para>
          </listitem>
          <listitem>
            <para><code>validateAll()</code> - валидация экрана. Реализация по умолчанию вызывает метод <code>validate()</code> у всех компонентов экрана, реализующих интерфейс <code>Component.Validatable</code>, накапливает информацию об исключениях, и если таковые имеются, выводит соответствующее сообщение и возвращает <code>false</code>, иначе возвращает <code>true</code>.</para>
            <para>Данный метод следует переопределять только в том случае, если необходимо полностью заменить стандартную процедуру валидации экрана. Если же нужно только дополнить ее, достаточно определить специальный шаблонный метод <code>postValidate()</code>.</para>
          </listitem>
          <listitem>
            <para><code>postValidate()</code> - шаблонный метод, который можно имплементировать в контроллере для дополнительной валидации экрана. Получаемый методом объект <code>ValidationErrors</code> используется для добавления информации об ошибках валидации, которая будет отображена совместно с ошибками стандартной валидации. Например:<programlisting language="java">private Pattern pattern = Pattern.compile(&quot;\\d&quot;);

@Override
protected void postValidate(ValidationErrors errors) {
  if (getItem().getAddress().getCity() != null) {
      if (pattern.matcher(getItem().getAddress().getCity()).find()) {
          errors.add(&quot;City name can&apos;t contain digits&quot;);
      }
  }
}</programlisting></para>
          </listitem>
          <listitem>
            <para><code>close()</code> - закрыть данный экран. </para>
            <para>Метод принимает строковое значение, передаваемое далее  в шаблонный метод <code>preClose()</code> и слушателям <code>CloseListener</code>. Таким образом, заинтересованный код может получить информацию о причине закрытия экрана от кода, инициирующего закрытие. В частности, в экранах редактирования сущностей при закрытии экрана после коммита изменений рекомендуется использовать константу <code>Window.COMMIT_ACTION_ID</code>, без коммита изменений - константу <code>Window.CLOSE_ACTION_ID</code>.</para>
            <para>Если какой-либо из источников данных содержит несохраненные изменения, перед закрытием экрана будет выдано диалоговое окно с соответствующим предупреждением. Тип предупреждения можно выбрать с помощью свойства приложения <property>
                <link linkend="cuba.gui.useSaveConfirmation">cuba.gui.useSaveConfirmation</link>
              </property>.</para>
            <para>Вариант  метода <code>close()</code> с параметром <code>force = true</code> закрывает экран без вызова <code>preClose()</code> и без предупреждения, независимо от наличия несохраненных изменений.</para>
            <para>Метод <code>close()</code> возвращает <code>true</code>, если экран был успешно закрыт, и <code>false</code> - если закрытие было прервано.</para>
          </listitem>
          <listitem>
            <para><code>preClose()</code> - шаблонный метод, который можно имплементировать в контроллере для перехвата момента закрытия экрана. Метод получает строковое значение, указанное инициатором закрытия при вызове метода <code>close()</code>.</para>
            <para>Если метод <code>preClose()</code> возвращает <code>false</code>, то процесс закрытия экрана прерывается.</para>
          </listitem>
        </itemizedlist>
      </section>
      <section id="abstractLookup">
        <title>AbstractLookup</title>
        <para><code>AbstractLookup</code> базовый класс контроллеров <link linkend="screen_lookup">экранов выбора</link>, является наследником <code>
            <link linkend="abstractWindow">AbstractWindow</link>
          </code>, и определяет следующие собственные методы:</para>
        <itemizedlist>
          <listitem>
            <para><code>setLookupComponent()</code> - установить компонент, из которого будет производиться выбор экземпляров сущности. </para>
            <para>Как правило,  компонент выбора устанавливается в XML-дескрипторе экрана, и вызывать данный метод в прикладном коде нет необходимости.</para>
          </listitem>
          <listitem>
            <para><code>setLookupValidator()</code> - установить для экрана объект типа <code>Window.Lookup.Validator</code>, метод <code>validate()</code> которого вызывается фреймворком перед тем как вернуть выбранные экземпляры сущностей. Если <code>validate()</code> возвращает <code>false</code>, процесс выбора и закрытия экрана прерывается.</para>
            <para>По умолчанию валидатор не установлен.</para>
          </listitem>
        </itemizedlist>
      </section>
      <section id="abstractEditor">
        <title>AbstractEditor</title>
        <para><code>AbstractEditor</code> − базовый класс контроллеров <link linkend="screen_edit">экранов редактирования</link>, является наследником <code>
            <link linkend="abstractWindow">AbstractWindow</link>
          </code>.</para>
        <para>При создании конкретного класса контроллера рекомендуется параметризовать <code>AbstractEditor</code> типом редактируемой сущности. При этом методы <code>getItem()</code> и <code>initItem()</code> будут работать с конкретным типом сущности и прикладному коду не потребуется дополнительных приведений типов. Например:</para>
        <programlisting language="java">public class CustomerEdit extends AbstractEditor&lt;Customer&gt; {

  @Override
  protected void initItem(Customer item) {
  ...</programlisting>
        <para><code>AbstractEditor</code> определяет следующие собственные методы:</para>
        <itemizedlist>
          <listitem>
            <para><code>getItem()</code> - возвращает экземпляр редактируемой сущности, установленный в главном источнике данных экрана (т.е. указанном в атрибуте <sgmltag>datasource</sgmltag> корневого элемента XML-дескриптора).</para>
            <para>Если редактируется не новый экземпляр, то в момент открытия экрана он перезагружается из базы данных с необходимым <link linkend="views">представлением</link>, указанным для главного источника данных. </para>
            <para>Изменения, вносимые в экземпляр, возвращаемый <code>getItem()</code>,  отражаются на состоянии источника данных, и будут отправлены на <structname>Middleware</structname> при коммите экрана.</para>
            <warning>
              <para>Следует иметь в виду, что <code>getItem()</code> возвращает значение только после инициализации экрана методом <code>setItem()</code>. До этого момента, например, в методах <code>init()</code> и <code>initItem()</code>, данный метод возвращает <code>null</code>.</para>
              <para>Однако в методе <code>init()</code> экземпляр сущности, переданный в <code>openEditor()</code>, можно получить из  параметров следующим образом:<programlisting language="java">@Override
public void init(Map&lt;String, Object&gt; params) {
  Customer item = WindowParams.ITEM.getEntity(params);
  // do something
}</programlisting></para>
              <para>В метод <code>initItem()</code> экземпляр передается явно и нужного типа.</para>
              <para>В обоих случаях полученный экземпляр сущности, если он не новый, будет впоследствии перезагружен, и вносить в него изменения или сохранять в поле для последующего использования не имеет смысла.</para>
            </warning>
          </listitem>
          <listitem>
            <para><code>setItem()</code> - вызывается фреймворком при открытии экрана методом <code>openEditor()</code> для установки редактируемого экземпляра сущности в главном источнике данных. В момент вызова   созданы все компоненты и источники данных экрана, и отработал метод <code>init()</code> контроллера.</para>
            <para>Для инициализации экрана редактирования вместо переопределения <code> setItem()</code> рекомендуется имплементировать специальные шаблонные методы <code>initItem()</code> и <code>postInit()</code>.</para>
          </listitem>
          <listitem id="initNewItem">
            <para><code>initNewItem()</code> - шаблонный метод, вызываемый фреймворком перед установкой редактируемого экземпляра сущности в главном источнике данных.</para>
            <tip>
              <para>Метод <code>initNewItem()</code> вызывается только для нового, только что созданного экземпляра сущности. Если редактируется <link linkend="entity_states">detached</link> экземпляр, метод не вызывается.</para>
            </tip>
            <para>Данный метод можно имплементировать в контроллере при необходимости инициализации нового экземпляра сущности перед его установкой в источник данных, например:<programlisting language="java">@Inject
private UserSession userSession;

@Override
protected void initNewItem(Complaint item) {
  item.setOpenedBy(userSession.getUser());
  item.setStatus(ComplaintStatus.OPENED);
}</programlisting></para>
            <para>Более сложный пример использования <code>initNewItem()</code> приведен в разделе <link linkend="init_values_in_initNewItem">рецептов разработки</link>.</para>
          </listitem>
          <listitem>
            <para><code>postInit()</code> - шаблонный метод, вызываемый фреймворком сразу после  установки редактируемого экземпляра сущности в главном источнике данных. Во время выполнения данного метода можно вызывать <code>getItem()</code>, который будет возвращать новый или перезагруженный при инициализации экрана  экземпляр сущности.</para>
            <para>Данный метод можно имплементировать в контроллере для окончательной инициализации экрана, например:<programlisting language="java">@Inject
protected EntityDiffViewer diffFrame;

@Override
protected void postInit() {
  if (!PersistenceHelper.isNew(getItem())) {
      diffFrame.loadVersions(getItem());
  }
}</programlisting></para>
          </listitem>
          <listitem>
            <para><code>commit()</code> - валидировать экран и отправить изменения через <code>
                <link linkend="dataSupplier">DataSupplier</link>
              </code> на <structname>Middleware</structname>.</para>
            <para>Если используется вариант метода с параметром <code>validate = false</code>, то валидация перед коммитом не производится.</para>
            <para>Данный метод не рекомендуется переопределять, лучше использовать специальные шаблонные методы <code>postValidate()</code>, <code>preCommit()</code> и <code>postCommit()</code>.</para>
          </listitem>
          <listitem>
            <para><code>commitAndClose()</code> - валидировать экран, отправить изменения  на <structname>Middleware</structname> и закрыть экран. В метод <code>preClose()</code> и зарегистрированным слушателям <code>CloseListener</code> будет передано значение константы <code>Window.COMMIT_ACTION_ID</code>.</para>
            <para>Данный метод не рекомендуется переопределять, лучше использовать специальные шаблонные методы <code>postValidate()</code>, <code>preCommit()</code> и <code>postCommit()</code>.</para>
          </listitem>
          <listitem>
            <para><code>preCommit()</code> - шаблонный метод, вызываемый фреймворком в процессе коммита изменений, после того как валидация завершена успешно и перед отправкой данных на <structname>Middleware</structname>.</para>
            <para>Данный метод можно имплементировать в контроллере. Если метод возвращает <code>false</code>, процесс коммита (и закрытия экрана, если был вызван <code>commitAndClose()</code>), прерывается. Например:<programlisting language="java">@Override
protected boolean preCommit() {
  if (somethingWentWrong) {
      showNotification(&quot;Something went wrong&quot;, NotificationType.WARNING);
      return false;
  }
  return true;
}</programlisting></para>
          </listitem>
          <listitem>
            <para><code>postCommit()</code> - шаблонный метод, вызываемый фреймворком на финальной стадии коммита изменений. Параметры метода:<itemizedlist>
                <listitem>
                  <para><code>committed</code> - установлен в <code>true</code>, если в экране действительно были изменения, и они отправлены на <structname>Middleware</structname>;</para>
                </listitem>
                <listitem>
                  <para><code>close</code> - установлен в <code>true</code>, если экран после коммита будет закрыт.</para>
                </listitem>
              </itemizedlist></para>
            <para>Реализация метода по умолчанию, если экран не закрывается, отображает сообщение об успешном коммите изменений и вызывает метод <code>postInit()</code>.</para>
            <para>Данный метод можно переопределить в контроллере для выполнения некоторых действий после успешного коммита, например:<programlisting language="java">@Inject
private Datasource&lt;Driver&gt; driverDs;
@Inject
private EntitySnapshotService entitySnapshotService;

@Override
protected boolean postCommit(boolean committed, boolean close) {
  if (committed) {
      entitySnapshotService.createSnapshot(driverDs.getItem(), driverDs.getView());
  }
  return super.postCommit(committed, close);
}</programlisting></para>
          </listitem>
        </itemizedlist>
        <para>Далее приведены диаграммы последовательностей инициализации и различных вариантов коммита экрана редактирования.</para>
        <figure>
          <title>Инициализация экрана редактирования</title>
          <mediaobject>
            <imageobject>
              <imagedata align="center" fileref="img/EditorInit.png"/>
            </imageobject>
          </mediaobject>
        </figure>
        <figure>
          <title>Коммит и закрытие экрана с фреймом editWindowActions</title>
          <mediaobject>
            <imageobject>
              <imagedata align="center" fileref="img/EditorCommit.png" contentwidth="900"/>
            </imageobject>
          </mediaobject>
        </figure>
        <figure>
          <title>Коммит экрана с фреймом extendedEditWindowActions</title>
          <mediaobject>
            <imageobject>
              <imagedata align="center" fileref="img/ExtendedEditorCommit.png"/>
            </imageobject>
          </mediaobject>
        </figure>
        <figure>
          <title>Коммит и закрытие экрана с фреймом extendedEditWindowActions</title>
          <mediaobject>
            <imageobject>
              <imagedata align="center" fileref="img/ExtendedEditorCommitAndClose.png" contentwidth="900"/>
            </imageobject>
          </mediaobject>
        </figure>
      </section>
      <section id="screen_controller_injection">
        <title>Инжекция зависимостей контроллеров</title>
        <para>В контроллерах можно использовать Dependency Injection для получения ссылок на используемые объекты. Для этого нужно объявить либо поле соответствующего типа, либо метод доступа на запись (setter) с соответствующим типом результата, и добавить ему одну из следующих аннотаций:<itemizedlist>
            <listitem>
              <para><code>@Inject</code> - простейший вариант, поиск объекта для инжекции будет произведен по типу поля/метода и по имени, эквивалентному имени поля либо имени атрибута (по правилам JavaBeans) для метода</para>
            </listitem>
            <listitem>
              <para><code>@Named(&quot;someName&quot;)</code> - вариант с явным указанием имени искомого объекта</para>
            </listitem>
          </itemizedlist></para>
        <para>Инжектировать в контроллеры можно следующие объекты: <itemizedlist>
            <listitem>
              <para>Визуальные компоненты данного экрана, определенные в XML-дескрипторе. Если тип атрибута унаследован от <code>Component</code>, в текущем экране будет произведен поиск компонента с соответствующим именем. </para>
            </listitem>
            <listitem>
              <para>Действия, определенные в XML-дескрипторе - см. <xref linkend="gui_Action"/></para>
            </listitem>
            <listitem>
              <para><link linkend="datasources">Источники данных</link>, определенные в XML-дескрипторе. Если тип атрибута унаследован от <code>Datasource</code>, в текущем экране будет произведен поиск источника данных с соответствующим именем. </para>
            </listitem>
            <listitem>
              <para><code>UserSession</code>. Если тип атрибута - <code>
                  <link linkend="userSession">UserSession</link>
                </code>, будет инжектирован объект текущей пользовательской сессии. </para>
            </listitem>
            <listitem>
              <para><code>DsContext</code>. Если тип атрибута - <code>DsContext</code>, будет инжектирован <code>DsContext</code> текущего экрана. </para>
            </listitem>
            <listitem>
              <para><code>WindowContext</code>. Если тип атрибута - <code>WindowContext</code>, будет инжектирован <code>WindowContext</code> текущего экрана. </para>
            </listitem>
            <listitem>
              <para><code>DataSupplier</code>. Если тип атрибута - <code>
                  <link linkend="dataSupplier">DataSupplier</link>
                </code>, будет инжектирован соответствующий экземпляр. </para>
            </listitem>
            <listitem>
              <para>Любой бин, определенный в контексте данного клиентского блока приложения, в том числе:<itemizedlist>
                  <listitem>
                    <para>импортируемые клиентом <link linkend="services">сервисы</link> <structname>Middleware</structname></para>
                  </listitem>
                  <listitem>
                    <para><link linkend="config_interfaces">конфигурационные интерфейсы</link></para>
                  </listitem>
                  <listitem>
                    <para><code>ComponentsFactory</code></para>
                  </listitem>
                  <listitem>
                    <para><code>WindowConfig</code></para>
                  </listitem>
                  <listitem>
                    <para><code>ExportDisplay</code></para>
                  </listitem>
                  <listitem>
                    <para><code>
                        <link linkend="background_tasks">BackgroundWorker</link>
                      </code></para>
                  </listitem>
                </itemizedlist></para>
            </listitem>
            <listitem>
              <para>Если ничего из вышеперечисленного не подошло и контроллер имеет <link linkend="companions">компаньонов</link>, в случае совпадения типов будет инжектирован компаньон для текущего типа клиента.</para>
            </listitem>
          </itemizedlist></para>
        <para>С помощью специальной аннотации <code>@WindowParam</code> можно инжектировать в контроллер параметры, передаваемые в мэп  метода <code>init()</code>. Аннотация имеет атрибут <code>name</code>, в котором указывается имя параметра (ключ в мэп), и опциональный атрибут <code>required</code>. Если <code>required = true</code>, то при отсутствии в мэп соответствующего параметра в лог выводится сообщение с уровнем <code>WARNING</code>. </para>
        <para>Пример инжекции объекта типа <code>Job</code>, передаваемого в метод <code>init()</code> контроллера:<programlisting language="java">@WindowParam(name = &quot;job&quot;, required = true)
protected Job job;</programlisting></para>
      </section>
      <section id="companions">
        <title>Компаньоны контроллеров</title>
        <para>Базовые классы контроллеров расположены в <link linkend="app_modules">модуле</link> <structname>gui</structname> <link linkend="base_projects">базового проекта</link> <structname>cuba</structname> и не содержат ссылок на классы реализации визуальных компонентов (<application>Swing</application> или <application>Vaadin</application>), что дает возможность использовать их в клиентах обоих типов. Вместо этого базовые классы контроллеров реализуют дополнительный интерфейс <code>Window.Wrapper</code> и делегируют выполнение &quot;обернутому&quot; окну. </para>
        <para>В то же время конкретные классы контроллеров могут быть расположены как в модуле <structname>gui</structname>, так и в <structname>web</structname> или <structname>desktop</structname>, в зависимости от применяемых в проекте клиентских <link linkend="app_tiers">блоков</link> и специфики экрана. Если контроллер является универсальным, но для разных типов клиента требуется дополнительная функциональность, ее можно определить в так называемых <firstterm>классах-компаньонах</firstterm>. </para>
        <para>Класс-компаньон располагается в модуле клиента соответствующего типа (<structname>web</structname> или <structname>desktop</structname>) и реализует интерфейс, задаваемый в использующем его контроллере. Класс компаньона задается в элементе <sgmltag>companions</sgmltag> XML-дескриптора экрана. Контроллер может получить ссылку на экземпляр компаньона с помощью инжекции или вызовом <code>getCompanion()</code>, и в нужный момент передать ему управление, например, для дополнительной инициализации визуальных компонентов специфичным для данного типа клиента способом. </para>
        <para>Например, необходимо раздельно для веб и десктоп клиентов проинициализировать таблицу некоторого экрана. Тогда в контроллере экрана, расположенном в модуле <structname>gui</structname>,  определяем интерфейс компаньона и делегируем ему инициализацию таблицы:<programlisting language="java">public class CustomerBrowse extends AbstractLookup {

  public interface Companion {
      void initTable(Table table);
  }

  @Inject
  protected Table table;

  @Inject
  protected Companion companion;

  @Override
  public void init(Map&lt;String, Object&gt; params) {
      if (companion != null) {
          companion.initTable(table);
      }
  }
}</programlisting></para>
        <para>В модулях <structname>web</structname> и <structname>desktop</structname> создаем соответствующие классы реализации компаньона:<programlisting language="java">public class WebCustomerBrowseCompanion implements CustomerBrowse.Companion {
  @Override
  public void initTable(Table table) {
      com.vaadin.ui.Table webTable = (com.vaadin.ui.Table) WebComponentsHelper.unwrap(table);
      // do something specific to Vaadin table
  }
}</programlisting><programlisting language="java">public class DesktopCustomerBrowseCompanion implements CustomerBrowse.Companion {
  @Override
  public void initTable(Table table) {
      javax.swing.JTable desktopTable = (javax.swing.JTable) DesktopComponentsHelper.unwrap(table);
      // do something specific to Swing table
  }
}</programlisting></para>
        <para>И регистрируем классы реализации компаньона в XML-дескрипторе экрана:<programlisting language="xml">&lt;window ...
      class=&quot;com.company.sample.gui.customers.CustomerBrowse&quot;&gt;
  &lt;companions&gt;
      &lt;web class=&quot;com.company.sample.web.customers.WebCustomerBrowseCompanion&quot;/&gt;
      &lt;desktop class=&quot;com.company.sample.desktop.customers.DesktopCustomerBrowseCompanion&quot;/&gt;
  &lt;/companions&gt;
  &lt;dsContext&gt;...&lt;/dsContext&gt;
  &lt;layout&gt;...&lt;/layout&gt;
&lt;/window&gt;</programlisting></para>
        <para>Так как классы-компаньоны расположены в <structname>web</structname> и <structname>desktop</structname> модулях, в них можно использовать метод <code>unwrap()</code> классов <link linkend="webComponentsHelper">WebComponentsHelper</link> и <link linkend="desktopComponentsHelper">DesktopComponentsHelper</link> для извлечения из интерфейса <link linkend="gui_Table">Table</link> ссылок на реализующие таблицу Vaadin и Swing компоненты, и работать  с ними непосредственно.</para>
      </section>
    </section>
  </section>
  <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="gui_vcl.xml" encoding="UTF-8"/>
  <section id="datasources">
    <title>Источники данных</title>
    <para>Источники данных обеспечивают работу связанных с данными (data-aware) компонентов.</para>
    <para>Визуальные компоненты сами не обращаются к <structname>Middleware</structname>, а получают экземпляры сущностей  из связанных источников данных. При этом один источник данных может обслуживать несколько визуальных компонентов, если им нужен один и тот же экземпляр или набор экземпляров.</para>
    <para>Связь визуального компонента и источника данных проявляется в следующем:<itemizedlist>
        <listitem>
          <para>При изменении пользователем значения в компоненте новое значение проставляется в атрибуте сущности, находящейся в источнике.</para>
        </listitem>
        <listitem>
          <para>При изменении атрибута сущности из кода новое значение проставляется и отображается в визуальном компоненте. </para>
        </listitem>
        <listitem>
          <para>Для слежения за вводом пользователя можно использовать как <link linkend="datasource_listeners">слушатель источника данных</link>, так и слушатель значения визуального компонента - они срабатывают друг за другом. </para>
        </listitem>
        <listitem>
          <para>При необходимости прочитать или записать значение атрибута сущности в коде предпочтительнее использовать источник данных, а не компонент. Рассмотрим пример чтения атрибута:<programlisting language="java">@Inject
private FieldGroup fieldGroup;
@Inject
private Datasource&lt;Order&gt; orderDs;

public void init(Map&lt;String, Object&gt; params) {
  Customer customer;
  // Get customer from component
  customer = (Customer) fieldGroup.getFieldValue(&quot;customer&quot;);
  // Get customer from datasource
  customer = orderDs.getItem().getCustomer();
}</programlisting></para>
          <para>Как видно из примера, работа со значениями атрибутов сущностей через компонент требует приведения типа и, в случае <link linkend="gui_FieldGroup">FieldGroup</link>, указания имени атрибута в виде строки. В то же время, получив методом <code>getItem()</code> из источника данных хранящийся в нем экземпляр, можно напрямую читать и изменять значения его атрибутов.</para>
        </listitem>
      </itemizedlist><warning>
        <para>Как правило, визуальный компонент привязывается к атрибуту, непосредственно принадлежащему сущности, находящейся в источнике данных. В приведенном выше примере компонент привязан к атрибуту <code>customer</code> сущности <code>Order</code>. </para>
        <para>Можно также привязать компонент к атрибуту связанной сущности, например к <code>customer.name</code>. В этом случае компонент будет корректно отображать значение атрибута <code>name</code>, но при его изменении пользователем слушатели источника данных вызваны не будут, и изменения не будут сохранены. Поэтому привязывать компонент к атрибутам второго и более порядка имеет смысл только для отображения, например в <link linkend="gui_Label">Label</link>, колонке <link linkend="gui_Table">Table</link> или установив для <link linkend="gui_TextField">TextField</link> свойство <code>editable = false</code>.</para>
      </warning></para>
    <para>Источники данных также отслеживают изменения содержащихся в них сущностей, и могут отправлять измененные экземпляры обратно на <structname>Middleware</structname> для сохранения в базе данных.</para>
    <para>Рассмотрим основные интерфейсы источников.</para>
    <figure>
      <title>Интерфейсы источников данных</title>
      <mediaobject>
        <imageobject>
          <imagedata align="center" fileref="img/Datasources.png"/>
        </imageobject>
      </mediaobject>
    </figure>
    <itemizedlist>
      <listitem>
        <para><code>Datasource</code> − простейший источник данных, предназначенный для работы с одним экземпляром сущности. Экземпляр устанавливается методом <code>setItem()</code> и  доступен через <code>getItem()</code>. </para>
        <para>Стандартной реализацией такого источника является класс <code>DatasourceImpl</code>, который используется, например, как главный источник данных в <link linkend="screen_edit">экранах редактирования</link> сущностей.</para>
      </listitem>
      <listitem>
        <para><code>CollectionDatasource</code> − источник данных, предназначенный для работы с коллекцией экземпляров сущности. Коллекция загружается при вызове метода <code>refresh()</code>, ключи экземпляров доступны через метод <code>getItemIds()</code>. Метод <code>setItem()</code> устанавливает, а <code>getItem()</code> возвращает  &quot;текущий&quot; экземпляр коллекции, т.е., например, соответствующий выбранной в данный момент строке таблицы.</para>
        <para>Способ загрузки коллекции сущностей определяется реализацией. Наиболее типичный - загрузка с
            Middleware через <link linkend="dataManager">DataManager</link>, при этом для формирования JPQL запроса
            используются методы <code>setQuery()</code>, <code>setQueryFilter()</code>.</para>
        <para>Стандартной реализацией такого источника является класс <code>CollectionDatasourceImpl</code>, который используется в экранах, отображающих списки сущностей.</para>
        <itemizedlist>
          <listitem>
            <para><code>GroupDatasource</code> − подвид <code>CollectionDatasource</code>, предназначенный для работы с компонентом <code>
                <link linkend="gui_GroupTable">GroupTable</link>
              </code>.</para>
            <para>Стандартной реализацией является класс <code>GroupDatasourceImpl</code>.</para>
          </listitem>
          <listitem>
            <para><code>HierarchicalDatasource</code> − подвид <code>CollectionDatasource</code>, предназначенный для работы с компонентами <code>
                <link linkend="gui_Tree">Tree</link>
              </code> и  <code>
                <link linkend="gui_TreeTable">TreeTable</link>
              </code>.</para>
            <para>Стандартной реализацией является класс <code>HierarchicalDatasourceImpl</code>.</para>
          </listitem>
        </itemizedlist>
      </listitem>
      <listitem>
        <para><code>NestedDatasource</code> - источник данных, предназначенный для работы с экземплярами, загруженными в атрибуте другой сущности. При этом источник, содержащий сущность-хозяина, доступен методом <code>getMaster()</code>, а <link linkend="metaProperty">мета-свойство</link>, соответствующее атрибуту хозяина, содержащему экземпляры данного источника, доступно через метод <code>getProperty()</code>.</para>
        <para>Например,  в источнике <code>dsOrder</code> установлен экземпляр сущности <code>Order</code>, содержащий ссылку на экземпляр <code>Customer</code>. Тогда для связи экземпляра <code>Customer</code> с визуальными компонентами достаточно создать <code>NestedDatasource</code>, у которого хозяином является <code>dsOrder</code>, а мета-свойство указывает на атрибут <code>Order.customer</code>.</para>
        <itemizedlist>
          <listitem>
            <para><code>PropertyDatasource</code> - подвид <code>NestedDatasource</code>, предназначенный для работы с одним экземпляром или коллекцией связанных сущностей, не являющихся встроенными (embedded).</para>
            <para>Стандартные реализации: для работы с одним экземпляром - <code>PropertyDatasourceImpl</code>, для работы с коллекцией - <code>CollectionPropertyDatasourceImpl</code>, <code>GroupPropertyDatasourceImpl</code>, <code>HierarchicalPropertyDatasourceImpl</code>. Последние реализуют также интерфейс <code>CollectionDatasource</code>, однако некоторые его нерелевантные методы, связанные с загрузкой, например, <code>setQuery()</code>, выбрасывают <code>UnsupportedOperationException</code>.</para>
          </listitem>
          <listitem>
            <para><code>EmbeddedDatasource</code> - подвид <code>NestedDatasource</code>, содержащий экземпляр встроенной сущности.</para>
            <para>Стандартной реализацией является класс <code>EmbeddedDatasourceImpl</code>.</para>
          </listitem>
        </itemizedlist>
      </listitem>
      <listitem>
        <para><code>RuntimePropsDatasource</code> − специфический источник, предназначенный для работы с <link linkend="dynamic_attributes">динамическими атрибутами</link> сущностей.</para>
      </listitem>
    </itemizedlist>
    <para>Как правило, источники данных объявляются декларативно в секции <sgmltag>dsContext</sgmltag> <link linkend="screen_xml">дескриптора экрана</link>.</para>
    <section>
      <title>Создание источников данных</title>
      <para>Объекты источников данных могут быть созданы как декларативно - путем объявления в XML-дескрипторе экрана, так и программно в контроллере. Обычно используются стандартные реализации интерфейсов источников, однако при необходимости можно создать собственный класс, унаследовав его от стандартного.</para>
      <section>
        <title>Декларативное создание</title>
        <para>Как правило, источники данных объявляются декларативно в элементе <sgmltag>dsContext</sgmltag> дескриптора экрана. В зависимости от взаимного расположения элементов объявлений создаются источники двух разновидностей:<itemizedlist>
            <listitem>
              <para>если элемент расположен непосредственно в <sgmltag>dsContext</sgmltag>, создается обычный <code>Datasource</code> или <code>CollectionDatasource</code>, который содержит независимо загруженную сущность или коллекцию;</para>
            </listitem>
            <listitem>
              <para>если элемент расположен внутри элемента другого источника, создается <code>NestedDatasource</code>, при этом  внешний источник становится его хозяином. </para>
            </listitem>
          </itemizedlist></para>
        <para>Пример объявления источников данных:<programlisting language="xml">&lt;dsContext&gt;
  &lt;datasource id=&quot;carDs&quot; class=&quot;com.haulmont.sample.entity.Car&quot; view=&quot;carEdit&quot;&gt;
      &lt;collectionDatasource id=&quot;allocationsDs&quot; property=&quot;driverAllocations&quot;/&gt;
      &lt;collectionDatasource id=&quot;repairsDs&quot; property=&quot;repairs&quot;/&gt;
  &lt;/datasource&gt;

  &lt;collectionDatasource id=&quot;colorsDs&quot; class=&quot;com.haulmont.sample.entity.Color&quot; view=&quot;_local&quot;&gt;
      &lt;query&gt;
          select c from sample$Color c order by c.name
      &lt;/query&gt;
  &lt;/collectionDatasource&gt;
&lt;/dsContext&gt;</programlisting></para>
        <para>Здесь источник <code>carDs</code> содержит один экземпляр сущности <code>Car</code>, а вложенные в него <code>allocationsDs</code> и <code>repairsDs</code> содержат коллекции связанных сущностей из атрибутов <code>Car.driverAllocations</code> и <code>Car.repairs</code> соответственно. Экземпляр <code>Car</code> вместе со связанными сущностями проставляется в источник данных извне. Если данный экран является <link linkend="screen_edit">экраном редактирования</link>, то это происходит автоматически при открытии экрана. Источник данных <code>colorsDs</code> содержит коллекцию экземпляров сущности <code>Color</code>, загружаемую самим источником по указанному JPQL-<link linkend="datasource_query">запросу</link> с <link linkend="views">представлением</link> <code>_local</code>.</para>
        <para>Рассмотрим схему XML. </para>
        <para><sgmltag>dsContext</sgmltag> - корневой элемент.</para>
        <para>Элементы <sgmltag>dsContext</sgmltag>:<itemizedlist>
            <listitem>
              <para><sgmltag>datasource</sgmltag> - определяет источник данных, содержащий единственный экземпляр сущности. </para>
              <para>Атрибуты:<itemizedlist>
                  <listitem>
                    <para><sgmltag>id</sgmltag> - идентификатор источника, должен быть уникальным  для данного <code>DsContext</code>.</para>
                  </listitem>
                  <listitem>
                    <para><sgmltag>class</sgmltag> - Java класс сущности, которая будет содержаться в данном источнике</para>
                  </listitem>
                  <listitem>
                    <para><sgmltag>view</sgmltag> - имя <link linkend="views">представления</link> сущности. Если источник сам загружает экземпляры, то это представление будет использовано при загрузке. В противном случае это представление сигнализирует внешним механизмам о том, как нужно загрузить сущность для данного источника.</para>
                  </listitem>
                  <listitem>
                    <para><sgmltag>allowCommit</sgmltag> - при установке значения <code>false</code> метод <code>isModified()</code> данного источника всегда возвращает <code>false</code>, а метод <code>commit()</code> ничего не делает. Таким образом, изменения содержащихся в источнике сущностей игнорируются. По умолчанию <code>true</code>, т.е. изменения отслеживаются и могут быть сохранены.</para>
                  </listitem>
                  <listitem>
                    <para><sgmltag>datasourceClass</sgmltag> - нестандартный класс реализации источника данных, если необходим.</para>
                  </listitem>
                </itemizedlist></para>
            </listitem>
            <listitem>
              <para><sgmltag>collectionDatasource</sgmltag> - определяет источник данных, содержащий коллекцию экземпляров.</para>
              <para>Атрибуты <sgmltag>collectionDatasource</sgmltag>:<itemizedlist>
                  <listitem>
                    <para><sgmltag>refreshMode</sgmltag> - режим обновления источника, по умолчанию <code>ALWAYS</code>. В режиме <code>NEVER</code> при вызове <code>refresh()</code> источник не производит загрузку данных, а только переходит в состояние <code>Datasource.State.VALID</code>, оповещает слушателей и сортирует имеющиеся в нем экземпляры. Режим <code>NEVER</code> удобен, если необходимо программно заполнить <code>CollectionDatasource</code> предварительно загруженными или созданными сущностями. Например:<programlisting language="java">@Override
public void init(Map&lt;String, Object&gt; params) {
  Set&lt;Customer&gt; entities = (Set&lt;Customer&gt;) params.get(&quot;customers&quot;);
  for (Customer entity : entities) {
      customersDs.includeItem(entity);
  }
  customersDs.refresh();
}</programlisting></para>
                  </listitem>
                  <listitem>
                    <para><sgmltag>softDeletion</sgmltag> - значение <code>false</code> отключает режим <link linkend="soft_deletion">мягкого удаления</link> при загрузке сущностей, т.е. будут загружены также и удаленные экземпляры. По умолчанию <code>true</code>.</para>
                  </listitem>
                </itemizedlist></para>
              <para>Элементы <sgmltag>collectionDatasource</sgmltag>:<itemizedlist>
                  <listitem>
                    <para><sgmltag>query</sgmltag> - <link linkend="datasource_query">запрос</link> для загрузки сущностей</para>
                  </listitem>
                </itemizedlist></para>
            </listitem>
            <listitem>
              <para><sgmltag>groupDatasource</sgmltag> - полностью аналогичен <sgmltag>collectionDatasource</sgmltag>, но создает реализацию источника данных, пригодную для использования совместно с компонентом <code>
                  <link linkend="gui_GroupTable">GroupTable</link>
                </code>.</para>
            </listitem>
            <listitem>
              <para><sgmltag>hierarchicalDatasource</sgmltag> - аналогичен <sgmltag>collectionDatasource</sgmltag>, и создает реализацию источника данных, пригодную для использования совместно с компонентами <code>
                  <link linkend="gui_Tree">Tree</link>
                </code> и <code>
                  <link linkend="gui_TreeTable">TreeTable</link>
                </code>.</para>
              <para>Специфическим атрибутом является <sgmltag>hierarchyProperty</sgmltag>, задающий имя атрибута сущности, по которому строится иерархия.</para>
            </listitem>
          </itemizedlist></para>
        <para>Класс реализации источника выбирается неявно на основе имени элемента XML и, как было сказано выше, взаимного расположения элементов. Однако если необходимо применить нестандартный источник данных, его класс может быть явно указан в атрибуте <code>datasourceClass</code>. </para>
      </section>
      <section>
        <title>Программное создание</title>
        <para>При необходимости создать источник данных в Java коде рекомендуется воспользоваться специальным классом <code>DsBuilder</code>. </para>
        <para>Экземпляр <code>DsBuilder</code> параметризуется цепочкой вызовов его методов в стиле текучего (fluent) интерфейса. Если установлены параметры <code>master</code> и <code>property</code>, то в результате будет создан <code>NestedDatasource</code>, в противном случае - <code>Datasource</code> или <code>CollectionDatasource</code>.</para>
        <para>Пример:<programlisting language="java">CollectionDatasource ds = new DsBuilder(getDsContext())
      .setJavaClass(Order.class)
      .setViewName(View.LOCAL)
      .setId(&quot;ordersDs&quot;)
      .buildCollectionDatasource();</programlisting></para>
      </section>
      <section>
        <title>Собственные классы реализации</title>
        <para>Как правило, нестандартная реализация источника данных требуется для изменения процесса загрузки коллекции сущностей. При создании класса такого источника рекомендуется унаследовать его от <code>CollectionDatasourceImpl</code>, либо от <code>GroupDatasourceImpl</code> или <code>HierarchicalDatasourceImpl</code>, и переопределить метод <code>loadData()</code>.</para>
        <para>Пример:<programlisting language="java">public class MyDatasource extends CollectionDatasourceImpl&lt;SomeEntity, UUID&gt; {

  private SomeService someService = AppBeans.get(SomeService.NAME);

  @Override
  protected void loadData(Map&lt;String, Object&gt; params) {
      detachListener(data.values());
      data.clear();

      for (SomeEntity entity : someService.getEntities()) {
          data.put(entity.getId(), entity);
          attachListener(entity);
      }
  }
}</programlisting></para>
        <para>Здесь <code>data</code> - поле базового класса, хранящее коллекцию загруженных экземпляров. Методы базового класса <code>detachListener()</code> и <code>attachListener()</code> управляют назначением на загруженные сущности слушателя, который оповещает источник данных об изменениях в полях экземпляров.</para>
        <para>Для создания нестандартного источника данных декларативным способом необходимо указать класс в атрибуте <sgmltag>datasourceClass</sgmltag> элемента XML. При программном создании через <code>DsBuilder</code> класс источника указывается вызовом <code>setDsClass()</code>.</para>
      </section>
    </section>
    <section id="datasource_query">
      <title>Запросы в CollectionDatasourceImpl</title>
      <para>Класс <code> CollectionDatasourceImpl</code> и его наследники <code>GroupDatasourceImpl</code>, <code>HierarchicalDatasourceImpl</code> являются стандартной реализацией источников данных, работающих с коллекциями независимых экземпляров сущностей. Эти источники загружают данные через <code>DataManager</code>, отправляя на <structname>Middleware</structname> запрос на языке JPQL. Далее рассматриваются особенности формирования таких запросов.</para>
      <section id="datasource_query_results">
        <title>Возвращаемые значения</title>
        <para>Запрос должен возвращать сущности того типа, который указан при создании источника данных. Тип сущности при декларативном создании указывается в атрибуте <sgmltag>class</sgmltag> элемента XML, при создании через <code>DsBuilder</code> - в методе <code>setJavaClass()</code> или <code>setMetaClass()</code>.</para>
        <para>Кроме того, тип объекта в предложении <code>from</code> запроса должен соответствовать типу источника. Это необходимо для проведения автоматических трансформаций запроса при наложении ограничений безопасности и др.</para>
        <para>Например, запрос источника данных типа <code>Customer</code> может выглядеть следующим образом:<programlisting language="sql">select c from sales$Customer c</programlisting></para>
        <para>Примеры недопустимых для источника типа <code>Customer</code> запросов:<programlisting language="sql">select c.id, c.name from sales$Customer c /* неверно - возвращает отдельные поля, а не весь объект Customer */

select o.customer from sales$Order o /* неверно - тип from (Order) отличается от типа результата (Customer) */</programlisting></para>
      </section>
      <section id="datasource_query_params">
        <title>Параметры запроса</title>
        <para>JPQL-запрос в источнике данных может содержать параметры нескольких видов. Вид параметра определяется по префиксу имени параметра. Префиксом является часть имени до знака &quot;$&quot;. Интерпретация имени после &quot;$&quot; рассматривается ниже.</para>
        <itemizedlist>
          <listitem id="datasource_query_params_ds">
            <para>Префикс <code>ds</code>. </para>
            <para>Значением параметра являются данные другого источника данных, зарегистрированного в этом же <code>DsContext</code>. Например:<programlisting language="xml">&lt;collectionDatasource id=&quot;customersDs&quot; class=&quot;com.sample.sales.entity.Customer&quot; view=&quot;_local&quot;&gt;
  &lt;query&gt;
      select c from sales$Customer c
  &lt;/query&gt;
&lt;/collectionDatasource&gt;

&lt;collectionDatasource id=&quot;ordersDs&quot; class=&quot;com.sample.sales.entity.Order&quot; view=&quot;_local&quot;&gt;
  &lt;query&gt;
      select o from sales$Order o where o.customer.id = :ds$customersDs
  &lt;/query&gt;
&lt;/collectionDatasource&gt;</programlisting></para>
            <para>В данном случае параметром запроса источника данных <code>ordersDs</code> будет текущий экземпляр сущности, находящийся в источнике данных <code>customersDs</code>. </para>
            <para>При использовании параметров с префиксом <code>ds</code> между источниками данных автоматически создаются зависимости, приводящие к обновлению источника если меняется значение его параметра. В приведенном примере если изменяется выбранный Покупатель, автоматически обновляется список его Заказов. </para>
            <para>Обратите внимание, что в примере запроса с параметром  левой частью оператора сравнения является значение идентификатора <code>o.customer.id</code>, а правой - экземпляр <code>Customer</code>, содержащийся в источнике <code>customersDs</code>. Такое сравнение допустимо, так как при выполнении запроса на <structname>Middleware</structname> реализация интерфейса <link linkend="query">
                <code>Query</code>
              </link>, присваивая значения параметрам запроса, автоматически подставляет ID сущности вместо переданного экземпляра сущности.</para>
            <para>В имени параметра после префикса и имени источника может быть также указан путь по графу сущностей к атрибуту, из которого нужно взять значение, например: <programlisting language="xml">&lt;query&gt;
  select o from sales$Order o where o.customer.id = :ds$customersDs.id
&lt;/query&gt;</programlisting></para>
            <para>или<programlisting language="xml">&lt;query&gt;
  select o from sales$Order o where o.tagName = :ds$customersDs.group.tagName
&lt;/query&gt;</programlisting></para>
          </listitem>
          <listitem>
            <para>Префикс <code>custom</code>. </para>
            <para>Значение параметра будет взято из объекта <code>Map&lt;String, Object&gt;</code>, переданного в метод <code>refresh()</code> источника данных. Например:<programlisting language="xml">&lt;collectionDatasource id=&quot;ordersDs&quot; class=&quot;com.sample.sales.entity.Order&quot; view=&quot;_local&quot;&gt;
  &lt;query&gt;
      select o from sales$Order o where o.number = :custom$number
  &lt;/query&gt;
&lt;/collectionDatasource&gt;</programlisting><programlisting language="java">Map&lt;String, Object&gt; params = new HashMap&lt;&gt;();
params.put(&quot;number&quot;, &quot;1&quot;);
ordersDs.refresh(params);</programlisting></para>
            <para>Приведение экземпляра при необходимости к его идентификатору осуществляется аналогично параметрам с префиксом <code>ds</code>. Путь по графу сущностей в имени параметра в данном случае не поддерживается. </para>
          </listitem>
          <listitem>
            <para>Префикс <code>param</code>. </para>
            <para>Значение параметра будет взято из объекта <code>Map&lt;String, Object&gt;</code>, переданного при открытии экрана в метод <code>init()</code> <link linkend="screen_controller">контроллера</link>. </para>
            <para>Приведение экземпляра при необходимости к его идентификатору осуществляется аналогично параметрам с префиксом <code>ds</code>. Поддерживается путь к атрибуту по графу сущностей в имени параметра. </para>
          </listitem>
          <listitem>
            <para>Префикс <code>component</code>. </para>
            <para>Значением параметра будет текущее значение визуального компонента, путь к которому указан в имени параметра. Например:<programlisting language="xml">&lt;query&gt;
  select o from sales$Order o where o.number = :component$filter.orderNumberField
&lt;/query&gt;</programlisting></para>
            <para>Путь к компоненту должен включать все вложенные <link linkend="frame">фреймы</link>.
</para>
            <para>Приведение экземпляра при необходимости к его идентификатору аналогично параметрам <code>ds</code>.
Поддерживается путь к атрибуту по графу сущностей в имени параметра как продолжение пути к компоненту. </para>
          </listitem>
          <listitem>
            <para>Префикс <code>session</code>. </para>
            <para>Значением параметра будет значение атрибута <link linkend="userSession">пользовательской сессии</link>, указанного в имени параметра.</para>
            <para>Значение извлекается методом <code>UserSession.getAttribute()</code>, поэтому поддерживаются также  предопределенные имена атрибутов сессии: <itemizedlist>
                <listitem>
                  <para><code>userId</code> - ID текущего зарегистрированного или замещенного пользователя;</para>
                </listitem>
                <listitem>
                  <para><code>userLogin</code> - логин текущего зарегистрированного или замещенного пользователя в нижнем регистре.</para>
                </listitem>
              </itemizedlist></para>
            <para>Пример:<programlisting language="xml">&lt;query&gt;
  select o from sales$Order o where o.createdBy = :session$userLogin
&lt;/query&gt;</programlisting></para>
            <para>Приведение экземпляра при необходимости к его идентификатору аналогично параметрам <code>ds</code>.
Путь по графу сущностей в имени параметра в данном случае не поддерживается. </para>
          </listitem>
        </itemizedlist>
        <warning>
          <para>Если значение параметра не найдено по правилам, задаваемым префиксом, для данного параметра устанавливается значение <code>null</code>. То есть если, например,  в запросе указан параметр с именем <code>param$some_name</code>, а в мэп параметров экрана нет ключа <code>some_name</code>, то для параметра <code>param$some_name</code> устанавливается значение <code>null</code>.</para>
        </warning>
      </section>
      <section id="datasource_query_filter">
        <title>Фильтр запроса</title>
        <para>Запрос источника данных может быть модифицирован во время работы приложения, в зависимости от вводимых пользователем условий, что позволяет эффективно фильтровать данные на уровне выборки из БД.</para>
        <para>Простейший способ обеспечения такой возможности - подключение к источнику данных специального визуального компонента <link linkend="gui_Filter">Filter</link>.</para>
        <para>Если по какой-то причине применение универсального фильтра нежелательно, можно встроить в текст запроса специальную разметку на XML, позволяющую сформировать итоговый запрос в зависимости от значений, введенных пользователем в произвольные визуальные компоненты экрана.</para>
        <para>В таком фильтре могут быть использованы следующие элементы:<itemizedlist>
            <listitem>
              <para><sgmltag>filter</sgmltag> - корневой элемент фильтра. Может непосредственно содержать  только одно условие.<itemizedlist>
                  <listitem>
                    <para><sgmltag>and</sgmltag>, <sgmltag>or</sgmltag> - логические условия, могут содержать любое количество других условий и предложений. </para>
                  </listitem>
                  <listitem>
                    <para><sgmltag>c</sgmltag> - предложение на JPQL, которое добавляется в секцию <code>where</code>. Содержит только текст и опционально атрибут <sgmltag>join</sgmltag>, значение которого будет добавлено в соответствующее место запроса, если добавляется данное предложение <code>where</code>. </para>
                  </listitem>
                </itemizedlist></para>
            </listitem>
          </itemizedlist></para>
        <para>Условия и предложения добавляются в итоговый запрос, только если присутствующие внутри них параметры получили значения, т.е. не равны <code>null</code>. </para>
        <para>Пример:<programlisting language="xml">&lt;query&gt;
  select distinct d from app$GeneralDoc d
  &lt;filter&gt;
      &lt;or&gt;
          &lt;and&gt;
              &lt;c join=&quot;, app$DocRole dr&quot;&gt;dr.doc.id = d.id and d.processState = :custom$state&lt;/c&gt;
              &lt;c&gt;d.barCode like :component$barCodeFilterField&lt;/c&gt;
          &lt;/and&gt;
          &lt;c join=&quot;, app$DocRole dr&quot;&gt;dr.doc.id = d.id and dr.user.id = :custom$initiator&lt;/c&gt;
      &lt;/or&gt;
  &lt;/filter&gt;
&lt;/query&gt;</programlisting></para>
        <para>В данном случае если в метод <code>refresh()</code> источника данных переданы параметры <code>state</code> и <code>initiator</code>, а в визуальном компоненте <code>barCodeFilterField</code> установлено некоторое значение, то итоговый запрос примет вид:<programlisting>select distinct d from app$GeneralDoc d, app$DocRole dr
where
(
  (dr.doc.id = d.id and d.processState = :custom$state)
  and
  (d.barCode like :component$barCodeFilterField)
)
or
(dr.doc.id = d.id and dr.user.id = :custom$initiator)</programlisting></para>
        <para>Если же, к примеру, компонент <code>barCodeFilterField</code> пуст, а в <code>refresh()</code> передан только параметр <code>initiator</code>, то запрос получится следующим:<programlisting>select distinct d from app$GeneralDoc d, app$DocRole dr
where
(dr.doc.id = d.id and dr.user.id = :custom$initiator)</programlisting></para>
        <warning>
          <para>Не используйте <link linkend="datasource_query_params_ds">ds-параметры</link>
            в фильтрах запросов. Они предназначены для связывания источников данных и обрабатываются специальным образом.
          </para>
        </warning>
      </section>
      <section id="datasource_query_case_insensitive">
        <title>Поиск подстроки без учета регистра</title>
        <para>В источниках данных можно использовать особенность выполнения JPQL-запросов, описанную для интерфейса <code>
            <link linkend="query">Query</link>
          </code> уровня <structname>Middleware</structname>: для удобного формирования условия поиска без учета регистра символов и по любой части строки можно использовать префикс <code>(?i)</code>. Однако, в связи с тем,  что значение параметра обычно передается неявно, имеются следующие отличия: <itemizedlist>
            <listitem>
              <para>Префикс <code>(?i)</code> нужно указывать не в значении, а перед именем параметра.</para>
            </listitem>
            <listitem>
              <para>Значение параметра будет автоматически переведено в нижний регистр.</para>
            </listitem>
            <listitem>
              <para>Если в значении параметра  отсутствуют символы <code>%</code>, то они будут добавлены в начало и конец.</para>
            </listitem>
          </itemizedlist></para>
        <para>Для примера рассмотрим обработку следующего запроса:<programlisting>select c from sales$Customer c where c.name like :(?i)component$customerNameField</programlisting></para>
        <para>В данном случае значение параметра, взятое из компонента <code>customerNameField</code>, будет переведено в нижний регистр и обрамлено символами <code>%</code>, а затем в базе данных будет выполнен SQL запрос с условием вида <code>lower(C.NAME) like ?</code></para>
        <para>Следует иметь в виду, что при таком поиске индекс, созданный в БД по полю <code>NAME</code>, не используется. </para>
      </section>
    </section>
    <section id="datasource_listeners">
      <title>Слушатели источников данных</title>
      <para>Слушатели <link linkend="datasources">источников данных</link> (datasource listeners)  позволяют получать оповещения об изменении состояния источников данных и экземпляров сущностей, в них находящихся.</para>
      <para>Для регистрации слушателей используются методы <code>Datasource.addListener()</code>, <code>Datasource.removeListener()</code>. Пример регистрации слушателя в <link linkend="screen_controller">контроллере экрана</link>:<programlisting language="java">@Inject
private Datasource&lt;Customer&gt; customerDs;
...
public void init(Map&lt;String, Object&gt; params) {
  ...
  customerDs.addListener(new DatasourceListener&lt;Customer&gt;() {
      // listener methods implementation
  });
}</programlisting></para>
      <para>Существует два интерфейса слушателей источников данных: <code>DatasourceListener</code> и <code>CollectionDatasourceListener</code>. Первый можно использовать для регистрации в любых источниках данных, второй - только в реализующих <code>CollectionDatasource</code>. Как правило, на практике требуется получать не все оповещения от слушателя, а только некоторые. Поэтому удобно вместо реализации самих интерфейсов слушателей использовать классы-адаптеры <code>DsListenerAdapter</code> и <code>CollectionDsListenerAdapter</code>, содержащие пустые реализации всех методов соответствующих интерфейсов.</para>
      <para>Рассмотрим методы <code>DatasourceListener</code>:<itemizedlist>
          <listitem>
            <para><code>valueChanged()</code> - объявление этого метода наследуется от базового интерфейса <code>ValueListener</code>. Данный метод слушателя вызывается, если изменилось значение какого-либо атрибута сущности, находящейся в данный момент в источнике. В метод передается сам измененный экземпляр, имя измененного атрибута, старое и новое значение.</para>
            <para>Оповещение <code>valueChanged()</code> можно использовать для действий в ответ на изменение пользователем сущности из UI, то есть редактирования полей ввода.
В следующем примере гипотетический метод <code>updateSettings()</code> будет вызван при изменении значения атрибута <code>active</code>, и в него будет передано новое значение этого атрибута: <programlisting language="java">@Inject
private Datasource&lt;Customer&gt; customerDs;

public void init(Map&lt;String, Object&gt; params) {
  ...
  customerDs.addListener(new DsListenerAdapter&lt;Customer&gt;() {
      @Override
      public void valueChanged(Customer source, String property, Object prevValue, Object value) {
          if (&quot;active&quot;.equals(property)) {
              boolean active = BooleanUtils.isTrue((Boolean) value); // converting null to false
              updateSettings(active);
          }
      }
  });
}</programlisting></para>
          </listitem>
          <listitem><para><code>itemChanged()</code> - вызывается при смене выбранного экземпляра, возвращаемого методом <code>getItem()</code>.</para><para>Для <code>Datasource</code> это происходит при установке другого экземпляра (или <code>null</code>) методом <code>setItem()</code>.</para><para>Для <code>CollectionDatasource</code> данное оповещение вызывается, когда в связанном визуальном компоненте меняется выделенный элемент. Например, это может быть выделенная строка таблицы, элемент дерева, или выделенный элемент выпадающего списка.</para>Пример использования оповещения <code>itemChanged()</code>для управления состоянием действия таблицы:<programlisting language="java">@Inject
protected CollectionDatasource&lt;Customer, UUID&gt; customersDs;

@Named(&quot;customersTable.remove&quot;)
protected RemoveAction removeAction;

public void init(Map&lt;String, Object&gt; params) {
  ...
  customersDs.addListener(new DsListenerAdapter&lt;Customer&gt;() {
      @Override
      public void itemChanged(Datasource&lt;Customer&gt; ds, Customer prevItem, Customer item) {
          removeAction.setEnabled(canCustomerBeDeleted(item));
      }
  });
}</programlisting></listitem>
          <listitem>
            <para><code>stateChanged()</code> - вызывается при изменении состояния источника данных. Источник данных может находиться в одном из трех состояний, соответствующих перечислению <code>Datasource.State</code>:<itemizedlist>
                <listitem>
                  <para><code>NOT_INITIALIZED</code> - источник только что создан.</para>
                </listitem>
                <listitem>
                  <para><code>INVALID</code> - создан весь <code>
                      <link linkend="dsContext">DsContext</link>
                    </code>, к которому относится данный источник.</para>
                </listitem>
                <listitem>
                  <para><code>VALID</code> - источник данных в рабочем состоянии: <code>Datasource</code> содержит экземпляр сущности или <code>null</code>, <code>CollectionDatasource</code> - коллекцию экземпляров или пустую коллекцию.</para>
                </listitem>
              </itemizedlist></para>
            <para>Получение оповещения об изменении состояния источника может быть актуально для сложных <link linkend="screen_edit">редакторов</link>, состоящих из нескольких <link linkend="frame">фреймов</link>, где сложно отследить момент проставления редактируемой сущности в источник. В этом случае можно использовать оповещение <code>stateChanged()</code> для отложенной инициализации некоторых элементов экрана: <programlisting language="java">@Inject
protected CollectionPropertyDatasourceImpl&lt;CategoryAttribute, UUID&gt; categoryAttrsDs;

categoryAttrsDs.addListener(new DsListenerAdapter&lt;CategoryAttribute&gt;() {
  @Override
  public void stateChanged(Datasource ds, Datasource.State prevState, Datasource.State state) {
      if (state != Datasource.State.VALID) return;
      initDataTypeColumn();
      initDefaultValueColumn();
  }
});</programlisting></para>
          </listitem>
        </itemizedlist></para>
      <para>Интерфейс <code>CollectionDatasourceListener</code> добавляет еще один метод: <itemizedlist>
          <listitem>
            <para><code>collectionChanged()</code> - вызывается при изменении коллекции сущностей, хранящейся в источнике данных. В метод передается тип изменения: <code>REFRESH</code>,
<code> CLEAR</code>,
<code> ADD</code>,
<code> REMOVE</code>,
<code> UPDATE</code>.</para>
            <para>Пример слушателя, вызывающего пересчет стоимости поездки при изменении адреса остановки (сущность <code>Stop</code>) или количества остановок:<programlisting language="java">protected class StopDsListener extends CollectionDsListenerAdapter&lt;Stop&gt; {
  @Override
  public void valueChanged(Stop source, String property, Object prevValue, Object value) {
      // existing stop address changed
      if (&quot;address&quot;.equals(property)) {
          fireRouteChanged();
      }
  }

  @Override
  public void collectionChanged(CollectionDatasource ds, Operation operation) {
      // stop was added or removed
      fireRouteChanged();
  }

  private void fireRouteChanged() {
      // journey route has changed, need to recalculate price, journey time, pickup time delay etc.
  }
}</programlisting></para>
          </listitem>
        </itemizedlist></para>
    </section>
    <section id="dsContext">
      <title>DsContext</title>
      <para>Все созданные декларативно источники данных  регистрируются в объекте <code>DsContext</code> экрана. Ссылку на <code>DsContext</code> можно получить методом <code>getDsContext()</code> контроллера экрана, либо инжекцией в поле класса.</para>
      <para><code>DsContext</code> решает следующие задачи:<orderedlist>
          <listitem>
            <para>Позволяет организовать зависимости между источниками данных, когда при навигации по одному источнику (т.е. при изменении &quot;текущего&quot; экземпляра методом <code>setItem()</code>) обновляется связанный источник. Такие зависимости дают возможность в экранах легко организовывать master-detail связи между визуальными компонентами.</para>
            <para>Зависимости между источниками организуются с помощью <link linkend="datasource_query">параметров запросов</link> с префиксом <code>ds$</code>.</para>
          </listitem>
          <listitem>
            <para>Позволяет собрать все измененные экземпляры сущностей и отправить их на <structname>Middleware</structname> в одном вызове <code>DataManager.commit()</code>, т.е. сохранить в базе данных в одной транзакции. </para>
            <para>В качестве примера предположим, что некоторый экран позволяет редактировать экземпляр сущности
                <code>Order</code> и коллекцию принадлежащих ему экземпляров <code>OrderLine</code>. Экземпляр
                <code>Order</code> находится в <code>Datasource</code>, коллекция <code>OrderLine</code> - во
                вложенном <code>CollectionDatasource</code>, созданном по атрибуту <code>Order.lines</code>. Допустим,
                пользователь изменил какой-то атрибут <code>Order</code> и создал новый экземпляр <code>OrderLine</code>.
                Тогда при коммите экрана в <link linkend="dataManager">DataManager</link> будут одновременно отправлены
                два экземпляра - измененный <code>Order</code> и новый <code>OrderLine</code>. Далее, они вместе попадут
                в один <link linkend="entityManager">персистентный контекст</link> и при коммите транзакции сохранятся в
                БД. Разумеется, экземпляр <code>OrderLine</code> содержится также в коллекции <code>Order.lines</code>,
                но если не передавать его в персистентный контекст независимо, то потребуется установка каскадности
                сохранения между <code>Order</code> и <code>OrderLines</code> на уровне ORM. Жесткие отношения
                каскадности на уровне ORM иногда вызывают нежелательные последствия в неожиданных местах, поэтому лучше
                их избегать, что и обеспечивает описываемый механизм <code>DsContext</code>.</para>
            <para>В результате коммита <code>DsContext</code> получает от  <structname>Middleware</structname> набор сохраненных экземпляров (в случае оптимистической блокировки у них, как минимум, увеличено значение атрибута <code>version</code>), и устанавливает эти экземпляры в источниках данных взамен устаревших. Это позволяет сразу после коммита работать со свежими экземплярами без необходимости лишнего обновления источников данных, связанного с запросами к <structname>Middleware</structname> и базе данных.</para>
          </listitem>
          <listitem>
            <para>Объявляет слушателя <code>DsContext.CommitListener</code>, позволяющего получать оповещения перед
                коммитом измененных экземпляров и после него. Перед коммитом можно дополнить коллекцию отправляемых в
                <link linkend="dataManager">DataManager</link> на Middleware экземпляров, тем самым обеспечив сохранение
                в той же транзакции произвольных сущностей. После коммита можно получить коллекцию вернувшихся из
                <code>DataManager</code> сохраненных экземпляров.</para>
            <para>Данный механизм необходим, если некоторые сущности, с которыми работает экран, находятся не под управлением источников данных, а создаются и изменяются непосредственно в коде контроллера. Например, визуальный компонент <code>
                <link linkend="gui_FileUploadField">FileUploadField</link>
              </code> после загрузки файла создает новый экземпляр сущности <code>FileDescriptor</code>, который можно сохранить вместе с другими сущностями экрана именно таким способом - добавив в <code>CommitContext</code> в методе <code>DsContext.CommitListener.beforeCommit()</code>.</para>
            <para><code>DsContext.CommitListener</code> имеет адаптер <code>DsContext.CommitListenerAdapter</code>, который удобно использовать при необходимости определить только один метод.</para>
            <para>В следующем примере новый экземпляр <code>Customer</code> будет отправлен на <structname>Middleware</structname> и сохранен в БД вместе с остальными измененными сущностями экрана при его коммите:<programlisting language="java">protected Customer customer;

protected void createNewCustomer() {
  customer = new Customer();
  customer.setName(&quot;John Doe&quot;);
}

public void init(Map&lt;String, Object&gt; params) {
  getDsContext().addListener(new DsContext.CommitListenerAdapter() {
      @Override
      public void beforeCommit(CommitContext context) {
          if (customer != null)
              context.getCommitInstances().add(customer);
      }
  });
}</programlisting></para>
          </listitem>
        </orderedlist></para>
    </section>
    <section id="dataSupplier">
      <title>DataSupplier</title>
      <para><code>DataSupplier</code> - интерфейс, через который источники данных обращаются к Middleware для
          загрузки и сохранения сущностей. Его стандартная реализация просто делегирует выполнение
          <link linkend="dataManager">DataManager</link>. Экран может задать свою реализацию интерфейса <code>DataSupplier</code>
          в атрибуте <code>dataSupplier</code> элемента <code>window</code>. Собственная реализация может, например,
          вызывать дополнительный блок Middleware для загрузки данных экрана из другой базы данных.</para>
      <para>Ссылку на <code>DataSupplier</code> можно получить либо <link linkend="screen_controller_injection">инжекцией</link>
          в контроллер экрана, либо через экземпляры <code>DsContext</code> или <code>Datasource</code>. В обоих случаях
      возвращается или стандартная, или собственная реализация интерфейса (если таковая определена).</para>
    </section>
  </section>
  <section id="gui_Action">
    <title>Действия. Интерфейс Action</title>
    <para><code>Action</code> − интерфейс, абстрагирующий действие (другими словами, некоторую функцию) от визуального компонента. Он особенно полезен в случаях, когда одно и то же действие может быть вызвано из разных визуальных компонентов. Кроме того, данный интерфейс позволяет снабдить действие дополнительными свойствами, такими как название, признаки доступности и видимости, и другими.</para>
    <para>Рассмотрим методы интерфейса <code>Action</code>:<itemizedlist>
        <listitem>
          <para><code>actionPerform()</code> - вызывается визуальным компонентом, связанным с данным действием. В метод передается экземпляр вызвавшего компонента.</para>
        </listitem>
        <listitem>
          <para><code>getId()</code> - возвращает идентификатор данного действия. Идентификатор обычно устанавливается конструктором класса, реализующего <code>Action</code>, и не меняется на протяжении жизни созданного объекта действия.</para>
        </listitem>
        <listitem>
          <para>методы получения и установки свойств <code>caption</code>, <code>description</code>, <code>shortcut</code>, <code>icon</code>, <code>enabled</code>, <code>visible</code>. Все эти свойства обычно используется связанными визуальными компонентами для установки собственных одноименных свойств.</para>
        </listitem>
        <listitem>
          <para><code>addPropertyChangeListener()</code>, <code>removePropertyChangeListener()</code> - подключение слушателей, реагирующих на изменение вышеупомянутых свойств. Слушатель получает уведомление типа <code>java.beans.PropertyChangeEvent</code>, в котором  содержится имя измененного свойства, его старое и новое значение.</para>
        </listitem>
        <listitem>
          <para><code>refreshState()</code> - метод, который может быть реализован в конкретном классе действия для инициализации вышеупомянутых свойств в соответствии с какими-либо внешними факторами, например правами пользователя. Вызывается обычно в конструкторах имплементирующих классов или из связанных визуальных компонентов.</para>
        </listitem>
        <listitem>
          <para><code>addOwner()</code>, <code>removeOwner()</code>, <code>getOwner()</code>, <code>getOwners()</code> - методы для управления связью действия с визуальными компонентами.</para>
        </listitem>
      </itemizedlist></para>
    <para>Для реализации действий рекомендуется использовать <link linkend="declarative_actions">декларативное создание</link> действий, либо наследоваться от класса <link linkend="baseAction">AbstractAction</link>. Кроме того, существует набор <link linkend="standard_actions">стандартных действий</link>, применимых для работы с таблицами и компонентами выбора. От стандартных действий также можно наследоваться для модификации их поведения или перехвата событий.</para>
    <para>Визуальные компоненты, связанные с действием, могут быть двух типов:<itemizedlist>
        <listitem>
          <para>Визуальный компонент, содержащий одно действие, реализует интерфейс <code>Component.ActionOwner</code>. Это <link linkend="gui_Button">Button</link> и <link linkend="gui_LinkButton">LinkButton</link>.</para>
          <para>Связь компонента с действием осуществляется путем вызова метода <code>ActionOwner.setAction()</code> компонента. В этот момент компонент заменяет свои свойства на соответствующие свойства действия (подробнее см. описание компонентов). </para>
        </listitem>
        <listitem>
          <para>Визуальный компонент, содержащий несколько действий, реализует интерфейс <code>Component.ActionsHolder</code>. Это <code>Window</code>, <code>IFrame</code>, <link linkend="gui_Table">Table</link> и ее наследники, <link linkend="gui_Tree">Tree</link>, <link linkend="gui_PopupButton">PopupButton</link>, <link linkend="gui_PickerField">PickerField</link>, <link linkend="gui_LookupPickerField">LookupPickerField</link>.</para>
          <para>Действия добавляются компоненту вызовом метода <code>ActionsHolder.addAction()</code>. Реализация этого метода в компоненте проверяет, нет ли уже в нем действия с таким же идентификатором. Если есть, то имеющееся действие будет заменено на новое переданное. Поэтому можно, например, декларировать стандартное действие в дескрипторе экрана, а затем в контроллере создать новое с переопределенными методами и добавить компоненту.</para>
        </listitem>
      </itemizedlist></para>
    <section id="declarative_actions">
      <title>Декларативное создание действий</title>
      <para>В XML-дескрипторе экрана для любого компонента, реализующего интерфейс <code>Component.ActionsHolder</code>, в том числе для всего экрана или фрейма, может быть задан набор <link linkend="gui_Action">действий</link>. Делается это в элементе <code>actions</code>, который содержит вложенные элементы <code>action</code>.</para>
      <para>Элемент <code>action</code> может иметь следующие атрибуты:<itemizedlist>
          <listitem>
            <para><code>id</code> − идентификатор, должен быть уникален в рамках данного компонента <code>ActionsHolder</code>.</para>
          </listitem>
          <listitem>
            <para><code>caption</code> - название действия.</para>
          </listitem>
          <listitem>
            <para><code>description</code> - описание действия.</para>
          </listitem>
          <listitem>
            <para><code>enable</code> - признак доступности действия (<code>true</code> / <code>false</code>).</para>
          </listitem>
          <listitem>
            <para><code>icon</code> - значок действия.</para>
          </listitem>
          <listitem>
            <para><code>invoke</code> -  имя вызываемого метода контроллера. Метод должен быть <code>public</code>, не возвращать результата и либо не иметь аргументов, либо иметь один аргумент типа <code>Component</code>. Если метод имеет аргумент <code>Component</code>, то при вызове в него будет передан экземпляр визуального компонента, запустившего данное действие.</para>
          </listitem>
          <listitem>
            <para><code>shortcut</code> -  комбинация клавиш для вызова. Возможные модификаторы - <code>ALT</code>, <code>CTRL</code>, <code>SHIFT</code> - отделяются символом &quot;-&quot;. Например:
<keycap>ALT-CTRL-C</keycap>.</para>
          </listitem>
          <listitem>
            <para><code>visible</code> - признак видимости действия (<code>true</code> / <code>false</code>).</para>
          </listitem>
        </itemizedlist></para>
      <para>Рассмотрим примеры декларативного объявления действий.<itemizedlist>
          <listitem>
            <para>Объявление действий на уровне экрана:<programlisting language="xml">&lt;window ...&gt;
  &lt;dsContext/&gt;

  &lt;actions&gt;
      &lt;action id=&quot;sayHelloAction&quot; caption=&quot;msg://sayHello&quot; shortcut=&quot;ALT-T&quot; invoke=&quot;sayHello&quot;/&gt;
  &lt;/actions&gt;

  &lt;layout&gt;
      &lt;button action=&quot;sayHelloAction&quot;/&gt;
  &lt;/layout&gt;
&lt;/window&gt;</programlisting><programlisting language="java">// controller

public void sayHello(Component component) {
  showNotification(&quot;Hello!&quot;, NotificationType.TRAY);
}</programlisting>Здесь объявляется действие с идентификатором <code>sayHelloAction</code> и  названием из <link linkend="message_packs">пакета сообщений</link>. С этим действием связывается кнопка, заголовок которой будет установлен в название действия. Действие вызовет метод <code>sayHello()</code> контроллера при нажатии на кнопку, а также при нажатии комбинации клавиш <keycap>ALT-T</keycap>, если в данный момент экран принимает фокус ввода.</para>
          </listitem>
          <listitem>
            <para>Объявление действий для <link linkend="gui_PopupButton">PopupButton</link>:<programlisting language="xml">&lt;popupButton caption=&quot;Say something&quot;&gt;
 &lt;actions&gt;
    &lt;action id=&quot;helloAction&quot; caption=&quot;Say hello&quot; invoke=&quot;sayHello&quot;/&gt;
    &lt;action id=&quot;goodbyeAction&quot; caption=&quot;Say goodbye&quot; invoke=&quot;sayGoodbye&quot;/&gt;
 &lt;/actions&gt;
&lt;/popupButton&gt;</programlisting></para>
          </listitem>
          <listitem>
            <para>Объявление действий для <link linkend="gui_Table">Table</link>:<programlisting language="xml">&lt;table id=&quot;usersTable&quot; width=&quot;100%&quot;&gt;
  &lt;actions&gt;
      &lt;action id=&quot;create&quot;/&gt;
      &lt;action id=&quot;edit&quot;/&gt;
      &lt;action id=&quot;copy&quot; caption=&quot;msg://copy&quot; icon=&quot;icons/copy.png&quot;
              invoke=&quot;copy&quot; trackSelection=&quot;true&quot;/&gt;
      &lt;action id=&quot;changePassw&quot; caption=&quot;msg://changePassw&quot; icon=&quot;icons/change-pass.png&quot;
              invoke=&quot;changePassword&quot; trackSelection=&quot;true&quot;/&gt;
  &lt;/actions&gt;
  &lt;buttonsPanel&gt;
      &lt;button action=&quot;usersTable.create&quot;/&gt;
      &lt;button action=&quot;usersTable.edit&quot;/&gt;
      &lt;button action=&quot;usersTable.copy&quot;/&gt;
      &lt;button action=&quot;usersTable.changePassw&quot;/&gt;
  &lt;/buttonsPanel&gt;
  &lt;rowsCount/&gt;
  &lt;columns&gt;
      &lt;column id=&quot;login&quot;/&gt;
      ...
  &lt;/columns&gt;
  &lt;rows datasource=&quot;usersDs&quot;/&gt;
&lt;/table&gt;</programlisting>Здесь помимо <link linkend="standard_actions">стандартных действий</link> таблицы <code>create</code> и  <code>edit</code>  объявлены  действия <code>copy</code> и <code>changePassw</code>, вызывающие соответствующие методы контроллера. Для этих действий указан также атрибут <code>trackSelection=&quot;true&quot;</code>, в результате чего действие и связанная с ним кнопка становятся недоступными, если в таблице не выбрана ни одна строка. Это удобно, если действие предназначено для выполнения над текущей выбранной строкой таблицы. </para>
            <para>Для действий <code>create</code> и <code>edit</code> можно указать дополнительный атрибут <code>openType</code> для указания режима открытия экрана редактирования, как описано для метода <code>setOpenType()</code> класса <link linkend="createAction">CreateAction</link>.</para>
          </listitem>
          <listitem>
            <para>Объявление действий для <link linkend="gui_PickerField">PickerField</link>:<programlisting language="xml">&lt;pickerField id=&quot;colourField&quot; datasource=&quot;carDs&quot; property=&quot;colour&quot;/&gt;
  &lt;actions&gt;
      &lt;action id=&quot;lookup&quot;/&gt;
      &lt;action id=&quot;show&quot; icon=&quot;icons/show.png&quot;
              invoke=&quot;showColour&quot; caption=&quot;&quot; description=&quot;Show colour&quot;/&gt;
  &lt;/actions&gt;
&lt;/pickerField&gt;</programlisting>В данном примере для  компонента <code>PickerField</code> объявлено <link linkend="standard_actions">стандартное действие</link> <code>lookup</code> и действие <code>show</code>, вызывающее метод <code>showColour()</code> контроллера. Так как в кнопках <code>PickerField</code>, отображающих действия, используются значки, а не надписи, атрибут <code>caption</code> явно установлен в пустую строку, иначе названием действия и заголовком кнопки стал бы идентификатор действия. Атрибут <code>description</code> позволяет отображать всплывающую подсказку при наведении мыши на кнопку действия.</para>
          </listitem>
        </itemizedlist></para>
      <para>Ссылки на любые декларативно объявленные действия можно получить в контроллере экрана либо непосредственно путем <link linkend="screen_controller_injection">инжекции</link>, либо из компонентов, реализующих интерфейс <code>Component.ActionsHolder</code>. Это может понадобиться для программной установки свойств действия. Например:<programlisting language="java">@Named(&quot;carsTable.create&quot;)
private CreateAction createAction;

@Named(&quot;carsTable.copy&quot;)
private Action copyAction;

@Inject
private PickerField colourField;

@Override
public void init(Map&lt;String, Object&gt; params) {
  Map&lt;String, Object&gt; values = new HashMap&lt;&gt;();
  values.put(&quot;type&quot;, CarType.PASSENGER);
  createAction.setInitialValues(values);

  copyAction.setEnabled(false);

  Action showAction = colourField.getAction(&quot;show&quot;);
  showAction.setEnabled(false);
}</programlisting></para>
    </section>
    <section id="standard_actions">
      <title>Стандартные действия</title>
      <para>Стандартные <link linkend="gui_Action">действия</link> - это классы, имплементирующие интерфейс <code>Action</code>, и предназначенные для решения типовых задач, таких как вызов экрана редактирования для сущности, выбранной в таблице. Стандартные действия имеют строго определенные идентификаторы, поэтому для декларативного объявления некоторого стандартного действия достаточно указать его идентификатор. </para>
      <para>Существует два вида стандартных действий:<itemizedlist>
          <listitem>
            <para><link linkend="list_actions">Действия с коллекцией</link> сущностей, отображаемой в  таблице или дереве.</para>
          </listitem>
          <listitem>
            <para><link linkend="picker_actions">Действия поля выбора</link> экземпляра сущности.</para>
          </listitem>
        </itemizedlist></para>
      <section id="list_actions">
        <title>Стандартные действия с коллекцией</title>
        <para>Для наследников <code>ListComponent</code> (это <link linkend="gui_Table">Table</link>, <link linkend="gui_GroupTable">GroupTable</link>, <link linkend="gui_TreeTable">TreeTable</link> и <link linkend="gui_Tree">Tree</link>)  набор стандартных действий определен в перечислении <code>ListActionType</code>, классы их реализации находятся в пакете <code>com.haulmont.cuba.gui.components.actions</code>. </para>
        <para>Пример использования стандартных действий в таблице:
          <programlisting language="xml"><xi:include href="../../source/gui/listActions_1.xml" encoding="UTF-8" parse="text"/></programlisting></para>
        <para>Рассмотрим их подробнее.</para>
        <section id="createAction">
          <title>CreateAction</title>
          <para><code>CreateAction</code> - действие с идентификатором <emphasis role="bold">create</emphasis>. Предназначено для создания нового экземляра сущности и открытия экрана редактирования для этого экземпляра. Если экран редактирования успешно закоммитил новый экземпляр в базу данных, то <code>CreateAction</code> добавляет этот новый экземпляр в источник данных таблицы и делает его выбранным. </para>
          <para>В классе <code>CreateAction</code> определены следующие специфические методы:
            <itemizedlist>
              <listitem>
                <para><code>setOpenType()</code> - позволяет задать режим открытия экрана редактирования новой сущности. По умолчанию экран открывается в режиме <code>THIS_TAB</code>. </para>
                <para>Так как довольно часто требуется открывать экраны редактирования в другом режиме (как правило, <code>DIALOG</code>), при декларативном создании действия <code>create</code> в элементе <code>action</code> можно указать атрибут <code>openType</code> с нужным значением. Это избавляет от необходимости получать ссылку на действие в контроллере и программно устанавливать данное свойство. Например:
                  <programlisting language="xml"><xi:include href="../../source/gui/createAction_1.xml" encoding="UTF-8" parse="text"/></programlisting>
                </para>
              </listitem>
              <listitem>
                <para><code>setWindowId()</code> - позволяет задать идентификатор экрана редактирования сущности. По умолчанию используется экран <code>{имя_сущности}.edit</code>, например <code>sales$Customer.edit</code>.</para>
              </listitem>
              <listitem>
                <para><code>setWindowParams()</code> - позволяет задать параметры экрана редактирования, передаваемые в его метод <code>init()</code>.</para>
              </listitem>
              <listitem>
                <para><code>setInitialValues()</code> - позволяет задать начальные значения атрибутов создаваемой сущности. Принимает объект  <code>Map</code>, в котором ключами являются имена атрибутов, а значениями - значения атрибутов. Например:
                  <programlisting language="java"><xi:include href="../../source/gui/createAction_2.java" encoding="UTF-8" parse="text"/></programlisting>
                </para>
                <para>Пример использования <code>setInitialValues()</code> приведен также в разделе <link linkend="init_values_in_CreateAction">рецептов разработки</link>.</para>
              </listitem>
              <listitem>
                <para><code>afterCommit()</code> -  вызывается действием после того, как экран редактирования успешно
                  закоммитил новую сущность и был закрыт.
                  Данный метод не имеет реализации и может быть переопределен в наследниках для реакции на это событие. </para>
              </listitem>
              <listitem>
                <para><code>setAfterCommitHandler()</code> - позволяет задать обработчик, который будет вызван
                  после того, как экран редактирования успешно закоммитил новую сущность и был закрыт. Данный обработчик
                  можно использовать вместо переопределения метода <code>afterCommit()</code>, тем самым избавившись от
                  необходимости создания наследника действия. Например:
                  <programlisting language="java"><xi:include href="../../source/gui/createAction_3.java" encoding="UTF-8" parse="text"/></programlisting>
                </para>
              </listitem>
              <listitem>
                <para><code>afterWindowClosed()</code> -  вызывается действием в последнюю очередь после закрытия экрана
                  редактирования, независимо от того, была ли закоммичена новая сущность или нет.
                  Данный метод не имеет реализации и может быть переопределен в наследниках для реакции на это событие. </para>
              </listitem>
              <listitem>
                <para><code>setAfterWindowClosedHandler()</code> - позволяет задать обработчик, который будет вызван
                  после закрытия экрана редактирования, независимо от того, была ли закоммичена новая сущность или нет. Данный обработчик
                  можно использовать вместо переопределения метода <code>afterWindowClosed()</code>, тем самым избавившись от
                  необходимости создания наследника действия.
                </para>
              </listitem>
            </itemizedlist>
          </para>
        </section>
        <section id="editAction">
          <title>EditAction</title>
          <para><code>EditAction</code> - действие с идентификатором <emphasis role="bold">edit</emphasis>. Открывает экран редактирования для выбранного экземпляра сущности. Если экран редактирования успешно закоммитил  экземпляр в базу данных, то <code>EditAction</code> обновляет этот экземпляр в источнике данных таблицы.</para>
          <para>В классе <code>EditAction</code> определены следующие специфические методы:<itemizedlist>
              <listitem>
                <para><code>setOpenType()</code> - позволяет задать режим открытия экрана редактирования  сущности. По умолчанию экран открывается в режиме <code>THIS_TAB</code>. </para>
                <para>Так как довольно часто требуется открывать экраны редактирования в другом режиме (как правило, <code>DIALOG</code>), при декларативном создании действия <code>edit</code> в элементе <code>action</code> можно указать атрибут <code>openType</code> с нужным значением. Это избавляет от необходимости получать ссылку на действие в контроллере и программно устанавливать данное свойство. Например:
                  <programlisting language="xml"><xi:include href="../../source/gui/editAction_1.xml" encoding="UTF-8" parse="text"/></programlisting>
                </para>
              </listitem>
              <listitem>
                <para><code>setWindowId()</code> - позволяет задать идентификатор экрана редактирования сущности. По умолчанию используется экран <code>{имя_сущности}.edit</code>, например <code>sales$Customer.edit</code>.</para>
              </listitem>
              <listitem>
                <para><code>setWindowParams()</code> - позволяет задать параметры экрана редактирования, передаваемые в его метод <code>init()</code>.</para>
              </listitem>
              <listitem>
                <para><code>afterCommit()</code> -  вызывается действием после того, как экран редактирования успешно закоммитил  сущность и был закрыт. Данный метод не имеет реализации и может быть переопределен в наследниках для реакции на это событие. </para>
              </listitem>
            <listitem>
              <para><code>setAfterCommitHandler()</code> - позволяет задать обработчик, который будет вызван
                после того, как экран редактирования успешно закоммитил новую сущность и был закрыт. Данный обработчик
                можно использовать вместо переопределения метода <code>afterCommit()</code>, тем самым избавившись от
                необходимости создания наследника действия. Например:
                <programlisting language="java"><xi:include href="../../source/gui/editAction_2.java" encoding="UTF-8" parse="text"/></programlisting>
              </para>
            </listitem>
              <listitem>
                <para><code>afterWindowClosed()</code> -  вызывается действием в последнюю очередь после закрытия экрана редактирования, независимо от того, была ли закоммичена редактируемая сущность. Данный метод не имеет реализации и может быть переопределен в наследниках для реакции на это событие. </para>
              </listitem>
            <listitem>
              <para><code>setAfterWindowClosedHandler()</code> - позволяет задать обработчик, который будет вызван
                после закрытия экрана редактирования, независимо от того, была ли закоммичена новая сущность или нет. Данный обработчик
                можно использовать вместо переопределения метода <code>afterWindowClosed()</code>, тем самым избавившись от
                необходимости создания наследника действия.
              </para>
            </listitem>
            </itemizedlist>
          </para>
        </section>
        <section id="removeAction">
          <title>RemoveAction</title>
          <para><code>RemoveAction</code> - действие с идентификатором <emphasis role="bold">remove</emphasis>. Предназначено для удаления выбранного экземпляра сущности.</para>
          <para>В классе <code>RemoveAction</code> определены следующие специфические методы:<itemizedlist>
              <listitem>
                <para><code>setAutocommit()</code> - позволяет управлять моментом удаления сущности из базы данных. По умолчанию после срабатывания действия и удаления сущности из источника данных у источника вызывается метод <code>commit()</code>, в результате чего сущность удаляется  из базы данных. Cвойство <code>autocommit</code> можно установить в <code>false</code> либо  методом <code>setAutocommit()</code>, либо соответствующим параметром конструктора. В результате после удаления сущности из источника данных для подтверждения удаления потребуется явно вызвать метод <code>commit()</code> источника данных.</para>
                <para>Значение <code>autocommit</code> не влияет на работу источников данных в режиме <code>Datasource.CommitMode.PARENT</code>, то есть тех, которые обеспечивают редактирование <link linkend="composition_annotation">композиционных</link> сущностей.</para>
              </listitem>
              <listitem>
                <para><code>setConfirmationMessage()</code> - позволяет задать текст сообщения в диалоге подтверждения удаления. </para>
              </listitem>
              <listitem>
                <para><code>setConfirmationTitle()</code> - позволяет задать заголовок диалога подтверждения удаления.</para>
              </listitem>
              <listitem>
                <para>
                  <code>afterRemove()</code> - вызывается действием после успешного удаления сущности. Данный метод не имеет реализации и может
                  быть переопределен в наследниках для реакции на это событие.
                </para>
              </listitem>
            <listitem>
              <para><code>setAfterRemoveHandler()</code> позволяет задать обработчик, который будет вызван
                после успешного удаления сущности. Данный обработчик
                можно использовать вместо переопределения метода <code>afterWindowClosed()</code>, тем самым избавившись от
                необходимости создания наследника действия. Например:
                <programlisting language="java"><xi:include href="../../source/gui/removeAction_1.java" encoding="UTF-8" parse="text"/></programlisting>
              </para>
            </listitem>
            </itemizedlist>
          </para>
        </section>
        <section id="refreshAction">
          <title>RefreshAction</title>
          <para><code>RefreshAction</code> - действие с идентификатором <emphasis role="bold">refresh</emphasis>. Предназначено для обновления (перезагрузки) коллекции сущностей. При срабатывании вызывает метод <code>refresh()</code> <link linkend="datasources">источника данных</link>, с которым связан компонент.</para>
          <para>В классе <code>RefreshAction</code> определены следующие специфические методы:<itemizedlist>
              <listitem>
                <para><code>setRefreshParams()</code> - позволяет задать параметры, передаваемые в метод <code>CollectionDatasource.refresh()</code>, для использования внутри <link linkend="datasource_query">запроса</link>. По умолчанию никакие параметры не передаются.</para>
              </listitem>
            </itemizedlist>
          </para>
        </section>
        <section id="addAction">
          <title>AddAction</title>
          <para><code>AddAction</code> - действие с идентификатором <emphasis role="bold">add</emphasis>. Предназначено для выбора существующего экземпляра сущности и добавления его в коллекцию. При срабатывании открывает <link linkend="screen_lookup">экран выбора</link> сущностей.</para>
          <para>В классе <code>AddAction</code> определены следующие специфические методы:<itemizedlist>
              <listitem>
                <para><code>setOpenType()</code> - позволяет задать режим открытия экрана выбора сущности. По умолчанию экран открывается в режиме <code>THIS_TAB</code>. </para>
                <para>Так как довольно часто требуется открывать экраны выбора в другом режиме (как правило, <code>DIALOG</code>), при декларативном создании действия <code>add</code> в элементе <code>action</code> можно указать атрибут <code>openType</code> с нужным значением. Это избавляет от необходимости получать ссылку на действие в контроллере и программно устанавливать данное свойство. Например:<programlisting language="xml">&lt;table id=&quot;usersTable&quot;&gt;
&lt;actions&gt;
  &lt;action id=&quot;add&quot; openType=&quot;DIALOG&quot;/&gt;</programlisting></para>
              </listitem>
              <listitem>
                <para><code>setWindowId()</code> - позволяет задать идентификатор экрана выбора сущности. По умолчанию используется экран <code>{имя_сущности}.lookup</code>, например <code>sales$Customer.lookup</code>. Если такого экрана не существует, то делается попытка открыть экран <code>{имя_сущности}.browse</code>, например <code>sales$Customer.browse</code>.</para>
              </listitem>
              <listitem>
                <para><code>setWindowParams()</code> - позволяет задать параметры экрана выбора, передаваемые в его метод <code>init()</code>.</para>
              </listitem>
              <listitem>
                <para><code>setHandler()</code> - позволяет задать объект, реализующий интерфейс <code>Window.Lookup.Handler</code>, передаваемый в экран выбора. По умолчанию используется объект класса <code>AddAction.DefaultHandler</code>.</para>
              </listitem>
            </itemizedlist></para>
        </section>
        <section id="excludeAction">
          <title>ExcludeAction</title>
          <para><code>ExcludeAction</code> - действие с идентификатором <emphasis role="bold">exclude</emphasis>. Позволяет исключать экземпляры сущности из коллекции, не удаляя их из базы данных.  Класс данного действия является наследником <code>RemoveAction</code>, однако при срабатывании вызывает у <code>CollectionDatasource</code> не <code>removeItem()</code>, а <code>excludeItem()</code>. Кроме того, для вложенных источников данных <code>ExcludeAction</code> разрывает связь с родительской сущностью, поэтому с помощью данного действия можно организовать редактирование ассоциации one-to-many. </para>
          <para>В классе <code>ExcludeAction</code> в дополнение к <code>RemoveAction</code> определены следующие специфические методы:<itemizedlist>
              <listitem>
                <para><code>setConfirm()</code> - показывать ли диалог подтверждения удаления. Это свойство можно также установить через конструктор действия. По умолчанию установлено в <code>false</code>.</para>
              </listitem>
            </itemizedlist></para>
        </section>
        <section id="excelAction">
          <title>ExcelAction</title>
          <para><code>ExcelAction</code> - действие с идентификатором <emphasis role="bold">excel</emphasis>. Предназначено для экспорта данных таблицы в формат XLS и выгрузки соответствующего файла. Данное действие можно связать только с компонентами <link linkend="gui_Table">Table</link>, <link linkend="gui_GroupTable">GroupTable</link> и <link linkend="gui_TreeTable">TreeTable</link>.</para>
          <para>При программном создании действия можно задать следующие параметры конструктора:<itemizedlist>
              <listitem>
                <para><code>display</code> - реализация интерфейса <code>ExportDisplay</code> для выгрузки файла. По умолчанию используется стандартная реализация.</para>
              </listitem>
              <listitem>
                <para><code>parameterized</code> - при установке в <code>true</code> действие отображает специальное окно с идентификатором <code>excelExport</code>, позволяющее пользователю выбрать колонки таблицы для экспорта.</para>
              </listitem>
            </itemizedlist>
          </para>
        </section>
      </section>
      <section id="picker_actions">
        <title>Стандартные действия поля выбора</title>
        <para>Для компонентов <link linkend="gui_PickerField">PickerField</link>,
          <link linkend="gui_LookupPickerField">LookupPickerField</link> и
          <link linkend="gui_SearchPickerField">SearchPickerField</link>
          набор стандартных действий определен в перечислении<code>PickerField.ActionType</code>. Реализации являются
          внутренними классами интерфейса <code>PickerField</code>.
        </para>
        <para>Пример использования стандартных действий в компоненте выбора:
          <programlisting language="xml"><xi:include href="../../source/gui/pickerActions_1.xml" encoding="UTF-8" parse="text"/></programlisting>
        </para>
        <section id="lookupAction">
          <title>LookupAction</title>
          <para><code>LookupAction</code> - действие с идентификатором <emphasis role="bold">lookup</emphasis>. Предназначено для выбора  экземпляра сущности и установки его в качестве значения компонента. При срабатывании открывает <link linkend="screen_lookup">экран выбора</link> сущностей.</para>
          <para>В классе <code>LookupAction</code> определены следующие специфические методы:<itemizedlist>
              <listitem>
                <para><code>setLookupScreenOpenType()</code> - позволяет задать режим открытия экрана выбора сущности. По умолчанию экран открывается в режиме <code>THIS_TAB</code>. </para>
              </listitem>
              <listitem>
                <para><code>setLookupScreenDialogParams</code>() - позволяет задать свойства дилогового окна при  открытия экрана выбора сущности в режиме <code>DIALOG</code> (см. предыдущий метод). На другие режимы влияния не оказывает. </para>
              </listitem>
              <listitem>
                <para><code>setLookupScreen()</code> - позволяет задать идентификатор экрана выбора сущности. По умолчанию используется экран <code>{имя_сущности}.lookup</code>, например <code>sales$Customer.lookup</code>. Если такого экрана не существует, то делается попытка открыть экран <code>{имя_сущности}.browse</code>, например <code>sales$Customer.browse</code>.</para>
              </listitem>
              <listitem>
                <para><code>setLookupScreenParams()</code> - позволяет задать параметры экрана выбора, передаваемые в его метод <code>init()</code>.</para>
              </listitem>
              <listitem>
                <para><code>afterSelect()</code> -  вызывается действием после того, как выбранный экземпляр установлен в качестве значения компонента. Данный метод не имеет реализации и может быть переопределен в наследниках для реакции на это событие. </para>
              </listitem>
              <listitem>
                <para><code>afterCloseLookup()</code> -  вызывается действием в последнюю очередь после закрытия экрана выбора, независимо от того, был сделан выбор или нет. Данный метод не имеет реализации и может быть переопределен в наследниках для реакции на это событие. </para>
              </listitem>
            </itemizedlist>
          </para>
        </section>
        <section id="clearAction">
          <title>ClearAction</title>
          <para><code>ClearAction</code>
            - действие с идентификатором <emphasis role="bold">clear</emphasis>. Предназначено для очистки (то есть
            установки в <code>null</code>) текущего значения компонента.
          </para>
        </section>
        <section id="openAction">
          <title>OpenAction</title>
          <para><code>OpenAction</code> - действие с идентификатором <emphasis role="bold">open</emphasis>. Предназначено для  открытия экрана редактирования экземпляра сущности, являющегося текущим значением компонента. </para>
          <para>В классе <code>OpenAction</code> определены следующие специфические методы:<itemizedlist>
              <listitem>
                <para><code>setEditScreenOpenType()</code> - позволяет задать режим открытия экрана редактирования сущности. По умолчанию экран открывается в режиме <code>THIS_TAB</code>. </para>
              </listitem>
              <listitem>
                <para><code>setEditScreenDialogParams()</code> - позволяет задать свойства дилогового окна при  открытия экрана редактирования в режиме <code>DIALOG</code> (см. предыдущий метод). На другие режимы влияния не оказывает. </para>
              </listitem>
              <listitem>
                <para><code>setEditScreen()</code> - позволяет задать идентификатор экрана редактирования сущности. По умолчанию используется экран <code>{имя_сущности}.edit</code>, например <code>sales$Customer.edit</code>. </para>
              </listitem>
              <listitem>
                <para><code>setEditScreenParams()</code> - позволяет задать параметры экрана редактирования, передаваемые в его метод <code>init()</code>.</para>
              </listitem>
              <listitem>
                <para><code>afterWindowClosed()</code> -  вызывается действием после закрытия экрана редактирования. Данный метод не имеет реализации и может быть переопределен в наследниках для реакции на это событие. </para>
              </listitem>
            </itemizedlist></para>
        </section>
      </section>
    </section>
    <section id="baseAction">
      <title>BaseAction</title>
      <para><code>BaseAction</code> - базовый класс реализации <link linkend="gui_Action">действий</link>. От него
          рекомендуется наследовать собственные нестандартные действия, если возможностей
          <link linkend="declarative_actions">декларативного создания действий</link> не хватает. </para>
      <para>При создании конкретного класса действия необходимо определить метод <code>actionPerform()</code> и передать
          в конструктор <code>BaseAction</code> идентификатор действия. Можно также переопределить любые методы получения
          свойств действия: <code>getCaption()</code>, <code>getDescription()</code>, <code>getIcon()</code>,
          <code>getShortcut()</code>, <code>isEnabled()</code>, <code>isVisible()</code>. Стандартные реализации этих
          методов возвращают значения, установленные соответствующими set-методами. Исключение составляет метод
          <code>getCaption()</code>: если название действия  явно не установлено методом <code>setCaption()</code>, то
          он обращается в <link linkend="message_packs">пакет локализованных сообщений</link> с именем, соответствующим
          пакету класса действия, и возвращает сообщение с ключом, равным идентификатору действия. Если сообщения с
          таким ключом нет, то возвращается сам ключ, то есть идентификатор действия. </para>
        <para><code>BaseAction</code> может изменять свои свойства <code>enabled</code> и <code>visible</code> в
            соответствии с <link linkend="permissions">разрешениями</link> пользователя и текущим контекстом.</para>
        <para><code>BaseAction</code> видим (visible), если:
          <itemizedlist>
              <listitem><para>метод <code>setVisible(false)</code> не вызывался;</para></listitem>
              <listitem><para>для действия не установлено UI разрешение <userinput>hide</userinput>.</para></listitem>
          </itemizedlist>
        </para>
        <para>Действие разрешено (enabled), если:
            <itemizedlist>
                <listitem><para>метод <code>setEnabled(false)</code> не вызывался;</para></listitem>
                <listitem><para>для действия не установлено UI разрешений <userinput>hide</userinput> или <userinput>read-only</userinput>;</para></listitem>
                <listitem><para>метод <code>isPermitted()</code> возвращает true;</para></listitem>
                <listitem><para>метод <code>isApplicable()</code> возвращает true.</para></listitem>
            </itemizedlist>
        </para>
      <para>Примеры использования:<itemizedlist>
          <listitem>
            <para>Действие кнопки:
                <programlisting language="java"><xi:include href="../../source/gui/baseAction_1.java" encoding="UTF-8" parse="text"/></programlisting>
                В данном случае кнопка <code>helloBtn</code> получит в качестве заголовка строку, находящуюся в пакете
                сообщений с ключом <code>hello</code>. Для того, чтобы получить название кнопки каким-либо иным способом,
                можно переопределить метод <code>getCaption()</code> действия.</para>
          </listitem>
          <listitem>
            <para>Действие кнопки программно создаваемого <link linkend="gui_PickerField">PickerField</link>:
                <programlisting language="java"><xi:include href="../../source/gui/baseAction_2.java" encoding="UTF-8" parse="text"/></programlisting>
                Здесь анонимный класс-наследник <code>BaseAction</code> используется для задания действия кнопки поля
                выбора. Заголовок кнопки не отображается, вместо него используется значок и описание, всплывающее  при
                наведении курсора мыши.</para>
          </listitem>
          <listitem>
            <para>Действие таблицы:
                <programlisting language="java"><xi:include href="../../source/gui/baseAction_3.java" encoding="UTF-8" parse="text"/></programlisting>
                Здесь объявлен класс <code>HelloAction</code>, экземпляр которого добавляется в список действий таблицы.
                Действие разрешено пользователям, имеющим специфическое разрешение <userinput>myapp.allow-greeting</userinput>,
                и только когда выбрана одна строка таблицы. Последнее условие реализуется с помощью свойства
                <code>target</code> действия, которое автоматически устанавливается когда действие добавляется в
                <code>ListComponent</code> (<code>Table</code> или <code>Tree</code>).
            </para>
          </listitem>
          <listitem>
              <para>Если необходимо действие, которое доступно, когда выделены одна или более строк таблицы,
                  удобно воспользоваться наследником <code>BaseAction</code> - классом <code>ItemTrackingAction</code>,
                  который добавляет стандартную реализацию метода <code>isApplicable()</code>:
                  <programlisting language="java"><xi:include href="../../source/gui/baseAction_4.java" encoding="UTF-8" parse="text"/></programlisting>
                  </para>
          </listitem>
        </itemizedlist></para>
    </section>
  </section>
  <section id="dialogs_and_notifications">
    <title>Диалоговые окна и уведомления</title>
    <para>Для вывода сообщений пользователю можно использовать диалоговые окна и уведомления. </para>
    <para>Диалоговые окна имеют заголовок с кнопкой закрытия и отображаются всегда в центре главного окна приложения. Уведомления могут отображаться как в центре, так и в углу приложения, и автоматически исчезать.</para>
    <section id="dialogs">
      <title>Диалоговые окна</title>
      <para>Диалоговые окна вызываются методами  <code>showMessageDialog()</code> и <code>showOptionDialog()</code> интерфейса <code>IFrame</code>. Этот интерфейс реализуется <link linkend="screen_controller">контроллером экрана</link>, поэтому данные методы можно вызывать напрямую в коде контроллера.</para>
      <itemizedlist>
        <listitem>
          <para><code>showMessageDialog()</code> предназначен для отображения сообщения. Метод принимает следующие параметры:<itemizedlist>
              <listitem>
                <para><code>title</code> - заголовок диалогового окна.</para>
              </listitem>
              <listitem>
                <para><code>message</code> - сообщение. В случае HTML-типа (см. ниже) в сообщении можно использовать
                    теги HTML для форматирования. При использовании HTML обязательно экранируйте данных из БД во
                    избежание code injection в веб-клиенте. В не-HTML сообщениях можно использовать символы <code>\n</code>
                    для переноса строки. </para>
              </listitem>
              <listitem>
                <para><code>messageType</code> - тип сообщения. Возможные типы:<itemizedlist>
                    <listitem>
                      <para><code>CONFIRMATION</code>, <code>CONFIRMATION_HTML</code> - диалог подтверждения. </para>
                    </listitem>
                    <listitem>
                      <para><code>WARNING</code>, <code>WARNING_HTML</code> - диалог преупреждения.</para>
                    </listitem>
                  </itemizedlist></para>
                <para>Различие типов сообщений отражается только в пользовательском интерфейсе десктоп-приложений.</para>
              </listitem>
            </itemizedlist>Пример вызова диалога:<programlisting language="java">showMessageDialog(&quot;Warning&quot;, &quot;Something is wrong&quot;, MessageType.WARNING);</programlisting></para>
        </listitem>
        <listitem>
          <para><code>showOptionDialog()</code> предназначен для отображения сообщения и кнопок для выбора пользователем. Метод в дополнение к параметрам, описанным для <code>showMessageDialog()</code>, принимает массив или список <link linkend="gui_Action">действий</link>. Для каждого действия в диалоге создается кнопка, при нажатии на которую пользователем диалог закрывается и вызывается метод <code>actionPerform()</code> данного действия.</para>
          <para>В качестве кнопок со стандартными названиями и значками удобно использовать анонимные классы, унаследованные от <code>DialogAction</code>. Поддерживаются пять видов действий, определяемых перечислением <code>DialogAction.Type</code>: <code>OK</code>, <code>CANCEL</code>, <code>YES</code>, <code>NO</code>, <code>CLOSE</code>. Названия соответствующих кнопок извлекаются из <link linkend="main_message_pack">главного пакета</link> локализованных сообщений.</para>
          <para>Пример вызова диалога с кнопками <guibutton>Да</guibutton> и <guibutton>Нет</guibutton> и с заголовком и сообщением, взятыми из пакета локализованных сообщений текущего экрана:<programlisting language="java">showOptionDialog(
      getMessage(&quot;confirmCopy.title&quot;),
      getMessage(&quot;confirmCopy.msg&quot;),
      MessageType.CONFIRMATION,
      new Action[]{
              new DialogAction(DialogAction.Type.YES) {
                  public void actionPerform(Component component) {
                      copySettings();
                  }
              },
              new DialogAction(DialogAction.Type.NO)
      }
);</programlisting></para>
        </listitem>
      </itemizedlist>
    </section>
    <section id="notifications">
      <title>Уведомления</title>
      <para>Уведомления вызываются методом <code>showNotification()</code> интерфейса <code>IFrame</code>. Этот интерфейс реализуется <link linkend="screen_controller">контроллером экрана</link>, поэтому данный метод можно вызывать напрямую в коде контроллера.</para>
      <para>Метод <code>showNotification()</code> принимает следующие параметры:<itemizedlist>
          <listitem>
            <para><code>caption</code> - текст уведомления. В случае HTML-типа (см. ниже) в сообщении можно использовать
                теги HTML для форматирования. При использовании HTML обязательно экранируйте данных из БД во избежание
                code injection в веб-клиенте. В не-HTML сообщениях можно использовать символы <code>\n</code>
                для переноса строки.</para>
          </listitem>
          <listitem>
            <para><code>description</code> - опциональное описание, которое будет отображено ниже <code>caption</code>.
                Также можно использовать символы <code>\n</code> или HTML-форматирование.</para>
          </listitem>
          <listitem>
            <para><code>type</code> - тип уведомления. Возможные типы:<itemizedlist>
                <listitem>
                  <para><code>TRAY</code>, <code>TRAY_HTML</code> - уведомление показывается в правом нижнем углу приложения и исчезает автоматически. </para>
                </listitem>
                <listitem>
                  <para><code>HUMANIZED</code>, <code>HUMANIZED_HTML</code> - стадартное уведомление в центре экрана, исчезает автоматически.</para>
                </listitem>
                <listitem>
                  <para><code>WARNING</code>, <code>WARNING_HTML</code> - предупреждение. Исчезает при клике пользователя.</para>
                </listitem>
                <listitem>
                  <para><code>ERROR</code>, <code>ERROR_HTML</code> - уведомление об ошибке. Исчезает при клике пользователя.</para>
                </listitem>
              </itemizedlist></para>
          </listitem>
        </itemizedlist></para>
      <para>Примеры вызова уведомлений:<programlisting language="java">showNotification(getMessage(&quot;selectBook.text&quot;), NotificationType.HUMANIZED);

showNotification(&quot;Validation error&quot;, &quot;&lt;b&gt;Date&lt;/b&gt; is incorrect&quot;, NotificationType.TRAY_HTML);</programlisting></para>
    </section>
  </section>
  <section id="background_tasks">
    <title>Фоновые задачи</title>
    <para>Фоновые задачи используются на клиентском уровне для асинхронного выполнения длительных операций без заморозки пользовательского интерфейса. </para>
    <section><title>Использование фоновых задач</title><orderedlist>
        <listitem>
          <para>Задача описывается как наследник абстрактного класса <code>BackgroundTask</code>. В конструктор задачи необходимо передать ссылку на контроллер экрана, с которым будет связана задача, и значение таймаута ее выполнения.</para>
          <para>Если экран указан, то при его закрытии пользователем активная задача будет прервана. Кроме того, задача будет автоматически прервана по истечении указанного таймаута.</para>
          <para>Собственно действия, выполняемые задачей, реализуются в методе <code>run()</code>.</para>
        </listitem>
        <listitem>
          <para>Создается объект управления задачей − <code>BackgroundTaskHandler</code>. Для этого экземпляр задачи необходимо передать методу <code>handle()</code> бина <code>BackgroundWorker</code>. Ссылку на <code>BackgroundWorker</code> можно получить инжекцией в <link linkend="screen_controller">контроллер экрана</link>, либо статическим методом класса <code>AppBeans</code>.</para>
        </listitem>
        <listitem>
          <para>Выполняется запуск задачи.</para>
        </listitem>
      </orderedlist>Пример:<programlisting language="java">@Inject
protected BackgroundWorker backgroundWorker;

@Override
public void init(Map&lt;String, Object&gt; params) {
  // Create task with 10 sec timeout and this screen as owner
  BackgroundTask&lt;Integer, Void&gt; task = new BackgroundTask&lt;Integer, Void&gt;(10, this) {
      @Override
      public Void run(TaskLifeCycle&lt;Integer&gt; taskLifeCycle) throws Exception {
          // Do something in background thread
          for (int i = 0; i &lt; 5; i++) {
              TimeUnit.SECONDS.sleep(1); // time consuming computations
              taskLifeCycle.publish(i); // publish current progress to show it in progress() method
          }
          return null;
      }

      @Override
      public void canceled() {
          // Do something in UI thread if the task is canceled
      }

      @Override
      public void done(Void result) {
          // Do something in UI thread when the task is done
      }

      @Override
      public void progress(List&lt;Integer&gt; changes) {
          // Show current progress in UI thread
      }
  };
  // Get task handler object and run the task
  BackgroundTaskHandler taskHandler = backgroundWorker.handle(task);
  taskHandler.execute();
}</programlisting><para>Подробная информация о назначении методов приведена в JavaDocs классов <code>BackgroundTask</code>, <code>TaskLifeCycle</code>, <code>BackgroundTaskHandler</code>. </para><para>Ниже приведены моменты, на которые следует обратить внимание:</para><itemizedlist>
        <listitem>
          <para><code>BackgroundTask&lt;T, V&gt;</code> − параметризованный класс:</para>
          <itemizedlist>
            <listitem>
              <para><code>T</code> − тип объектов, показывающих прогресс задачи. Объекты этого типа передаются в метод <code>progress()</code> задачи при вызове <code>TaskLifeCycle.publish()</code> в рабочем потоке.</para>
            </listitem>
            <listitem>
              <para><code>V</code> − тип результата задачи, он передается в метод <code>done()</code>. Его также можно получить вызовом метода  <code>BackgroundTaskHandler.getResult()</code>, что приведет к ожиданию завершения задачи.</para>
            </listitem>
          </itemizedlist>
        </listitem>
        <listitem>
          <para>Метод <code>canceled()</code> вызывается только в случае управляемой отмены задачи, то есть при вызове <code>cancel()</code> у <code>TaskHandler</code>.</para>
        </listitem>
        <listitem>
          <para>Если у задачи истек таймаут, или было закрыто окно, в котором она исполнялась, то задача будет завершена без уведомлений. В блоке <structname>Web Client</structname> завершение по таймауту производится с задержкой, задаваемой свойством приложения <property>
              <link linkend="cuba.backgroundWorker.maxClientLatencySeconds">cuba.backgroundWorker.maxClientLatencySeconds</link>
            </property>.</para>
        </listitem>
        <listitem>
          <para>Метод <code>run()</code> задачи должен поддерживать возможность прерывания извне. Для этого в долгих процессах желательно периодически проверять флаг <code>TaskLifeCycle.isInterrupted()</code>, и соответственно завершать выполнение. Кроме того, нельзя тихо проглатывать исключение <code>InterruptedException</code> (или вообще все исключения). Вместо этого нужно либо вообще не перехватывать его, либо выполнять корректный выход из метода.</para>
        </listitem>
        <listitem>
          <para>Объекты <code>BackgroundTask</code> не имеют состояния. Если при реализации конкретного класса задачи не заводить полей для хранения промежуточных данных, то можно запускать несколько параллельно работающих процессов, используя единственный экземпляр задачи.</para>
        </listitem>
        <listitem>
          <para>Объект <code>BackgroundHandler</code> можно запускать (т.е. вызывать его метод <code>execute()</code>) всего один раз. Если требуется частый перезапуск задачи, то используйте класс <code>BackgroundTaskWrapper</code>.</para>
        </listitem>
        <listitem>
          <para>Для  показа пользователю модального окна с прогрессом и кнопкой <guibutton>Отмена</guibutton> используйте классы <code>BackgroundWorkWindow</code> или <code>BackgroundWorkProgressWindow</code> с набором статических методов.
Для окна можно задать режим отображения прогресса и разрешить или запретить отмену фоновой задачи.</para>
        </listitem>
        <listitem>
          <para>Если внутри потока задачи необходимо использовать некоторые значения визуальных компонентов, то нужно реализовать их получение в  методе <code>getParams()</code>, который выполняется  в потоке UI один раз при запуске задачи. В методе <methodname>run()</methodname> эти параметры будут доступны через метод <code>getParams()</code>  объекта <code>TaskLifeCycle</code>.</para>
        </listitem>
        <listitem>
          <para>При возникновении исключительных ситуаций в потоке UI вызывается метод <code>BackgroundTask.handleException()</code>,  в котором можно отобразить ошибку.</para>
        </listitem>
      </itemizedlist></section>
    <section>
      <title>Настройка окружения</title>
      <para>Для корректной работы фоновых задач в проекте приложения необходимо произвести следующие настройки:</para>
      <itemizedlist>
        <listitem>
          <para>Прерывание задач по таймауту реализуется бином <code>WatchDog</code>. Для его периодического вызова в файлы <filename>
              <link linkend="spring.xml">spring.xml</link>
            </filename> блоков <structname>Web Client</structname> и <structname>Desktop Client</structname> необходимо добавить следующее объявление:<programlisting language="xml">&lt;bean id=&quot;backgroundWorkerScheduler&quot; class=&quot;org.springframework.scheduling.concurrent.ThreadPoolTaskScheduler&quot;&gt;
  &lt;property name=&quot;daemon&quot; value=&quot;true&quot;/&gt;
  &lt;property name=&quot;poolSize&quot; value=&quot;1&quot;/&gt;
&lt;/bean&gt;

&lt;task:scheduled-tasks scheduler=&quot;backgroundWorkerScheduler&quot;&gt;
  &lt;task:scheduled ref=&quot;cuba_BackgroundWorker_WatchDog&quot; method=&quot;cleanupTasks&quot; fixed-delay=&quot;2000&quot;/&gt;
&lt;/task:scheduled-tasks&gt; </programlisting></para>
        </listitem>
        <listitem>
          <para>В блоке <structname>Web Client</structname> опрос состояния задачи инициируется клиентским кодом, выполняющимся в  веб-браузере. Периодичность опроса задается свойством приложения <property>
              <link linkend="cuba.backgroundWorker.uiCheckInterval">cuba.backgroundWorker.uiCheckInterval</link>
            </property>, по умолчанию - 2 сек.</para>
          <para>Кроме того, на выполнение фоновых задач в блоке <structname>Web Client</structname> влияют свойства приложения <property>
              <link linkend="cuba.backgroundWorker.maxActiveTasksCount">cuba.backgroundWorker.maxActiveTasksCount</link>
            </property> и <property>
              <link linkend="cuba.backgroundWorker.maxClientLatencySeconds">cuba.backgroundWorker.maxClientLatencySeconds</link>
            </property>.</para>
        </listitem>
      </itemizedlist>
    </section>
  </section>
  <section id="gui_themes">
    <title>Создание темы приложения</title>
    <para>Тема служит для управления визуальным представлением приложения. </para>
    <section id="web_theme">
      <title>Тема в веб-приложениях</title>
      <para>Тема веб-приложения состоит из файлов SCSS и других ресурсов, в том числе файлов изображений.</para>
      <section id="web_theme_usage">
        <title>Использование существующих тем</title>
        <para>Платформа включает в себя две готовые темы: Halo и Havana. Приложение будет по умолчанию использовать ту из них, которая указана в свойстве приложения <link linkend="cuba.web.theme">cuba.web.theme</link>. Пользователь может выбрать другую доступную тему в стандартном экране <guimenu>Help</guimenu> -&gt; <guimenu>Settings</guimenu>. Если вы не хотите, чтобы пользователи имели возможность сами выбирать тему, зарегистрируйте экран <code>settings</code> в файле <link linkend="screens.xml">web-screens.xml</link> проекта с параметром <code>changeThemeEnabled = false</code>:
        <programlisting language="xml">&lt;screen id=&quot;settings&quot; template=&quot;/com/haulmont/cuba/web/app/ui/core/settings/settings-window.xml&quot;&gt;
  &lt;param name=&quot;changeThemeEnabled&quot; value=&quot;false&quot;/&gt;
&lt;/screen&gt;          </programlisting></para>
        <para>При использовании существующих тем можно настроить некоторые параметры фирменного стиля (branding): пиктограммы и заголовки окна логина и главного окна, пиктограмму вебсайта <filename>favicon.ico</filename>. Для этого необходимо выполнить следующее:<orderedlist>
            <listitem>
              <para>Создайте следующую файловую структуру внутри каталога <filename>modules/web</filename> проекта:<programlisting>VAADIN/
themes/
  havana/
    branding/
      myapp-login.png
      myapp-menu.png
    favicon.ico</programlisting></para>
              <para>Здесь <filename>havana</filename> - каталог с именем используемой темы, <filename>favicon.ico</filename> - пиктограмма вебсайта, <filename>myapp-login.png</filename> - изображение для окна логина, <filename>myapp-menu.png</filename> - изображение для главного окна. </para>
            </listitem>
            <listitem>
              <para>В <application>CUBA Studio</application> откройте <guimenu>Project properties</guimenu> -&gt; <guimenu>Edit</guimenu> и нажмите кнопку <guibutton>Branding</guibutton> внизу страницы. Используя  ссылки <guibutton>Set application logo image</guibutton> и <guibutton>Set login window logo image</guibutton> задайте путь к файлам пиктограмм соответственно главного окна и окна логина. Путь указывается относительно каталога темы. Остальные ссылки служат для задания заголовков окон и текста приглашения окна логина.</para>
              <para>Данные параметры сохраняются в <link linkend="main_message_pack">главном пакете сообщений</link> модуля <structname>gui</structname> (то есть в файле <filename>modules/gui/&lt;root_package&gt;/gui/messages.properties</filename> и его вариантах для разных локалей). Использование пакетов сообщений дает возможность использовать разные файлы изображений для разных локалей пользователей. Пример содержимого файла <filename>messages.properties</filename>:<programlisting>application.caption = MyApp
application.logoImage = branding/myapp-menu.png

loginWindow.caption = MyApp Login
loginWindow.welcomeLabel = Welcome to MyApp!
loginWindow.logoImage = branding/myapp-login.png</programlisting></para>
              <para>Путь к <code>favicon.ico</code> указывать не нужно, он должен обязательно находится в корне каталога с именем темы.</para>
            </listitem>
          </orderedlist>В существующую тему можно также добавить файлы изображений для использования в свойствах <link linkend="gui_attr_basic_icon">icon</link> <link linkend="gui_Action">действий</link> и визуальных компонентов, например <link linkend="gui_Button">Button</link>. </para>
        <para>Например, чтобы добавить в тему Havana пиктограмму, достаточно в описанный выше каталог <filename>modules/web/VAADIN/themes/havana</filename>  добавить файл изображения (желательно в некоторый подкаталог): <programlisting>VAADIN/
themes/
  havana/
    images/
      address-book.png</programlisting>После этого можно использовать эту пиктограмму, указывая в свойстве <code>icon</code> путь к ней относительно каталога темы:<programlisting language="xml">&lt;action id=&quot;adresses&quot;
      icon=&quot;images/address-book.png&quot;/&gt;</programlisting></para>
        <para>Вместо файлов изображений для пиктограмм можно использовать элементы шрифта <ulink url="http://fortawesome.github.io/Font-Awesome">Font Awesome</ulink>. Для этого достаточно указать в свойстве <code>icon</code> имя нужной константы перечисления <code>com.vaadin.server.FontAwesome</code> с префиксом <code>font-icon:</code>, например:
          <programlisting language="xml">&lt;action id=&quot;adresses&quot;
      icon=&quot;font-icon:BOOK&quot;/&gt;</programlisting></para>
        <para>В  проекте можно заменить изображения, используемые в стандартных действиях и экранах платформы. Для замены пиктограммы темы Havana достаточно положить в каталог <filename>modules/web/VAADIN/themes/havana/icons</filename> проекта нужный файл изображения. Например, для замены пиктограммы стандартного действия <code>create</code> это будет файл с именем  <filename>create.png</filename> (имя файла легко определить по URL соответствующего  HTML-элемента <code>img</code> в работающем приложении):<programlisting>VAADIN/
themes/
  havana/
    icons/
      create.png</programlisting></para>
        <para>В теме Halo по умолчанию (при включенном свойстве приложения <link linkend="cuba.web.useFontIcons">cuba.web.useFontIcons</link>) пиктограммы стандартных действий и экранов платформы загружаются из  шрифта <application>Font Awesome</application>. В этом случае заменить стандартную пиктограмму можно только создав свою тему на базе Halo (см. <link linkend="web_theme_creation">далее</link>) и задав в файле <filename>&lt;your_theme&gt;-theme.properties</filename> нужное соответствие между именем пиктограммы и именем элемента шрифта, например:<programlisting>cuba.web.icons.create.png = PLUS</programlisting></para>
        <para>При выключенном свойстве <code>cuba.web.useFontIcons</code> пиктограммы стандартных действий и экранов платформы для темы Halo загружаются так же, как и для темы Havana - из файлов изображений в подкаталоге <filename>icons</filename>. Поэтому их можно заменить описанным для Havana способом.</para>
        <para>Тема Halo поддерживает свойство приложения <link linkend="cuba.web.useInverseHeader">cuba.web.useInverseHeader</link>, управляющее цветом заголовка приложения. По умолчанию это свойство установлено в <code>true</code>, что задает темный (инверсный) заголовок. В проекте можно не изменяя темы сделать заголовок светлым, установив данное свойство в <code>false</code>.</para>
      </section>
      <section id="web_theme_extension">
        <title>Расширение существующей темы</title>
        <para>Существующая в платформе тема может быть изменена в  проекте приложения. Тема описывается в файлах <ulink url="http://sass-lang.com">SCSS</ulink> в определенной файловой структуре, поэтому простейший способ адаптации - изменение базовых переменных SCSS, влияющих на цвет фона, размеры компонентов и отступы между ними. Для изменения параметров отдельных компонентов требуется знание CSS.</para>
        <para>Для адаптации (расширения) темы в проекте необходимо создать специальную файловую структуру в модуле <structname>web</structname>. Это удобно сделать с помощью <application>CUBA Studio</application>: откройте секцию <guimenu>Project properties</guimenu> и нажмите ссылку <guibutton>Create theme extension</guibutton>. В диалоговом окне выберите тему, которую вы хотите расширить. В результате в проекте будет создана структура каталогов, аналогичная описанной в <link linkend="web_theme_usage">предыдущем</link> разделе. Кроме того, скрипт сборки <link linkend="build.gradle">build.gradle</link> будет дополнен задачей <code>buildScssThemes</code>, автоматически запускаемой при сборке модуля <structname>web</structname>.</para>
        <para>Рассмотрим пример расширения  темы Halo, так как она основана на теме <ulink url="https://vaadin.com/valo">Valo</ulink> фреймворка <application>Vaadin</application>, и предоставляет максимальные возможности адаптации.</para>
        <para>Файл <filename>themes/halo/halo-ext-defaults.scss</filename> предназначен для размещения в нем переменных темы. Большинство переменных Halo соответствует описанным в <ulink url="https://vaadin.com/api/valo">документации по Valo</ulink>, ниже приведены основные:<programlisting language="">$v-background-color: #fafafa;        /* цвет фона компонентов */
$v-app-background-color: #e7ebf2;    /* цвет фона приложения */
$v-panel-background-color: #fff;     /* цвет фона панелей */
$v-focus-color: #3b5998;             /* цвет выделения компонентов в фокусе */
$v-error-indicator-color: #ed473b;   /* цвет выделения обязательных незаполненных полей */

$v-line-height: 1.35;                /* высота строк */
$v-font-size: 14px;                  /* размер шрифта */
$v-font-weight: 400;                 /* начертание шрифта */
$v-unit-size: 30px;                  /* базовый размер темы, определяет высоту кнопок, полей и другие размеры компонентов */

$v-font-size--h1: 24px;              /* размер шрифта Label со стилем h1 */
$v-font-size--h2: 20px;              /* размер шрифта Label со стилем h2 */
$v-font-size--h3: 16px;              /* размер шрифта Label со стилем h3 */

/* размеры отступов margin для контейнеров */
$v-layout-margin-top: 10px;
$v-layout-margin-left: 10px;
$v-layout-margin-right: 10px;
$v-layout-margin-bottom: 10px;

/* размер отступа между компонентами в контейнере с включенной опцией spacing */
$v-layout-spacing-vertical: 10px;
$v-layout-spacing-horizontal: 10px;

/* базовые размеры для строк таблицы */
$v-table-row-height: 30px;
$v-table-header-font-size: 13px;
$v-table-cell-padding-horizontal: 7px;

/* стиль фокуса для полей ввода */
$v-focus-style: inset 0px 0px 5px 1px rgba($v-focus-color, 0.5);
/* стиль, применяемый к обязательным полям ввода в фокусе */
$v-error-focus-style: inset 0px 0px 5px 1px rgba($v-error-indicator-color, 0.5);

/* анимация элементов по умолчанию включена */
$v-animations-enabled: true;
/* анимация всплывающих окон по умолчанию выключена */
$v-window-animations-enabled: false;

/* инверсный заголовок управляется свойством cuba.web.useInverseHeader */
$v-support-inverse-menu: true;</programlisting></para>
        <para>Пример содержимого файла <filename>halo-ext-defaults.scss</filename> для темы с темным фоном и немного уменьшенными отступами:<programlisting>$v-background-color: #444D50;

$v-font-size--h1: 22px;
$v-font-size--h2: 18px;
$v-font-size--h3: 16px;

$v-layout-margin-top: 8px;
$v-layout-margin-left: 8px;
$v-layout-margin-right: 8px;
$v-layout-margin-bottom: 8px;

$v-layout-spacing-vertical: 8px;
$v-layout-spacing-horizontal: 8px;

$v-table-row-height: 25px;
$v-table-header-font-size: 13px;
$v-table-cell-padding-horizontal: 5px;

$v-support-inverse-menu: false;</programlisting>Для изменения параметров отдельных компонентов необходимо добавить соответствующий код CSS в блок <code>@mixin halo-ext {...}</code> файла <filename>halo-ext.scss</filename>. Например, для того, чтобы пункты главного меню отображались жирным шрифтом, содержимое файла <filename>halo-ext.scss</filename> должно быть следующим:<programlisting language="">@import &quot;../halo/halo&quot;;

@mixin halo-ext {
@include halo;

.v-menubar-menuitem-caption {
  font-weight: bold;
}
}</programlisting></para>
      </section>
      <section id="web_theme_creation">
        <title>Создание новой темы</title>
        <para>В проекте можно создать одну или несколько новых  тем и дать возможность пользователям выбирать среди них подходящую. Создание новой темы позволяет также переопределять переменные файла <filename>*-theme.properties</filename>, задающие некоторые параметры, требуемые на стороне сервера:<itemizedlist>
            <listitem>
              <para>Размеры диалоговых окон по умолчанию.</para>
            </listitem>
            <listitem>
              <para>Ширина полей ввода  по умолчанию.</para>
            </listitem>
            <listitem>
              <para>Размеры некоторых компонентов (<link linkend="gui_Filter">Filter</link>, <link linkend="gui_FileMultiUploadField">FileMultiUploadField</link>).</para>
            </listitem>
            <listitem>
              <para>Соответствие между именами пиктограмм и именами констант перечисления <code>com.vaadin.server.FontAwesome</code> для использования элементов шрифта <application>Font Awesome</application> в стандартных действиях и экранах платформы при включенном свойстве <link linkend="cuba.web.useFontIcons">cuba.web.useFontIcons</link>.</para>
            </listitem>
          </itemizedlist></para>
        <para>Рассмотрим пример создания на основе Halo новой темы Facebook, напоминающей интерфейс сайта известной социальной сети.<orderedlist>
            <listitem>
              <para>В <application>CUBA Studio</application> откройте секцию <guimenu>Project properties</guimenu> и нажмите ссылку <guibutton>Create theme extension</guibutton>. В диалоговом окне выберите <code>halo</code> и нажмите <guibutton>Create</guibutton>. В проекте будет создано расширение темы Halo, как описано в предыдущем разделе.</para>
            </listitem>
            <listitem>
              <para>Переименуйте созданный в модуле <structname>web</structname> каталог <filename>themes/halo</filename> в <filename>themes/facebook</filename>, внутри него файл <filename>halo-ext.scss</filename> переименуйте в <filename>facebook.scss</filename>, <filename>halo-ext-defaults.scss</filename> в <filename>facebook-defaults.scss</filename>.</para>
            </listitem>
            <listitem>
              <para>Отредактируйте файл <filename>styles.scss</filename>, заменив в нем импорты <code>halo-ext</code>  и корневой селектор <code>halo</code>:<programlisting language="">@import &quot;halo-defaults&quot;;
@import &quot;facebook-defaults&quot;;
@import &quot;facebook&quot;;

.facebook {
@include facebook;
}

.v-theme-version {
display: none;
}</programlisting></para>
            </listitem>
            <listitem>
              <para>Отредактируйте файл  <filename>facebook.scss</filename>, заменив в нем <code>@mixin halo-ext</code>:<programlisting language="">@import &quot;../halo/halo&quot;;

@mixin facebook {
@include halo;
}</programlisting></para>
            </listitem>
            <listitem>
              <para>Поместите в файл <filename>facebook-defaults.scss</filename> следующие переменные:<programlisting>$v-background-color: #fafafa;
$v-app-background-color: #e7ebf2;
$v-panel-background-color: #fff;
$v-focus-color: #3b5998;

$v-border-radius: 0;
$v-textfield-border-radius: 0;

$v-font-family: Helvetica, Arial, &apos;lucida grande&apos;, tahoma, verdana, arial, sans-serif;
$v-font-size: 14px;
$v-font-color: #37404E;
$v-font-weight: 400;

$v-link-text-decoration: none;
$v-shadow: 0 1px 0 (v-shade 0.2);
$v-bevel: inset 0 1px 0 v-tint;
$v-unit-size: 30px;
$v-gradient: v-linear 12%;
$v-overlay-shadow: 0 3px 8px v-shade, 0 0 0 1px (v-shade 0.7);
$v-shadow-opacity: 20%;
$v-selection-overlay-padding-horizontal: 0;
$v-selection-overlay-padding-vertical: 6px;
$v-selection-item-border-radius: 0;

$v-line-height: 1.35;
$v-font-size: 14px;
$v-font-weight: 400;
$v-unit-size: 25px;

$v-font-size--h1: 22px;
$v-font-size--h2: 18px;
$v-font-size--h3: 16px;

$v-layout-margin-top: 8px;
$v-layout-margin-left: 8px;
$v-layout-margin-right: 8px;
$v-layout-margin-bottom: 8px;

$v-layout-spacing-vertical: 8px;
$v-layout-spacing-horizontal: 8px;

$v-table-row-height: 25px;
$v-table-header-font-size: 13px;
$v-table-cell-padding-horizontal: 5px;

$v-focus-style: inset 0px 0px 1px 1px rgba($v-focus-color, 0.5);
$v-error-focus-style: inset 0px 0px 1px 1px rgba($v-error-indicator-color, 0.5);</programlisting></para>
            </listitem>
            <listitem>
              <para>Создайте в подкаталоге <filename>src</filename> модуля <structname>web</structname> файл <filename>facebook-theme.properties</filename> со следующим содержимым:<programlisting>@include=halo-theme.properties</programlisting></para>
              <para>При необходимости в этом файле можно переопределять server-side переменные темы, заданные в файле <filename>halo-theme.properties</filename> платформы.</para>
            </listitem>
            <listitem>
              <para>В файл <filename>web-app.properties</filename> добавьте следующие свойства:<programlisting>cuba.web.theme = facebook
cuba.themeConfig = havana-theme.properties halo-theme.properties facebook-theme.properties</programlisting></para>
            </listitem>
            <listitem>
              <para>Пересоберите приложение и запустите сервер. Теперь при первом входе пользователь увидит приложение в теме Facebook, и в окне <guimenu>Help</guimenu> -&gt; <guimenu>Settings</guimenu> сможет выирать между темами Facebook, Halo, Havana.</para>
            </listitem>
          </orderedlist></para>
      </section>
    </section>
    <section id="desktop_theme">
      <title>Тема в десктоп-приложениях</title>
      <para>В десктоп-приложениях базовой темой является тема <code>Nimbus</code>.</para>
      <para>Для внесения изменения в стандартную тему нужно создать пакет <code>res.nimbus</code> в пакете <code>com.sample.sales.desktop</code> модуля <structname>desktop</structname>. В пакете <code>res.nimbus</code> будут храниться файлы темы.</para>
      <figure>
        <title/>
        <mediaobject>
          <imageobject>
            <imagedata align="center" fileref="img/gui_themes_desktop_structure.png"/>
          </imageobject>
        </mediaobject>
      </figure>
      <para>В папке <code>icons</code> хранятся файлы пиктограмм, в файле <filename>nimbus.xml</filename> − описание стиля темы.</para>
      <para>В <link linkend="app_properties">файле свойств</link> для десктоп-приложения нужно установить свойство <property>cuba.desktop.resourceLocations</property> (задает набор директорий, в которых расположены файлы стилей):<programlisting>cuba.desktop.resourceLocations = \
com/haulmont/cuba/desktop/res \
com/sample/sales/desktop/res</programlisting></para>
      <para><emphasis role="bold">Примеры</emphasis></para>
      <orderedlist>
        <listitem>
          <para>Добавление пиктограммы.</para>
          <para>Если в десктоп-приложении требуется добавить новую пиктограмму, например, для кнопки,   нужно создать пакет <code>res.nimbus.icons</code> в пакете <code>com.sample.sales.desktop</code> модуля <structname>desktop</structname> и поместить в него требуемое изображение.</para>
          <figure>
            <title/>
            <mediaobject>
              <imageobject>
                <imagedata align="center" fileref="img/gui_themes_example4.png"/>
              </imageobject>
            </mediaobject>
          </figure>
          <para>Описываем <link linkend="gui_Button">кнопку</link> в <link linkend="screen_xml_glossentry">дескрипторе</link>, указывая в атрибуте <link linkend="gui_attr_basic_icon">icon</link> путь до пиктограммы:</para>
          <programlisting language="xml">&lt;button id=&quot;button1&quot; caption=&quot;Attention&quot;  icon=&quot;icons/attention.png&quot;/&gt;</programlisting>
          <para>Ниже представлена кнопка с  пиктограммой <filename>attention.png</filename></para>
          <figure>
            <title/>
            <mediaobject>
              <imageobject>
                <imagedata align="center" fileref="img/gui_themes_example5.png"/>
              </imageobject>
            </mediaobject>
          </figure>
        </listitem>
        <listitem>
          <para>Переопределение значений свойств темы, установленных по умолчанию.</para>
          <para>Рассмотрим на примере изменения цвета фона текстовых полей, обязательных для ввода.</para>
          <para>В пакете <code>res.nimbus</code> нужно создать файл <filename>nimbus.xml</filename> следующего содержания:<programlisting language="xml">&lt;theme xmlns=&quot;http://schemas.haulmont.com/cuba/5.5/desktop-theme.xsd&quot;&gt;
  &lt;ui-defaults&gt;
      &lt;color property=&quot;cubaRequiredBackground&quot; value=&quot;#f78260&quot;/&gt;
  &lt;/ui-defaults&gt;
&lt;/theme&gt;</programlisting></para>
          <para>Элемент <sgmltag>ui-defaults</sgmltag> служит для переопределения значений свойств темы платформы, установленных по умолчанию.</para>
          <para>В элементе <sgmltag>ui-defaults</sgmltag> присутствуют как свойства, содержащиеся в стандартной  теме <code>Nimbus</code> (<ulink url="http://docs.oracle.com/javase/tutorial/uiswing/lookandfeel/_nimbusDefaults.html">http://docs.oracle.com/javase/tutorial/uiswing/lookandfeel/_nimbusDefaults.html</ulink>), так и свойства, созданные в платформе.</para>
          <para>В данном примере переопределено значение свойства платформы <sgmltag>cubaRequiredBackground</sgmltag>, хранящего цвет фона поля, обязательного для заполнения. Данное изменение коснется всех полей, обязательных для ввода.</para>
        </listitem>
        <listitem>
          <para>Создание стиля для элемента с помощью стандартных средств.</para>
          <para>Рассмотрим пример выделения надписи жирным цветом.</para>
          <para>Для того чтобы создать такой стиль, необходимо определить элемент <sgmltag>style</sgmltag> в файле темы <filename>nimbus.xml</filename> следующим образом:<programlisting language="xml">&lt;theme xmlns=&quot;http://schemas.haulmont.com/cuba/5.5/desktop-theme.xsd&quot;&gt;
  &lt;style name=&quot;boldlabel&quot;&gt;
      &lt;font style=&quot;bold&quot;/&gt;
  &lt;/style&gt;
&lt;/theme&gt;</programlisting></para>
          <para>Элемент <sgmltag>style</sgmltag> может содержать  другие элементы, в которых можно определять те или иные свойства: <sgmltag>background</sgmltag>, <sgmltag>foreground</sgmltag>, <sgmltag>icon</sgmltag>.</para>
          <para>В описании компонента надписи в <link linkend="screen_xml_glossentry">xml-дескрипторе</link>, к которой нужно применить созданный стиль, нужно указать атрибут <link linkend="gui_attr_basic_stylename">stylename</link> с именем стиля:<programlisting language="xml">&lt;label id=&quot;label1&quot; value=&quot;msg://labelVal&quot; stylename=&quot;boldlabel&quot;/&gt;</programlisting></para>
          <para>Таким образом, данный стиль будет применен только к тем надписям, для которых  определен атрибут <link linkend="gui_attr_basic_stylename">stylename</link> со значением <literal>boldlabel</literal>.</para>
        </listitem>
        <listitem>
          <para>Создание пользовательского стиля.</para>
          <para>Если не хватает стандартных средств изменения стиля компонента, есть возможность создать пользовательский стиль. </para>
          <para>Создадим пользовательский стиль, который будет применяться для компонента <link linkend="gui_Label">Label</link>. С помощью стиля содержимое компонента  <link linkend="gui_Label">Label</link> будет отображаться подчеркнутым.</para>
          <para>В первую очередь создадим класс-декоратор <code>UnderlinedLabelDecorator</code>:<programlisting language="java">public class UnderlinedLabelDecorator implements ComponentDecorator {

  @Override
  @SuppressWarnings(&quot;unchecked&quot;)
  public void decorate(Object component, Set&lt;String&gt; state) {
      DesktopLabel item = (DesktopLabel) component;
      JLabel jlabel = item.getComponent();

      Font originalFont = jlabel.getFont();
      Map attributes = originalFont.getAttributes();
      attributes.put(TextAttribute.UNDERLINE, TextAttribute.UNDERLINE_ON);
      jlabel.setFont(originalFont.deriveFont(attributes));
  }
}</programlisting></para>
          <para>Определим пользовательский стиль в файле <filename>nimbus.xml</filename>:<programlisting language="xml">&lt;theme xmlns=&quot;http://schemas.haulmont.com/cuba/5.5/desktop-theme.xsd&quot;&gt;
  &lt;style name=&quot;label-underlined&quot; component=&quot;com.haulmont.cuba.desktop.gui.components.DesktopLabel&quot;&gt;
      &lt;custom class=&quot;com.sample.sales.desktop.gui.decorators.UnderlinedLabelDecorator&quot;/&gt;
  &lt;/style&gt;
&lt;/theme&gt;</programlisting></para>
          <para>В  атрибуте <sgmltag>component</sgmltag> элемента <sgmltag>style</sgmltag> содержится название компонента, к которому может быть применен стиль с названием <literal>label-underlined</literal>.</para>
          <para>В элементе <sgmltag>custom</sgmltag> указывается путь до класса-декоратора, определенного ранее.</para>
          <para>При описании элемента надписи, к которой нужно применить пользовательский стиль, нужно в атрибуте <sgmltag>stylename</sgmltag> указать название стиля:<programlisting language="xml">&lt;label id=&quot;label1&quot; stylename=&quot;label-underlined&quot; value=&quot;Label&quot;/&gt;</programlisting></para>
          <figure>
            <title>Компонент надписи с пользовательским стилем</title>
            <mediaobject>
              <imageobject>
                <imagedata align="center" fileref="img/gui_themes_example6.png"/>
              </imageobject>
            </mediaobject>
          </figure>
        </listitem>
      </orderedlist>
    </section>
  </section>
  <section id="gui_web">
    <title>Специфика Web Client</title>
    <para>Реализация универсального пользовательского интерфейса в <link linkend="app_tiers">блоке</link> <structname>Web Client</structname> основана на фреймворке <application>Vaadin</application>. Рассмотрим основные классы, входящие в состав инфраструктуры веб клиента.<figure>
        <title>Классы инфраструктуры Web Client</title>
        <mediaobject>
          <imageobject>
            <imagedata align="center" fileref="img/WebClientInfrastructure.png"/>
          </imageobject>
        </mediaobject>
      </figure></para>
    <itemizedlist>
      <listitem>
        <para><code>App</code> - центральный класс инфраструктуры приложения. Позволяет получить ссылки на <code>Connection</code>, <code>AppWindow</code> и другие объекты инфраструктуры. Экземпляр <code>App</code> существует в единственном экземпляре для данной HTTP-сессии пользователя.</para>
        <para>В конкретном приложении, как правило, создается собственный класс <code>App</code>, унаследованный от <code>DefaultApp</code> и, соответственно, от базового абстрактного <code>App</code> платформы. Это позволяет переопределить методы <code>createAppWindow()</code> и <code>createLoginWindow()</code> для создания   собственных реализаций главного окна и окна логина.</para>
        <para>Класс <code>App</code> приложения должен быть зарегистрирован в параметре <code>application</code> сервлета <code>app_servlet</code> в файле <link linkend="web.xml">web.xml</link> модуля <structname>web</structname>.</para>
      </listitem>
      <listitem>
        <para><code>Connection</code> - интерфейс, обеспечивающий функциональность подключения к среднему слою и хранящий пользовательскую сессию <link linkend="userSession">UserSession</link>. Стандартной реализацией этого интерфейса является класс <code>DefaultConnection</code>.</para>
      </listitem>
      <listitem>
        <para><code>AppUI</code> - класс платформы, унаследованный от класса <code>com.vaadin.ui.UI</code>. Экземпляр данного класса соответствует одной открытой вкладке веб браузера. Содержит ссылку на объект <code>UIView</code> - это может быть либо <code>LoginWindow</code>, либо <code>AppWindow</code>.</para>
        <para>Класс <code>AppUI</code> приложения должен быть зарегистрирован в параметре <code>UI</code> сервлета <code>app_servlet</code> в файле <filename>web/WEB-INF/web.xml</filename> модуля <structname>web</structname>. Как правило используется стандартный класс платформы.</para>
      </listitem>
      <listitem>
        <para><code>LoginWindow</code> - окно, отображаемое до логина пользователя. В конкретном приложении можно создать наследника <code>LoginWindow</code> и переопределить метод <code>createLoginWindow()</code> класса <code>App</code> для его использования.</para>
      </listitem>
      <listitem>
        <para><code>AppWindow</code> - главное окно приложения, отображаемое после логина пользователя. В конкретном приложении можно создать наследника <code>AppWindow</code> и переопределить метод <code>createAppWindow()</code> класса <code>App</code> для его использования.</para>
        <para>Метод <code>onHistoryBackPerformed()</code> позволяет обработать нажатия на кнопку <guibutton>Back</guibutton>
          браузера. Этот метод вызывается вместо стандартного поведения браузера если свойство приложения
          <link linkend="cuba.web.allowHandleBrowserHistoryBack">cuba.web.allowHandleBrowserHistoryBack</link> установлено
          в true.</para>
        <para>Без создания собственного наследника <code>AppWindow</code> можно управлять некоторыми параметрами главного окна с помощью следующих свойств приложения:<itemizedlist>
            <listitem>
              <para><link linkend="cuba.web.useLightHeader">cuba.web.useLightHeader</link> - включает формирование компактной вехней части окна - лого, строка меню, имя пользователя и кнопка логаута в одну строку. В выключенном состоянии методом <code>AppWindow.createTitleLayout()</code> формируется дополнительная область сверху.</para>
            </listitem>
            <listitem>
              <para><link linkend="cuba.web.foldersPaneEnabled">cuba.web.foldersPaneEnabled</link> - включает формирование <link linkend="folders_pane">панели папок</link> методом <code>AppWindow.createFoldersPane()</code>.</para>
            </listitem>
            <listitem>
              <para><link linkend="cuba.web.appWindowMode">cuba.web.appWindowMode</link> - задает начальный режим главного окна: с вкладками или одноэкранный (<code>TABBED</code> или <code>SINGLE</code>). Пользователь впоследствии может задать желаемый режим через экран <guimenu>Help</guimenu> &gt; <guimenu>Settings</guimenu>.</para>
            </listitem>
            <listitem>
              <para><link linkend="cuba.web.maxTabCount">cuba.web.maxTabCount</link> - в режиме представления главного окна с вкладками задает максимальное количество вкладок, которое может открыть пользователь. По умолчанию 7.</para>
            </listitem>
          </itemizedlist></para>
      </listitem>
      <listitem>
        <para><code>WindowManager</code> - центральный класс, реализующий логику работы экранов системы. Ему делегируются вызовы <code>openWindow()</code>, <code>openEditor()</code>, <code>showMessageDialog()</code> и другие методы интерфейса <code>IFrame</code>, реализуемого <link linkend="screen_controller">контроллерами</link> экранов. Класс <code>WindowManager</code> расположен в общем модуле <structname>gui</structname> платформы и является абстрактным. В модуле <structname>web</structname> имеется конкретный класс <code>WebWindowManager</code>, реализующий специфику веб клиента.</para>
        <para>Как правило, <code>WindowManager</code> не используется в прикладном коде напрямую.</para>
      </listitem>
      <listitem>
        <para><code>ExceptionHandlers</code> - содержит коллекцию <link linkend="exceptionHandlers">обработчиков исключений клиентского уровня</link>.</para>
      </listitem>
    </itemizedlist>
    <section id="webComponentsHelper">
      <title>Работа с компонентами Vaadin</title>
      <para>Для работы непосредственно с компонентами Vaadin, реализующими интерфейсы <link linkend="gui_vcl">библиотеки визуальных компонентов</link> в <link linkend="app_tiers">блоке</link> <structname>Web Client</structname>, необходимо воспользоваться классом <code>WebComponentsHelper</code>. Он имеет два статических метода для получения ссылок на компоненты Vaadin:<itemizedlist>
          <listitem>
            <para><code>unwrap</code> - получить Vaadin-компонент для данного CUBA-компонента.</para>
          </listitem>
          <listitem>
            <para><code>getComposition</code> - получить Vaadin-компонент, который является наиболее внешним контейнером в реализации данного CUBA-компонента. Для простых компонентов, например <link linkend="gui_Button">Button</link>, этот метод возвращает тот же объект, что и <code>unwrap()</code> - <code>com.vaadin.ui.Button</code>. Для сложных компонентов, например <link linkend="gui_Table">Table</link>, <code>unwrap()</code> вернет соответсвующий объект  <code>com.vaadin.ui.Table</code>, а <code>getComposition()</code> - объект  <code>com.vaadin.ui.VerticalLayout</code>, который содержит таблицу вместе с описанными вместе с ней <link linkend="gui_ButtonsPanel">ButtonsPanel</link> и <code>RowsCount</code>.</para>
          </listitem>
        </itemizedlist></para>
      <para>Следует иметь в виду, что если экран расположен в модуле <structname>gui</structname> проекта, то в его контроллере можно работать только с обобщенными интерфейсами CUBA-компонентов. Чтобы использовать <code>WebComponentsHelper.unwrap()</code> нужно либо расположить весь экран в модуле <structname>web</structname>, либо воспользоваться механизмом <link linkend="companions">компаньонов контроллеров</link>.</para>
    </section>
    <section id="main_window_layout">
      <title>Компоновка главного окна приложения</title>
      <para>Механизм предоставляет возможность задавать компоновку главного экрана веб-приложения с использованием
        технологии универсального пользовательского интерфейса CUBA - XML-дескриптора и Java-контроллера с применением
        <link linkend="gui_vcl">визуальных компонентов</link> и <link linkend="datasources">источников данных</link>.
      </para>
      <para>Главное окно - особый экран системы, имеющий идентификатор <code>mainWindow</code>. Контроллер главного экрана
        должен быть наследником класса<code>AbstractMainWindow</code>.
      </para>
      <para>Помимо стандартных компонентов GUI в главном экране приложения можно использовать дополнительные компоненты:</para>
      <itemizedlist>
        <listitem>
          <para><code>AppMenu</code> - главное меню.</para>
        </listitem>
        <listitem>
          <para><code>FoldersPane</code> - панель <link linkend="folders_pane">папок поиска и папок приложения</link>.</para>
        </listitem>
        <listitem>
          <para><code>AppWorkArea</code> - рабочая область, обязательный компонент для работы с экранами в режимах
            <code>THIS_TAB</code>, <code>NEW_TAB</code> и <code>NEW_WINDOW</code>.</para>
        </listitem>
        <listitem>
          <para><code>UserIndicator</code> - поле, отображающее имя текущего пользователя, а при наличии замещаемых
            пользователей позволяет переключаться между ними.</para>
        </listitem>
        <listitem>
          <para><code>NewWindowButton</code> - кнопка открытия нового окна приложения.</para>
        </listitem>
        <listitem>
          <para><code>LogoutButton</code> - кнопка выхода из приложения.</para>
        </listitem>
        <listitem>
          <para><code>TimeZoneIndicator</code> - надпись, которая отображает
            <link linkend="timeZone">часовой пояс</link> пользователя.</para>
        </listitem>
        <listitem>
          <para><code>FtsField</code> - поле полнотекстового поиска.</para>
        </listitem>
      </itemizedlist>
      <para>Для работы с дополнительными компонентами в XML-дескриптор экрана нужно добавить элемент
        <code>xmlns:main</code>:</para>
      <programlisting language="xml"><xi:include href="../../source/gui/main_window_1.xml" encoding="UTF-8" parse="text"/></programlisting>
      <para>Специальный компонент <code>AppWorkArea</code> представляет собой рабочую область, в которой открываются экраны
        приложения. Если свойство приложения <link linkend="cuba.web.appWindowMode">cuba.web.appWindowMode</link> имеет
        значение <code>TABBED</code> (по умолчанию), то на месте рабочей области будет расположен компонент <code>TabSheet</code>
        с экранами приложения. В противном случае рабочая область будет содержать единственный открытый экран.
        Когда не открыт ни один экран, рабочая область содержит компоненты, определенные во вложенном элементе
        <code>initialLayout</code>:
        <programlisting language="xml"><xi:include href="../../source/gui/main_window_2.xml" encoding="UTF-8" parse="text"/></programlisting>
      </para>
      <para>При открытии экранов компоновка начального экрана (<code>initialLayout</code>) удаляется из
        <code>AppWorkArea</code>, при закрытии всех экранов - добавляется обратно. Для реакции на события смены рабочей
        области на стартовый экран и на отображение экранов приложения можно добавить обработчик
        <code>AppWorkArea.StateChangeListener</code>. Например, в таком слушателе можно разместить код обновления данных
        стартового экрана.
      </para>
      <para>В платформе существует стандартная реализация главного окна приложения. Ее XML-дескриптор -
        <filename>/com/haulmont/cuba/web/app/mainwindow/mainwindow.xml</filename>, соответствующий контроллер -
        <code>AppMainWindow</code>. Стандартная реализация главного окна может быть расширена в проекте, так же как
        обычный экран системы. Пример расширяющего экрана:
        <programlisting language="xml"><xi:include href="../../source/gui/main_window_3.xml" encoding="UTF-8" parse="text"/></programlisting>
        Этот экран должен быть зарегистрирован в <link linkend="screens.xml">screens.xml</link> с идентификатором
        <code>mainWindow</code>.
      </para>
      <para>Реализация главного окна может быть полностью заменена. Например:
        <programlisting language="xml"><xi:include href="../../source/gui/main_window_4.xml" encoding="UTF-8" parse="text"/></programlisting>
      </para>
      <para>В результате главное окно приложения выглядит следующим образом:
        <mediaobject><imageobject><imagedata fileref="img/main_window_1.png" align="center"/></imageobject></mediaobject>
      </para>
      <para>Оно же с открытым экраном:
        <mediaobject><imageobject><imagedata fileref="img/main_window_2.png" align="center"/></imageobject></mediaobject>
      </para>
      <para>Свойство приложения <link linkend="cuba.web.showBreadCrumbs">cuba.web.showBreadCrumbs</link> позволяет
        скрыть панель навигации (breadcrumbs) над открытым экраном.</para>
    </section>
  </section>
<section id="gui_desktop">
    <title>Специфика Desktop Client</title>
    <para>Реализация универсального пользовательского интерфейса в <link linkend="app_tiers">блоке</link> <structname>Desktop Client</structname> основана на  <application>Java Swing</application>. Рассмотрим основные классы, входящие в состав инфраструктуры десктоп клиента.<figure>
        <title>Классы инфраструктуры Desktop Client</title>
        <mediaobject>
          <imageobject>
            <imagedata align="center" fileref="img/DesktopClientInfrastructure.png"/>
          </imageobject>
        </mediaobject>
      </figure></para>
    <itemizedlist>
      <listitem>
        <para><code>App</code> - центральный класс инфраструктуры десктоп приложения. Содержит ссылки на <code>Connection</code> и главный <code>TopLevelFrame</code>, а также  методы инициализации и получения параметров приложения (см. ниже). </para>
        <para>В конкретном приложении необходимо  создать собственный класс-наследник <code>App</code> и переопределить в нем следующие методы:<itemizedlist>
            <listitem>
              <para><code>getDefaultAppPropertiesConfig</code> - должен возвращать строку, в которой через пробел перечислены <link linkend="app_properties_files">файлы свойств приложения</link>, например:<programlisting language="java">@Override
protected String getDefaultAppPropertiesConfig() {
  return &quot;/cuba-desktop-app.properties /desktop-app.properties&quot;;
}</programlisting></para>
            </listitem>
            <listitem>
              <para><code>getDefaultHomeDir</code> - должен вовращать путь к каталогу, в котором приложение будет хранить временные и рабочие файлы, например:<programlisting language="java">@Override
protected String getDefaultHomeDir() {
  return System.getProperty(&quot;user.home&quot;) + &quot;/.mycompany/sales&quot;;
}</programlisting></para>
            </listitem>
            <listitem>
              <para><code>getDefaultLog4jConfig</code> - должен возвращать имя файла настройки Log4J, если таковой определен в проекте. Например:<programlisting language="java">@Override
protected String getDefaultLog4jConfig() {
  return &quot;sales-log4j.xml&quot;;
}</programlisting></para>
            </listitem>
          </itemizedlist></para>
        <para>Кроме того, в собственном классе-наследнике <code>App</code> необходимо определить метод <code>main()</code> следующим образом:<programlisting language="java">public static void main(final String[] args) {
  SwingUtilities.invokeLater(new Runnable() {
      public void run() {
          app = new App();
          app.init(args);
          app.show();
          app.showLoginDialog();
      }
  });
}</programlisting></para>
      </listitem>
      <listitem>
        <para><code>Connection</code> - класс, обеспечивающий функциональность подключения к среднему слою и хранящий пользовательскую сессию <link linkend="userSession">UserSession</link>. </para>
      </listitem>
      <listitem>
        <para><code>LoginDialog</code> - диалог логина пользователя. В конкретном приложении можно создать наследника <code>LoginDialog</code> и переопределить метод <code>createLoginDialog()</code> класса <code>App</code> для его использования.</para>
      </listitem>
      <listitem>
        <para><code>TopLevelFrame</code> - наследник <code>JFrame</code>, являющийся окном самого верхнего уровня. В приложении существует как минимум один экземпляр данного класса, создаваемый при старте приложения и содержащий главное меню. Этот экземпляр возвращается методом <code>getMainFrame()</code> класса <code>App</code>.</para>
        <para>При отделении пользователем вкладок главного окна или компонента <link linkend="gui_TabSheet">TabSheet</link> (см. атрибут <code>detachable</code>) создаются дополнительные экземпляры <code>TopLevelFrame</code>, не содержащие главного меню.</para>
      </listitem>
      <listitem>
        <para><code>WindowManager</code> - центральный класс, реализующий логику работы экранов системы. Ему делегируются вызовы <code>openWindow()</code>, <code>openEditor()</code>, <code>showMessageDialog()</code> и другие методы интерфейса <code>IFrame</code>, реализуемого <link linkend="screen_controller">контроллерами</link> экранов. Класс <code>WindowManager</code> расположен в общем модуле <structname>gui</structname> платформы и является абстрактным. В модуле <structname>desktop</structname> имеется конкретный класс <code>DesktopWindowManager</code>, реализующий специфику десктоп клиента.</para>
        <para>Как правило, <code>WindowManager</code> не используется в прикладном коде напрямую.</para>
      </listitem>
      <listitem>
        <para><code>ExceptionHandlers</code> - содержит коллекцию <link linkend="exceptionHandlers">обработчиков исключений клиентского уровня</link>.</para>
      </listitem>
    </itemizedlist>
    <section id="desktopComponentsHelper">
      <title>Работа с компонентами Swing</title>
      <para>Для работы непосредственно с компонентами Swing, реализующими интерфейсы <link linkend="gui_vcl">библиотеки визуальных компонентов</link> в <link linkend="app_tiers">блоке</link> <structname>Desktop Client</structname>, необходимо воспользоваться классом <code>DesktopComponentsHelper</code>. Он имеет два статических метода для получения ссылок на компоненты Swing:<itemizedlist>
          <listitem>
            <para><code>unwrap</code> - получить Swing-компонент для данного CUBA-компонента.</para>
          </listitem>
          <listitem>
            <para><code>getComposition</code> - получить Swing-компонент, который является наиболее внешним контейнером в реализации данного CUBA-компонента. Для простых компонентов, например <link linkend="gui_Button">Button</link>, этот метод возвращает тот же объект, что и <code>unwrap()</code> - <code>javax.swing.JButton</code>. Для сложных компонентов, например <link linkend="gui_Table">Table</link>, <code>unwrap()</code> вернет соответсвующий объект  <code>org.jdesktop.swingx.JXTable</code>, а <code>getComposition()</code> - объект  <code>javax.swing.JPanel</code>, который содержит таблицу вместе с описанными вместе с ней <link linkend="gui_ButtonsPanel">ButtonsPanel</link> и <code>RowsCount</code>.</para>
          </listitem>
        </itemizedlist></para>
      <para>Следует иметь в виду, что если экран расположен в модуле <structname>gui</structname> проекта, то в его контроллере можно работать только с обобщенными интерфейсами CUBA-компонентов. Чтобы использовать <code>DesktopComponentsHelper.unwrap()</code> нужно либо расположить весь экран в модуле <structname>desktop</structname>, либо воспользоваться механизмом <link linkend="companions">компаньонов контроллеров</link>.</para>
    </section>
  </section>
  <section id="own_components">
    <title>Создание собственных компонентов</title>
    <para>В данном разделе рассматривается процесс создания и использования собственных визуальных компонентов приложения. Сначала мы возьмем сторонний компонент, доступный в виде дополнения (add-on) Vaadin, подключим его в проект и будем использовать в экране непосредственно. Затем выполним более тесную интеграцию - создадим для компонента новый <link linkend="gui_framework">GUI</link>-интерфейс  и загрузчик из XML, что позволит использовать его аналогично всем остальным компонентам платформы. </para>
    <section id="vaadin_addon">
      <title>Использование сторонних компонентов Vaadin</title>
      <para>В веб клиенте приложения можно использовать сторонние компоненты Vaadin, распространяемые в виде дополнений (add-ons). На данный момент в репозитории <ulink url="https://vaadin.com/directory">https://vaadin.com/directory</ulink> находится около 200 визуальных компонентов, совместимых с CUBA. Основное условие совместимости - компонент должен поддерживать Vaadin версии 7 и выше. </para>
      <para>Для подключения стороннего компонента в проекте необходимо выполнить следующее:<orderedlist>
          <listitem>
            <para>Добавить в проект модуль <structname>web-toolkit</structname>, выполняющий интеграцию с клиентской (браузерной) частью Vaadin-компонентов. Проще всего это сделать в <application>CUBA Studio</application>, выполнив команду <guibutton>Create web toolkit module</guibutton> секции <guilabel>Project properties</guilabel> навигатора. </para>
          </listitem>
          <listitem>
            <para>В <link linkend="build.gradle">build.gradle</link> проекта добавить зависимость модуля <structname>web</structname> от нужного add-on, например:<programlisting>configure(webModule) {
  ...
  dependencies {
      ...
      compile(&quot;org.vaadin.addons:some-addon:1.2.3&quot;)
  }</programlisting></para>
          </listitem>
          <listitem>
            <para>В созданный на шаге 1 файл <filename>AppWidgetSet.gwt.xml</filename> подключить набор виджетов add-on:<programlisting>&lt;module&gt;
  ...
  &lt;inherits name=&quot;org.vaadin.someaddon.widgetset.SomeAddonWidgetset&quot; /&gt;</programlisting></para>
          </listitem>
          <listitem>
            <para>В экране модуля <structname>web</structname> (либо в соответствующем <link linkend="companions">компаньоне</link>) получить ссылку на контейнер Vaadin с помощью класса <link linkend="webComponentsHelper">WebComponentsHelper</link>, создать экземпляр нового компонента, и добавить его в контейнер.</para>
          </listitem>
          <listitem>
            <para>Для изменения внешнего вида подключенного компонента можно создать в проекте <link linkend="web_theme">расширение темы</link> и внести в файл <filename>&lt;theme&gt;-ext.scss</filename> нужные изменения. Файлы темы проще всего создать в <application>Studio</application> командой <guibutton>Create theme extension</guibutton> секции <guilabel>Project properties</guilabel> навигатора.</para>
          </listitem>
        </orderedlist></para>
      <para>В <xref linkend="vaadin_addon_sample"/> рассмотрен процесс подключения и использования Vaadin-дополнения <application>Stepper</application>, содержащего визуальный компонент для пошагового изменения значения.</para>
    </section>
    <section id="own_gui_component">
      <title>Интеграция компонентов в Generic UI</title>
      <para>Интеграция &quot;нативного&quot; компонента в универсальный пользовательский интерфейс позволяет использовать его в большом количестве экранов с минимумом усилий - так же как и базовые компоненты платформы. Для полной интеграции необходимо выполнить следующие шаги:<orderedlist>
          <listitem>
            <para>Создать интерфейс компонента. Обычно интерфейсы располагаются в модуле <structname>gui</structname>, чтобы быть доступными обоим типам клиентов - веб и десктоп. Если же вы уверены, что компонент будет реализован только для одного типа клиента, интерфейс можно расположить в соответствующем модуле - <structname>web</structname> или <structname>desktop</structname>. Далее предполагается что компонент реализован только для веб клиента.</para>
            <para>Интерфейс компонента должен быть унаследован от <code>com.haulmont.cuba.gui.components.Component</code> или какого-либо его наследника, например <code>DatasourceComponent</code> или <code>Field</code>:<programlisting language="java">package com.company.myproject.gui.components;

import com.haulmont.cuba.gui.components.Component;

public interface MyComponent extends Component {

  String NAME = &quot;myComponent&quot;;

  int getSomeParameter();
  void setSomeParameter(int value);
}</programlisting></para>
            <para>В интерфейсе желательно определить константу <code>NAME</code>, содержащую строковое имя компонента для его получения через <code>ComponentsFactory</code>. Это же имя используется обычно как имя XML-элемента для работы с компонентом в XML-дескрипторах экранов.</para>
          </listitem>
          <listitem>
            <para>Создать класс имплементации компонента в модуле <structname>web</structname>.</para>
            <para>Класс компонента  рекомендуется унаследовать от <code>com.haulmont.cuba.web.gui.components.WebAbstractComponent</code> или какого-либо его наследника, например <code>WebAbstractField</code>. В конструкторе класса создается экземпляр &quot;нативного&quot; компонента, и ему делегируются вызовы методов GUI-интерфейса:<programlisting language="java">package com.company.myproject.web.components;

import com.company.myproject.gui.components.MyComponent;
import com.haulmont.cuba.web.gui.components.WebAbstractComponent;

public class WebMyComponent
      extends WebAbstractComponent&lt;org.vaadin.someaddon.SomeComponent&gt;
      implements MyComponent {

  public WebMyComponent() {
      component = new org.vaadin.someaddon.SomeComponent();
  }

  @Override
  public int getSomeParameter() {
      return component.getSomeParameter();
  }

  @Override
  public void setSomeParameter(boolean value) {
      component.setSomeParameter(value);
  }
}</programlisting></para>
          </listitem>
          <listitem>
            <para>Создать класс, имплементирующий интерфейс <code>ComponentPalette</code>, и из его метода <code>getComponents()</code> вернуть мэп имен своих компонентов на их классы реализации:<programlisting language="java">package com.company.myproject.web;

import com.company.myproject.gui.components.MyComponent;
import com.company.myproject.web.components.WebMyComponent;
import com.haulmont.cuba.gui.ComponentPalette;
import com.haulmont.cuba.gui.components.Component;
import com.haulmont.cuba.gui.xml.layout.ComponentLoader;
import java.util.HashMap;
import java.util.Map;

public class AppComponentPalette implements ComponentPalette {

  @Override
  public Map&lt;String, Class&lt;? extends Component&gt;&gt; getComponents() {
      Map&lt;String, Class&lt;? extends Component&gt;&gt; components = new HashMap&lt;&gt;();
      components.put(MyComponent.NAME, WebMyComponent.class);
      return components;
  }

  @Override
  public Map&lt;String, Class&lt;? extends ComponentLoader&gt;&gt; getLoaders() {
      return Collections.emptyMap();
  }
}</programlisting></para>
            <para>Экземпляр палитры компонентов необходимо зарегистрировать в приложении. Это можно сделать в блоке инициализации класса <link linkend="gui_web">App</link>:<programlisting language="java">package com.company.myproject.web;

import com.haulmont.cuba.web.DefaultApp;
import com.haulmont.cuba.web.gui.WebUIPaletteManager;

public class App extends DefaultApp {

  static {
      WebUIPaletteManager.registerPalettes(new AppComponentPalette());
  }
}</programlisting></para>
          </listitem>
          <listitem>
            <para>На данном этапе новый GUI-компонент доступен для получения через <code>ComponentsFactory</code>:<programlisting language="java" lang="">@Inject
private BoxLayout box;
@Inject
private ComponentsFactory componentsFactory;

@Override
public void init(Map&lt;String, Object&gt; params) {
  MyComponent myComponent = componentsFactory.createComponent(MyComponent.NAME);
  box.addComponent(myComponent);
  ...
}</programlisting></para>
          </listitem>
          <listitem>
            <para>Для поддержки объявления компонента в XML-дескрипторах экранов необходимо создать класс-загрузчик компонента, реализующий интерфейс <code>com.haulmont.cuba.gui.xml.layout.ComponentLoader</code>. Класс-загрузчик рекомендуется унаследовать от класса <code>com.haulmont.cuba.gui.xml.layout.loaders.ComponentLoader</code> или какого-либо его наследника. Загрузчик оперирует только с GUI-интерфейсом компонента, поэтому он является общим для всех типов клиентов и  его можно разместить в модуле <structname>gui</structname>. В загрузчике достаточно вызвать унаследованный метод <code>loadComponent()</code>, который создает экземпляр компонента и устанавливает ему из XML общие свойства, такие как идентификатор, размеры и пр. После этого можно проинициализировать специфические свойства компонента:<programlisting language="java">package com.company.myproject.gui.loaders;

import com.company.myproject.gui.components.MyComponent;
import com.haulmont.cuba.gui.components.Component;
import com.haulmont.cuba.gui.xml.layout.*;
import org.dom4j.Element;

public class MyComponentLoader extends ComponentLoader {

  public MyComponentLoader(Context context, LayoutLoaderConfig config, ComponentsFactory factory) {
      super(context, config, factory);
  }

  @Override
  public Component loadComponent(ComponentsFactory factory, Element element, Component parent) {
      MyComponent component = (MyComponent) super.loadComponent(factory, element, parent);

      String someParameter = element.attributeValue(&quot;someParameter&quot;);
      if (someParameter != null) {
          component.setSomeParameter(Integer.valueOf(someParameter));
      }
      return component;
  }
}</programlisting></para>
            <para>Для того, чтобы система нашла загрузчик, необходимо зарегистрировать его с помощью метода <code>getLoaders()</code> созданной ранее палитры компонентов:<programlisting language="java">public class AppComponentPalette implements ComponentPalette {
  ...

  @Override
  public Map&lt;String, Class&lt;? extends ComponentLoader&gt;&gt; getLoaders() {
      Map&lt;String, Class&lt;? extends ComponentLoader&gt;&gt; loaders = new HashMap&lt;&gt;();
      loaders.put(MyComponent.NAME, MyComponentLoader.class);
      return loaders;
  }
}</programlisting></para>
          </listitem>
          <listitem>
            <para>Теперь компонент можно использовать и в XML-дескрипторах экранов проекта:<programlisting language="xml">&lt;layout&gt;
  &lt;myComponent id=&quot;someId&quot; width=&quot;100%&quot; someParameter=&quot;10&quot;/&gt;
&lt;/layout&gt;</programlisting></para>
            <para>Для того, чтобы IDE подсказывала имя компонента и его атрибуты, можно определить собственную XSD и включать ее в экранах:<programlisting language="xml">&lt;window xmlns=&quot;http://schemas.haulmont.com/cuba/5.5/window.xsd&quot;
      xmlns:app=&quot;http://schemas.company.com/app/0.1/app-components.xsd&quot;
      ...&gt;

  &lt;layout&gt;
      &lt;app:myComponent id=&quot;someId&quot; width=&quot;100%&quot; someParameter=&quot;10&quot;/&gt;
  &lt;/layout&gt;</programlisting></para>
          </listitem>
        </orderedlist></para>
      <para>В <xref linkend="own_gui_component_sample"/> рассмотрен процесс интеграции в универсальный  UI компонента <application>IntStepper</application>, предназначенного для пошагового изменения целого значения.</para>
    </section>
  </section>
  <section id="shortcuts">
    <title>Горячие клавиши</title>
    <para>В данном разделе приведена информация обо всех горячих клавишах (shortcuts), которые используются по умолчанию в универсальном пользовательском интерфейсе приложения. Все перечисленные ниже <link linkend="app_properties">свойства приложения</link> принадлежат интерфейсу <code>ClientConfig</code> и используются в блоках <structname>Web Client</structname> и <structname>Desktop Client</structname>. </para>
    <itemizedlist>
      <listitem>
        <para>Главное окно приложения.</para>
        <itemizedlist>
          <listitem>
            <para><keycap>CTRL-SHIFT-PAGE_DOWN</keycap> - переход на следующую вкладку. Настраивается свойством приложения <code>cuba.gui.nextTabShortcut</code>.</para>
          </listitem>
          <listitem>
            <para><keycap>CTRL-SHIFT-PAGE_UP</keycap> - переход на предыдущую вкладку. Настраивается свойством приложения <code>cuba.gui.previousTabShortcut</code>.</para>
          </listitem>
        </itemizedlist>
      </listitem>
      <listitem>
        <para>Экраны.</para>
        <itemizedlist>
          <listitem>
            <para><keycap>ESCAPE</keycap> - закрыть текущий <link linkend="abstractWindow">экран</link>. Настраивается свойством приложения <code>cuba.gui.closeShortcut</code>.</para>
          </listitem>
          <listitem>
            <para><keycap>CTRL-ENTER</keycap> - закрыть текущий <link linkend="abstractEditor">экран редактирования</link> с  сохранением изменений. Настраивается свойством приложения <code>cuba.gui.commitShortcut</code>.</para>
          </listitem>
        </itemizedlist>
      </listitem>
      <listitem>
        <para>Стандартные действия компонента-списка (<link linkend="gui_Table">Table</link>, <link linkend="gui_GroupTable">GroupTable</link>, <link linkend="gui_TreeTable">TreeTable</link>, <link linkend="gui_Tree">Tree</link>). Кроме указанных свойств приложения горячая клавиша для конкретного экземпляра действия может быть установлена его методом <code>setShortcut()</code>.</para>
        <itemizedlist>
          <listitem>
            <para><keycap>CTRL-INSERT</keycap> - вызов действия <link linkend="createAction">CreateAction</link>. Настраивается свойством приложения <code>cuba.gui.tableInsertShortcut</code>. </para>
          </listitem>
          <listitem>
            <para><keycap>CTRL-ALT-INSERT</keycap> - вызов действия <link linkend="addAction">AddAction</link>. Настраивается свойством приложения <code>cuba.gui.tableAddShortcut</code>.</para>
          </listitem>
          <listitem>
            <para><keycap>ENTER</keycap> - вызов действия <link linkend="editAction">EditAction</link>. Настраивается свойством приложения <code>cuba.gui.tableEditShortcut</code>.</para>
          </listitem>
          <listitem>
            <para><keycap>CTRL-DELETE</keycap> - вызов действий <link linkend="removeAction">RemoveAction</link> и <link linkend="excludeAction">ExcludeAction</link>. Настраивается свойством приложения <code>cuba.gui.tableRemoveShortcut</code>.</para>
          </listitem>
        </itemizedlist>
      </listitem>
      <listitem>
        <para>Стандартные действия поля выбора (<link linkend="gui_PickerField">PickerField</link>, <link linkend="gui_LookupPickerField">LookupPickerField</link>, <link linkend="gui_SearchPickerField">SearchPickerField</link>).  Кроме указанных свойств приложения горячая клавиша для конкретного экземпляра действия может быть установлена его методом <code>setShortcut()</code>.</para>
        <itemizedlist>
          <listitem>
            <para><keycap>CTRL-ALT-L</keycap> - вызов действия <link linkend="lookupAction">LookupAction</link>. Настраивается свойством приложения <code>cuba.gui.pickerShortcut.lookup</code>.</para>
          </listitem>
          <listitem>
            <para><keycap>CTRL-ALT-O</keycap> - вызов действия <link linkend="openAction">OpenAction</link>. Настраивается свойством приложения <code>cuba.gui.pickerShortcut.open</code>.</para>
          </listitem>
          <listitem>
            <para><keycap>CTRL-ALT-C</keycap> - вызов действия <link linkend="clearAction">ClearAction</link>. Настраивается свойством приложения <code>cuba.gui.pickerShortcut.clear</code>.</para>
          </listitem>
        </itemizedlist>
        <para>В полях выбора кроме вышеперечисленных горячих клавиш поддерживается вызов действий сочетанием <keycap>CTRL-ALT-1</keycap>, <keycap>CTRL-ALT-2</keycap> и так далее по количеству действий. То есть при нажатии сочетания клавиш <keycap>CTRL-ALT-1</keycap> произойдет вызов действия, которое описано первым в списке действий, при нажатии сочетания клавиш <keycap>CTRL-ALT-2</keycap> − вызов второго действия и так далее. Сочетание <keycap>CTRL-ALT</keycap> можно заменить другим, указав его в свойстве приложения <code>cuba.gui.pickerShortcut.modifiers</code>.</para>
      </listitem>
      <listitem>
        <para>Компонент <link linkend="gui_Filter">Filter</link>.</para>
        <itemizedlist>
          <listitem>
            <para><keycap>SHIFT-BACKSPACE</keycap> – открыть список выбора фильтров. Настраивается свойством приложения <code>cuba.gui.filterSelectShortcut</code>.</para>
          </listitem>
          <listitem>
            <para><keycap>SHIFT-ENTER</keycap> - применить выбранный фильтр. Настраивается свойством приложения <code>cuba.gui.filterApplyShortcut</code>.</para>
          </listitem>
        </itemizedlist>
      </listitem>
    </itemizedlist>
  </section>
</section>
