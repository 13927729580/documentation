<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE section PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" []>
<section id="common_components" xmlns:xi="http://www.w3.org/2001/XInclude">
  <title>Общие компоненты</title>
  <para>В данной главе рассмотрены компоненты платформы, общие для всех <link linkend="app_tiers">уровней</link> приложения.</para>
  <section id="data_model">
    <title>Модель данных</title>
    <para>Предметная область моделируется в приложении с помощью взаимосвязанных классов Java, называемых классами сущностей или просто сущностями. </para>
    <para>Сущности подразделяются на две категории:<itemizedlist>
        <listitem>
          <para>персистентные – экземпляры таких сущностей хранятся в таблицах базы данных</para>
        </listitem>
        <listitem>
          <para>неперсистентные – экземпляры существуют только в оперативной памяти</para>
        </listitem>
      </itemizedlist></para>
    <para>Сущности характеризуются своими атрибутами. Атрибут соответствует полю класса и паре методов доступа (get / set) к полю. Чтобы атрибут был  неизменяемым (read only), достаточно не создавать метод set. </para>
    <para>Персистентные сущности могут включать в себя атрибуты, не хранящиеся в БД. В случае неперсистентного атрибута можно не создавать поле класса, ограничившись методами доступа.</para>
    <para>Класс сущности должен удовлетворять следующим требованиям: <itemizedlist>
        <listitem>
          <para>наследоваться от одного из базовых классов, предоставляемых платформой (см. ниже)</para>
        </listitem>
        <listitem>
          <para>иметь набор полей и методов доступа, соответствующих атрибутам сущностей</para>
        </listitem>
        <listitem>
          <para>класс и его поля (или методы доступа при отсутствии для атрибута соответствующего поля)  должны быть определенным образом <link linkend="entity_annotations">аннотированы</link> для работы <glossterm linkend="jpa">JPA</glossterm> (в случае персистентной сущности) и <link linkend="metadata_framework">фреймворка метаданных</link> </para>
        </listitem>
        <listitem>
          <para>для поддержки возможного <link linkend="extension">расширения</link> сущностей поля класса необходимо объявлять с модификатором <code>protected</code>, а не <code>private</code></para>
        </listitem>
      </itemizedlist></para>
    <para>Поддерживаются следующие типы атрибутов сущностей:<itemizedlist>
        <listitem>
          <para><code>java.lang.String</code></para>
        </listitem>
        <listitem>
          <para><code>java.lang.Boolean</code></para>
        </listitem>
        <listitem>
          <para><code>java.lang.Integer</code></para>
        </listitem>
        <listitem>
          <para><code>java.lang.Long</code></para>
        </listitem>
        <listitem>
          <para><code>java.lang.Double</code></para>
        </listitem>
        <listitem>
          <para><code>java.math.BigDecimal</code></para>
        </listitem>
        <listitem>
          <para><code>java.util.Date</code></para>
        </listitem>
        <listitem>
          <para><code>java.sql.Date</code></para>
        </listitem>
        <listitem>
          <para><code>java.sql.Time</code></para>
        </listitem>
        <listitem>
          <para><code>java.util.UUID</code></para>
        </listitem>
        <listitem>
          <para><code>byte[]</code></para>
        </listitem>
        <listitem>
          <para><code>enum</code></para>
        </listitem>
        <listitem>
          <para>сущность</para>
        </listitem>
      </itemizedlist></para>
    <para>Базовые классы сущностей (см. ниже) переопределяют <code>equals()</code> и <code>hashCode()</code> таким образом, что экземпляры сущностей сравниваются по их глобальным уникальным идентификаторам (UUID). То есть экземпляры считаются равными, если равны их идентификаторы. Глобальный уникальный идентификатор присваивается сразу после создания экземпляра в памяти, поэтому новые экземпляры также можно сравнивать и помещать в коллекции.</para>
    <section id="base_entity_classes">
      <title>Базовые классы сущностей</title>
      <para>Рассмотрим базовые классы и интерфейсы сущностей более подробно.</para>
      <figure>
        <title>Базовые классы сущностей</title>
        <mediaobject>
          <imageobject>
            <imagedata align="center" fileref="img/EntityClasses.png"/>
          </imageobject>
        </mediaobject>
      </figure>
      <itemizedlist>
        <listitem>
          <para><code>Instance</code> – декларирует базовые методы работы с объектами предметной области: <itemizedlist>
              <listitem>
                <para>Получение глобального уникального идентификатора (UUID) сущности.</para>
              </listitem>
              <listitem>
                <para>Получение ссылки на мета-класс объекта.</para>
              </listitem>
              <listitem>
                <para>Генерация имени экземпляра.</para>
              </listitem>
              <listitem>
                <para>Чтение/установка значений атрибутов по имени.</para>
              </listitem>
              <listitem>
                <para>Добавление слушателей, получающих уведомления об изменениях атрибутов.</para>
              </listitem>
            </itemizedlist></para>
        </listitem>
        <listitem>
          <para><code>Entity</code> – дополняет <code>Instance</code> понятием идентификатора сущности (который не обязательно равен UUID), причем <code>Entity</code> не определяет тип идентификатора, оставляя эту возможность наследникам.</para>
        </listitem>
        <listitem>
          <para><code>AbstractInstance</code> – реализует логику работы со слушателями изменения атрибутов.</para>
          <warning>
            <para><code>AbstractInstance</code> хранит слушателей в коллекции <code>WeakReference</code>, т.е. при отсутствии внешних ссылок на добавленного слушателя, он будет немедленно уничтожен сборщиком мусора. Как правило, слушателями изменения атрибутов являются <link linkend="gui_vcl">визуальные компоненты</link> и <link linkend="datasources">источники данных</link> UI, на которые всегда имеются ссылки из других объектов, поэтому проблема исчезновения слушателей не возникает. Однако если слушатель создается прикладным кодом и на него никто не ссылается естественным образом, необходимо кроме добавления в <code>Instance</code> сохранить  его в некотором поле объекта.</para>
          </warning>
        </listitem>
        <listitem>
          <para><code>AbstractNotPersistentEntity</code> – базовый класс неперсистентных сущностей с идентификаторами типа <code>UUID</code>.</para>
        </listitem>
        <listitem>
          <para><code>BaseEntity</code> – базовый интерфейс всех персистентных сущностей, декларирует методы получения информации о том, кто и когда создал экземпляр сущности в базе данных.</para>
        </listitem>
        <listitem>
          <para><code>BaseGenericIdEntity</code> - реализует <code>BaseEntity</code> и добавляет аннотации для поддержки <glossterm linkend="jpa">JPA</glossterm>,  не специфицируя при этом тип идентификатора (то есть первичного ключа) сущности.</para>
        </listitem>
        <listitem>
          <para><code>BaseUuidEntity</code> - расширяет <code>BaseGenericIdEntity</code>, задавая атрибут-идентификатор с именем <code>id</code>  типа <code>UUID</code>.</para>
        </listitem>
        <listitem>
          <para><code>BaseLongIdEntity</code> - расширяет <code>BaseGenericIdEntity</code>, задавая атрибут-идентификатор с именем <code>id</code>  типа <code>Long</code>.</para>
        </listitem>
        <listitem>
          <para><code>BaseIntegerIdEntity</code> - расширяет <code>BaseGenericIdEntity</code>, задавая атрибут-идентификатор с именем <code>id</code>  типа <code>Integer</code>.</para>
        </listitem>
        <listitem>
          <para><code>BaseStringIdEntity</code> - расширяет <code>BaseGenericIdEntity</code>, задавая только  тип идентификатора - <code>String</code>. В конкретном классе сущности, унаследованной от <code>BaseStringIdEntity</code>, необходимо задать атрибут-идентификатор типа <code>String</code> и добавить ему JPA-аннотацию <code>@Id</code>.</para>
        </listitem>
        <listitem>
          <para><code>Versioned</code> – интерфейс сущностей, поддерживающих <glossterm linkend="optimistic_locking">оптимистичную блокировку</glossterm></para>
        </listitem>
        <listitem>
          <para><code>Updatable</code> – интерфейс сущностей, для которых требуется сохранять информацию о том, кто и когда изменял экземпляр в последний раз</para>
        </listitem>
        <listitem>
          <para><code>SoftDelete</code> – интерфейс сущностей, поддерживающих <link linkend="soft_deletion">мягкое удаление</link></para>
        </listitem>
        <listitem>
          <para><code>StandardEntity</code> – наиболее часто используемый базовый класс персистентных сущностей, имеющий идентификатор типа <code>UUID</code> и реализующий интерфейсы <code>Versioned</code>, <code>Updatable</code>, <code>SoftDelete</code>.</para>
        </listitem>
      </itemizedlist>
      <para>При создании классов сущностей рекомендуется выбирать базовый класс по следующим правилам:<itemizedlist>
          <listitem>
            <para>Если сущность не хранится в БД, наследуйте ее от <code>AbstractNotPersistentEntity</code>.</para>
          </listitem>
          <listitem>
            <para>Если сущность встраиваемая - наследуйте ее от <code>EmbeddableEntity</code>.</para>
          </listitem>
          <listitem>
            <para>Если сущность только создается в БД, никогда не изменяется, и мягкое удаление не требуется - наследуйте ее от <code>BaseUuidEntity</code>.</para>
          </listitem>
          <listitem>
            <para>Если сущность ведет себя стандартным образом: изменяется в БД, требует оптимистичной блокировки и мягкого удаления   − наследуйте ее от <code>StandardEntity</code>.</para>
          </listitem>
          <listitem>
            <para>В противном случае наследуйте сущность от <code>BaseUuidEntity</code> и реализуйте в классе тот набор интерфейсов <code>Versioned</code>, <code>Updatable</code>, <code>SoftDelete</code>, который требуется.</para>
          </listitem>
          <listitem>
            <para>Иногда для некоторых сущностей желательно использовать целочисленные или строковые первичные ключи. В этом случае вместо <code>BaseUuidEntity</code> унаследуйте класс сущности от <code>BaseLongIdEntity</code>, <code>BaseIntegerIdEntity</code>, или <code>BaseStringIdEntity</code>.</para>
          </listitem>
        </itemizedlist></para>
    </section>
    <section id="entity_annotations">
      <title>Аннотации сущностей</title>
      <para>В данном разделе описаны все поддерживаемые платформой аннотации классов и атрибутов сущностей. </para>
      <para>Аннотации пакета <code>javax.persistence</code> обеспечивают работу <glossterm linkend="jpa">JPA</glossterm>, аннотации пакетов <code>com.haulmont.*</code> предназначены для управления <link linkend="metadata_framework">метаданными</link> и другими механизмами платформы. </para>
      <para>Если для аннотации указано только простое имя класса, подразумевается что это класс платформы, расположенный в одном  из пакетов <code>com.haulmont.*</code></para>
      <section id="entity_class_annotations">
        <title>Аннотации класса</title>
        <variablelist>
          <varlistentry id="entity_annotation">
            <term>
              <code>
                <ulink url="http://docs.oracle.com/javaee/5/api/javax/persistence/Entity.html">@javax.persistence.Entity</ulink>
              </code>
            </term>
            <listitem>
              <para>Объявляет класс сущностью модели данных. </para>
              <para>Параметры:<itemizedlist>
                  <listitem>
                    <para><code>name</code> - имя сущности, обязательно должно начинаться с префикса, отделенного знаком <literal>$</literal>. Желательно использовать в качестве префикса короткое имя проекта для формирования отдельного пространства имен. </para>
                  </listitem>
                </itemizedlist></para>
              <para>Пример:<programlisting language="java">@Entity(name = &quot;sales$Customer&quot;)</programlisting></para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>
              <code>
                <ulink url="http://docs.oracle.com/javaee/5/api/javax/persistence/MappedSuperclass.html">@javax.persistence.MappedSuperclass</ulink>
              </code>
            </term>
            <listitem>
              <para>Определяет, что данный класс является предком некоторых сущностей, и его атрибуты должны быть использованы в составе сущностей-наследников. Такой класс не сопоставляется никакой отдельной таблице БД.</para>
            </listitem>
          </varlistentry>
          <varlistentry id="table_annotation">
            <term>
              <code>@<ulink url="http://docs.oracle.com/javaee/5/api/javax/persistence/Table.html">javax.persistence.Table</ulink></code>
            </term>
            <listitem>
              <para>Определяет таблицу базы данных для данной сущности. </para>
              <para>Параметры:<itemizedlist>
                  <listitem>
                    <para><code>name</code> - имя таблицы</para>
                  </listitem>
                </itemizedlist></para>
              <para>Пример:<programlisting language="java">@Table(name = &quot;SALES_CUSTOMER&quot;)</programlisting></para>
            </listitem>
          </varlistentry>
          <varlistentry id="embeddable_annotation">
            <term>
              <code>
                <ulink url="http://docs.oracle.com/javaee/5/api/javax/persistence/Embeddable.html">@javax.persistence.Embeddable</ulink>
              </code>
            </term>
            <listitem>
              <para>Определяет встраиваемую сущность, экземпляры которой хранятся вместе с владеющей сущностью в той же таблице. </para>
              <para>Для задания имени сущности требуется применение аннотации <link linkend="metaclass_annotation">
                  <code>@MetaClass</code>
                </link>.</para>
            </listitem>
          </varlistentry>
          <varlistentry id="inheritance_annotation">
            <term>
              <code>
                <ulink url="http://docs.oracle.com/javaee/5/api/javax/persistence/Inheritance.html">@javax.persistence.Inheritance</ulink>
              </code>
            </term>
            <listitem>
              <para>Определяет стратегию наследования для иерархии классов сущностей. Данная аннотация должна быть помещена на корневом классе иерархии. </para>
              <para>Параметры:<itemizedlist>
                  <listitem>
                    <para><code>strategy</code> - стратегия, по умолчанию <code>SINGLE_TABLE</code></para>
                  </listitem>
                </itemizedlist></para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>
              <code>@<ulink url="http://docs.oracle.com/javaee/5/api/javax/persistence/DiscriminatorColumn.html">javax.persistence.DiscriminatorColumn</ulink></code>
            </term>
            <listitem>
              <para>Используется для определения колонки БД, отвечающей за различение типов сущностей в случае стратегий наследования <code>SINGLE_TABLE</code> и <code>JOINED</code>. </para>
              <para>Параметры:<itemizedlist>
                  <listitem>
                    <para><code>name</code> - имя колонки-дискриминатора</para>
                  </listitem>
                  <listitem>
                    <para><code>discriminatorType</code> - тип данных колонки-дискриминатора</para>
                  </listitem>
                </itemizedlist></para>
              <para>Пример:<programlisting language="java">@DiscriminatorColumn(name = &quot;TYPE&quot;, discriminatorType = DiscriminatorType.INTEGER)</programlisting></para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>
              <code>
                <ulink url="http://docs.oracle.com/javaee/5/api/javax/persistence/DiscriminatorValue.html">@javax.persistence.DiscriminatorValue</ulink>
              </code>
            </term>
            <listitem>
              <para>Определяет значение колонки-дискриминатора для данной сущности. Эта аннотация должна быть помещена на конкретном классе сущности. </para>
              <para>Пример:<programlisting language="java">@DiscriminatorValue(&quot;0&quot;)</programlisting></para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>
              <code>
                <ulink url="http://docs.oracle.com/javaee/5/api/javax/persistence/PrimaryKeyJoinColumn.html">@javax.persistence.PrimaryKeyJoinColumn</ulink>
              </code>
            </term>
            <listitem>
              <para>Используется в случае стратегии наследования <code>JOINED</code> для указания колонки внешнего ключа данной сущности, ссылающегося на первичный ключ сущности-предка.  </para>
              <para>Параметры:<itemizedlist>
                  <listitem>
                    <para><code>name</code> - имя колонки внешнего ключа данной сущности</para>
                  </listitem>
                  <listitem>
                    <para><code>referencedColumnName</code> - имя колонки первичного ключа сущности предка</para>
                  </listitem>
                </itemizedlist></para>
              <para>Пример:<programlisting language="java">@PrimaryKeyJoinColumn(name = &quot;CARD_ID&quot;, referencedColumnName = &quot;ID&quot;)</programlisting></para>
            </listitem>
          </varlistentry>
          <varlistentry id="namePattern">
            <term>
              <code>@NamePattern</code>
            </term>
            <listitem>
              <para>Определяет способ получения имени экземпляра, возвращаемого методом <code>Instance.getInstanceName()</code>.</para>
              <para>Значением аннотации должна быть строка вида <literal>{0}|{1}</literal>, где <itemizedlist>
                  <listitem>
                    <para><literal>{0}</literal> - строка форматирования по правилам  <code>String.format()</code>, или имя метода данного объекта с префиксом <literal>#</literal>. Метод должен возвращать <code>String</code> и не иметь параметров.</para>
                  </listitem>
                  <listitem>
                    <para><literal>{1}</literal> - разделенный запятыми список имен полей класса, соответствующий формату <literal>{0}</literal>. В случае использования в <literal>{0}</literal> метода список полей все равно необходим, так как по нему формируется <link linkend="views">представление</link> <literal>_minimal</literal>.</para>
                  </listitem>
                </itemizedlist></para>
              <para>Примеры:<programlisting language="java">@NamePattern(&quot;%s|name&quot;)</programlisting><programlisting language="java">@NamePattern(&quot;#getCaption|login,name&quot;)</programlisting></para>
            </listitem>
          </varlistentry>
          <varlistentry id="listeners_annotation">
            <term>
              <code>@Listeners</code>
            </term>
            <listitem>
              <para>Определяет список слушателей, предназначенных для реакции на события жизненного цикла экземпляров сущности на <link linkend="app_tiers">уровне</link><structname> Middleware</structname>. </para>
              <para>Значением аннотации должна быть строка или массив строк с именами классов слушателей - см. <xref linkend="entity_listeners"/></para>
              <para>Строки используются здесь вместо ссылок на классы потому, что классы слушателей находятся только на уровне <structname>Middleware</structname> и не доступны клиентскому коду, в то время как классы самих сущностей используются на всех уровнях.</para>
              <para>Примеры:<programlisting language="java">@Listeners(&quot;com.haulmont.cuba.security.listener.UserEntityListener&quot;)</programlisting><programlisting language="java">@Listeners({&quot;com.abc.sales.entity.FooListener&quot;,&quot;com.abc.sales.entity.BarListener&quot;})</programlisting></para>
            </listitem>
          </varlistentry>
          <varlistentry id="metaclass_annotation">
            <term>
              <code>@MetaClass</code>
            </term>
            <listitem>
              <para>Используется для объявления неперсистентной или <link linkend="embeddable_annotation">встраиваемой</link> сущности (т.е. когда аннотация <code>@javax.persistence.Entity</code> не применима)  </para>
              <para>Параметры:<itemizedlist>
                  <listitem>
                    <para><code>name</code> - имя сущности, обязательно должно начинаться с префикса, отделенного знаком <literal>$</literal>. Желательно использовать в качестве префикса короткое имя проекта для формирования отдельного пространства имен.</para>
                  </listitem>
                </itemizedlist></para>
              <para>Пример:<programlisting language="java">@MetaClass(name = &quot;sys$LockInfo&quot;)</programlisting></para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>
              <code>@SystemLevel</code>
            </term>
            <listitem>
              <para>Указывает, что данная сущность является системной и не должна быть доступна для выбора пользователем в различных списках сущностей, например, как тип параметра универсального фильтра или тип <link linkend="runtime_properties">динамического атрибута</link>.  </para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>
              <code>@EnableRestore</code>
            </term>
            <listitem>
              <para>Указывает, что экземпляры данной сущности доступны для восстановления после <link linkend="soft_deletion">мягкого удаления</link> в специальном экране <literal>core$Entity.restore</literal>. </para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>
              <code>@TrackEditScreenHistory</code>
            </term>
            <listitem>
              <para>Указывает, что для данной сущности будет запоминаться история открытия экранов редактирования (<literal>{имя_сущности}.edit</literal>) с возможностью отображения в специальном экране <literal>sec$ScreenHistory.browse</literal>.  </para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>
              <code>@Extends</code>
            </term>
            <listitem>
              <para>Указывает, что  данная сущность является расширением и должна повсеместно использоваться вместо базовой. См. <xref linkend="extension"/>  </para>
            </listitem>
          </varlistentry>
          <varlistentry id="postConstruct_entity_annotation">
            <term>
              <code>@PostConstruct</code>
            </term>
            <listitem>
              <para>Данная аннотация может быть указана для метода класса. Такой метод будет вызван сразу после создания экземпляра сущности через <link linkend="metadata">Metadata.create()</link>. Это удобно, если для инициализации экземпляра сущности требуется вызов каких-либо <link linkend="managed_beans">бинов</link>. Пример см. в <xref linkend="init_values_in_class"/>.</para>
            </listitem>
          </varlistentry>
        </variablelist>
      </section>
      <section id="entity_attr_annotations">
        <title>Аннотации атрибутов</title>
        <para>Аннотации атрибутов устанавливаются на соответствующие поля класса, за одним исключением: если требуется объявить неизменяемый (read only) неперсистентный атрибут <literal>foo</literal>, то достаточно создать метод доступа <code>getFoo()</code> и поместить на этот метод аннотацию <code>@MetaProperty</code>.</para>
        <variablelist>
          <varlistentry>
            <term>
              <code>
                <ulink url="http://docs.oracle.com/javaee/5/api/javax/persistence/Transient.html">@javax.persistence.Transient</ulink>
              </code>
            </term>
            <listitem>
              <para>Указывает, что данное поле не хранится в БД, т.е. является неперсистентным. </para>
              <para>Поля поддерживаемых <glossterm linkend="jpa">JPA</glossterm> типов (см. <ulink url="http://docs.oracle.com/javaee/5/api/javax/persistence/Basic.html">http://docs.oracle.com/javaee/5/api/javax/persistence/Basic.html</ulink>) <emphasis>по умолчанию являются персистентными</emphasis>, поэтому аннотация <code>@Transient</code> обязательна для объявления неперсистентного атрибута такого типа. </para>
              <para>Для включения <code>@Transient</code> атрибута в метаданные, необходимо также указать аннотацию <code>
                  <link linkend="metaProperty_annotation">@MetaProperty</link>
                </code>. </para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>
              <code>@org.apache.openjpa.persistence.Persistent</code>
            </term>
            <listitem>
              <para>Указывает, что данное поле хранится в БД, т.е. является персистентным.</para>
              <para>Данная аннотация требуется только для нестандартного для <glossterm linkend="jpa">JPA</glossterm> типа поля, платформа на данный момент поддерживает  один такой тип - <code>java.util.UUID</code>. Таким образом, <code>@Persistent</code> требуется только в одном случае - при объявлении персистентного поля типа <code>UUID</code>.</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>
              <code>
                <ulink url="http://docs.oracle.com/javaee/5/api/javax/persistence/Column.html">@javax.persistence.Column</ulink>
              </code>
            </term>
            <listitem>
              <para>Определяет колонку БД, в которой будут храниться значения данного атрибута. </para>
              <para>Параметры:<itemizedlist>
                  <listitem>
                    <para><code>name</code> - имя колонки</para>
                  </listitem>
                  <listitem>
                    <para><code>length</code> - (необязательный параметр, по умолчанию <literal>255</literal>) - длина колонки. Используется также при формировании <link linkend="metadata_framework">метаданных</link> и, в конечном счете, может ограничивать максимальную длину вводимого текста в визуальных компонентах, работающих с данным атрибутом. Для отмены ограничения по длине атрибуту необходимо добавить аннотацию <link linkend="lob_annotation">@Lob</link>.</para>
                  </listitem>
                  <listitem>
                    <para><code>nullable</code> - (необязательный параметр, по умолчанию <code>true</code>) - может ли атрибут содержать  <code>null</code>. При указании <code>nullable = false</code> <glossterm linkend="jpa">JPA</glossterm> контролирует наличие значения поля при сохранении, кроме того, визуальные компоненты, работающие с данным атрибутом, могут сигнализировать пользователю о необходимости ввода значения.</para>
                  </listitem>
                </itemizedlist></para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>
              <code>
                <ulink url="http://docs.oracle.com/javaee/5/api/javax/persistence/Id.html">@javax.persistence.Id</ulink>
              </code>
            </term>
            <listitem>
              <para>Указывает, что  данный атрибут является первичным ключом сущности. Обычно эта аннотация присутствует на поле базового класса, такого как <link linkend="base_entity_classes">BaseUuidEntity</link>. Использовать эту аннотацию в конкретном классе сущности необходимо только при наследовании от базового класса <code>BaseStringIdEntity</code> (то есть при создании сущности со строковым первичным ключом).</para>
            </listitem>
          </varlistentry>
          <varlistentry id="manyToOne">
            <term>
              <code>
                <ulink url="http://docs.oracle.com/javaee/5/api/javax/persistence/ManyToOne.html">@javax.persistence.ManyToOne</ulink>
              </code>
            </term>
            <listitem>
              <para>Определяет атрибут-ссылку на сущность с типом ассоциации много-к-одному. </para>
              <para>Параметры:<itemizedlist>
                  <listitem>
                    <para><code>fetch</code> - (по умолчанию <code>EAGER</code>) параметр, определяющий, будет ли JPA <glossterm linkend="eager_fetching">жадно</glossterm> загружать ассоциированную сущность. Данный параметр всегда должен быть установлен в значение <code>LAZY</code>, так как в CUBA-приложении политика загрузки связей определяется динамически на основе механизма <link linkend="views">представлений</link>.</para>
                  </listitem>
                  <listitem>
                    <para><code>optional</code> - (необязательный параметр, по умолчанию <code>true</code>) - может ли атрибут содержать  <code>null</code>. При указании <code>optional = false</code> <glossterm linkend="jpa">JPA</glossterm> контролирует наличие ссылки при сохранении, кроме того, визуальные компоненты, работающие с данным атрибутом, могут сигнализировать пользователю о необходимости ввода значения.</para>
                  </listitem>
                </itemizedlist></para>
              <para>Например, несколько экземпляров <code>Order</code> (заказов) ссылаются на один экземпляр <code>Customer</code> (покупателя), в этом случае класс <code>Order</code> должен содержать следующее объявление:<programlisting language="java">@ManyToOne(fetch = FetchType.LAZY)
@JoinColumn(name = &quot;CUSTOMER_ID&quot;)
protected Customer customer;</programlisting></para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>
              <code>
                <ulink url="http://docs.oracle.com/javaee/5/api/javax/persistence/OneToMany.html">@javax.persistence.OneToMany</ulink>
              </code>
            </term>
            <listitem>
              <para>Определяет атрибут-коллекцию ссылок на сущность с типом ассоциации один-ко-многим. </para>
              <para>Параметры:<itemizedlist>
                  <listitem>
                    <para><code>mappedBy</code> - поле связанной сущности, определяющее ассоциацию </para>
                  </listitem>
                  <listitem>
                    <para><code>targetEntity</code> - тип связанной сущности. Необязательный параметр, если коллекция объявлена с использованием <application>Java generics</application>. </para>
                  </listitem>
                  <listitem>
                    <para><code>fetch</code> - (необязательный параметр, по умолчанию <code>LAZY</code>) - определяет, будет ли JPA <glossterm linkend="eager_fetching">жадно</glossterm> загружать коллекцию связанных сущностей. Необходимо всегда оставлять значение по умолчанию <code>LAZY</code>, так как в CUBA-приложении политика загрузки связей определяется динамически на основе механизма <link linkend="views">представлений</link>.</para>
                  </listitem>
                  <listitem>
                    <para><code>cascade</code> - (необязательный параметр, по умолчанию <code>{}</code>) - каскадирование операций определяет, какие операции над сущностью должны быть применены к ассоциированным сущностям. Каскадирование на данном уровне не рекомендуется использовать.</para>
                  </listitem>
                </itemizedlist></para>
              <para>Например, несколько экземпляров <code>Item</code> (пунктов заказа) ссылаются на один экземпляр <code>Order</code> (заказ) с помощью <code>@ManyToOne</code> поля <code>Item.order</code>, в этом случае класс <code>Order</code> может содержать коллекцию экземпляров <code>Item</code>:<programlisting language="java">@OneToMany(mappedBy = &quot;order&quot;)
protected Set&lt;Item&gt; items;</programlisting></para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>
              <code>
                <ulink url="http://docs.oracle.com/javaee/5/api/javax/persistence/OneToOne.html">@javax.persistence.OneToOne</ulink>
              </code>
            </term>
            <listitem>
              <para>Определяет атрибут-ссылку на сущность с типом ассоциации один-к-одному. </para>
              <para>Параметры:<itemizedlist>
                  <listitem>
                    <para><code>fetch</code> - (по умолчанию <code>EAGER</code>) параметр, определяющий, будет ли JPA <glossterm linkend="eager_fetching">жадно</glossterm> загружать ассоциированную сущность. Данный параметр всегда должен быть установлен в значение <code>LAZY</code>, так как в CUBA-приложении политика загрузки связей определяется динамически на основе механизма <link linkend="views">представлений</link>.</para>
                  </listitem>
                  <listitem>
                    <para><code>mappedBy</code> - поле связанной сущности, определяющее ассоциацию. Требуется устанавливать только на ведомой стороне ассоциации. </para>
                  </listitem>
                  <listitem>
                    <para><code>optional</code> - (необязательный параметр, по умолчанию <code>true</code>) - может ли атрибут содержать  <code>null</code>. При указании <code>optional = false</code> <glossterm linkend="jpa">JPA</glossterm> контролирует наличие ссылки при сохранении, кроме того, визуальные компоненты, работающих с данным атрибутом, могут сигнализировать пользователю о необходимости ввода значения.</para>
                  </listitem>
                </itemizedlist></para>
              <para>Пример ведущей стороны ассоциации, класс <code>Driver</code>:<programlisting language="java">@OneToOne(fetch = FetchType.LAZY)
@JoinColumn(name = &quot;CALLSIGN_ID&quot;)
protected DriverCallsign callsign;</programlisting></para>
              <para>Пример ведомой стороны ассоциации, класс <code>DriverCallsign</code>:<programlisting language="java">@OneToOne(fetch = FetchType.LAZY, mappedBy = &quot;callsign&quot;)
protected Driver driver;</programlisting></para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>
              <code>
                <ulink url="http://docs.oracle.com/javaee/5/api/javax/persistence/ManyToMany.html">@javax.persistence.ManyToMany</ulink>
              </code>
            </term>
            <listitem>
              <para>Определяет атрибут-коллекцию ссылок на сущность с типом ассоциации много-ко-многим.</para>
              <para>Ассоциация много-ко-многим всегда имеет ведущую сторону и может иметь обратную сторону - ведомую. На ведущей стороне указывается дополнительная аннотация <code>@JoinTable</code>, на ведомой стороне - параметр <code>mappedBy</code>.</para>
              <para>Параметры:<itemizedlist>
                  <listitem>
                    <para><code>mappedBy</code> - поле связанной сущности, определяющее ассоциацию с ведущей стороны. Необходимо указывать только на ведомой стороне.</para>
                  </listitem>
                  <listitem>
                    <para><code>targetEntity</code> - тип связанной сущности. Необязательный параметр, если коллекция объявлена с использованием <application>Java generics</application>. </para>
                  </listitem>
                  <listitem>
                    <para><code>fetch</code> - (необязательный параметр, по умолчанию <code>LAZY</code>) - определяет, будет ли JPA <glossterm linkend="eager_fetching">жадно</glossterm> загружать коллекцию связанных сущностей. Необходимо всегда оставлять значение по умолчанию <code>LAZY</code>, так как в CUBA-приложении политика загрузки связей определяется динамически на основе механизма <link linkend="views">представлений</link>.</para>
                  </listitem>
                </itemizedlist></para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>
              <code>
                <ulink url="http://docs.oracle.com/javaee/5/api/javax/persistence/JoinColumn.html">@javax.persistence.JoinColumn</ulink>
              </code>
            </term>
            <listitem>
              <para>Используется для указания колонки БД, определяющей ассоциацию между сущностями.  </para>
              <para>Параметры:<itemizedlist>
                  <listitem>
                    <para><code>name</code> - имя колонки</para>
                  </listitem>
                </itemizedlist></para>
              <para>Пример:<programlisting language="java">@ManyToOne(fetch = FetchType.LAZY)
@JoinColumn(name = &quot;CUSTOMER_ID&quot;)
protected Customer customer;</programlisting></para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>
              <code>
                <ulink url="http://docs.oracle.com/javaee/5/api/javax/persistence/JoinTable.html">@javax.persistence.JoinTable</ulink>
              </code>
            </term>
            <listitem>
              <para>Используется для указания таблицы связи на ведущей стороне <code>@ManyToMany</code> ассоциации. </para>
              <para>Параметры:<itemizedlist>
                  <listitem>
                    <para><code>name</code> - имя таблицы связи</para>
                  </listitem>
                  <listitem>
                    <para><code>joinColumns</code> - элемент <code>@JoinColumn</code>, определяющий колонку таблицы связей, соответствующую первичному ключу ведущей стороны ассоциации (т.е. содержащей аннотацию <code>@JoinTable</code>)</para>
                  </listitem>
                  <listitem>
                    <para><code>inverseJoinColumns</code> - элемент <code>@JoinColumn</code>, определяющий колонку таблицы связей, соответствующую первичному ключу ведомой стороны ассоциации</para>
                  </listitem>
                </itemizedlist></para>
              <para>Пример атрибута <code>customers</code> класса <code>Group</code>, являющегося ведущей стороной ассоциации:<programlisting language="java">@ManyToMany
@JoinTable(name = &quot;SALES_CUSTOMER_GROUP_LINK&quot;,
  joinColumns = @JoinColumn(name = &quot;GROUP_ID&quot;),
  inverseJoinColumns = @JoinColumn(name = &quot;CUSTOMER_ID&quot;))
protected Set&lt;Customer&gt; customers;</programlisting></para>
              <para>Пример атрибута <code>groups</code> класса <code>Customer</code>, являющегося ведомой стороной этой же ассоциации:<programlisting language="java">@ManyToMany(mappedBy = &quot;customers&quot;)
protected Set&lt;Group&gt; groups;</programlisting></para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>
              <code>
                <ulink url="http://docs.oracle.com/javaee/5/api/javax/persistence/OrderBy.html">@javax.persistence.OrderBy</ulink>
              </code>
            </term>
            <listitem>
              <para>Определяет порядок элементов в атрибуте-коллекции на момент извлечения из базы данных. Данную аннотацию необходимо задавать для упорядоченных коллекций, таких как <code>List</code> или <code>LinkedHashSet</code> для получения предсказуемого порядка следования элементов.</para>
              <para>Параметры:<itemizedlist>
                  <listitem>
                    <para><code>value</code> - строка, определяющая порядок, в формате:<programlisting>orderby_list::= orderby_item [,orderby_item]*
orderby_item::= property_or_field_name [ASC | DESC]</programlisting></para>
                  </listitem>
                </itemizedlist></para>
              <para>Пример:<programlisting language="java">@OneToMany(mappedBy = &quot;user&quot;)
@OrderBy(&quot;createTs&quot;)
protected List&lt;UserRole&gt; userRoles;</programlisting></para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>
              <code>
                <ulink url="http://docs.oracle.com/javaee/5/api/javax/persistence/Embedded.html">@javax.persistence.Embedded</ulink>
              </code>
            </term>
            <listitem>
              <para>Определяет атрибут типа встраиваемой сущности, в свою очередь аннотированной <code>@Embeddable</code>. </para>
              <para>Пример:<programlisting language="java">@Embedded
protected Address address;</programlisting></para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>
              <code>
                <ulink url="http://docs.oracle.com/javaee/5/api/javax/persistence/Temporal.html">@javax.persistence.Temporal</ulink>
              </code>
            </term>
            <listitem>
              <para>Для атрибута типа <code>java.util.Date</code> уточняет тип хранимого значения: дата, время или дата+время. </para>
              <para>Параметры:<itemizedlist>
                  <listitem>
                    <para><code>value</code> - тип хранимого значения: <code>DATE</code>, <code>TIME</code>, <code> TIMESTAMP</code></para>
                  </listitem>
                </itemizedlist></para>
              <para>Пример:<programlisting language="java">@Column(name = &quot;START_DATE&quot;)
@Temporal(TemporalType.DATE)
protected Date startDate;</programlisting></para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>
              <code>
                <ulink url="http://docs.oracle.com/javaee/5/api/javax/persistence/Version.html">@javax.persistence.Version</ulink>
              </code>
            </term>
            <listitem>
              <para>Указывает, что данное поле хранит версию для поддержки <glossterm linkend="optimistic_locking">оптимистичной блокировки</glossterm> сущностей. </para>
              <para>Применение такого поля необходимо при реализации классом сущности интерфейса <code>Versioned</code> (базовый класс <code>StandardEntity</code> уже содержит такое поле).</para>
              <para>Пример:<programlisting language="java">@Version
@Column(name = &quot;VERSION&quot;)
private Integer version;</programlisting></para>
            </listitem>
          </varlistentry>
          <varlistentry id="lob_annotation">
            <term>
              <code>
                <ulink url="http://docs.oracle.com/javaee/5/api/javax/persistence/Lob.html">@javax.persistence.Lob</ulink>
              </code>
            </term>
            <listitem>
              <para>Указывает, что данный атрибут не имеет ограничений длины. Применяется совместно с аннотацией <code>@Column</code>. Если <code>@Lob</code>  указан, то длина, заданная в <code>@Column</code> явно или по умолчанию, игнорируется. </para>
              <para>Пример:<programlisting language="java">@Column(name = &quot;DESCRIPTION&quot;)
@Lob
private String description;</programlisting></para>
            </listitem>
          </varlistentry>
          <varlistentry id="metaProperty_annotation">
            <term>
              <code>@MetaProperty</code>
            </term>
            <listitem>
              <para>Указывает, что данный атрибут должен быть включен в <link linkend="metadata_framework">метаданные</link>. Данная аннотация может быть установлена как на поле класса, так и на метод доступа, в случае отсутствия соответствующего атрибуту поля.</para>
              <para>Данная аннотация не обязательна для полей, снабженных следующими аннотациями пакета <code>javax.persistence</code>: <code>@Column</code>, <code>@OneToOne</code>, <code>@OneToMany</code>, <code>@ManyToOne</code>, <code>@ManyToMany</code>, <code>@Embedded</code>. Такие поля отражаются в метаданных автоматически. Поэтому <code>@MetaProperty</code> в основном применяется для определения неперсистентных атрибутов сущностей. </para>
              <para>Параметры:<itemizedlist>
                  <listitem>
                    <para><code>mandatory</code> - (необязательный параметр, по умолчанию <code>false</code>) - может ли атрибут содержать  <code>null</code>. При указании <code>mandatory = true</code> визуальные компоненты, работающие с данным атрибутом, могут сигнализировать пользователю о необходимости ввода значения.</para>
                  </listitem>
                </itemizedlist></para>
              <para>Пример использования для поля:<programlisting language="java">@Transient
@MetaProperty
protected String token;</programlisting></para>
              <para>Пример использования для метода:<programlisting language="java">@MetaProperty
public String getLocValue() {
  if (!StringUtils.isBlank(messagesPack)) {
      return AppBeans.get(Messsages.class).getMessage(messagesPack, value);
  } else {
      return value;
  }
}</programlisting></para>
            </listitem>
          </varlistentry>
          <varlistentry id="onDelete_annotation">
            <term>
              <code>@OnDelete</code>
            </term>
            <listitem>
              <para>Определяет политику обработки связи в случае мягкого удаления сущности, содержащей данный атрибут. См. <xref linkend="soft_deletion"/></para>
              <para>Пример:<programlisting language="java">@OneToMany(mappedBy = &quot;group&quot;)
@OnDelete(DeletePolicy.CASCADE)
private Set&lt;Constraint&gt; constraints;</programlisting></para>
            </listitem>
          </varlistentry>
          <varlistentry id="onDeleteInverse_annotation">
            <term>
              <code>@OnDeleteInverse</code>
            </term>
            <listitem>
              <para>Определяет политику обработки связи в случае мягкого удаления сущности с обратной стороны ассоциации. См. <xref linkend="soft_deletion"/> </para>
              <para>Пример:<programlisting language="java">@ManyToOne
@JoinColumn(name = &quot;DRIVER_ID&quot;)
@OnDeleteInverse(DeletePolicy.DENY)
private Driver driver;</programlisting></para>
            </listitem>
          </varlistentry>
          <varlistentry id="composition_annotation">
            <term>
              <code>@Composition</code>
            </term>
            <listitem>
              <para>Указывает на то, что связь является композицией - более тесным вариантом ассоциации. Это означает, что связанная сущность имеет смысл только как часть владеющей сущности, т.е. создается и удаляется вместе с ней. </para>
              <para>Например, список пунктов в заказе (класс <code>Order</code> содержит коллекцию экземпляров <code>Item</code>):<programlisting language="java">@OneToMany(mappedBy = &quot;order&quot;)
@Composition
protected List&lt;Item&gt; items;</programlisting></para>
              <para>Указание для связи аннотации <code>@Composition</code> позволяет организовать в <link linkend="screen_edit">экранах редактирования</link> специальный режим коммита источников данных, при котором изменения экземпляров детализирующей сущности сохраняются в базе данных только при коммите основной сущности. Подробнее см. <xref linkend="composition_recipe"/>.</para>
            </listitem>
          </varlistentry>
          <varlistentry id="localizedValue_annotation">
            <term>
              <code>@LocalizedValue</code>
            </term>
            <listitem>
              <para>Служит для описания способа получения локализованного значения некоторого изменяющегося атрибута, которое возвращает метод <code><link linkend="messageTools">MessageTools</link>.getLocValue()</code>. </para>
              <para>Параметры:<itemizedlist>
                  <listitem>
                    <para><code>messagePack</code> - явное указание пакета, из которого будет взято локализованное сообщение, например, <code>com.haulmont.cuba.core.entity</code></para>
                  </listitem>
                  <listitem>
                    <para><code>messagePackExpr</code> - выражение в терминах пути к атрибуту, хранящему имя пакета, из которого будет взято локализованное сообщение, например <code>proc.messagesPack</code>. Путь начинается с атрибута текущей сущности. </para>
                  </listitem>
                </itemizedlist></para>
              <para>Пример аннотации, означающей, что локализованное значение атрибута <code>state</code> будет взято из пакета, имя которого хранится в атрибуте <code>messagesPack</code> связанной сущности <code>proc</code>:<programlisting language="java">@Column(name = &quot;STATE&quot;)
@LocalizedValue(messagePackExpr = &quot;proc.messagesPack&quot;)
protected String state;

@ManyToOne(fetch = FetchType.LAZY)
@JoinColumn(name = &quot;PROC_ID&quot;)
protected Proc proc;</programlisting></para>
            </listitem>
          </varlistentry>
            <varlistentry id="ignoreUserTimeZone">
                <term><code>@IgnoreUserTimeZone</code></term>
                <listitem>
                    <para>Для атрибутов типа timestamp с аннотацией <code>@javax.persistence.Temporal.TIMESTAMP</code> заставляет платформу игнорировать  <link linkend="timeZone">часовой пояс</link> пользователя, если он задан для текущей сессии.</para>
                </listitem>
            </varlistentry>
        </variablelist>
      </section>
    </section>
    <section id="enum_attributes">
      <title>Атрибуты типа enum</title>
      <para>В стандартном варианте использования <glossterm linkend="jpa">JPA</glossterm> для атрибутов типа <code>enum</code> в базе данных хранится целое число, получаемое методом <code>ordinal()</code> этого перечисления. Такой подход может привести к следующим проблемам при эксплуатации и развитии системы:<itemizedlist>
          <listitem>
            <para>при появлении в БД значения, не равного ни одному <code>ordinal</code> значению перечисления, экземпляр сущности нельзя загрузить вообще;</para>
          </listitem>
          <listitem>
            <para>невозможно ввести новое значение между имеющимися, что актуально при использовании сортировки по значению перечисления (order by).</para>
          </listitem>
        </itemizedlist></para>
      <para>Чтобы решить эти проблемы, в подходе <productname>CUBA</productname> предлагается отвязать значение, хранимое в БД, от <code>ordinal</code> перечисления. Для этого необходимо поле класса сущности объявлять с типом, хранимым в БД (<code>Integer</code> или <code>String</code>), а методы доступа (getter / setter) создавать для типа самого перечисления.</para>
      <para>Например:<programlisting language="java">@Entity(name = &quot;sales$Customer&quot;)
@Table(name = &quot;SALES_CUSTOMER&quot;)
public class Customer extends StandardEntity {

  @Column(name = &quot;GRADE&quot;)
  protected Integer grade;

  public CustomerGrade getGrade() {
      return grade == null ? null : CustomerGrade.fromId(grade);
  }

  public void setGrade(CustomerGrade grade) {
      this.grade = grade == null ? null : grade.getId();
  }
...
}  </programlisting></para>
      <para>При этом сам класс перечисления может выглядеть следующим образом:<programlisting language="java">public enum CustomerGrade implements EnumClass&lt;Integer&gt; {

  PREMIUM(10),
  HIGH(20),
  MEDIUM(30);

  private Integer id;

  CustomerGrade(Integer id) {
      this.id = id;
  }

  @Override
  public Integer getId() {
      return id;
  }

  public static CustomerGrade fromId(Integer id) {
      for (CustomerGrade grade : CustomerGrade.values()) {
          if (grade.getId().equals(id))
              return grade;
      }
      return null;
  }
}</programlisting></para>
      <para>Для правильного отражения в <link linkend="metadata_framework">метаданных</link> класс перечисления, используемый в качестве типа атрибута сущности, должен реализовывать интерфейс <code>EnumClass</code>.</para>
      <para>Как видно из примеров, для атрибута <code>grade</code> в БД хранится значение типа <code>Integer</code>, задаваемое полем <code>id</code> перечисления <code>CustomerGrade</code>, а конкретно <literal>10</literal>, <literal>20</literal> или <literal>30</literal>. В то же время прикладной код и метаданные работают с самим типом <code>CustomerGrade</code> через методы доступа, которые и осуществляют конвертацию.</para>
      <para>При наличии в поле БД значения, не соответствующего ни одному значению перечисления, метод <code>getGrade()</code> просто вернет <code>null</code>. Для ввода нового значения, например, <code>HIGHER</code>, между <code>HIGH</code> и <code>PREMIUM</code>, достаточно добавить это значение в перечисление с идентификатором <literal>15</literal>, при этом сортировка по полю <code>Customer.grade</code> останется верной.</para>
      <para>Значениям перечисления могут быть сопоставлены <link linkend="enum_localization">локализованные названия</link> для отображения в пользовательском интерфейсе приложения.</para>
    </section>
    <section id="soft_deletion">
      <title>Мягкое удаление</title>
      <para>Платформа CUBA поддерживает режим &quot;мягкого удаления&quot; данных - когда вместо удаления записей из базы данных они только помечаются определенным образом и становятся недоступными для обычного использования. В дальнейшем такие записи можно либо совсем удалить из БД с помощью отдельной регламентной процедуры, либо восстановить.</para>
      <para>Механизм мягкого удаления является &quot;прозрачным&quot; для прикладного программиста - достаточно убедиться, что класс сущности реализует интерфейс <code>SoftDelete</code>, и платформа сама нужным образом будет  модифицировать запросы и операции с данными.</para>
      <para>Режим мягкого удаления имеет следующие преимущества:<itemizedlist>
          <listitem>
            <para>значительно снижается риск потери данных вследствие неверных действий пользователей</para>
          </listitem>
          <listitem>
            <para>позволяет быстро сделать некоторые  записи недоступными, даже если на них имеются ссылки. </para>
            <para>Возьмем для примера  модель данных Заказы - Покупатели. Допустим, на некоторого покупателя оформлено несколько заказов, однако нам нужно сделать его недоступным для  дальнейшей работы. Традиционным &quot;жестким&quot; удалением сделать это невозможно, так как для удаления покупателя нам нужно либо удалить все его заказы, либо обнулить в этих заказах ссылки на него (т.е. потерять информацию). При мягком удалении покупателя он становится недоступным для поиска и изменения, однако при просмотре заказов пользователь видит на экране название покупателя, так как при загрузке связей признак удаления намеренно игнорируется.</para>
            <para>Описанное поведение является стандартным, но может быть модифицировано с помощью <link linkend="delete_policy">политики обработки связей</link> при удалении.</para>
          </listitem>
        </itemizedlist></para>
      <para>Отрицательной стороной мягкого удаления является увеличение объема базы данных и потенциальная необходимость дополнительных процедур ее очистки.</para>
      <section>
        <title>Использование</title>
        <para>Для того чтобы экземпляры сущности удалялись мягко, класс сущности должен реализовывать интерфейс <code>SoftDelete</code>,  а соответствующая таблица БД должна содержать колонки: <itemizedlist>
            <listitem>
              <para><database>DELETE_TS</database> - когда удалена запись</para>
            </listitem>
            <listitem>
              <para><database>DELETED_BY</database> - логин пользователя, который удалил запись</para>
            </listitem>
          </itemizedlist></para>
        <para>Поведение системы по умолчанию - сущности, реализующие <code>SoftDelete</code>, удаляются мягко, удаленные сущности не возвращаются запросами и поиском по идентификатору. При необходимости такое поведение можно динамически отключить следующими способами:<itemizedlist>
            <listitem>
              <para>для текущего экземпляра <link linkend="entityManager">EntityManager</link> - вызовом <code>setSoftDeletion(false)</code></para>
            </listitem>
            <listitem>
              <para>при запросе данных через <link linkend="dataManager">DataManager</link> - вызовом у передаваемого объекта <code>LoadContext</code> метода <code>setSoftDeletion(false)</code></para>
            </listitem>
            <listitem>
              <para>на уровне <link linkend="datasources">источников данных</link> - используя метод <code>CollectionDatasource.setSoftDeletion(false)</code> или атрибут <literal>softDeletion=&quot;false&quot;</literal> элемента <sgmltag>collectionDatasource</sgmltag> в <link linkend="screen_xml">XML-дескрипторе</link> экрана.</para>
            </listitem>
          </itemizedlist></para>
        <para>В режиме мягкого удаления платформа автоматически отфильтровывает  удаленные экземпляры при загрузке по идентификатору и по <glossterm linkend="jpql">JPQL-запросу</glossterm>, а также удаленные элементы связанных сущностей в атрибутах-коллекциях. Однако связанные сущности в единичных атрибутах загружаются независимо от того, удален связанный экземпляр или нет.</para>
      </section>
      <section id="delete_policy">
        <title>Политика обработки связей</title>
        <para>Платформа предоставляет средство обработки связей при удалении сущностей, во многом аналогичное правилам <database>ON DELETE</database> внешних ключей в базе данных. Это средство работает на <link linkend="app_tiers">уровне</link><structname> Middleware</structname> и использует аннотации <link linkend="onDelete_annotation">@OnDelete</link>, <link linkend="onDeleteInverse_annotation">@OnDeleteInverse</link> атрибутов сущности.</para>
        <para>Аннотация <code>@OnDelete</code> обрабатывается при удалении той сущности, в которой она встретилась, а не той, на которую указывает аннотированный атрибут (в этом отличие от каскадных удалений на уровне БД).
</para>
        <para>
Аннотация <code>@OnDeleteInverse</code> обрабатывается при удалении той сущности, на которую указывает аннотированный атрибут, (т.е. аналогично каскадному удалению на уровне внешних ключей в БД). Эта аннотация полезна при отсутствии в удаляемом объекте атрибута, который нужно проверять при удалении. При этом, как правило, в проверяемом объекте существует ссылка на удаляемый, на этот атрибут и устанавливается аннотация <code>@OnDeleteInverse</code>. </para>
        <para>Значением аннотации может быть: <itemizedlist>
            <listitem>
              <para><code>DeletePolicy.DENY</code> - запретить удаление сущности, если аннотированный атрибут не <code>null</code> или не пустая коллекция </para>
            </listitem>
            <listitem>
              <para><code>DeletePolicy.CASCADE</code> - каскадно удалить аннотированный атрибут </para>
            </listitem>
            <listitem>
              <para><code>DeletePolicy.UNLINK</code> - разорвать связь с аннотированным атрибутом. Разрыв связи имеет смысл указывать только на ведущей стороне ассоциации - той, которая в  классе сущности аннотирована <code>@JoinColumn</code>. </para>
            </listitem>
          </itemizedlist></para>
        <para>Примеры: <orderedlist>
            <listitem>
              <para>Запрет удаления при наличии ссылки: при попытке удаления экземпляра <code>Customer</code>, на который ссылается хотя бы один <code>Order</code>, будет выброшено исключение <code>DeletePolicyException</code>.</para>
              <para><filename>Order.java</filename><programlisting language="java">@ManyToOne(fetch = FetchType.LAZY)
@JoinColumn(name = &quot;CUSTOMER_ID&quot;)
@OnDeleteInverse(DeletePolicy.DENY)
protected Customer customer;</programlisting></para>
              <para><filename>Customer.java</filename><programlisting language="java">@OneToMany(mappedBy = &quot;customer&quot;)
protected List&lt;Order&gt; orders;</programlisting></para>
            </listitem>
            <listitem>
              <para>Каскадное удаление элементов коллекции: при удалении экземпляра <code>Role</code> все экземпляры <code>Permission</code> также будут удалены.</para>
              <para><filename>Role.java</filename><programlisting language="java">@OneToMany(mappedBy = &quot;role&quot;)
@OnDelete(DeletePolicy.CASCADE)
protected Set&lt;Permission&gt; permissions;</programlisting></para>
              <para><filename>Permission.java</filename><programlisting language="java">@ManyToOne(fetch = FetchType.LAZY)
@JoinColumn(name = &quot;ROLE_ID&quot;)
protected Role role;</programlisting></para>
            </listitem>
            <listitem>
              <para>Разрыв связи с элементами коллекции: удаление экземпляра <code>Role</code> приведет к установке в <code>null</code> ссылок со стороны всех входивших в коллекцию экземпляров <code>Permission</code>.</para>
              <para><filename>Role.java</filename><programlisting language="java">@OneToMany(mappedBy = &quot;role&quot;)
protected Set&lt;Permission&gt; permissions;</programlisting></para>
              <para><filename>Permission.java</filename><programlisting language="java">@ManyToOne(fetch = FetchType.LAZY)
@JoinColumn(name = &quot;ROLE_ID&quot;)
@OnDeleteInverse(DeletePolicy.UNLINK)
protected Role role;</programlisting></para>
            </listitem>
          </orderedlist></para>
        <para>Особенности реализации:<orderedlist>
            <listitem>
              <para>Нужно быть  осторожным при использовании <code>@OnDeleteInverse</code> с политиками <code>CASCADE</code> и <code>UNLINK</code>, так как при этом происходит извлечение из БД на сервер приложения всех экземпляров ссылающихся объектов, изменение и затем сохранение. </para>
              <para>Например, в случае ассоциации <code>Customer</code> - <code>Job</code> и большого количества работ для одного заказчика, если поставить на атрибут <code>Job.customer</code> политику <code>@OnDeleteInverse(CASCADE)</code>, то при удалении экземпляра заказчика будет предпринята попытка извлечь и изменить все его работы. Это может привести  к перегрузке сервера приложения и  БД.</para>
              <para>С другой стороны, использование <code>@OnDeleteInverse(DENY)</code> безопасно, так как при этом производится только подсчет количества ссылающихся объектов, и если оно больше <literal>0</literal>, выбрасывается исключение. Поэтому <code>@OnDeleteInverse(DENY)</code> для атрибута <code>Job.customer</code> вполне допустимо. </para>
            </listitem>
            <listitem>
              <para>Политика обработки связей реализуется   с помощью <link linkend="entity_listeners">Entity Listeners</link>, то есть при сохранении данных в БД  на <link linkend="app_tiers">уровне</link> <structname>Middleware</structname>.</para>
            </listitem>
          </orderedlist> </para>
      </section>
      <section>
        <title>Ограничение уникальности на уровне БД</title>
        <para>В режиме мягкого удаления для ограничения уникальности некоторого значения необходимо обеспечить существование единственной неудаленной записи с этим значением, и произвольного количества удаленных записей с этим же значением.</para>
        <para>Реализуется данная логика путем, специфичным для используемого сервера базы данных:<itemizedlist>
            <listitem>
              <para>Если сервер БД поддерживает частичные (partial) индексы (например, <application>PostgreSQL</application>), то ограничение уникальности можно создать следующим образом:<programlisting>create unique index IDX_SEC_USER_UNIQ_LOGIN on SEC_USER (LOGIN_LC) where DELETE_TS is null</programlisting></para>
            </listitem>
            <listitem>
              <para>Если сервер БД не поддерживает частичные индексы (например, <application>Microsoft SQL Server 2005</application>), то в уникальный индекс можно включить поле <database>DELETE_TS</database>:<programlisting>create unique index IDX_SEC_USER_UNIQ_LOGIN on SEC_USER (LOGIN_LC, DELETE_TS)</programlisting></para>
            </listitem>
          </itemizedlist></para>
      </section>
    </section>
  </section>
  <section id="metadata_framework">
    <title>Metadata Framework</title>
    <para>Для эффективной работы с <link linkend="data_model">моделью данных</link> в CUBA-приложениях используется фреймворк метаданных, который:</para>
    <itemizedlist>
      <listitem>
        <para>предоставляет удобный интерфейс для получения информации о <glossterm linkend="entity">сущностях</glossterm>, их атрибутах и отношениях между сущностями; а также для навигации по ссылкам</para>
      </listitem>
      <listitem>
        <para>служит специализированной и более удобной в использовании альтернативой <application>Java Reflection API</application></para>
      </listitem>
      <listitem>
        <para>регламентирует допустимые типы данных и отношений между сущностями</para>
      </listitem>
      <listitem>
        <para>позволяет создавать универсальные механизмы работы с данными</para>
      </listitem>
    </itemizedlist>
    <section>
      <title>Интерфейсы метаданных</title>
      <para>Рассмотрим основные интерфейсы метаданных.</para>
      <figure>
        <title>Интерфейсы фреймворка метаданных</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="img/MetadataFramework.png" align="center"/>
          </imageobject>
        </mediaobject>
      </figure>
      <variablelist>
        <varlistentry>
          <term>
            <code>Session</code>
          </term>
          <listitem>
            <para>Точка входа в фреймворк метаданных. Позволяет получать экземпляры <code>MetaClass</code> по имени и по соответствующему классу Java. Обратите внимание на различие методов <code>getClass()</code> и <code>getClassNN()</code> - первые могут возвращать <code>null</code>, вторые нет (NonNull).</para>
            <para>Объект <code>Session</code> может быть получен через интерфейс инфраструктуры <code>
                <link linkend="metadata">Metadata</link>
              </code>.</para>
            <para>Пример:<programlisting language="java">@Inject
protected Metadata metadata;
...
Session session = metadata.getSession();
MetaClass metaClass1 = session.getClassNN(&quot;sec$User&quot;);
MetaClass metaClass2 = session.getClassNN(User.class);
assert metaClass1 == metaClass2;</programlisting></para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>
            <code>MetaModel</code>
          </term>
          <listitem>
            <para>Редко используемый интерфейс, служит для группировки мета-классов. </para>
            <para>Группировка осуществляется по  имени корневого Java пакета  проекта, указываемого в файле <filename>
                <link linkend="metadata.xml">metadata.xml</link>
              </filename>.</para>
          </listitem>
        </varlistentry>
        <varlistentry id="metaClass">
          <term>
            <code>MetaClass</code>
          </term>
          <listitem>
            <para>Интерфейс метаданных класса сущности. <code>MetaClass</code> всегда ассоциирован с классом Java, которого он представляет.</para>
            <para>Основные методы:</para>
            <itemizedlist>
              <listitem>
                <para><code>getName()</code> – имя сущности, по соглашению первой частью имени до знака <code>$</code> является код пространства имен, например, <code>sales$Customer</code></para>
              </listitem>
              <listitem>
                <para><code>getProperties()</code> – список мета-свойств (<code>MetaProperty</code>)</para>
              </listitem>
              <listitem>
                <para><code>getProperty()</code>, <code>getPropertyNN()</code> - получение мета-свойства по имени. Первый метод в случае отсутствия атрибута с указанным именем возвращает <code>null</code>, второй выбрасывает исключение.</para>
                <para>Пример:<programlisting language="java">MetaClass userClass = session.getClassNN(User.class);
MetaProperty groupProperty = userClass.getPropertyNN(&quot;group&quot;);</programlisting></para>
              </listitem>
              <listitem>
                <para><code>getPropertyPath()</code> - позволяет перемещаться по ссылкам. Данный метод принимает строковый параметр - путь из имен атрибутов, разделенных точкой. Возвращаемый объект <code>MetaPropertyPath</code> позволяет обратиться к искомому (последнему в пути) атрибуту вызовом <code>getMetaProperty()</code>. </para>
                <para>Пример:<programlisting language="java">MetaClass userClass = session.getClassNN(User.class);
MetaProperty groupNameProp = userClass.getPropertyPath(&quot;group.name&quot;).getMetaProperty();
assert groupNameProp.getDomain().getName().equals(&quot;sec$Group&quot;);</programlisting></para>
              </listitem>
              <listitem>
                <para><code>getJavaClass()</code> – класс сущности, которому соответствует данный <code>MetaClass</code></para>
              </listitem>
              <listitem>
                <para><code>getAnnotations()</code> – коллекция <link linkend="meta_annotations">мета-аннотаций</link> </para>
              </listitem>
            </itemizedlist>
          </listitem>
        </varlistentry>
        <varlistentry id="metaProperty">
          <term>
            <code>MetaProperty</code>
          </term>
          <listitem>
            <para>Интерфейс метаданных атрибута сущности. </para>
            <para>Основные методы:</para>
            <itemizedlist>
              <listitem>
                <para><code>getName()</code> – имя свойства, соответствует имени атрибута сущности</para>
              </listitem>
              <listitem>
                <para><code>getDomain()</code> – мета-класс, которому принадлежит данное свойство</para>
              </listitem>
              <listitem id="metaProperty.getType">
                <para><code>getType() </code>– тип свойства:<itemizedlist>
                    <listitem>
                      <para>простой тип: <code>DATATYPE</code></para>
                    </listitem>
                    <listitem>
                      <para>перечисление: <code>ENUM</code></para>
                    </listitem>
                    <listitem>
                      <para>ссылочный тип двух видов:</para>
                      <itemizedlist>
                        <listitem id="associationType">
                          <para><code>ASSOCIATION</code> − простая ссылка на другую сущность. Например, отношение заказа и покупателя − ассоциация.</para>
                        </listitem>
                        <listitem>
                          <para><code>COMPOSITION</code> − ссылка на сущность, которая не имеет самостоятельного значения без владеющей сущности. <code>COMPOSITION</code> можно считать &quot;более тесным&quot; отношением, чем <code>ASSOCIATION</code>. Например, отношение заказа и пункта этого заказа − <code>COMPOSITION</code>, т.к. пункт не может существовать без заказа, которому он принадлежит.</para>
                        </listitem>
                      </itemizedlist>
                      <para>Вид ссылочного атрибута <code>ASSOCIATION</code> или <code>COMPOSITION</code> влияет на режим редактирования сущности: в первом случае сохранение связанной сущности в базу данных происходит независимо, а во втором − связанная сущность сохраняется в БД только вместе с владеющей сущностью.</para>
                    </listitem>
                  </itemizedlist></para>
              </listitem>
              <listitem>
                <para><code>getRange()</code> –  интерфейс <code>Range</code>, детально описывающий тип данного атрибута</para>
              </listitem>
              <listitem>
                <para><code>isMandatory()</code> – признак обязательности атрибута. Используется, например, визуальными компонентами для сигнализации пользователю о необходимости ввода значения.</para>
              </listitem>
              <listitem>
                <para><code>isReadOnly()</code> – признак неизменности атрибута</para>
              </listitem>
              <listitem>
                <para><code>getInverse()</code> – для ссылочного атрибута возвращает мета-свойство с обратной стороны ассоциации, если таковое имеется</para>
              </listitem>
              <listitem>
                <para><code>getAnnotatedElement()</code> – поле (<code>java.lang.reflect.Field</code>) или метод (<code>java.lang.reflect.Method</code>), соответствующие данному атрибуту сущности</para>
              </listitem>
              <listitem>
                <para><code>getJavaType()</code> – класс Java данного атрибута сущности. Это либо тип поля класса, либо тип возвращаемого значения метода.</para>
              </listitem>
              <listitem>
                <para><code>getDeclaringClass()</code> – класс Java, содержащий данный атрибут</para>
              </listitem>
            </itemizedlist>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>
            <code>Range</code>
          </term>
          <listitem>
            <para>Интерфейс, детально описывающий тип атрибута сущности.</para>
            <para>Основные методы:</para>
            <itemizedlist>
              <listitem>
                <para><code>isDatatype()</code> – возвращает <code>true</code> для атрибута простого  <link linkend="metaProperty.getType">типа</link></para>
              </listitem>
              <listitem>
                <para><code>asDatatype()</code> - возвращает <link linkend="datatype">
                    <code>Datatype</code>
                  </link> для атрибута простого <link linkend="metaProperty.getType">типа</link></para>
              </listitem>
              <listitem>
                <para><code>isEnum()</code> – возвращает <code>true</code> для атрибута <link linkend="metaProperty.getType">типа</link> перечисления</para>
              </listitem>
              <listitem>
                <para><code>asEnumeration()</code> - возвращает <link linkend="datatype">
                    <code>Enumeration</code>
                  </link> для атрибута  <link linkend="metaProperty.getType">типа</link> перечисления</para>
              </listitem>
              <listitem>
                <para><code>isClass()</code> – возвращает <code>true</code> для ссылочного атрибута <link linkend="metaProperty.getType"> типа</link>  <code>ASSOCIATION</code> или <code>COMPOSITION</code></para>
              </listitem>
              <listitem>
                <para><code>asClass()</code> - возвращает <link linkend="metaClass">мета-класс</link> ассоциированной сущности для ссылочного атрибута</para>
              </listitem>
              <listitem>
                <para><code>isOrdered()</code> – возвращает <code>true</code>  если атрибут представляет собой упорядоченную коллекцию (например, <code>List</code>)</para>
              </listitem>
              <listitem>
                <para><code>getCardinality()</code> – вид отношения для ссылочного атрибута: <code>ONE_TO_ONE</code>, <code>MANY_TO_ONE</code>, <code>ONE_TO_MANY</code>, <code>MANY_TO_MANY</code></para>
              </listitem>
            </itemizedlist>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>
    <section id="metadata_building">
      <title>Формирование метаданных</title>
      <para>Основной источник формирования структуры метаданных - <link linkend="entity_annotations">аннотированные</link> классы сущностей. </para>
      <para>Класс сущности отражается в метаданных в следующих случаях: <itemizedlist>
          <listitem>
            <para>Класс персистентной сущности аннотирован <code>@Entity</code>, <code>@Embeddable</code>, <code>@MappedSuperclass</code> и расположен в пределах корневого пакета, указанного в <filename>
                <link linkend="metadata.xml">metadata.xml</link>
              </filename>.</para>
          </listitem>
          <listitem>
            <para>Класс неперсистентной сущности аннотирован <code>@MetaClass</code> и расположен в пределах корневого пакета, указанного в <filename>metadata.xml</filename>.</para>
          </listitem>
        </itemizedlist></para>
      <para>Все сущности внутри одного корневого пакета помещаются в один экземпляр <code>MetaModel</code>, которому присваивается имя этого пакета. Между сущностями внутри одной <code>MetaModel</code> можно устанавливать произвольные связи, между разными - в порядке объявления файлов <filename>metadata.xml</filename> в свойстве <property>
          <link linkend="cuba.metadataConfig">cuba.metadataConfig</link>
        </property>. </para>
      <para>Атрибут сущности отражается в метаданных, если: <itemizedlist>
          <listitem>
            <para>поле класса аннотировано <code>@Column</code>, <code>@OneToOne</code>, <code>@OneToMany</code>, <code>@ManyToOne</code>, <code>@ManyToMany</code>, <code>@Embedded</code></para>
          </listitem>
          <listitem>
            <para>поле класса или метод доступа на чтение (getter) аннотирован <code>@MetaProperty</code></para>
          </listitem>
        </itemizedlist></para>
      <para>Параметры мета-класса и мета-свойств формируются на основе параметров перечисленных <link linkend="entity_annotations">аннотаций</link>, а также типов полей и методов класса. Кроме того, если у атрибута отсутствует метод доступа на запись (setter), атрибут становится неизменяемым (read only). </para>
    </section>
    <section id="datatype">
      <title>Datatype</title>
      <para>Интерфейс <code>Datatype</code> описывает тип данных, допустимый для  атрибута сущности, не являющегося ассоциацией. Каждый экземпляр реализации <code>Datatype</code> соответствует одному классу Java, для работы с которым он предназначен.</para>
      <para>Все экземпляры зарегистрированы в репозитории - классе <code>Datatypes</code>, который выполняет загрузку и инициализацию классов реализации <code>Datatype</code> следующим образом:<itemizedlist>
          <listitem>
            <para>в корне <literal>CLASSPATH</literal> ищется файл <filename>
                <link linkend="datatypes.xml">datatypes.xml</link>
              </filename>, и если он найден, репозиторий <code>Datatypes</code> инициализируется из него</para>
          </listitem>
          <listitem>
            <para>в противном случае инициализация <code>Datatypes</code> производится из файла <filename>/com/haulmont/chile/core/datatypes/<link linkend="datatypes.xml">datatypes.xml</link></filename></para>
          </listitem>
        </itemizedlist></para>
      <para>Экземпляр <code>Datatype</code> может быть получен двумя способами:<itemizedlist>
          <listitem>
            <para>для атрибута сущности из соответствующего ему  мета-свойства типа <code>
                <link linkend="metaProperty.getType">DATATYPE</link>
              </code>, вызовом <code>getRange().asDatatype()</code></para>
          </listitem>
          <listitem>
            <para>статическим методом <code>Datatypes.get()</code>, передавая в него имя реализации <code>Datatype</code> или класс Java, для которого он создан.</para>
          </listitem>
        </itemizedlist></para>
      <para><code>Datatype</code> сопоставляется атрибуту сущности на старте системы по следующим правилам:<itemizedlist>
          <listitem>
            <para>Если для поля или метода задана аннотация <code>@MetaProperty</code> с непустым значением <code>datatype</code>, то атрибуту сопоставляется экземпляр <code>Datatype</code> с данным именем. </para>
            <para>Например, при следующем объявлении атрибута сущности он получит нестандартный тип <code>GeoCoordinateDatatype</code> (см. пример ниже):<programlisting language="java">@MetaProperty(datatype = GeoCoordinateDatatype.NAME)
@Column(name = &quot;LATITUDE&quot;)
private Double latitude;</programlisting></para>
          </listitem>
          <listitem>
            <para>как правило, явное указание отсутствует, и атрибуту сопоставляется экземпляр <code>Datatype</code>, возвращаемый репозиторием <code>Datatypes.get(Class)</code>, при передаче в него типа поля или метода.</para>
            <para>Например, в данном случае атрибут latitude получит стандартный тип DoubleDatatype, зарегистрированный в базовом <filename>/com/haulmont/chile/core/datatypes/datatypes.xml</filename>:<programlisting language="java">@Column(name = &quot;LATITUDE&quot;)
private Double latitude;</programlisting></para>
          </listitem>
        </itemizedlist></para>
      <para>Основные методы интерфейса <code>Datatype</code>:<itemizedlist>
          <listitem>
            <para><code>getName()</code> - возвращает уникальное имя данной реализации</para>
          </listitem>
          <listitem>
            <para><code>format()</code> - преобразовывает переданное значение в строку</para>
          </listitem>
          <listitem>
            <para><code>parse()</code> - преобразовывает строку в значение нужного типа </para>
          </listitem>
        </itemizedlist></para>
      <para><code>Datatype</code> определяет два набора методов для форматирования/парсинга: с учетом локали и без учета локали. Преобразование с учетом локали используется повсеместно в пользовательском интерфейсе, преобразование без учета локали используется в системных механизмах, например, для сериализации в <link linkend="rest_api">REST API</link>. </para>
      <para>Форматы для преобразований без учета локали задаются в вышеупомянутом файле <filename>
          <link linkend="datatypes.xml">datatypes.xml</link>
        </filename>.</para>
      <para>Форматы для преобразований с учетом локали задаются в <link linkend="main_message_pack">главном пакете локализованных сообщений</link>, в  строках со следующими ключами:<itemizedlist>
          <listitem>
            <para><literal>numberDecimalSeparator</literal> - задает символ разделителя целой и дробной части для числовых типов</para>
          </listitem>
          <listitem>
            <para><literal>numberGroupingSeparator</literal> - задает символ разделителя групп разрядов  для числовых типов</para>
          </listitem>
          <listitem>
            <para><literal>integerFormat</literal> - формат для  типов <code>Integer</code> и <code>Long</code></para>
          </listitem>
          <listitem>
            <para><literal>doubleFormat</literal> - формат для типа <code>Double</code></para>
          </listitem>
          <listitem>
            <para><literal>decimalFormat</literal> - формат для типа <code>BigDecimal</code></para>
          </listitem>
          <listitem>
            <para><literal>dateTimeFormat</literal> - формат для типа <code>java.util.Date</code></para>
          </listitem>
          <listitem>
            <para><literal>dateFormat</literal> - формат для типа <code>java.sql.Date</code></para>
          </listitem>
          <listitem>
            <para><literal>timeFormat</literal> - формат для типа <code>java.sql.Time</code></para>
          </listitem>
          <listitem>
            <para><literal>trueString</literal> - строка, соответствующая <code>Boolean.TRUE</code></para>
          </listitem>
          <listitem>
            <para><literal>falseString</literal> - строка, соответствующая <code>Boolean.FALSE</code></para>
          </listitem>
        </itemizedlist>Все перечисленные форматы по умолчанию заданы в главном пакете локализованных сообщений <link linkend="base_projects">базового проекта</link> <structname>cuba</structname>, и могут быть переопределены в аналогичных файлах проекта приложения.</para>
      <section>
        <title>Пример форматирования даты в UI</title>
        <para>Рассмотрим отображение атрибута <code>Order.date</code> в таблице браузера заказов.</para>
        <para>order-browse.xml<programlisting language="xml">&lt;table id=&quot;ordersTable&quot;&gt;
  ...
  &lt;columns&gt;
      &lt;column id=&quot;date&quot;/&gt;
      ...</programlisting></para>
        <para>Атрибут <code>date</code>  в классе <code>Order</code> определен с типом &quot;дата&quot;:<programlisting language="java">@Column(name = &quot;DATE&quot;, nullable = false)
@Temporal(TemporalType.DATE)
private Date date;</programlisting></para>
        <para>Если текущий пользователь зарегистрирован c русской локалью, то из <link linkend="main_message_pack">главного пакета</link> локализованных сообщений клиентского <link linkend="app_tiers">уровня</link>, из файла <filename>messages_ru.properties</filename> извлекается строка:<programlisting>dateFormat=dd.MM.yyyy</programlisting></para>
        <para>Результат: дата &quot;6 августа 2012 года&quot; конвертируется в строку &quot;06.08.2012&quot; для отображения в ячейке таблицы.</para>
      </section>
      <section>
        <title>Примеры форматирования дат и чисел в коде приложения</title>
        <itemizedlist>
          <listitem>
            <para>Пример форматирования даты<programlisting language="java">@Inject
protected UserSessionSource userSessionSource;
...
Date date = ...;
String dateStr = Datatypes.get(Date.class).format(date, userSessionSource.getLocale());</programlisting></para>
          </listitem>
          <listitem>
            <para>Пример форматирования числового значения с повышенной точностью  (5 знаков после запятой) в <link linkend="app_tiers">блоке</link> <structname>Web Client</structname></para>
            <para><filename>/com/sample/sales/web/messages_ru.properties</filename><programlisting>coordinateFormat = #,##0.00000</programlisting></para>
            <para><filename>SomeClass.java</filename><programlisting language="java">@Inject
protected Messages messages;
@Inject
protected UserSessionSource userSessionSource;
...
String coordinateFormat = messages.getMainMessage(&quot;coordinateFormat&quot;);
FormatStrings formatStrings = Datatypes.getFormatStrings(userSessionSource.getLocale());
NumberFormat format = new DecimalFormat(coordinateFormat, formatStrings.getFormatSymbols());

String formattedValue = format.format(value);</programlisting></para>
          </listitem>
        </itemizedlist>
      </section>
      <section>
        <title>Пример специализированного Datatype</title>
        <para>Рассмотрим реализацию нестандартного типа GeoCoordinateDatatype, предназначенного для атрибутов, хранящих географические координаты.</para>
        <para>Создаем класс в модуле <structname>global</structname>:<programlisting language="java">public class GeoCoordinateDatatype extends DoubleDatatype {

  public static final String NAME = &quot;geocoordinate&quot;;

  // формат общий для всех локалей, отличаться могут только символы десятичной точки
  public static final String FORMAT = &quot;#0.000000&quot;;

  public GeoCoordinateDatatype(Element element) {
      super(element);
  }

  @Override
  public String getName() {
      return NAME;
  }

  @Override
  public String format(Double value, Locale locale) {
      if (value == null)
          return &quot;&quot;;
      FormatStrings formatStrings = Datatypes.getFormatStrings(locale);
      if (formatStrings == null)
          return format(value); // FormatStrings для локали не определены, форматируем по данным datatypes.xml

      NumberFormat format = new DecimalFormat(FORMAT, formatStrings.getFormatSymbols());
      return format.format(value);
  }

  @Override
  public Double parse(String value, Locale locale) throws ParseException {
      if (StringUtils.isBlank(value))
          return null;
      FormatStrings formatStrings = Datatypes.getFormatStrings(locale);
      if (formatStrings == null)
          return parse(value); // FormatStrings для локали не определены, парсим по данным datatypes.xml

      NumberFormat format = new DecimalFormat(FORMAT, formatStrings.getFormatSymbols());
      return parse(value, format).doubleValue();
  }
}</programlisting></para>
        <para>Создаем файл <filename>datatypes.xml</filename> в корне каталога <filename>src</filename> модуля <structname>global</structname> проекта приложения и копируем в него все из файла <filename>/com/haulmont/chile/core/datatypes/datatypes.xml</filename>, расположенного в модуле <structname>global</structname> базового проекта <structname>cuba</structname>. Затем добавляем в него регистрацию нового типа:<programlisting language="xml">&lt;datatypes&gt;

  &lt;datatype class=&quot;com.sample.sales.entity.GeoCoordinateDatatype&quot;
            format=&quot;#0.000000&quot; decimalSeparator=&quot;.&quot; groupingSeparator=&quot;&quot;/&gt;
...</programlisting></para>
        <para>Указываем новый тип данных для требуемых атрибутов:<programlisting language="java">@MetaProperty(datatype = GeoCoordinateDatatype.NAME)
@Column(name = &quot;LATITUDE&quot;)
private Double latitude;</programlisting></para>
        <para>После выполнения перечисленных действий атрибут <code>latitude</code> везде в приложении будет отображаться в нужном формате.</para>
      </section>
    </section>
    <section id="meta_annotations">
      <title>Мета-аннотации</title>
      <para>Мета-аннотации сущностей - набор пар ключ/значение, содержащих дополнительную информацию о сущностях.</para>
      <para>Обращение к мета-аннотациям  производится с помощью метода <link linkend="metaClass">мета-класса</link> <code>getAnnotations()</code>.</para>
      <para>Источниками мета-аннотаций сущности являются:<itemizedlist>
          <listitem>
            <para><link linkend="entity_annotations">Аннотации</link>  <code>@OnDelete</code>, <code>@OnDeleteInverse</code>, <code>@Extends</code>. При этом в мета-аннотациях создаются служебные объекты связей между сущностями. </para>
          </listitem>
          <listitem>
            <para><link linkend="entity_annotations">Аннотации</link> <code>@NamePattern</code>, <code>@SystemLevel</code>, <code>@EnableRestore</code>, <code>@TrackEditScreenHistory</code>. При этом создаются  мета-аннотации с ключами, соответствующими полному имени класса Java аннотации. </para>
          </listitem>
          <listitem>
            <para>Опционально: в прикладном проекте могут быть определены свои аннотации для сущностей, и в <link linkend="extension">переопределенном</link> методе <code>MetadataImpl.initMetaAnnotations()</code> отображены в соответствующие мета-аннотации. </para>
          </listitem>
          <listitem>
            <para>Опционально: в файлах <filename>
                <link linkend="metadata.xml">metadata.xml</link>
              </filename> также могут быть определены мета-аннотации сущностей. Если мета-аннотация в XML имеет то же имя, что и мета-аннотация, созданная по Java аннотации класса сущности, первая переопределит значение второй. </para>
            <para>Пример определения мета-аннотаций в <filename>
                <link linkend="metadata.xml">metadata.xml</link>
              </filename>:<programlisting language="xml">&lt;annotations&gt;
  &lt;entity class=&quot;com.haulmont.cuba.security.entity.User&quot;&gt;
      &lt;annotation name=&quot;com.haulmont.cuba.core.entity.annotation.TrackEditScreenHistory&quot; value=&quot;false&quot;/&gt;
      &lt;annotation name=&quot;com.haulmont.cuba.core.entity.annotation.EnableRestore&quot; value=&quot;true&quot;/&gt;
  &lt;/entity&gt;
&lt;/annotations&gt;</programlisting></para>
          </listitem>
        </itemizedlist></para>
    </section>
  </section>
  <section id="views">
    <title>Представления</title>
    <para>При извлечении сущностей из базы данных обычно встает вопрос - как обеспечить загрузку связанных сущностей на нужную глубину? </para>
    <para>Например,  для браузера Заказов нужно отобразить дату и сумму заказа совместно с названием Покупателя, т.е. загрузить связанный экземпляр Покупателя. А для экрана редактирования Заказа необходимо загрузить еще и коллекцию Пунктов заказа, причем каждый Пункт заказа должен содержать связанный экземпляр Товара для отображения его наименования. </para>
    <para><link linkend="lazy_loading">Загрузка по требованию</link> в большинстве случаев не может помочь, так как обработка данных, как правило, происходит не в транзакции, в которой загружаются сущности, а, например, на клиентском <link linkend="app_tiers">уровне</link> в пользовательском интерфейсе. В то же время задание <glossterm linkend="eager_fetching">жадной загрузки</glossterm> в <link linkend="entity_annotations">аннотациях сущностей</link> недопустимо, так как приводит к постоянному извлечению всего графа связанных сущностей, который может быть очень большим.</para>
    <para>Другой похожей проблемой является ограничение набора <glossterm linkend="local_attribute">локальных</glossterm> атрибутов сущностей загружаемого графа: например, некоторая сущность имеет 50 атрибутов, в том числе BLOB, а в экране отображается только 10 атрибутов. Зачем загружать из БД, затем сериализовать и передавать клиенту 40 атрибутов, которые ему в данный момент не нужны?</para>
    <para>Механизм <firstterm>представлений</firstterm> (views)  решает эти проблемы, обеспечивая извлечение из базы данных и передачу клиенту графов сущностей, ограниченных в глубину и по атрибутам. <firstterm>Представление</firstterm> является описателем графа объектов, который требуется в некотором экране UI или другом процессе обработки данных.</para>
    <para>Обработка представлений производится следующим образом:<itemizedlist>
        <listitem>
          <para>Все связи в модели данных объявляются с признаком <link linkend="lazy_loading">загрузки по требованию</link> (<code>fetch = FetchType.LAZY</code>, см. <xref linkend="entity_annotations"/>).</para>
        </listitem>
        <listitem>
          <para>В процессе загрузки данных через <link linkend="dataManager">DataManager</link> клиентский код помимо <glossterm linkend="jpql">JPQL</glossterm> запроса указывает нужное  представление.</para>
        </listitem>
        <listitem>
          <para>На основе представления формируется так называемый <firstterm>Fetch Plan</firstterm> - особенность лежащего в основе <link linkend="orm">слоя ORM</link> фреймворка <application>Apache OpenJPA</application>. Fetch Plan влияет на формирование SQL запроса к базе данных: как на список возвращаемых полей, так и на соединения с другими таблицами, содержащими связанные сущности.</para>
        </listitem>
        <listitem>
          <para>В представлении некоторые ссылочные атрибуты могут быть объявлены как <code>lazy</code> (см. ниже). Lazy-атрибуты не включаются в Fetch Plan, а загружаются отдельными SQL запросами (иногда это полезно  для упрощения основного SQL запроса). Для этого механизм обработки представлений просто обращается к соответствующим методам чтения атрибутов.</para>
        </listitem>
        <listitem>
          <para>В результате на момент завершения <link linkend="transactions">транзакции</link>, загружающей данные, в памяти <structname>Middleware</structname> содержится граф объектов, заданный  JPQL запросом и представлением.</para>
        </listitem>
      </itemizedlist></para>
    <figure>
      <title>Классы представления</title>
      <mediaobject>
        <imageobject>
          <imagedata align="center" fileref="img/View.png"/>
        </imageobject>
      </mediaobject>
    </figure>
    <para>Представление определяется экземпляром класса <code>View</code>, в котором:<itemizedlist>
        <listitem>
          <para><code>entityClass</code> - класс сущности, для  которого определено представление. Другими словами, &quot;корень&quot; дерева загружаемых сущностей.</para>
        </listitem>
        <listitem>
          <para><code>name</code> - имя представления. Должно быть либо <code>null</code>, либо уникальным в пределах данной сущности.</para>
        </listitem>
        <listitem>
          <para><code>properties</code> - коллекция экземпляров класса ViewProperty, соответствующих загружаемым атрибутам сущности.</para>
        </listitem>
        <listitem>
          <para><code>includeSystemProperties</code> - признак включения системных атрибутов (входящих в состав <link linkend="base_entity_classes">базовых интерфейсов</link> персистентных сущностей <code>BaseEntity</code> и  <code>Updatable</code>). Системные атрибуты не перечисляются в <code>properties</code>  явно, а учитываются механизмом обработки представлений в зависимости от того, какие интерфейсы реализует данная сущность.</para>
        </listitem>
      </itemizedlist></para>
    <para>Класс <code>ViewProperty</code> имеет следующие свойства:<itemizedlist>
        <listitem>
          <para><code>name</code> - имя атрибута сущности</para>
        </listitem>
        <listitem>
          <para><code>view</code> - для ссылочных атрибутов задает представление, с которым необходимо загружать связанную сущность</para>
        </listitem>
        <listitem>
          <para><code>lazy</code> - для ссылочных атрибутов признак того, что данный атрибут нужно не  включать в
              Fetch Plan, а загружать отдельным SQL запросом, инициированным обращением к атрибуту. Следует иметь в виду,
              что при использовании <link linkend="dataManager">DataManager</link> и <link linkend="datasources">источников данных</link>
              атрибут в любом случае будет загружен, данный признак влияет только на способ загрузки. Если же
              представление с <code>lazy</code> атрибутами используется на уровне ORM, то после загрузки экземпляров их
              обязательно нужно передать в метод <link linkend="entityManager">EntityManager</link>.fetch() до окончания
              транзакции, иначе <code>lazy</code> атрибуты загружены не будут.</para>
        </listitem>
      </itemizedlist></para>
    <warning>
      <para>Независимо от набора атрибутов, определенного в представлении, всегда загружаются следующие атрибуты:<itemizedlist>
          <listitem>
            <para><code>id</code> - идентификатор сущности</para>
          </listitem>
          <listitem>
            <para><code>version</code> - для оптимистично блокируемых сущностей, реализующих <code>Versioned</code></para>
          </listitem>
          <listitem>
            <para><code>deleteTs</code>, <code>deletedBy</code> - для сущностей, реализующих <code>
                <link linkend="soft_deletion">SoftDelete</link>
              </code></para>
          </listitem>
        </itemizedlist></para>
    </warning>
    <para>Незагруженные атрибуты имеют значение <code>null</code>. По умолчанию попытка установки значения незагруженного атрибута (вызов setter) для <link linkend="entity_states">Detached</link> сущности вызывает исключение. Это поведение можно изменить с помощью свойства приложения <property>
        <link linkend="cuba.allowSetNotLoadedAttributes">cuba.allowSetNotLoadedAttributes</link>
      </property>. Если данное свойство установлено в <code>true</code>, то вызов setter не приведет к исключению, но значение все равно сохранено не будет.</para>
    <para>Следует иметь в виду, что незагруженные ссылочные атрибуты Detached сущности, соответствующие внешним ключам (т.е. ManyToOne, OneToOne), можно установить в новое ненулевое значение в любом случае, и изменения будут сохранены при последующем <code>merge()</code>.</para>
    <section id="view_creation">
      <title>Создание представлений</title>
      <para>Представление может быть создано двумя путями:<itemizedlist>
          <listitem>
            <para><emphasis role="bold">программно</emphasis> - созданием экземпляра <code>View</code>, например:<programlisting language="java">View view = new View(Order.class)
      .addProperty(&quot;date&quot;)
      .addProperty(&quot;amount&quot;)
      .addProperty(&quot;customer&quot;, new View(Customer.class)
          .addProperty(&quot;name&quot;)
      );</programlisting></para>
            <para>Как правило, таким способом создаются представления, используемые только в каком-то одном месте бизнес-логики.</para>
          </listitem>
          <listitem>
            <para><emphasis role="bold">декларативно</emphasis> - путем создания описателя на XML и его развертывания в репозитории представлений <code>ViewRepository</code>. При развертывании на основе XML-описателя создаются и кэшируются экземпляры <code>View</code>. В дальнейшем в любом месте кода приложения требуемое представление можно получить вызовом репозитория с указанием класса сущности и имени представления.</para>
          </listitem>
        </itemizedlist></para>
      <para>Рассмотрим подробнее декларативный способ создания и работы с представлениями.</para>
      <para><code>ViewRepository</code> является бином <application>Spring</application>, доступным для всех блоков приложения. Ссылка на <code>ViewRepository</code> может быть также получена через интерфейс инфраструктуры <code>
          <link linkend="metadata">Metadata</link>
        </code>. Для получения экземпляра <code>View</code>, содержащегося в репозитории, используются методы <code>getView()</code>. Для развертывания XML-описателей представлений в репозитории используются методы  <code>deployViews()</code> базовой реализации <code>AbstractViewRepository</code>.</para>
      <para>В репозитории для каждой сущности по умолчанию доступны два  представления с именами <filename>_local</filename> и <filename>_minimal</filename>:<itemizedlist>
          <listitem>
            <para><filename>_local</filename> включает в себя все <glossterm linkend="local_attribute">локальные</glossterm> атрибуты сущности</para>
          </listitem>
          <listitem>
            <para><filename>_minimal</filename> включает в себя атрибуты, входящие в имя экземпляра сущности, и задаваемые аннотацией <code>
                <link linkend="namePattern">@NamePattern</link>
              </code>. Если аннотация <code>@NamePattern</code>  для сущности не указана, данное представление не включает никаких атрибутов.</para>
          </listitem>
        </itemizedlist></para>
      <para>Подробная структура XML-описателей изложена в <xref linkend="views.xml"/></para>
      <para>Пример описателя представления для сущности Заказ, которое должно обеспечить загрузку всех локальных атрибутов, ассоциированного Покупателя и коллекции Пунктов заказа:<programlisting language="xml">&lt;view class=&quot;com.sample.sales.entity.Order&quot;
    name=&quot;orderWithCustomer&quot;
    extends=&quot;_local&quot;&gt;
  &lt;property name=&quot;customer&quot; view=&quot;_minimal&quot;/&gt;
  &lt;property name=&quot;items&quot; view=&quot;itemsInOrder&quot;/&gt;
&lt;/view&gt;</programlisting></para>
      <para>Рекомендуемый способ группировки и развертывания описателей представлений:<itemizedlist>
          <listitem>
            <para>В <link linkend="app_modules">модуле</link> <structname>global</structname>  в корне <filename>src</filename>  создать файл <filename>views.xml</filename> и поместить в него все описатели представлений, которые должны быть доступны глобально, т.е. на всех <link linkend="app_tiers">уровнях приложения</link>.</para>
          </listitem>
          <listitem>
            <para>Зарегистрировать данный файл в свойстве <property>
                <link linkend="cuba.viewsConfig">cuba.viewsConfig</link>
              </property> блока <structname>Middleware</structname> и используемых клиентских блоков, т.е. в файле <filename>app.properties</filename> модуля <structname>core</structname>, в файле <filename>web-app.properties</filename> модуля <structname>web</structname> и так далее. Это обеспечит автоматическое развертывание представлений на старте приложения в репозитории <structname>Middleware</structname> и клиентских блоков (см. метод <code>AbstractViewRepository.init()</code>).</para>
          </listitem>
          <listitem>
            <para>Если существуют представления, которые необходимы только какому-то одному клиентскому блоку приложения, то можно определить их в аналогичном файле данного блока, например, <filename>web-views.xml</filename>, и добавить этот файл в свойство <code>cuba.viewsConfig</code> этого блока, т.е. в данном случае в  файл <filename>web-app.properties</filename>. </para>
          </listitem>
        </itemizedlist></para>
      <para>Если на момент развертывания некоторого представления в репозитории уже есть представление для этого же класса сущности и с таким же именем, то новое будет проигнорировано. Для того чтобы представление заменило имеющееся в репозитории и гарантированно было развернуто, в XML-описателе должен быть явно указан атрибут <literal>overwrite = &quot;true&quot;</literal>.</para>
      <tip>
        <para>Рекомендуется давать представлениям &quot;описательные&quot; имена. Например, не &quot;browse&quot;, а &quot;customerBrowse&quot;. Это упрощает поиск XML-описателей представлений по имени в процессе разработки приложения.</para>
      </tip>
    </section>
  </section>
  <section id="managed_beans">
    <title>Управляемые бины</title>
    <para><firstterm>Управляемые бины (Managed Beans)</firstterm> − это программные компоненты, предназначенные для реализации бизнес-логики приложения. Термин &quot;управляемые&quot; в данном случае означает, что созданием экземпляров и установкой связей между такими компонентами управляет <glossterm linkend="container">контейнер</glossterm>, который является основной частью фреймворка <application>Spring</application>.</para>
    <warning>
      <para>Managed Bean представляет собой <firstterm>singleton</firstterm>, то есть в некотором блоке приложения существует только один экземпляр данного класса. Поэтому, если бин содержит изменяемые данные в полях (другими словами, имеет состояние), то обращение к таким данным необходимо синхронизировать.</para>
    </warning>
    <section>
      <title>Создание бина</title>
      <para>Для создания  управляемого бина достаточно добавить классу  Java аннотацию  <literal>@javax.annotation.ManagedBean</literal>. Например:<programlisting language="java">package com.sample.sales.core;

import com.sample.sales.entity.Order;
import javax.annotation.ManagedBean;

@ManagedBean(OrderWorker.NAME)
public class OrderWorker {
  public static final String NAME = &quot;sales_OrderWorker&quot;;

  public void calculateTotals(Order order) {
  }
}</programlisting></para>
      <para>Рекомендуется присваивать бину уникальное имя вида <literal>{имя_проекта}_{имя_класса}</literal>, и определять его в константе <code>NAME</code>. </para>
      <para>Класс управляемого бина должен находиться внутри дерева пакетов с корнем, заданным в элементе <literal>context:component-scan</literal> файла <filename>
          <link linkend="spring.xml">spring.xml</link>
        </filename>. В нашем случае файл <filename>spring.xml</filename> содержит элемент:<programlisting language="xml">&lt;context:component-scan base-package=&quot;com.sample.sales&quot;/&gt;</programlisting>что означает, что поиск аннотированных бинов для данного блока приложения будет происходить начиная с пакета <code>com.sample.sales</code>.</para>
      <para>Если нужно обеспечить возможность подмены реализации,  рекомендуется  выделять бизнес-интерфейс бина, например, следующим образом:</para>
      <programlisting language="java">package com.sample.sales.core;

import com.sample.sales.entity.Order;

public interface OrderWorker {
  String NAME = &quot;sales_OrderWorker&quot;;

  void calculateTotals(Order order);
}</programlisting>
      <programlisting language="java">package com.sample.sales.core;

import com.sample.sales.entity.Order;
import javax.annotation.ManagedBean;

@ManagedBean(OrderWorker.NAME)
public class OrderWorkerBean implements OrderWorker {
  @Override
  public void calculateTotals(Order order) {
  }
}</programlisting>
      <para>Управляемые бины можно создавать на любом <link linkend="app_tiers">уровне</link>, так как контейнер <application>Spring Framework</application> используется во всех стандартных блоках приложения.</para>
    </section>
    <section>
      <title>Использование бина</title>
      <para>Ссылку на бин можно получить с помощью инжекции или класса <code>AppBeans</code>. В качестве примера использования бина рассмотрим реализацию <link linkend="services">сервиса</link> <code>OrderService</code>, делегирующего выполнение бину <code>OrderWorker</code>:<programlisting language="java">package com.sample.sales.core;

import com.haulmont.cuba.core.Persistence;
import com.sample.sales.entity.Order;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import javax.inject.Inject;

@Service(OrderService.NAME)
public class OrderServiceBean implements OrderService {

  @Inject
  protected Persistence persistence;

  @Inject
  protected OrderWorker orderWorker;

  @Transactional
  @Override
  public BigDecimal calculateTotals(Order order) {
      Order entity = persistence.getEntityManager().merge(order);
      orderWorker.calculateTotals(entity);
  }
}</programlisting></para>
      <para>В данном примере сервис стартует <link linkend="transactions">транзакцию</link>, вносит полученный с клиентского уровня экземпляр сущности в <link linkend="entityManager">персистентный контекст</link>, и передает управление бину <code>OrderWorker</code>, который и содержит основную бизнес-логику. </para>
    </section>
  </section>
  <section id="jmx_beans">
    <title>JMX-бины</title>
    <para>Иногда требуется  предоставить администратору системы возможность просматривать и изменять  состояние некоторого <link linkend="managed_beans">управляемого бина</link> во время выполнения. В этом случае рекомендуется создать  JMX-бин - программный компонент, имеющий <glossterm linkend="jmx">JMX</glossterm>-интерфейс. Такой бин, как правило, делегирует вызовы управляемому бину, содержащему кэш, конфигурационные данные или статистику, к которым нужно обеспечить доступ через JMX.</para>
    <figure>
      <title/>
      <mediaobject>
        <imageobject>
          <imagedata align="center" fileref="img/JMXBeans.png"/>
        </imageobject>
      </mediaobject>
    </figure>
    <para>Как видно из диаграммы, JMX-бин состоит из интерфейса и класса реализации. Класс должен представлять собой <link linkend="managed_beans">управляемый бин</link>, то есть иметь аннотацию <code>@ManagedBean</code> и уникальное имя. Интерфейс JMX-бина специальным образом регистрируется в <link linkend="spring.xml">spring.xml</link> для создания в текущей JVM собственно JMX-интерфейса.</para>
    <para>Вызовы всех методов интерфейса JMX-бина перехватываются с помощью <application>Spring AOP</application> классом−<glossterm linkend="interceptor">интерцептором</glossterm> <methodname>MBeanInterceptor</methodname>, который обеспечивает установку правильного <code>ClassLoader</code> в контексте потока выполнения, и журналирование необработанных исключений.</para>
    <warning>
      <para>Интерфейс JMX-бина обязательно должен иметь имя вида <literal>{имя_класса}MBean</literal>.</para>
    </warning>
    <para>С JMX-интерфейсом можно работать из  внешних инструментов, таких как <code>jconsole</code> или <code>jvisualvm</code>. Кроме того, в состав блока Web Client платформы входит <link linkend="jmx_console">JMX консоль</link>, предоставляющая базовые средства просмотра состояния и вызова методов JMX-бинов.</para>
    <section>
      <title>Создание JMX-бина</title>
      <para>Рассмотрим процесс создания JMX-бина на примере.</para>
      <itemizedlist>
        <listitem>
          <para>Интерфейс JMX-бина:<programlisting language="java">package com.sample.sales.core;

import org.springframework.jmx.export.annotation.*;

@ManagedResource(description = &quot;Performs operations on Orders&quot;)
public interface OrdersMBean {

  @ManagedOperation(description = &quot;Recalculates an order amount&quot;)
  @ManagedOperationParameters({@ManagedOperationParameter(name = &quot;orderId&quot;, description = &quot;&quot;)})
  String calculateTotals(String orderId);
}</programlisting></para>
          <para>Интерфейс и его методы могут содержать аннотации для задания описания JMX-бина и его операций. Это описание будет отображаться во всех инструментах, работающих с данным JMX-интерфейсом, тем самым помогая администратору системы.</para>
          <para>Так как инструменты JMX поддерживают ограниченный набор типов данных,  параметры и результат метода желательно задавать типа <code>String</code>, и при необходимости выполнять конвертацию внутри метода.</para>
        </listitem>
        <listitem>
          <para>Класс JMX-бина:<programlisting language="java">package com.sample.sales.core;

import com.haulmont.cuba.core.*;
import com.haulmont.cuba.core.app.*;
import com.sample.sales.entity.Order;
import org.apache.commons.lang.exception.ExceptionUtils;
import javax.annotation.ManagedBean;
import javax.inject.Inject;
import java.util.UUID;

@ManagedBean(&quot;sales_OrdersMBean&quot;)
public class Orders implements OrdersMBean {

  @Inject
  protected OrderWorker orderWorker;

  @Inject
  protected Persistence persistence;

  @Authenticated
  @Override
  public String calculateTotals(final String orderId) {
      try {
          persistence.createTransaction().execute(new Transaction.Runnable() {
              @Override
              public void run(EntityManager em) {
                  Order entity = em.find(Order.class, UUID.fromString(orderId));
                  orderWorker.calculateTotals(entity);
              }
          });
          return &quot;Done&quot;;
      } catch (Throwable e) {
          return ExceptionUtils.getStackTrace(e);
      }
  }
}</programlisting></para>
          <para>Аннотация <code>@ManagedBean</code> определяет, что данный класс является управляемым бином с именем <literal>sales_OrdersMBean</literal>. Имя указано напрямую в аннотации, а не в константе, так как доступ к JMX-бину из кода Java не требуется.</para>
          <para>Рассмотрим реализацию метода <code>calculateTotals()</code>.<itemizedlist>
              <listitem>
                <para>Метод имеет аннотацию <code>@Authenticated</code>, т.е. при входе в метод и при отсутствии в потоке выполнения <link linkend="userSession">пользовательской сессии</link> выполняется <link linkend="system_authentication">системная аутентификация</link>.</para>
              </listitem>
              <listitem>
                <para>Тело метода обернуто в блок <code>try/catch</code>, так что метод в случае успешного выполнения возвращает строку &quot;Done&quot;, а в случае ошибки - stacktrace исключения в виде строки. </para>
                <para>Следует иметь в виду, что в данном случае все исключения обрабатываются, а значит, не попадают в <code>MBeanInterceptor</code> и не выводятся в журнал автоматически. Поэтому при необходимости логгировать исключения здесь нужно добавить вызов логгера в секции <code>catch</code>.</para>
              </listitem>
              <listitem>
                <para>Логика метода заключается в том, что он стартует транзакцию, загружает экземпляр сущности <code> Order</code> по  идентификатору, и передает управление бину <code>OrderWorker</code> для обработки.</para>
              </listitem>
            </itemizedlist></para>
        </listitem>
        <listitem>
          <para>Регистрация JMX-бина в <filename>spring.xml</filename>:</para>
          <programlisting language="xml">&lt;bean id=&quot;sales_MBeanExporter&quot; lazy-init=&quot;false&quot;
    class=&quot;com.haulmont.cuba.core.sys.jmx.MBeanExporter&quot;&gt;
  &lt;property name=&quot;beans&quot;&gt;
      &lt;map&gt;
          &lt;entry key=&quot;${cuba.webContextName}.sales:type=Orders&quot;
                 value-ref=&quot;sales_OrdersMBean&quot;/&gt;
      &lt;/map&gt;
  &lt;/property&gt;
&lt;/bean&gt;</programlisting>
        </listitem>
      </itemizedlist>
      <para>Все JMX-бины проекта объявляются в одном экземпляре <code>MBeanExporter</code>  в элементах <literal>map/entry</literal> свойства <code>beans</code>. Ключом элемента здесь является JMX ObjectName, значением - имя бина, заданное
в аннотации <code>@ManagedBean</code>. ObjectName начинается с имени веб-приложения, так как в одном экземпляре <application>Tomcat</application> (т.е. в одной JVM) может быть развернуто несколько веб-приложений, экспортирующих одинаковые JMX-интерфейсы.</para>
    </section>
    <section>
      <title>JMX-бины платформы</title>
      <para>В данном разделе описаны некоторые имеющиеся в платформе JMX-бины.</para>
      <section id="cachingFacadeMBean">
        <title>CachingFacadeMBean</title>
        <para><code>CachingFacadeMBean</code> предоставляет методы очистки различных кэшей в блоках <structname>Middleware</structname> и  <structname>Web Client</structname>.</para>
        <para>JMX ObjectName: <literal>app-core.cuba:type=CachingFacade</literal> и <literal>app.cuba:type=CachingFacade</literal></para>
      </section>
      <section id="configStorageMBean">
        <title>ConfigStorageMBean</title>
        <para><code>ConfigStorageMBean</code> позволяет просматривать и задавать значения <link linkend="app_properties">свойствам приложения</link> в блоках <structname>Middleware</structname>, <structname>Web Client</structname> и <structname>Web Portal</structname>.</para>
        <para>Данный интерфейс имеет отдельные наборы методов для работы  с параметрами конфигурации и развертывания (<code>*AppProperties</code>) и с параметрами времени выполнения (<code>*DbProperties</code>), что обусловлено различием механизмов хранения этих категорий свойств.</para>
        <warning>
          <para>Существуют следующие ограничения в использовании интерфейса <code>ConfigStorageMBean</code>:<itemizedlist>
              <listitem>
                <para>Отображаются только явно установленные в месте хранения свойства. Если значение свойства не задано, то в случае обращения к нему из кода программы через <link linkend="config_interfaces">конфигурационный интерфейс</link>, возвращается значение по умолчанию. Однако через <code>ConfigStorageMBean</code> значение по умолчанию не может быть получено. </para>
              </listitem>
              <listitem>
                <para>Измененные значения для свойств, хранящихся в файлах, не сохраняются, и действуют только до рестарта данного блока.</para>
              </listitem>
            </itemizedlist></para>
        </warning>
        <para>JMX ObjectName: <literal>app-core.cuba:type=ConfigStorage</literal>, <literal>app.cuba:type=ConfigStorage</literal>, <literal>app-portal.cuba:type=ConfigStorage</literal></para>
      </section>
      <section>
        <title>EmailerMBean</title>
        <para><code>EmailerMBean</code> позволяет просмотреть текущие значения параметров <link linkend="email_sending">отсылки email</link>, а также отправить тестовое сообщение.</para>
        <para>JMX ObjectName: <literal>app-core.cuba:type=Emailer</literal></para>
      </section>
      <section id="persistenceManagerMBean">
        <title>PersistenceManagerMBean</title>
        <para><code>PersistenceManagerMBean</code> предоставляет следующие возможности:<itemizedlist>
            <listitem>
              <para>управление механизмом <link linkend="entity_statistics">статистики сущностей</link></para>
            </listitem>
            <listitem>
              <para>отображение новых скриптов обновления БД методом <code>findUpdateDatabaseScripts()</code> и запуск обновления методом <code>updateDatabase()</code></para>
            </listitem>
            <listitem>
              <para>запуск произвольных JPQL запросов в контексте <structname>Middleware</structname> методами <code>jpqlLoadList()</code>, <code>jpqlExecuteUpdate()</code></para>
            </listitem>
          </itemizedlist></para>
        <para>JMX ObjectName: <literal>app-core.cuba:type=PersistenceManager</literal></para>
      </section>
      <section id="scriptingManagerMBean">
        <title>ScriptingManagerMBean</title>
        <para><code>ScriptingManagerMBean</code> является JMX-фасадом для интерфейса инфраструктуры <code>
            <link linkend="scripting">Scripting</link>
          </code>.</para>
        <para>JMX ObjectName: <literal>app-core.cuba:type=ScriptingManager</literal></para>
        <para>JMX атрибуты:<itemizedlist>
            <listitem>
              <para><code>RootPath</code> - абсолютный путь к <link linkend="conf_dir">конфигурационному каталогу</link> <link linkend="app_tiers">блока приложения</link>, в котором запущен данный бин</para>
            </listitem>
          </itemizedlist></para>
        <para>JMX операции:<itemizedlist>
            <listitem>
              <para><code>runGroovyScript()</code> - выполнить скрипт Groovy в контексте <structname>Middleware</structname> и вернуть результат. В скрипт передаются следующие переменные:<itemizedlist>
                  <listitem>
                    <para><code>persistence</code> типа <code>
                        <link linkend="persistence">Persistence</link>
                      </code> </para>
                  </listitem>
                  <listitem>
                    <para><code>metadata</code> типа <code>
                        <link linkend="metadata">Metadata</link>
                      </code></para>
                  </listitem>
                  <listitem>
                    <para><code>configuration</code> типа <code>
                        <link linkend="configuration">Configuration</link>
                      </code></para>
                  </listitem>
                </itemizedlist></para>
              <para>Для отображения в JMX-интерфейсе результат должен быть типа <code>String</code>. В остальном аналогичен методу <code>Scripting.<link linkend="scripting.runGroovyScript">runGroovyScript()</link></code>. </para>
              <para>Пример скрипта, создающего набор тестовых пользователей:<programlisting language="java">import com.haulmont.cuba.core.*
import com.haulmont.cuba.core.global.*
import com.haulmont.cuba.security.entity.*

PasswordEncryption passwordEncryption = AppBeans.get(PasswordEncryption.class)

Transaction tx = persistence.createTransaction()
try {
  EntityManager em = persistence.getEntityManager()
  Group group = em.getReference(Group.class, UUID.fromString(&apos;0fa2b1a5-1d68-4d69-9fbd-dff348347f93&apos;))
  for (i in (1..250)) {
      User user = new User()
      user.setGroup(group)
      user.setLogin(&quot;user_${i.toString().padLeft(3, &apos;0&apos;)}&quot;)
      user.setName(user.login)
      user.setPassword(passwordEncryption.getPasswordHash(user.id, &apos;1&apos;));
      em.persist(user)
  }
  tx.commit()
} finally {
  tx.end()
}</programlisting></para>
            </listitem>
          </itemizedlist></para>
      </section>
      <section id="serverInfoMBean">
        <title>ServerInfoMBean</title>
        <para><code>ServerInfoMBean</code> предоставляет общую информацию о данном блоке <structname>Middleware</structname>: номер и дату сборки, <link linkend="serverId">идентификатор сервера</link>.</para>
        <para>JMX ObjectName: <literal>app-core.cuba:type=ServerInfo</literal></para>
      </section>
    </section>
  </section>
  <section id="infrastructure_interfaces">
    <title>Интерфейсы инфраструктуры</title>
    <para>Интерфейсы инфраструктуры обеспечивают доступ к часто используемой функциональности платформы. Большинство из этих интерфейсов расположены в <link linkend="app_modules">модуле</link> <structname>global</structname> и могут быть использованы как на среднем слое, так и в <link linkend="app_tiers">блоках</link> клиентского уровня, но некоторые (например, <code>
        <link linkend="persistence">Persistence</link>
      </code>) доступны только коду среднего слоя.</para>
    <para>Интерфейсы инфраструктуры реализуются бинами <application>Spring Framework</application>, поэтому они могут быть инжектированы в любые другие управляемые компоненты (<link linkend="managed_beans">Managed Beans</link>, <link linkend="services">сервисы среднего слоя</link>, <link linkend="screen_controller">контроллеры</link> экранов универсального пользовательского интерфейса.</para>
    <para>Кроме того, как и любые другие бины, интерфейсы инфраструктуры могут быть получены с помощью статических методов класса <code>AppBeans</code>, и использоваться в неуправляемых компонентах (<glossterm linkend="pojo">POJO</glossterm>, вспомогательных классах и пр.).</para>
    <section id="configuration">
      <title>Configuration</title>
      <para>Позволяет получать ссылки на <link linkend="config_interfaces">конфигурационные интерфейсы</link> там, где невозможна их инжекция.</para>
      <para>Пример:<programlisting language="java">String tempDir = AppBeans.get(Configuration.class).getConfig(GlobalConfig.class).getTempDir();</programlisting></para>
    </section>
    <section id="messages">
      <title>Messages</title>
      <para>Интерфейс <code>Messages</code> обеспечивает получение <link linkend="localization">локализованных строк сообщений</link>.</para>
      <para>Рассмотрим методы интерфейса подробнее.</para>
      <itemizedlist>
        <listitem>
          <para><code>getMessage()</code> - возвращает локализованное сообщение по ключу, имени пакета сообщений и требуемой локали. Существует несколько модификаций данного метода в зависимости от набора параметров. Если локаль не указана в параметре метода, используется локаль текущего пользователя. </para>
          <para>Примеры:<programlisting language="java">@Inject
protected Messages messages;
...
String message1 = messages.getMessage(getClass(), &quot;someMessage&quot;);
String message2 = messages.getMessage(&quot;com.abc.sales.web.customer&quot;, &quot;someMessage&quot;);
String message3 = messages.getMessage(RoleType.STANDARD);</programlisting></para>
        </listitem>
        <listitem>
          <para><code>formatMessage()</code> - находит локализованное сообщение по ключу, имени пакета сообщений и требуемой локали, и использует его для форматирования переданных параметров. Формат задается по правилам метода <code>String.format()</code>. Существует несколько модификаций данного метода в зависимости от набора параметров. Если локаль не указана в параметре метода, используется локаль текущего пользователя.</para>
          <para>Пример:<programlisting language="java">String formattedValue = messages.formatMessage(getClass(), &quot;someFormat&quot;, someValue);</programlisting></para>
        </listitem>
        <listitem>
          <para><code>getMainMessage()</code> - возвращает локализованное сообщение из <link linkend="main_message_pack">главного пакета</link> данного <link linkend="app_tiers">блока</link> приложения.</para>
          <para>Пример:<programlisting language="java">protected Messages messages = AppBeans.get(Messages.class);
...
messages.getMainMessage(&quot;actions.Ok&quot;);</programlisting></para>
        </listitem>
        <listitem>
          <para><code>getMainMessagePack()</code> - возвращает имя <link linkend="main_message_pack">главного пакета</link> сообщений данного блока приложения.</para>
          <para>Пример:<programlisting language="java">String formattedValue = messages.formatMessage(messages.getMainMessagePack(), &quot;someFormat&quot;, someValue);</programlisting></para>
        </listitem>
        <listitem>
          <para><code>getTools()</code> - возвращает экземпляр интерфейса  <code>MessageTools</code>  (см. ниже).</para>
        </listitem>
      </itemizedlist>
      <section id="messageTools">
        <title>MessageTools</title>
        <para><link linkend="managed_beans">ManagedBean</link>, содержащий вспомогательные методы работы с <link linkend="localization">локализованными сообщениями</link>. Интерфейс <code>MessageTools</code> можно получить либо методом <code>Messages.getTools()</code>, либо как любой другой бин - инжекцией или через класс <code>AppBeans</code>. </para>
        <para>Методы <code>MessageTools</code>:<itemizedlist>
            <listitem id="messageTools.loadString">
              <para><code>loadString()</code> - возвращает локализованное сообщение, заданное ссылкой вида <literal>msg://{messagePack}/{key}</literal>.</para>
              <para>Составные части ссылки:<itemizedlist>
                  <listitem>
                    <para><literal>msg://</literal> - обязательный префикс.</para>
                  </listitem>
                  <listitem>
                    <para><literal>{messagePack}</literal> - необязательное имя пакета сообщения. Если не указано, предполагается, что имя пакета передается в <code>loadString()</code> отдельным параметром.</para>
                  </listitem>
                  <listitem>
                    <para><literal>{key}</literal> - ключ сообщения в пакете.</para>
                  </listitem>
                </itemizedlist></para>
              <para>Примеры ссылок на сообщения:<programlisting>msg://someMessage
msg://com.abc.sales.web.customer/someMessage</programlisting></para>
            </listitem>
            <listitem>
              <para><code>getEntityCaption()</code> - возвращает локализованное название сущности.</para>
            </listitem>
            <listitem>
              <para><code>getPropertyCaption()</code> - возвращает локализованное название атрибута сущности.</para>
            </listitem>
            <listitem>
              <para><code>hasPropertyCaption()</code> - определяет, задано ли для атрибута сущности локализованное название. </para>
            </listitem>
            <listitem>
              <para><code>getLocValue()</code> - возвращает локализованное значение атрибута сущности, основываясь на определении аннотации <code>
                  <link linkend="localizedValue_annotation">@LocalizedValue</link>
                </code>.</para>
            </listitem>
            <listitem>
              <para><code>getMessageRef()</code> - формирует для <link linkend="metaProperty">мета-свойства</link> <link linkend="messageTools.loadString">ссылку на сообщение</link>, по которой  можно получить локализованное название атрибута сущности.</para>
            </listitem>
            <listitem>
              <para><code>getDefaultLocale()</code> - возвращает локаль приложения по умолчанию, то есть указанную первой в списке свойства <link linkend="cuba.availableLocales">
                  <property>cuba.availableLocales</property>
                </link>.</para>
            </listitem>
            <listitem>
              <para><code>useLocaleLanguageOnly()</code> - возвращает <code>true</code>, если в списке поддерживаемых приложением локалей, заданном свойством <link linkend="cuba.availableLocales">
                  <property>cuba.availableLocales</property>
                </link>, для всех локалей определен  только язык, а <code>country</code> и <code>variant</code> не указаны. Этим методом пользуются механизмы платформы, которым необходимо найти наиболее подходящую локаль из списка поддерживаемых на основе локали, полученной  из внешних источников, таких как операционная система или HTTP запрос.</para>
            </listitem>
            <listitem>
              <para><code>trimLocale()</code> - удаляет из переданной локали все кроме языка, если метод <code>useLocaleLanguageOnly()</code> возвращает <code>true</code>.</para>
            </listitem>
          </itemizedlist></para>
        <para>Для расширения набора вспомогательных методов в конкретном приложении бин <code>MessageTools</code> можно <link linkend="bean_extension">переопределить</link>. Примеры работы с  расширенным интерфейсом:<programlisting language="java">MyMessageTools tools = messages.getTools();
tools.foo();</programlisting><programlisting language="java">((MyMessageTools) messages.getTools()).foo();</programlisting> </para>
      </section>
    </section>
    <section id="metadata">
      <title>Metadata</title>
      <para>Интерфейс <code>Metadata</code> обеспечивает доступ к сессии <link linkend="metadata_framework">метаданных</link> и репозиторию <link linkend="views">представлений</link>.</para>
      <para>Методы интерфейса:<itemizedlist>
          <listitem>
            <para><code>getSession()</code> - возвращает экземпляр сессии <link linkend="metadata_framework">метаданных</link> </para>
          </listitem>
          <listitem>
            <para><code>getViewRepository()</code> - возвращает экземпляр репозитория <link linkend="views">представлений</link></para>
          </listitem>
          <listitem>
            <para><code>getExtendedEntities()</code> - возвращает экземпляр <code>ExtendedEntities</code>, предназначенный для работы с расширенными сущностями. Подробнее см. <xref linkend="entity_extension"/></para>
          </listitem>
          <listitem>
            <para><code>create()</code> - создать экземпляр сущности, учитывая возможность расширения. Подробнее см. <xref linkend="entity_extension"/> </para>
          </listitem>
          <listitem>
            <para><code>getTools()</code> - возвращает экземпляр интерфейса  <code>MetadataTools</code>  (см. ниже).</para>
          </listitem>
        </itemizedlist></para>
      <section>
        <title>MetadataTools</title>
        <para><link linkend="managed_beans">ManagedBean</link>, содержащий вспомогательные методы работы с метаданными. Интерфейс <code>MetadataTools</code> можно получить либо методом <code>Metadata.getTools()</code>, либо как любой другой бин - инжекцией или через класс <code>AppBeans</code>.</para>
        <para>Методы <code>MetadataTools</code>:<itemizedlist>
            <listitem>
              <para><code>getAllPersistentMetaClasses()</code> - возвращает коллекцию <link linkend="metaClass">мета-классов</link> персистентных сущностей</para>
            </listitem>
            <listitem>
              <para><code>getAllEmbeddableMetaClasses()</code> - возвращает коллекцию <link linkend="metaClass">мета-классов</link> встраиваемых сущностей</para>
            </listitem>
            <listitem>
              <para><code>getAllEnums()</code> - возвращает коллекцию классов перечислений, используемых в качестве типов атрибутов сущностей</para>
            </listitem>
            <listitem>
              <para><code>format()</code> - форматирует переданное значение в соответствии с типом данных заданного <link linkend="metaProperty">мета-свойства</link></para>
            </listitem>
            <listitem>
              <para><code>isSystem()</code> - определяет, является ли переданное <link linkend="metaProperty">мета-свойство</link> системным, т.е. заданным в одном из <link linkend="base_entity_classes">базовых интерфейсов сущностей</link></para>
            </listitem>
            <listitem>
              <para><code>isPersistent()</code> - определяет, является ли переданное мета-свойство персистентным, т.е. хранимым в БД</para>
            </listitem>
            <listitem>
              <para><code>isTransient()</code> - определяет, является ли переданное мета-свойство или произвольный атрибут неперсистентным</para>
            </listitem>
            <listitem>
              <para><code>isEmbedded()</code> - определяет, является ли переданное мета-свойство встроенным объектом</para>
            </listitem>
            <listitem>
              <para><code>isAnnotationPresent()</code> - определяет наличие указанной аннотации на классе или его предках</para>
            </listitem>
            <listitem>
              <para><code>getNamePatternProperties()</code> - возвращает коллекцию мета-свойств атрибутов, входящих в  имя экземпляра, возвращаемого методом <code>Instance.getInstanceName()</code>. См. <code>
                  <link linkend="namePattern">@NamePattern</link>
                </code>.</para>
            </listitem>
          </itemizedlist></para>
        <para>Для расширения набора вспомогательных методов в конкретном приложении бин <code>MetadataTools</code> можно <link linkend="bean_extension">переопределить</link>. Примеры работы с  расширенным интерфейсом:<programlisting language="java">MyMetadataTools tools = metadata.getTools();
tools.foo();</programlisting><programlisting language="java">((MyMetadataTools) metadata.getTools()).foo();</programlisting></para>
      </section>
    </section>
    <section id="resources">
      <title>Resources</title>
      <para>Обеспечивает загрузку ресурсов по следующим правилам:<orderedlist>
          <listitem>
            <para>если указанное местонахождение представляет собой URL, ресурс загружается из этого URL;</para>
          </listitem>
          <listitem>
            <para>если указанное местонахождение начинается с префикса <literal>classpath:</literal>, ресурс загружается из classpath;</para>
          </listitem>
          <listitem>
            <para>если не URL и не начинается с <literal>classpath:</literal>, то:<orderedlist>
                <listitem>
                  <para>в <link linkend="conf_dir">каталоге конфигурации</link> приложения ищется файл, используя указанное местонахождение как относительный путь. Если файл найден, ресурс загружается из него;</para>
                </listitem>
                <listitem>
                  <para>если ресурс не найден на предыдущих этапах, он загружается из classpath.</para>
                </listitem>
              </orderedlist></para>
          </listitem>
        </orderedlist></para>
      <para>На практике явное указание URL или префикса <code>classpath:</code> используется редко, т.е. обычно ресурсы загружаются либо из <link linkend="conf_dir">конфигурационного каталога</link>, либо из classpath. Ресурс в конфигурационном каталоге замещает одноименный ресурс в classpath.</para>
      <para>Методы <code>Resources</code>:<itemizedlist>
          <listitem>
            <para><code>getResourceAsStream()</code> - возвращает <code>InputStream</code> для указанного ресурса, либо <code>null</code>, если ресурс не найден. Поток должен быть закрыт после использования, например:<programlisting language="java">@Inject
protected Resources resources;
...
InputStream stream = null;
try {
  stream = resources.getResourceAsStream(resourceLocation);
  ...
} finally {
  IOUtils.closeQuietly(stream);
}</programlisting></para>
            <para>Возможно использование &quot;try with resources&quot;:<programlisting language="java">try (InputStream stream = resources.getResourceAsStream(resourceLocation)) {
  ...
}</programlisting></para>
          </listitem>
          <listitem>
            <para><code>getResourceAsString()</code> - возвращает указанный ресурс в виде строки, либо <code>null</code>, если ресурс не найден</para>
          </listitem>
        </itemizedlist></para>
    </section>
    <section id="scripting">
      <title>Scripting</title>
      <para>Интерфейс <code>Scripting</code> позволяет динамически (т.е. во время работы приложения) компилировать и загружать классы Java и Groovy, а также выполнять скрипты и выражения на Groovy.</para>
      <para>Методы <code>Scripting</code>:<itemizedlist>
          <listitem>
            <para><code>evaluateGroovy()</code> - выполняет выражение на Groovy и возвращает его результат. </para>
            <para>Свойство приложения <property>
                <link linkend="cuba.groovyEvaluatorImport">cuba.groovyEvaluatorImport</link>
              </property> позволяет определить общий набор импортируемых классов, подставляемых в каждое выполняемое выражение. По умолчанию все стандартные блоки приложения импортируют класс <code>
                <link linkend="persistenceHelper">PersistenceHelper</link>
              </code>.</para>
            <para>Скомпилированные выражения кэшируются, что значительно ускоряет повторное выполнение.</para>
            <para>Пример:<programlisting language="java">@Inject
protected Scripting scripting;
...
Integer intResult = scripting.evaluateGroovy(&quot;2 + 2&quot;, new Binding());

Binding binding = new Binding();
binding.setVariable(&quot;instance&quot;, new User());
Boolean boolResult = scripting.evaluateGroovy(&quot;return PersistenceHelper.isNew(instance)&quot;, binding);</programlisting></para>
          </listitem>
          <listitem id="scripting.runGroovyScript">
            <para><code>runGroovyScript()</code> - выполняет скрипт Groovy и возвращает его результат.</para>
            <para>Скрипт должен быть расположен либо в <link linkend="conf_dir">конфигурационном каталоге</link> приложения, либо в classpath (текущая реализация <code>Scripting</code> поддерживает ресурсы classpath только внутри JAR-файлов). Скрипт в конфигурационном каталоге замещает одноименный скрипт в classpath.</para>
            <para>Путь к скрипту указывается с разделителями <literal>/</literal>, в начале пути символ <literal>/</literal> не требуется.</para>
            <para>Пример:<programlisting language="java">@Inject
protected Scripting scripting;
...
Binding binding = new Binding();
binding.setVariable(&quot;itemId&quot;, itemId);
BigDecimal amount = scripting.runGroovyScript(&quot;com/abc/sales/CalculatePrice.groovy&quot;, binding);</programlisting></para>
          </listitem>
          <listitem>
            <para><code>loadClass()</code> - загружает Java или Groovy класс, используя следующую последовательность действий:<orderedlist>
                <listitem>
                  <para>Если класс уже загружен, возвращает его.</para>
                </listitem>
                <listitem>
                  <para>Ищет исходный текст Groovy (файл <filename>*.groovy</filename>) в каталоге конфигурации. Если найден, компилирует его, загружает  и возвращает класс.</para>
                </listitem>
                <listitem>
                  <para>Ищет исходный текст Java (файл <filename>*.java</filename>) в каталоге конфигурации. Если найден, компилирует его, загружает и возвращает класс.</para>
                </listitem>
                <listitem>
                  <para>Ищет скомпилированный класс в classpath, если найден - загружает и возвращает его.</para>
                </listitem>
                <listitem>
                  <para>Если ничего не найдено, возвращает <code>null</code>.</para>
                </listitem>
              </orderedlist></para>
            <para>Файлы исходных текстов Java и Groovy  в каталоге конфигурации можно изменять во время работы приложения. При следующем вызове <code>loadClass()</code> соответствующий класс будет перекомпилирован и возвращен новый, однако существуют следующие ограничения:<itemizedlist>
                <listitem>
                  <para>нельзя изменять тип исходного текста с Groovy на Java</para>
                </listitem>
                <listitem>
                  <para>если существовал исходный текст Groovy, и был однажды скомпилирован, то удаление файла исходного текста не приведет к загрузке другого класса из classpath - будет по-прежнему возвращаться класс, скомпилированный из  удаленного исходника.</para>
                </listitem>
              </itemizedlist></para>
            <para>Пример:<programlisting language="java">@Inject
protected Scripting scripting;
...
Class calculatorClass = scripting.loadClass(&quot;com.abc.sales.PriceCalculator&quot;);</programlisting></para>
          </listitem>
          <listitem>
            <para><code>getClassLoader()</code> - возвращает <code>ClassLoader</code>, способный работать по правилам, описанным выше для метода <code>loadClass()</code>.</para>
          </listitem>
        </itemizedlist></para>
      <para>Кэш скомпилированных классов можно очистить во время выполнения с помощью JMX-бина  <link linkend="cachingFacadeMBean">CachingFacadeMBean</link>.</para>
      <para>См. также <xref linkend="scriptingManagerMBean"/></para>
    </section>
    <section id="security">
      <title>Security</title>
      <para>Обеспечивает авторизацию - проверку прав пользователя на различные объекты системы. Перед вызовом соответствующих методов <link linkend="userSession">UserSession</link> выполняется поиск исходного мета-класса сущности, что является важным при наличии <link linkend="entity_extension">расширений</link>. Кроме методов, дублирующих методы <code>UserSession</code>, данный интерфейс имеет методы <code>isEntityAttrReadPermitted()</code> и <code>isEntityAttrUpdatePermitted()</code>, предназначенные для определения доступности пути к атрибуту с учетом доступности атрибутов и сущностей, входящих в этот путь.</para>
      <para>Подробнее см. <xref linkend="authentication"/></para>
    </section>
    <section id="timeSource">
      <title>TimeSource</title>
      <para>Обеспечивает получение текущего времени. Применение <code>new Date()</code> и т.п. в прикладном коде не рекомендуется.</para>
      <para>Примеры:<programlisting language="java">@Inject
protected TimeSource timeSource;
...
Date date = timeSource.currentTimestamp();</programlisting><programlisting language="java">long startTime = AppBeans.get(TimeSource.class).currentTimeMillis();</programlisting></para>
    </section>
    <section id="userSessionSource">
      <title>UserSessionSource</title>
      <para>Обеспечивает получение объекта сессии текущего пользователя. Подробнее см. <xref linkend="authentication"/></para>
    </section>
    <section id="uuidSource">
      <title>UuidSource</title>
      <para>Обеспечивает получение значений <code>UUID</code>, в том числе для идентификаторов сущностей. Применение <code>UUID.randomUUID()</code> в прикладном коде не рекомендуется.</para>
      <para>Для вызова из статического контекста можно использовать класс <code>UuidProvider</code>, который имеет также дополнительный метод <code>fromString()</code>, работающий быстрее, чем стандартный метод <code>UUID.fromString()</code>.</para>
    </section>
      <section id="dataManager">
        <title>DataManager</title>
        <para>Интерфейс <code>DataManager</code> является универсальным средством для загрузки графов сущностей из
            базы данных, и для сохранения изменений, произведенных в detached экземплярах сущностей. </para>
        <para><code>DataManager</code> всегда стартует новую транзакцию и по завершении работы выполняет коммит, таким
            образом возвращая сущности в <link linkend="entity_states">detached состоянии</link>.</para>
        <para>Методы <code>DataManager</code>:<itemizedlist>
            <listitem>
              <para><code>load()</code>, <code>loadList()</code> - загружает граф сущностей в соответствии с параметрами
                  переданного объекта <code>LoadContext</code>. </para>
              <para>В <code>LoadContext</code> обязательно должен быть передан либо JPQL-запрос, либо идентификатор
                  сущности. Если передано и то и другое, используется запрос, а идентификатор игнорируется. </para>
              <para>Правила создания запросов аналогичны описанным в <xref linkend="query"/>. Отличием является то,
                  что в запросе <code>LoadContext</code> могут быть использованы только именованные параметры,
                  позиционные не поддерживаются.</para>
              <para>Методы <code>load()</code> и <code>loadList()</code> проверяют наличие у пользователя
                  <link linkend="permissions">права</link> <code>EntityOp.READ</code> на загружаемую сущность.
                  Кроме того, при извлечении сущностей из БД накладываются <link linkend="constraints">ограничения</link>
                  групп доступа. Для отмены действия ограничений в текущем запросе можно передать в <code>LoadContext</code>
                  атрибут <code>useSecurityConstraints = false</code>.</para>
              <para>Примеры загрузки сущностей  в контроллере экрана:
                  <programlisting language="java"><xi:include href="../../source/common/dataManager_1.java" encoding="UTF-8" parse="text"/></programlisting>
              </para>
            </listitem>
            <listitem>
              <para><code>commit()</code> - сохраняет в базе данных набор сущностей, переданный в объекте
                  <code>CommitContext</code>. Отдельно указываются коллекции сущностей, которые нужно сохранить,
                  и которые нужно удалить.</para>
              <para>Метод возвращает набор экземпляров сущностей, возвращенных из метода
                  <link linkend="entityManager">EntityManager</link>.merge(), то есть по сути свежие экземпляры,
                  только что обновленные в БД. Дальнейшая работа должна производиться именно с этими возвращенными
                  экземплярами, чтобы предотвратить потерю данных или исключения оптимистичной блокировки. Для того,
                  чтобы обеспечить наличие нужных атрибутов у возвращенных сущностей, с помощью мэп
                  <code>CommitContext.getViews()</code> можно указать <link linkend="views">представление</link> для
                  каждого сохраняемого экземпляра. </para>
              <para>Метод <code>commit()</code>  проверяет наличие у пользователя <link linkend="permissions">права</link>
                  <code>EntityOp.UPDATE</code> на изменяемые сущности, и <code>EntityOp.DELETE</code> на  удаляемые. </para>
              <para>Примеры сохранения коллекций сущностей:
                  <programlisting language="java"><xi:include href="../../source/common/dataManager_2.java" encoding="UTF-8" parse="text"/></programlisting>
              </para>
            </listitem>
            <listitem>
                <para><code>reload()</code> - удобные методы для перезагрузки экземпляра сущности с требуемым
                    <link linkend="views">представлением</link>. Делегируют выполнение методу <code>load()</code>.</para>
            </listitem>
            <listitem>
                <para><code>remove()</code> - удаляет экземпляр сущности из базы данных. Делегируют выполнение методу
                    <code>commit()</code>.</para>
            </listitem>
          </itemizedlist></para>
        <para>В процессе загрузки данных <code>DataManager</code> может реализовывать дополнительную функциональность,
            описанную ниже.</para>
        <section id="query_with_distinct">
          <title>Запросы с distinct</title>
          <para>В JPQL запросах для экранов со списками сущностей, в которых включено постраничное отображение и
              возможна непредсказуемая модификация запроса <link linkend="gui_Filter">универсальным фильтром</link> или
              механизмом ограничений групп доступа, при отсутствии в запросе оператора <literal>distinct</literal> может
              возникать следующий эффект: <itemizedlist>
              <listitem>
                <para>при объединении с коллекцией на уровне извлечения из базы данных возникает набор с дубликатами строк</para>
              </listitem>
              <listitem>
                <para>на клиентском уровне в источнике данных дубликаты исчезают, т.к. попадают в мэп
                    (<code>java.util.Map</code>) </para>
              </listitem>
              <listitem>
                <para>при постраничном отображении на одной странице оказывается меньшее количество строк, чем запрошено,
                    общее количество строк наоборот завышено.</para>
              </listitem>
            </itemizedlist></para>
          <para>Таким образом, рекомендуется в JPQL запросы браузеров включать предложение <literal> distinct</literal>,
              которое гарантирует отсутствие дубликатов записей при выборке из базы данных. Однако в некоторых серверах БД
              (в частности <application>PostgreSQL</application>) при большом количестве извлекаемых записей (более 10000)
              SQL запрос с <literal>distinct</literal> выполняется недопустимо долго.</para>
          <para>Для решения этой проблемы в платформе реализована возможность корректной работы без
              <literal>distinct</literal> на уровне SQL. Данный механизм включается свойством приложения
              <link linkend="cuba.inMemoryDistinct">cuba.inMemoryDistinct</link>, при активации которого выполняется
              следующее:
              <itemizedlist>
              <listitem>
                <para>В JPQL запросе должен по-прежнему присутствовать <literal>select distinct</literal></para>
              </listitem>
              <listitem>
                <para>В <code>DataManager</code> из JPQL запроса перед отправкой в ORM <literal>distinct</literal>
                    вырезается  </para>
              </listitem>
              <listitem>
                <para>После загрузки страницы данных на <structname>Middleware</structname> удаляются дубликаты и
                    выполняются дополнительные запросы к БД для получения нужного количества строк, которые затем и
                    возвращаются клиенту.</para>
              </listitem>
            </itemizedlist></para>
        </section>
        <section id="query_from_selected">
          <title>Последовательная выборка</title>
          <para><code>DataManager</code> может выполнять последовательную выборку данных из результатов предыдущего
              запроса. Эта возможность используется в <link linkend="gui_Filter">универсальном фильтре</link> при
              последовательном наложении фильтров. </para>
          <para>Данный механизм работает следующим образом:<itemizedlist>
              <listitem>
                <para>При получении <code>LoadContext</code> с установленными атрибутами <code>prevQueries</code> и
                    <code>queryKey</code> <code>DataManager</code> выполняет выборку по предыдущему запросу и сохраняет
                    идентификаторы полученных сущностей в таблице <database>SYS_QUERY_RESULT</database> (соответствующей
                    сущности <literal>sys$QueryResult</literal>), разделяя наборы записей по идентификаторам
                    пользовательских сессий и ключу сеанса выборки <code>queryKey</code>. </para>
              </listitem>
              <listitem>
                <para>Текущий запрос модифицируется для объединения с результатами предыдущего, так что в итоге возвращает
                    данные, соответствующие условиям обоих запросов, объединенных по &quot;И&quot;.</para>
              </listitem>
              <listitem>
                <para>Далее процесс может повторяться, при  этом уменьшающийся набор предыдущих результатов удаляется из таблицы <database>SYS_QUERY_RESULT</database> и заполняется заново.</para>
              </listitem>
            </itemizedlist></para>
          <para>Таблицу <database>SYS_QUERY_RESULT</database> необходимо периодически чистить от ненужных результатов
              запросов, оставленных завершенными пользовательскими сессиями. Для этого предназначен метод
              <code>deleteForInactiveSessions</code> бина <code>QueryResultsManagerAPI</code>. В прикладном проекте с
              включенным параметром <link linkend="cuba.allowQueryFromSelected">cuba.allowQueryFromSelected</link> необходимо
              вызывать этот метод из <link linkend="scheduled_tasks">назначенных заданий</link>, например:<programlisting language="xml">&lt;task:scheduled-tasks scheduler=&quot;scheduler&quot;&gt;
      &lt;task:scheduled ref=&quot;cuba_QueryResultsManager&quot; method=&quot;deleteForInactiveSessions&quot; fixed-rate=&quot;600000&quot;/&gt;
  &lt;/task:scheduled-tasks&gt;</programlisting></para>
        </section>
      </section>
  </section>
  <section id="appContext">
    <title>AppContext</title>
    <para><code>AppContext</code> - системный класс, в статических полях которого хранятся ссылки на некоторые общие для любого <link linkend="app_tiers">блока</link> приложения компоненты:<itemizedlist>
        <listitem>
          <para><code>ApplicationContext</code> фреймворка <application>Spring</application></para>
        </listitem>
        <listitem>
          <para>Набор <link linkend="app_properties">свойств приложения</link>, загруженных из файлов <filename>app.properties</filename></para>
        </listitem>
        <listitem>
          <para><code>ThreadLocal</code> переменная, хранящая экземпляры <code>SecurityContext</code></para>
        </listitem>
        <listitem>
          <para>Коллекция слушателей жизненного цикла приложения (<code>AppContext.Listener</code>)</para>
        </listitem>
      </itemizedlist></para>
    <para><code>AppContext</code> инициализируется на запуске приложения классами-загрузчиками, специфичными для типа <link linkend="app_tiers">блока</link> приложения:<itemizedlist>
        <listitem>
          <para>загрузчик <structname>Middleware</structname> - <code>AppContextLoader</code></para>
        </listitem>
        <listitem>
          <para>загрузчик <structname>Web Client</structname> - <code>WebAppContextLoader</code></para>
        </listitem>
        <listitem>
          <para>загрузчик <structname>Web Portal</structname> - <code>PortalAppContextLoader</code></para>
        </listitem>
        <listitem>
          <para>загрузчик <structname>Desktop Client</structname> - <code>DesktopAppContextLoader</code></para>
        </listitem>
      </itemizedlist></para>
    <para><code>AppContext</code> может быть использован в прикладном коде для решения следующих задач:<itemizedlist>
        <listitem>
          <para>Регистрации слушателей, срабатывающих после полной инициализации и перед закрытием приложения, например:<programlisting language="java">AppContext.addListener(new AppContext.Listener() {
  @Override
  public void applicationStarted() {
      System.out.println(&quot;Application is ready&quot;);
  }

  @Override
  public void applicationStopped() {
      System.out.println(&quot;Application is closing&quot;);
  }
});</programlisting></para>
          <para>В момент вызова <code>applicationStarted()</code>:<itemizedlist>
              <listitem>
                <para>Полностью инициализированы все <link linkend="managed_beans">бины</link>, в том числе выполнены их методы <code>@PostConstruct</code>.</para>
              </listitem>
              <listitem>
                <para>Можно использовать статические методы получения бинов <code>AppBeans.get()</code>.</para>
              </listitem>
              <listitem>
                <para>Метод <code>AppContext.isStarted()</code> возвращает <code>true</code>.</para>
              </listitem>
              <listitem>
                <para>Метод <code>AppContext.isReady()</code> возвращает <code>false</code>.</para>
              </listitem>
              <listitem>
                <para>В блоке Middleware: если свойство приложения <link linkend="cuba.automaticDatabaseUpdate">cuba.automaticDatabaseUpdate</link> включено, все скрипты обновления БД успешно выполнены.</para>
              </listitem>
            </itemizedlist></para>
          <para>В момент вызова <code>applicationStopped()</code>:<itemizedlist>
              <listitem>
                <para>Все бины работоспособны и доступны через статические методы <code>AppBeans.get()</code>.</para>
              </listitem>
              <listitem>
                <para>Метод <code>AppContext.isStarted()</code> возвращает <code>false</code>.</para>
              </listitem>
              <listitem>
                <para>Метод <code>AppContext.isReady()</code> возвращает <code>false</code>.</para>
              </listitem>
            </itemizedlist></para>
          <para>Практический пример использования <code>AppContext.Listener</code> см. в <xref linkend="app_start_recipe"/>.</para>
        </listitem>
        <listitem>
          <para>Получения значений <link linkend="app_properties">свойств приложения</link>, хранимых в файлах <filename>app.properties</filename>, если они недоступны через <link linkend="config_interfaces">конфигурационные интерфейсы</link>.</para>
        </listitem>
        <listitem>
          <para>Передачи <code>SecurityContext</code> в новые потоки выполнения, см. <xref linkend="authentication"/>.</para>
        </listitem>
      </itemizedlist></para>
    <tip>
      <para>Для получения ссылок на <application>Spring</application>-бины используйте инжекцию или статические методы класса <code>AppBeans</code>.</para>
      <para>Использование <code>AppContext.getApplicationContext().getBean()</code> не рекомендуется.</para>
    </tip>
  </section>
  <section id="app_properties">
    <title>Свойства приложения</title>
    <para>Свойства приложения − именованные данные различных типов, определяющие всевозможные аспекты конфигурации и функционирования приложения.</para>
    <para>По назначению свойства приложения можно классифицировать следующим образом:</para>
    <itemizedlist>
      <listitem>
        <para><firstterm>Конфигурационные параметры</firstterm> - задают наборы конфигурационных файлов и некоторые параметры пользовательского интерфейса, т.е. определяют функциональность приложения. </para>
        <para>Например: <property>cuba.springContextConfig</property>, <property>cuba.web.useLightHeader</property>.</para>
      </listitem>
      <listitem>
        <para><firstterm>Параметры развертывания</firstterm> - различные URL для соединения <link linkend="app_tiers">блоков</link> приложения, тип используемой БД, настройки подсистемы безопасности и т.д. </para>
        <para>Например: <property>cuba.connectionUrlList</property>, <property>cuba.dbmsType</property>, <property>
            <link linkend="cuba.userSessionExpirationTimeoutSec">cuba.userSessionExpirationTimeoutSec</link>
          </property>.</para>
      </listitem>
      <listitem>
        <para><firstterm>Параметры времени выполнения</firstterm> - активность аудита, параметры отсылки email и т.д. </para>
        <para>Например: <property>cuba.security.EntityLog.enabled</property>, <property>cuba.email.smtpHost</property>.</para>
      </listitem>
    </itemizedlist>
    <para>Как правило, некоторое свойство принадлежит только одному или нескольким <link linkend="app_tiers">блокам</link> приложения. Например, <property>
        <link linkend="cuba.persistenceConfig">cuba.persistenceConfig</link>
      </property> имеет смысл только для <structname>Middleware</structname>, <property> cuba.web.useLightHeader</property> − только для <structname>Web Client</structname>, а <property>
        <link linkend="cuba.springContextConfig">cuba.springContextConfig</link>
      </property> − для всех блоков. </para>
    <para>Принадлежность к блоку означает, что если нужно задать значение некоторому свойству, это необходимо сделать <emphasis>во всех блоках</emphasis>, которым данное свойство принадлежит (и которые используются в приложении). </para>
    <para>Принадлежность можно выяснить следующими способами:<itemizedlist>
        <listitem>
          <para>Из документации: см. <xref linkend="app_properties_reference"/> </para>
        </listitem>
        <listitem>
          <para>Проследив использование свойства в коде приложения</para>
        </listitem>
        <listitem>
          <para>Если к свойству есть доступ через <link linkend="config_interfaces">конфигурационный интерфейс</link>, то по принадлежности интерфейса <link linkend="app_modules">модулю</link> проекта.</para>
        </listitem>
      </itemizedlist></para>
    <section>
      <title>Доступ к свойствам</title>
      <para>Основной способ доступа к свойствам приложения из прикладного кода − использование механизма <link linkend="config_interfaces">конфигурационных интерфейсов</link>. Кроме того, все параметры конфигурации и развертывания доступны через методы класса <code>
          <link linkend="appContext">AppContext</link>
        </code>.</para>
      <para>Некоторые блоки приложения определяют JMX-интерфейсы для доступа к свойствам приложения. В частности, в блоках <structname>Middleware</structname>, <structname>Web Client</structname> и <structname>Web Portal</structname> имеется JMX-интерфейс <code>
          <link linkend="configStorageMBean">ConfigStorageMBean</link>
        </code>, позволяющий получить и задать значение любого свойства во время работы приложения. </para>
    </section>
    <section id="app_properties_files">
      <title>Хранение свойств в файлах</title>
      <para>Свойства, определяющие конфигурацию и параметры развертывания, задаются в специальных файлах свойств, имеющих имя вида <filename>*-app.properties</filename>. Каждый <link linkend="app_tiers">блок</link> приложения имеет набор таких файлов, включающий в себя файлы из <link linkend="base_projects">базовых проектов</link> платформы и файл текущего приложения. Набор файлов свойств  определяется следующим образом:</para>
      <itemizedlist>
        <listitem>
          <para>Для блоков, являющихся веб-приложениями (<structname>Middleware</structname>, <structname>Web Client</structname>, <structname>Web Portal</structname>) набор файлов свойств задается в <filename>web.xml</filename> в параметре <literal>appPropertiesConfig</literal>.</para>
        </listitem>
        <listitem>
          <para>Для блока <structname>Desktop Client</structname> основной способ задания набора файлов свойств − переопределение в приложении метода <methodname>getDefaultAppPropertiesConfig()</methodname> в классе-наследнике <code>com.haulmont.cuba.desktop.App</code>.</para>
        </listitem>
      </itemizedlist>
      <para>Например, набор файлов свойств блока <structname>Middleware</structname> проекта <application>sales</application> задается в файле  <filename>web/WEB-INF/web.xml</filename>  модуля <structname>core</structname>, и выглядит следующим образом:</para>
      <programlisting>classpath:cuba-app.properties
classpath:app.properties
file:${catalina.home}/conf/app-core/local.app.properties</programlisting>
      <para>Здесь префикс <literal>classpath:</literal> означает, что данный файл нужно искать в Java classpath, префикс <literal>file:</literal> − в файловой системе. Возможно использование системных свойств Java, в данном случае это <literal>catalina.home</literal> − путь к корню <application>Tomcat</application>.</para>
      <para>Порядок перечисления файлов важен, так как значения, указанные в каждом последующем файле заменяют значения одноименных свойств, заданные в предыдущих файлах. Этим достигается переопределение свойств платформы в конкретном приложении.</para>
      <para>Последний файл в приведенном наборе − <filename>local.app.properties</filename>. Он может использоваться для переопределения свойств приложения при развертывании. Если этого файла нет, он игнорируется. Если же во время инсталляции системы требуется переопределение некоторых параметров (как правило, различных URL), достаточно создать этот файл и поместить в него переопределяемые свойства. При последующих обновлениях системы такой файл с локальными настройками легко сохранить.</para>
      <para>Аналогом <filename>local.app.properties</filename> для <structname>Desktop Client</structname> служат аргументы командной строки запуска JVM. Загрузчик свойств данного блока воспринимает все аргументы, содержащие знак &quot;<literal>=</literal>&quot;, как пары ключ-значение, и заменяет ими соответствующие свойства приложения, заданные в файлах <filename>app.properties</filename>.</para>
      <tip>
        <para>Правила задания информации в файлах  <filename>*.properties</filename>:</para>
        <itemizedlist>
          <listitem>
            <para>Кодировка файла - <literal>UTF-8</literal></para>
          </listitem>
          <listitem>
            <para>Ключ может состоять из латинских букв, цифр, точек  и знаков подчеркивания</para>
          </listitem>
          <listitem>
            <para>Значение пишется после знака равно (<literal>=</literal>)</para>
          </listitem>
          <listitem>
            <para>Значение  не нужно брать в кавычки &quot; или &apos;</para>
          </listitem>
          <listitem>
            <para>Файловые пути записываются либо в UNIX виде (<filename>/opt/haulmont/</filename>), либо в Windows виде (<filename>c:\\haulmont\\</filename>)</para>
          </listitem>
          <listitem>
            <para>Возможно использование кодов <literal>\n \t \r</literal>. Символ <literal>\</literal>  является зарезервированным, для вставки в значение экранируется сам собой (<literal>\\</literal>).
Подробнее см.: <ulink url="http://docs.oracle.com/javase/tutorial/java/data/characters.html">http://docs.oracle.com/javase/tutorial/java/data/characters.html</ulink></para>
          </listitem>
          <listitem>
            <para>Для ввода значения в нескольких строках файла используйте символ <literal>\</literal> в конце строки, для того чтобы данное значение продолжалось на следующей строке.</para>
          </listitem>
        </itemizedlist>
      </tip>
    </section>
    <section id="app_properties_db">
      <title>Хранение свойств в базе данных</title>
      <para>Параметры времени выполнения хранятся в таблице <database>SYS_CONFIG</database> базы данных. </para>
      <para>Такие свойства имеют следующие особенности:<itemizedlist>
          <listitem>
            <para>так как значение свойства хранится в базе данных, оно задается в одном месте, независимо от того, в каких  блоках приложения оно используется</para>
          </listitem>
          <listitem>
            <para>значение может быть изменено и сохранено во время работы приложения, как через <link linkend="config_interfaces">конфигурационный интерфейс</link>, содержащий это свойство, так и через <link linkend="configStorageMBean">ConfigStorageMBean</link>.</para>
          </listitem>
          <listitem>
            <para>значение свойства может быть переопределено для конкретного блока приложения в его файле <filename>app.properties</filename>. Поиск значения всегда происходит в два этапа - сначала в <filename>app.properties</filename>, если не найдено - то в базе данных. Поэтому изменять значение нужно в обоих местах хранения.</para>
          </listitem>
        </itemizedlist></para>
      <para>Хранящиеся в БД свойства кэшируются на уровне <structname>Middleware</structname>. Очистить кэш можно с помощью JMX-интерфейсов <code>
          <link linkend="configStorageMBean">ConfigStorageMBean</link>
        </code> методом <code>clearCache()</code> или <code>
          <link linkend="cachingFacadeMBean">CachingFacadeMBean</link>
        </code> методом <code>clearConfigStorageCache()</code>.</para>
      <para>Следует иметь в виду, что на клиентском уровне чтение свойства, хранящегося в БД, приводит к запросу к <structname>Middleware</structname>, что менее эффективно, чем чтение локального свойства из <filename>app.properties</filename>. Для уменьшения количества таких запросов клиент кэширует все свойства, хранящиеся в БД, на время жизни экземпляра реализации конфигурационного интерфейса. Поэтому если, например, в некотором экране UI необходимо несколько раз обратиться к свойствам одного конфигурационного интерфейса, лучше получить ссылку на него при инициализации экрана, и сохранить в поле для последующих обращений к одному и тому же экземпляру. </para>
    </section>
    <section id="config_interfaces">
      <title>Конфигурационные интерфейсы</title>
      <para>Данный механизм позволяет работать  со свойствами приложения через методы Java-интерфейсов, что дает следующие преимущества:<itemizedlist>
          <listitem>
            <para>типизированность - прикладной код работает с нужными типами (String, Boolean, Integer и пр.), а не только со строками</para>
          </listitem>
          <listitem>
            <para>в прикладном коде вместо строковых идентификаторов свойств используются методы интерфейсов, имена которых подсказываются средой разработки</para>
          </listitem>
        </itemizedlist></para>
      <para>Пример получения значения таймаута транзакции в блоке <structname>Middleware</structname>:<programlisting language="java">@Inject
private ServerConfig serverConfig;

public void doSomething() {
  int timeout = serverConfig.getDefaultQueryTimeoutSec();
  ...
}</programlisting></para>
      <para>При невозможности инжекции можно получить ссылку на конфигурационный интерфейс через <link linkend="configuration">Configuration</link>:<programlisting language="java">int timeout = AppBeans.get(Configuration.class)
  .getConfig(ServerConfig.class)
  .getDefaultQueryTimeoutSec();</programlisting></para>
      <warning>
        <para>Конфигурационные интерфейсы не являются нормальными бинами Spring, не пытайтесь получить их через <code>AppBeans.get()</code> - только непосредственной  инжекцией самого интерфейса  или через <code>Configuration.getConfig()</code>.</para>
      </warning>
      <section>
        <title>Использование</title>
        <para>Для создания конфигурационного интерфейса необходимо:</para>
        <itemizedlist>
          <listitem>
            <para>Создать интерфейс, унаследованный от <code>com.haulmont.cuba.core.config.Config</code> (не путать с классом сущности <code>com.haulmont.cuba.core.entity.Config</code>)</para>
          </listitem>
          <listitem>
            <para>Добавить интерфейсу  аннотацию <code>@Source</code> для указания источника (способа хранения) параметров:<itemizedlist>
                <listitem>
                  <para><code>SourceType.SYSTEM</code> - значение свойства будет взято из системных свойств данной JVM, т.е. методом <code> System.getProperty()</code></para>
                </listitem>
                <listitem>
                  <para><code>SourceType.APP</code> - значение свойства будет взято из файлов <filename>app.properties</filename></para>
                </listitem>
                <listitem>
                  <para><code>SourceType.DATABASE</code> - значение свойства будет взято из таблицы <database>SYS_CONFIG</database></para>
                </listitem>
              </itemizedlist></para>
          </listitem>
          <listitem>
            <para>Создать методы доступа к свойству (getter / setter). Если значение свойства не предполагается изменять во время выполнения, метод доступа на запись не нужен. Возможный тип свойства рассмотрен ниже.</para>
          </listitem>
          <listitem>
            <para>Добавить методу доступа на чтение аннотацию <code>@Property</code>, определяющую имя свойства.</para>
          </listitem>
          <listitem>
            <para>Опционально аннотацию <code>@Source</code> можно задать для отдельного свойства в интерфейсе, если его источник отличается от заданного для всего интерфейса.</para>
          </listitem>
        </itemizedlist>
        <para>Например:<programlisting language="java">@Source(type = SourceType.DATABASE)
public interface SalesConfig extends Config {

  @Property(&quot;sales.companyName&quot;)
  String getCompanyName();
}</programlisting></para>
        <para>Создавать класс реализации конфигурационного интерфейса не нужно - при получении ссылки на интерфейс через <link linkend="configuration">Configuration</link> будет автоматически создан необходимый прокси-объект.</para>
      </section>
      <section id="config_interface_property_types">
        <title>Типы свойств</title>
        <para>Без дополнительных усилий поддерживаются следующие типы свойств: <itemizedlist>
            <listitem>
              <para><code>String</code>, простые типы либо их объектные обертки (<code>boolean</code>, <code>Boolean</code>, <code>int</code>, <code>Integer</code>, etc.).</para>
            </listitem>
            <listitem>
              <para>Перечисления (<code>enum</code>). Значение свойства сохраняется в файле или БД в виде имени значения перечисления.</para>
              <para>Если перечисление реализует интерфейс <code>EnumClass</code> и имеет статический метод <code>fromId()</code> для получения значения по идентификатору, с помощью аннотации <code>@EnumStore</code> можно задать хранение значения в виде  идентификатора. Например:<programlisting language="java">@Property(&quot;myapp.defaultCustomerGrade&quot;)
@DefaultInteger(10)
@EnumStore(EnumStoreMode.ID)
CustomerGrade getDefaultCustomerGrade();

@EnumStore(EnumStoreMode.ID)
void setDefaultCustomerGrade(CustomerGrade grade);</programlisting></para>
            </listitem>
            <listitem>
              <para>Классы персистентных <link linkend="data_model">сущностей</link>. При обращении к свойству типа сущности происходит загрузка из БД экземпляра, заданного значением свойства.</para>
            </listitem>
          </itemizedlist></para>
        <para>Для поддержки произвольного типа необходимо реализовать классы <code>TypeStringify</code> и <code>TypeFactory</code> для преобразования значения в строку и из нее, и указать эти классы для свойства с помощью аннотаций <code>@Stringify</code> и <code>@Factory</code>.</para>
        <para>Рассмотрим этот процесс на примере типа <code>UUID</code>.</para>
        <itemizedlist>
          <listitem>
            <para>Создаем класс <code>com.haulmont.cuba.core.config.type.UuidTypeFactory</code> унаследованный от <code>com.haulmont.cuba.core.config.type.TypeFactory</code> и реализуем в нем метод:<programlisting language="java">public Object build(String string) {
  if (string == null)
      return null;
  return UUID.fromString(string);
}</programlisting></para>
          </listitem>
          <listitem>
            <para><code>TypeStringify</code> создавать не нужно, т.к. по умолчанию будет использован метод <code>toString()</code> − в данном случае он нам подходит.</para>
          </listitem>
          <listitem>
            <para>Аннотируем свойство в конфигурационном интерфейсе:<programlisting language="java">@Factory(factory = UuidTypeFactory.class)
UUID getUuidProp();
void setUuidProp(UUID value);</programlisting></para>
          </listitem>
        </itemizedlist>
        <para>В платформе определены реализации <code>TypeFactory</code> для следующих типов:<itemizedlist>
            <listitem>
              <para><code>UUID</code> - <code>UuidTypeFactory</code>, описано выше.</para>
            </listitem>
            <listitem>
              <para><code>java.util.Date</code> - <code>DateFactory</code>. Значение даты должно быть указано в формате <code>yyyy-MM-dd HH:mm:ss.SSS</code>, например:<programlisting>cuba.test.dateProp = 2013-12-12 00:00:00.000</programlisting></para>
            </listitem>
            <listitem>
              <para><code>List&lt;Integer&gt;</code> (список целых чисел) - <code>IntegerListTypeFactory</code>. Значение свойства должно быть указано в виде списка чисел, разделенных пробелами, например:<programlisting>cuba.test.integerListProp = 1 2 3</programlisting></para>
            </listitem>
            <listitem>
              <para><code>List&lt;String&gt;</code> (список строк) - <code>StringListTypeFactory</code>. Значение свойства должно быть указано в виде списка строк, разделенных символом &quot;|&quot;, например:<programlisting>cuba.test.stringListProp = aaa|bbb|ccc</programlisting></para>
            </listitem>
          </itemizedlist></para>
      </section>
      <section>
        <title>Значения по умолчанию</title>
        <para>Для свойств конфигурационных интерфейсов могут быть заданы значения по умолчанию. Эти значения будут возвращаться вместо <code>null</code>, если данный параметр не задан в месте хранения - в БД или в <filename>app.properties</filename>.</para>
        <para>Значение по умолчанию может быть задано в виде строки с помощью аннотации <code>@Default</code>, либо в виде конкретного типа с помощью других аннотаций пакета <code>com.haulmont.cuba.core.config.defaults</code>:<programlisting language="java">@Property(&quot;cuba.email.adminAddress&quot;)
@Default(&quot;address@company.com&quot;)
String getAdminAddress();

@Property(&quot;cuba.email.delayCallCount&quot;)
@Default(&quot;2&quot;)
int getDelayCallCount();

@Property(&quot;cuba.email.defaultSendingAttemptsCount&quot;)
@DefaultInt(10)
int getDefaultSendingAttemptsCount();

@Property(&quot;cuba.test.dateProp&quot;)
@Default(&quot;2013-12-12 00:00:00.000&quot;)
@Factory(factory = DateFactory.class)
Date getDateProp();

@Property(&quot;cuba.test.integerList&quot;)
@Default(&quot;1 2 3&quot;)
@Factory(factory = IntegerListTypeFactory.class)
List&lt;Integer&gt; getIntegerList();

@Property(&quot;cuba.test.stringList&quot;)
@Default(&quot;aaa|bbb|ccc&quot;)
@Factory(factory = StringListTypeFactory.class)
List&lt;String&gt; getStringList();</programlisting></para>
        <para>Для сущностей  значение по умолчанию задается строкой вида <literal>{entity_name}-{id}-{optional_view_name}</literal>, например:<programlisting language="java">@Default(&quot;sec$User-98e5e66c-3ac9-11e2-94c1-3860770d7eaf-browse&quot;)
User getAdminUser();

@Default(&quot;sec$Role-a294aef0-3ac9-11e2-9433-3860770d7eaf&quot;)
Role getAdminRole();</programlisting></para>
      </section>
    </section>
  </section>
  <section id="localization">
    <title>Локализация сообщений</title>
    <para>Приложение на основе платформы CUBA поддерживает локализацию сообщений, то есть вывод всех элементов пользовательского интерфейса на языке, выбранном пользователем.</para>
    <para>Возможности выбора языка пользователем определяются комбинацией свойств приложения <link linkend="cuba.localeSelectVisible">cuba.localeSelectVisible</link> и <link linkend="cuba.availableLocales">cuba.availableLocales</link>.</para>
    <para>Для того, чтобы некоторое сообщение могло быть локализовано, т.е. представлено пользователю на нужном языке, его необходимо поместить в так называемый <firstterm>пакет сообщений</firstterm>. Ниже рассмотрены принципы работы механизма локализации и правила создания сообщений.   </para>
    <para><xref linkend="getting_messages"/> содержит информацию о способах получения локализованных сообщений в различных компонентах системы.</para>
    <section id="message_packs">
      <title>Пакеты сообщений</title>
      <para>Пакет сообщений представляет собой набор файлов свойств с именами вида <filename>messages{_XX}.properties</filename>, расположенных в одном Java-пакете. Суффикс <literal>XX</literal> определяет язык, для которого в данном файле содержатся сообщения, и соответствует коду языка в <code>Locale.getLanguage()</code>. Возможно также использование остальных атрибутов <code>Locale</code>, например, <code>country</code>. В этом случая файл пакета будет иметь вид <filename>messages{_XX_YY}.properties</filename>. Один из файлов пакета может быть без суффикса языка - это <firstterm>файл по умолчанию</firstterm>. Именем пакета сообщений считается имя Java-пакета, в котором расположены файлы пакета.</para>
      <para>Рассмотрим пример:<programlisting>/com/abc/sales/gui/customer/messages.properties
/com/abc/sales/gui/customer/messages_fr.properties
/com/abc/sales/gui/customer/messages_ru.properties</programlisting></para>
      <para>Данный пакет состоит из 3-х файлов - один для русского языка, один для французского, и один по умолчанию. Имя пакета - <code>com.abc.sales.gui.customer</code> </para>
      <para>Файлы сообщений содержат пары ключ-значение,  где ключ - это идентификатор сообщения, на который ссылается код приложения, а значение - само сообщение на языке данного файла. Правила задания пар аналогичны правилам файлов свойств <code>java.util.Properties</code>, со следующими особенностями:<itemizedlist>
          <listitem>
            <para>Кодировка файла - обязательно <code>UTF-8</code></para>
          </listitem>
          <listitem>
            <para>Поддерживается включение других пакетов сообщений с помощью ключа <literal>@include</literal>, в том числе нескольких сразу - перечислением через запятую. При этом если некоторый ключ сообщения встречается и во включаемом пакете, и в текущем, будет использовано сообщение из текущего. Пример включения пакетов:<programlisting>@include=com.haulmont.cuba.web, com.abc.sales.web

someMessage=Some Message
...</programlisting></para>
          </listitem>
        </itemizedlist></para>
      <para>Получение сообщений из пакетов производится с помощью методов интерфейса <code>
          <link linkend="messages">Messages</link>
        </code> по следующим правилам:<itemizedlist>
          <listitem>
            <para>Сначала производится поиск в <link linkend="conf_dir">конфигурационном каталоге</link> приложения<itemizedlist>
                <listitem>
                  <para>Ищется файл <filename>messages_XX.properties</filename> в каталоге, задаваемом именем пакета сообщений, где <literal>XX</literal> - код требуемого языка</para>
                </listitem>
                <listitem>
                  <para>Если такого файла нет, в этом же каталоге ищется файл по умолчанию <filename>messages.properties</filename></para>
                </listitem>
                <listitem>
                  <para>Если найден или файл нужного языка, или файл по умолчанию, он загружается вместе со всеми <literal>@include</literal>, и в нем ищется ключ сообщения</para>
                </listitem>
                <listitem>
                  <para>Если файл не найден, либо нужный ключ в нем отсутствует, производится смена каталога на родительский, и процедура поиска повторяется. И так до достижения корня конфигурационного каталога.</para>
                </listitem>
              </itemizedlist></para>
          </listitem>
          <listitem>
            <para>Если в конфигурационном каталоге сообщение не найдено, производится поиск в classpath по такому же алгоритму.</para>
          </listitem>
          <listitem>
            <para>На клиентском <link linkend="app_tiers">уровне</link>, если сообщение не найдено на предыдущих шагах, отправляется запрос на <structname>Middleware</structname>, и сообщение ищется там аналогичным способом.</para>
          </listitem>
          <listitem>
            <para>Если сообщение найдено, оно кэшируется и возвращается. Если не найдено - кэшируется факт отсутствия сообщения и возвращается ключ, который был передан для поиска. Таким образом, сложная процедура поиска выполняется только один раз, в дальнейшем результат загружается из локального для блока приложения кэша.</para>
          </listitem>
        </itemizedlist></para>
      <tip>
        <para>Рекомендуется организовывать пакеты сообщений следующим образом:<itemizedlist>
            <listitem>
              <para>Если приложение не предполагает интернационализации, то можно не использовать пакеты и включать строки сообщений прямо в код приложения, либо пользоваться файлами по умолчанию <filename>messages.properties</filename> для отделения ресурсов от кода.</para>
            </listitem>
            <listitem>
              <para>Если приложение  интернациональное, логично файлы по умолчанию использовать для языка основной аудитории приложения, либо для английского языка. Именно сообщения из файлов по умолчанию будут показаны пользователю, если сообщений для нужного языка не найдено.</para>
            </listitem>
          </itemizedlist></para>
      </tip>
    </section>
    <section id="main_message_pack">
      <title>Главный пакет сообщений</title>
      <para>Каждый стандартный <link linkend="app_tiers">блок</link> приложения определяет для себя один <firstterm>главный</firstterm> пакет сообщений. Для блоков клиентского уровня этот пакет содержит названия пунктов главного меню и общих элементов UI (например, названия кнопок <guibutton>OK</guibutton> и <guibutton>Cancel</guibutton>). Для всех блоков приложения, включая <structname>Middleware</structname>, главный пакет  определяет форматы преобразований <link linkend="datatype">
          <code>Datatype</code>
        </link>.</para>
      <para>Для указания главного пакета сообщений используется свойство приложения <property>
          <link linkend="cuba.mainMessagePack">cuba.mainMessagePack</link>
        </property>. Значением свойства может быть либо один пакет, либо список пакетов, разделенный пробелами. Например:<programlisting>cuba.mainMessagePack=com.haulmont.cuba.web com.abc.sales.web</programlisting></para>
      <para>В данном случае сообщения, заданные во втором пакете списка будут перекрывать сообщений из первого пакета. Таким образом в проекте приложения можно переопределять сообщения, заданные в пакетах <link linkend="base_projects">базовых проектов</link>.</para>
    </section>
    <section id="entity_localization">
      <title>Локализация названий сущностей и атрибутов</title>
      <para>Для отображения в UI локализованных названий сущностей и их атрибутов необходимо создать специальные пакеты сообщений в тех же Java-пакетах, что и сами сущности. Формат файлов сообщений должен быть следующим:<itemizedlist>
          <listitem>
            <para>Ключ названия сущности - простое имя класса (без пакета)</para>
          </listitem>
          <listitem>
            <para>Ключ названия атрибута - простое имя класса, затем через точку имя атрибута</para>
          </listitem>
        </itemizedlist></para>
      <para>Пример русской локализации сущности <code>com.abc.sales.entity.Customer</code> - файл <filename>/com/abc/sales/entity/messages_ru.properties</filename>:<programlisting>Customer=Покупатель
Customer.name=Имя
Customer.email=Email

Order=Заказ
Order.customer=Покупатель
Order.date=Дата
Order.amount=Сумма</programlisting></para>
      <para>Такие пакеты сообщений, как правило, используются неявно для  разработчика, например, визуальными компонентами <code>
          <link linkend="gui_Table">Table</link>
        </code> и <code>
          <link linkend="gui_FieldGroup">FieldGroup</link>
        </code>. Кроме того, названия сущностей и атрибутов могут быть также получены следующими методами:<itemizedlist>
          <listitem>
            <para>программно - методами <code>
                <link linkend="messageTools">MessageTools</link>
              </code> <code>getEntityCaption()</code>, <code>getPropertyCaption()</code></para>
          </listitem>
          <listitem>
            <para>в XML дескрипторе экрана - указанием ссылки на сообщение по правилам <code>MessageTools.<link linkend="messageTools.loadString">loadString</link>()</code>: <literal>msg://{entity_package}/{key}</literal>, например, <programlisting>caption=&quot;msg://com.abc.sales.entity/Customer.name&quot;</programlisting></para>
          </listitem>
        </itemizedlist></para>
    </section>
    <section id="enum_localization">
      <title>Локализация enum</title>
      <para>Для локализации названий  и значений перечислений необходимо в пакет сообщений, находящийся в Java-пакете класса перечисления добавить сообщения со следующими ключами:<itemizedlist>
          <listitem>
            <para>Ключ названия перечисления - простое имя класса (без пакета)</para>
          </listitem>
          <listitem>
            <para>Ключ значения - простое имя класса, затем через точку имя значения</para>
          </listitem>
        </itemizedlist></para>
      <para>Например, для перечисления <programlisting language="java">package com.abc.sales;

public enum CustomerGrade { PREMIUM, HIGH, STANDARD }</programlisting></para>
      <para>файл русской локализации <filename>/com/abc/sales/messages_ru.properties</filename> должен содержать строки:<programlisting>CustomerGrade=Уровень покупателя
CustomerGrade.PREMIUM=Премиум
CustomerGrade.HIGH=Высокий
CustomerGrade.STANDARD=Стандартный</programlisting></para>
      <para>Локализованные значения перечислений автоматически используются различными визуальными компонентами, например, <code>
          <link linkend="gui_LookupField">LookupField</link>
        </code>. Для программного получения локализованного значения перечисления можно использовать метод <code>getMessage()</code> интерфейса <code>
          <link linkend="messages">Messages</link>
        </code>, просто передавая в него экземпляр <code>enum</code>.</para>
    </section>
  </section>
  <section id="authentication">
    <title>Аутентификация пользователей</title>
    <para>В данном разделе рассмотрены некоторые аспекты управления доступом с точки зрения разработчика приложения. Для получения полной информации о возможностях и настройке ограничения доступа пользователей к данным см. <xref linkend="chapter_security"/>. </para>
    <section id="userSession">
      <title>UserSession</title>
      <para>Основной элемент подсистемы контроля доступа в CUBA-приложении - пользовательская сессия. Это объект класса <code>UserSession</code>, который ассоциирован с аутентифицированным в данный момент в системе пользователем, и содержит информацию о правах доступа пользователя к данным. Объект текущей сессии может быть получен в любом <link linkend="app_tiers">блоке</link> приложения через интерфейс инфраструктуры <code>
          <link linkend="userSessionSource">UserSessionSource</link>
        </code>.</para>
      <para>Пользовательская сессия создается на <structname>Middleware</structname> при выполнении метода <code>LoginService.login()</code> после аутентификации пользователя по переданному имени и паролю. Объект <code>UserSession</code> затем кэшируется в данном блоке <structname>Middleware</structname>, и возвращается на клиентский уровень. При работе в кластере объект сессии реплицируется на соседние узлы кластера <structname>Middleware</structname>. Клиентский блок, получив объект сессии, также сохраняет его у себя, так или иначе ассоциируя с активным пользователем (например, в HTTP сессии). Далее все вызовы <structname>Middleware</structname> для данного пользователя сопровождаются передачей идентификатора сессии (типа <code>UUID</code>), причем прикладному коду не нужно об этом заботиться - идентификатор сессии передается автоматически, независимо от сигнатуры вызываемых методов среднего слоя. Обработка вызовов клиентов на <structname>Middleware</structname> начинается с извлечения из кэша сессии по полученному идентификатору и установки ее в потоке выполнения. Объект сессии удаляется из кэша при вызове метода <code>LoginService.logout()</code>, либо при истечении времени бездействия, определяемого свойством  приложения <property>
          <link linkend="cuba.userSessionExpirationTimeoutSec">cuba.userSessionExpirationTimeoutSec</link>
        </property>.</para>
      <para>Таким образом, идентификатор сессии, создаваемой при входе пользователя в систему, служит для аутентификации пользователя при каждом вызове среднего слоя.</para>
      <para>Объект <code>UserSession</code> содержит также методы для <firstterm>авторизации</firstterm> текущего пользователя, т.е. проверки его прав на объекты системы: <code>isScreenPermitted()</code>, <code>isEntityOpPermitted()</code>, <code>isEntityAttrPermitted()</code>, <code>isSpecificPermitted()</code>.</para>
      <para>С объектом <code>UserSession</code> могут быть ассоциированы именованные атрибуты произвольного сериализуемого типа. Атрибуты устанавливаются методом <code>setAttribute()</code> и возвращаются методом <code>getAttribute()</code>. Последний может также возвращать следующие параметры сессии, как если бы они были атрибутами:<itemizedlist>
          <listitem>
            <para><code>userId</code> - ID текущего зарегистрированного или замещенного пользователя;</para>
          </listitem>
          <listitem>
            <para><code>userLogin</code> - логин текущего зарегистрированного или <link linkend="user_substitution">замещенного</link> пользователя в нижнем регистре.</para>
          </listitem>
        </itemizedlist></para>
      <para>Атрибуты реплицируются в кластере <structname>Middleware</structname> так же, как и  все остальные данные сессии.</para>
    </section>
    <section id="login">
      <title>Вход в систему</title>
      <para>Стандартный вариант входа пользователя: <itemizedlist>
          <listitem>
            <para>пользователь вводит свой логин и пароль</para>
          </listitem>
          <listitem>
            <para>клиентский блок приложения хэширует пароль, вызывая метод <code>getPlainHash()</code> бина <code>PasswordEncryption</code> и вызывает на <structname>Middleware</structname> метод <code>LoginService.login()</code>, передавая ему логин пользователя и хэш пароля</para>
          </listitem>
          <listitem>
            <para><code>LoginService</code> делегирует выполнение бину <code>LoginWorker</code>, который загружает объект <code>User</code> по полученному логину, хэширует полученный хэш пароля повторно, используя в качестве соли идентификатор пользователя, и сравнивает полученный хэш с сохраненным в БД хэшем пароля. В случае несовпадения выбрасывается исключение <code>LoginException</code>.</para>
          </listitem>
          <listitem>
            <para>После успешной аутентификации в созданный экземпляр <code>
                <link linkend="userSession">UserSession</link>
              </code> загружаются все параметры доступа данного пользователя: список ролей, права, ограничения и атрибуты сессии.</para>
          </listitem>
        </itemizedlist></para>
      <para>Алгоритм хэширования паролей реализуется бином типа <code>EncryptionModule</code> и задается в свойстве приложения <property>
          <link linkend="cuba.passwordEncryptionModule">cuba.passwordEncryptionModule</link>
        </property>. По умолчанию - SHA-1.</para>
      <para>Возможен вариант, когда пароль пользователя (точнее, хэш пароля) не хранится в базе данных, а проверяется внешними средствами, например, путем интеграции с <application>ActiveDirectory</application>. В этом случае фактически аутентификацию выполняет клиентский блок, а <structname> Middleware</structname> &quot;доверяет&quot; клиенту, создавая сессию по одному только логину пользователя без пароля методом <code>LoginService.loginTrusted()</code>. Метод <code>loginTrusted()</code> требует выполнения следующих условия:<itemizedlist>
          <listitem>
            <para>клиентский блок должен передать так называемый доверенный пароль, задаваемый на <structname>Middleware</structname> и на клиентском блоке свойством приложения <property>
                <link linkend="cuba.trustedClientPassword">cuba.trustedClientPassword</link>
              </property></para>
          </listitem>
          <listitem>
            <para>IP адрес клиентского блока должен соответствовать маске, задаваемой свойством приложения <property>
                <link linkend="cuba.trustedClientPermittedIpMask">cuba.trustedClientPermittedIpMask</link>
              </property></para>
          </listitem>
        </itemizedlist></para>
      <para>Вход в систему требуется также для автоматических процессов, запускаемых по расписанию, а также при подключении к бинам <structname>Middleware</structname> через JMX-интерфейс. Строго говоря, такие действия считаются административными и не требуют аутентификации до тех пор, пока не выполняется каких-либо изменений сущностей в базе данных. При записи сущностей в БД требуется проставить логин пользователя, который выполнил изменения, поэтому для работы таких процессов должен быть указан пользователь, от лица которого выполняются изменения. </para>
      <para>Дополнительным плюсом входа в систему для автоматического процесса и для JMX-вызова является то, что вывод в журнал сообщений от логгеров сопровождается указанием логина текущего пользователя, если пользовательская сессия установлена в потоке выполнения. Это упрощает поиск сообщений от конкретного процесса при разборе журнала.</para>
      <para>Вход в систему для процессов внутри <structname>Middleware</structname> выполняется вызовом <code>LoginWorker.loginSystem()</code> с передачей логина пользователя (без пароля), от имени которого будет работать данный процесс. В результате создается объект <code>
          <link linkend="userSession">UserSession</link>
        </code>, который будет закэширован в данном блоке <structname>Middleware</structname> и не будет реплицироваться в кластере. </para>
      <para>Более подробно аутентификация процессов внутри <structname>Middleware</structname> рассмотрена в разделе <xref linkend="system_authentication"/></para>
    </section>
    <section id="securityContext">
      <title>SecurityContext</title>
      <para>Экземпляр класса <code>SecurityContext</code> хранит информацию о пользовательской сессии для текущего потока выполнения. Он создается и передается в метод <code>AppContext.setSecurityContext()</code> в следующие моменты:<itemizedlist>
          <listitem>
            <para>для блоков <structname>Web Client</structname>  и <structname>Web Portal</structname> - в начале обработки каждого HTTP-запроса от пользовательского браузера</para>
          </listitem>
          <listitem>
            <para>для блока <structname>Middleware</structname> - в начале обработки каждого запроса от клиентского уровня</para>
          </listitem>
          <listitem>
            <para>для блока <structname>Desktop Client</structname> - один раз после входа пользователя, так как десктопное приложение является однопользовательским</para>
          </listitem>
        </itemizedlist></para>
      <para>По окончании выполнения запроса в первых двух случаях  <code>SecurityContext</code> удаляется из потока выполнения.</para>
      <para>При создании прикладным кодом нового потока выполнения в него необходимо передать текущий экземпляр <code>SecurityContext</code>, например:<programlisting language="java">final SecurityContext securityContext = AppContext.getSecurityContext();
executor.submit(new Runnable() {
  public void run() {
      AppContext.setSecurityContext(securityContext);
      // business logic here
  }
});</programlisting></para>
    </section>
  </section>
  <section id="exception_handling">
    <title>Обработка исключений</title>
    <para>В данном разделе рассмотрены различные аспекты генерации и обработки исключений в CUBA-приложениях.</para>
    <section id="exception_classes">
      <title>Классы исключений</title>
      <para>При создании собственных классов исключений следует придерживаться следующих правил:<itemizedlist>
          <listitem>
            <para>Если исключение является нормальной частью бизнес-логики и при его возникновении требуется предпринимать некоторые нетривиальные действия, то класс исключения следует делать декларируемым (наследником <code>Exception</code>). Обработка таких исключений производится вызывающим кодом.</para>
          </listitem>
          <listitem>
            <para>Если исключение сигнализирует об  ошибочной ситуации, и реакцией на него должно быть прерывание хода выполнения и простое действие типа отображения информации об ошибке пользователю, то класс исключения следует делать недекларируемым (наследником <code>RuntimeException</code>). Обработка таких исключений производится специальными классами-обработчиками, зарегистрированными в клиентских блоках приложения.</para>
          </listitem>
          <listitem>
            <para>Если исключение выбрасывается и обрабатывается в рамках одного <link linkend="app_tiers">блока</link> приложения, то класс исключения следует объявлять в соответствующем <link linkend="app_modules">модуле</link>. Если же исключение выбрасывается на <structname>Middleware</structname>, а обрабатывается на клиентском уровне, то класс исключения необходимо объявлять в модуле <structname>global</structname>.</para>
          </listitem>
        </itemizedlist></para>
      <para>Платформа содержит специальный класс недекларируемого исключения <code>SilentException</code>, который можно использовать для прерывания хода выполнения без выдачи каких-либо сообщений пользователю или в лог. <code>SilentException</code> объявлен в модуле <structname>global</structname>, поэтому доступен как на <structname>Middleware</structname>, так и в клиентских блоках.</para>
    </section>
    <section id="remoteException">
      <title>Передача исключений Middleware</title>
      <para>Если при выполнении запроса от клиента на <structname>Middleware</structname> возникает исключение, выполнение прерывается и на клиента возвращается объект исключения, как правило, включающий цепочку порождающих друг друга исключений. Так как цепочка исключений может содержать классы, недоступные клиентскому блоку (например, исключения JDBC-драйвера), на клиента передается не сама эта цепочка, а ее представление внутри специального создаваемого исключения <code>RemoteException</code>. </para>
      <para>Информация об исключениях-причинах сохраняется в виде списка объектов <code>RemoteException.Cause</code>. Каждый объект <code>Cause</code> хранит обязательно имя класса исключения и его сообщение. Кроме того, если класс исключения &quot;поддерживается клиентом&quot;, то <code>Cause</code> содержит также и сам объект исключения. Это дает возможность передать на клиента информацию в полях исключения. </para>
      <para>Класс исключения, объекты которого нужно передавать на клиентский уровень именно в виде Java-объектов, нужно аннотировать <code>@SupportedByClient</code>, например: <programlisting language="java">@SupportedByClient
public class WorkflowException extends RuntimeException {
...</programlisting></para>
      <para>Таким образом, при возникновении на <structname>Middleware</structname> исключения, не аннотированного <code>@SupportedByClient</code>, вызывающий клиентский код получит <code>RemoteException</code>, внутри которого будет находиться исходное исключение  в виде строки. Если же исходное исключение аннотировано <code>@SupportedByClient</code>, то вызывающий код получит именно его. Это дает возможность в прикладном коде организовывать обработку декларируемых <link linkend="services">сервисами</link> <structname>Middleware</structname> исключений традиционным образом - с помощью блоков <code>try...catch</code>. </para>
      <para>Следует иметь в виду, что чтобы поддерживаемое клиентом исключение было действительно передано на клиента в виде объекта, оно не должно содержать внутри себя в цепочке <code>getCause()</code> неподдерживаемых исключений. Поэтому если вы создаете на <structname>Middleware</structname> экземпляр исключения и хотите передать его на клиента, указывайте для него параметр <code>cause</code> только если вы уверены, что он содержит только исключения, известные клиенту.</para>
      <para>Упаковку объектов исключений в <code>RemoteException</code> перед передачей на клиентский уровень выполняет перехватчик вызовов <link linkend="services">сервисов</link> - класс <code>ServiceInterceptor</code>. Кроме того, он же выполняет логгирование исключений. По умолчанию в журнал выводится вся информация об исключении, включая полный stack trace. Если это нежелательно, можно добавить классу исключения аннотацию <code>@Logging</code>, указав в ней тип логгирования:<itemizedlist>
          <listitem>
            <para><code>FULL</code> - (по умолчанию) полная информация, включая stacktrace</para>
          </listitem>
          <listitem>
            <para><code>BRIEF</code> - только имя класса исключения и сообщение</para>
          </listitem>
          <listitem>
            <para><code>NONE</code> - не выводить ничего</para>
          </listitem>
        </itemizedlist></para>
      <para>Например:<programlisting language="java">@SupportedByClient
@Logging(Logging.Type.BRIEF)
public class FinancialTransactionException extends Exception {
...</programlisting></para>
    </section>
    <section id="exceptionHandlers">
      <title>Обработчики исключений клиентского уровня</title>
      <para>Необработанные исключения в <link linkend="app_tiers">блоках</link> <structname>Web Client</structname> и <structname>Desktop Client</structname>, возникшие на клиентском уровне или переданные с <structname>Middleware</structname>, попадают в специальный механизм обработчиков. Этот механизм схож для обоих блоков, однако использует разные (хотя и в основном одноименные) классы реализации. </para>
      <para>Рассмотрим механизм на примере блока <structname>Web Client</structname>. </para>
      <para>В файле <filename>
          <link linkend="spring.xml">spring.xml</link>
        </filename> блока объявляется бин класса <code>ExceptionHandlersConfiguration</code>, в свойстве <code>handlerClasses</code> которого задается список имен классов обработчиков. Например: <programlisting language="xml">&lt;bean id=&quot;sales_exceptionHandlersConf&quot; class=&quot;com.haulmont.cuba.web.exception.ExceptionHandlersConfiguration&quot;&gt;
  &lt;property name=&quot;handlerClasses&quot;&gt;
      &lt;list&gt;
          &lt;value&gt;com.sample.sales.web.exception.ZeroBalanceExceptionHandler&lt;/value&gt;
          &lt;value&gt;com.sample.sales.web.exception.InvalidCustomerStateExceptionHandler&lt;/value&gt;
      &lt;/list&gt;
  &lt;/property&gt;
&lt;/bean&gt;</programlisting></para>
      <para>Идентификатор бина должен быть уникальным и не совпадать ни с одним из бинов <link linkend="base_projects">базовых проектов</link>, так как базовые проекты в свою очередь могут содержать аналогичные конфигурационные бины с собственными идентификаторами. </para>
      <para>Обработчик должен реализовывать интерфейс <code>ExceptionHandler</code>, в методе <code>handle()</code> которого производить обработку и возвращать <code>true</code>, либо сразу возвращать <code>false</code>, если данный обработчик не может обработать переданное ему исключение. Такое поведение позволяет организовать &quot;цепочку ответственности&quot; обработчиков. </para>
      <para>Рекомендуется наследовать класс своего обработчика от базового класса <code>AbstractExceptionHandler</code>, который умеет разбирать цепочку исключений (с учетом упакованных внутри <code>RemoteException</code>) и реагировать на конкретные типы исключений. Типы исключений, для которых предназначен данный обработчик, указываются в массиве строк, передаваемом в конструкторе обработчика базовому конструктору. Каждая строка массива должна содержать одно полное имя класса обрабатываемого исключения, например:<programlisting language="java">public class ReportExceptionHandler extends AbstractExceptionHandler {

  public ReportExceptionHandler() {
      super(ReportingException.class.getName(),
            FailedToConnectToOpenOfficeException.class.getName(),
            UnsupportedFormatException.class.getName());
  }
...</programlisting></para>
      <para>Если класс исключения недоступен на клиенте, следует указывать его имя строковым литералом:<programlisting language="java">public class OptimisticExceptionHandler extends AbstractExceptionHandler {

  public OptimisticExceptionHandler() {
      super(&quot;org.springframework.orm.jpa.JpaOptimisticLockingFailureException&quot;);
  }
...</programlisting></para>
      <para>В случае использования в качестве базового класса <code>AbstractExceptionHandler</code> логика обработки
        располагается в методе <code>doHandle()</code>, и для блока <structname>Web Client</structname> может выглядеть
        следующим образом:
        <programlisting language="java">
<![CDATA[
@Override
protected void doHandle(App app, String className, String message, @Nullable Throwable throwable) {
    String msg = messages.getMainMessage("zeroBalance.message");
    Notification.show(msg, Notification.Type.ERROR_MESSAGE);
}
]]></programlisting></para>
      <para>Если имени класса исключения недостаточно для того, чтобы принять решение о применимости данного обработчика к исключению, следует определить метод canHandle(), получающий кроме прочего текст исключения. Метод должен вернуть true, если данный обработчик применим для исключения. Например:<programlisting language="java">public class NumericOverflowExceptionHandler extends AbstractExceptionHandler {

  public NumericOverflowExceptionHandler() {
      super(ReportingSQLException.class.getName());
  }

  @Override
  protected boolean canHandle(String className, String message, @Nullable Throwable throwable) {
      return StringUtils.containsIgnoreCase(message, &quot;Numeric field overflow&quot;);
  }
...</programlisting></para>
    </section>
  </section>
</section>
