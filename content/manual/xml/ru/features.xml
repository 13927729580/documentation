<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE section PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" []>
<section id="features">
  <title>Механизмы платформы</title>
  <para>В данной главе рассматриваются различные опциональные возможности, предоставляемые платформой.</para>
  <section id="scheduled_tasks">
    <title>Выполнение задач по расписанию</title>
    <para>Платформа предлагает два способа запуска задач по расписанию:<itemizedlist>
        <listitem>
          <para>Использование стандартного механизма <code>TaskScheduler</code> фреймворка <application>Spring</application></para>
        </listitem>
        <listitem>
          <para>Использование собственного механизма выполнения назначенных заданий</para>
        </listitem>
      </itemizedlist></para>
    <section id="scheduled_tasks_spring">
      <title>Spring TaskScheduler</title>
      <para>Данный механизм подробно описан в разделе <application>Task Execution and Scheduling</application> руководства <application>Spring Framework</application>.</para>
      <para><code>TaskScheduler</code> можно использовать для запуска методов произвольных бинов Spring в любом <link linkend="app_tiers">блоке</link> приложения - как на <structname>Middleware</structname>, так и на клиентском уровне.</para>
      <para>Пример конфигурации в файле <filename>
          <link linkend="spring.xml">spring.xml</link>
        </filename>:<programlisting language="xml">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
     xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
     xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
     xmlns:task=&quot;http://www.springframework.org/schema/task&quot;
     xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd
      http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd
      http://www.springframework.org/schema/task http://www.springframework.org/schema/task/spring-task-3.0.xsd&quot;&gt;

  ...

  &lt;task:scheduled-tasks scheduler=&quot;scheduler&quot;&gt;
      &lt;task:scheduled ref=&quot;sales_Processor&quot; method=&quot;someMethod&quot; fixed-rate=&quot;60000&quot;/&gt;
      &lt;task:scheduled ref=&quot;sales_Processor&quot; method=&quot;someOtherMethod&quot; cron=&quot;0 0 1 * * MON-FRI&quot;/&gt;
  &lt;/task:scheduled-tasks&gt;
&lt;/beans&gt;</programlisting></para>
      <para>Здесь объявлены две задачи, запускающие на выполнение методы <code>someMethod()</code> и <code> someOtherMethod()</code> бина <code>sales_Processor</code>. При этом <code>someMethod()</code> запускается с момента старта приложения через фиксированные промежутки времени - 60 сек. Метод <code>someOtherMethod()</code> запускается в соответствии с расписанием, заданным выражением Cron (описание формата таких выражений см. <ulink url="http://quartz-scheduler.org/documentation/quartz-1.x/tutorials/crontrigger">http://quartz-scheduler.org/documentation/quartz-1.x/tutorials/crontrigger</ulink> ).</para>
      <para>Собственно запуск задач выполняет бин типа <code>TaskScheduler</code>, заданный в атрибуте <sgmltag>scheduler</sgmltag> элемента <sgmltag>scheduled-tasks</sgmltag>. В данном случае используется бин <code>CubaThreadPoolTaskScheduler</code> с именем <code>scheduler</code>, который сконфигурирован в модулях <structname>core</structname> и <structname>web</structname> базового проекта <structname>cuba</structname> (см. <filename>cuba-spring.xml</filename>, <filename>cuba-web-spring.xml</filename>). Этот класс содержит специфическую реализацию, выполняющую очистку <code>
          <link linkend="securityContext">SecurityContext</link>
        </code> в запускаемых на выполнение потоках.</para>
    </section>
    <section id="scheduled_tasks_cuba">
      <title>Назначенные задания CUBA</title>
      <para>Механизм назначенных заданий <application>CUBA</application> предназначен для запуска по расписанию методов произвольных бинов Spring в блоке <structname>Middleware</structname>. Целью данного механизма и отличием его от вышеупомянутого стандартного механизма <application> Spring Framework</application> являются: <itemizedlist>
          <listitem>
            <para>возможность конфигурирования заданий во время работы приложения   без остановки сервера</para>
          </listitem>
          <listitem>
            <para>координация выполнения синглтон-заданий в кластере <structname>Middleware</structname>, в том числе: <itemizedlist>
                <listitem>
                  <para>надежная защита от одновременного выполнения </para>
                </listitem>
                <listitem>
                  <para>привязка заданий к серверам по приоритетам</para>
                </listitem>
              </itemizedlist></para>
          </listitem>
        </itemizedlist></para>
      <para>Под <firstterm>синглтон</firstterm>-заданием понимается задача, которая должна выполняться в некоторый момент времени только на одном сервере. Пример - чтение из очереди и отсылка email.</para>
      <section>
        <title>Регистрация задания</title>
        <para>Задания регистрируются в таблице <code>SYS_SCHEDULED_TASK</code> базы данных, соответствующей сущности <code>ScheduledTask</code>. Для работы с заданиями существуют экраны просмотра и редактирования, доступные через меню <guimenu>Администрирование</guimenu> -&gt; <guimenuitem>Назначенные задания</guimenuitem>. </para>
        <para>Рассмотрим атрибуты задания:<itemizedlist>
            <listitem>
              <para><guilabel>Defined by</guilabel> - каким программным объектом реализуется задание. Возможные значения:<itemizedlist>
                  <listitem>
                    <para><guilabel>Bean</guilabel> - задание реализуется методом бина Spring. Дополнительные атрибуты:<itemizedlist>
                        <listitem>
                          <para><guilabel>Bean name</guilabel> - имя бина. Бин отображается в списке и доступен для выбора, только если у него есть интерфейс, содержащий подходящие для вызова из задания методы. Бины без интерфейса не поддерживаются.</para>
                        </listitem>
                        <listitem>
                          <para><guilabel>Method name</guilabel> - метод интерфейса бина для выполнения. Метод должен либо не иметь параметров, либо иметь все параметры типа <code>String</code>.</para>
                        </listitem>
                        <listitem>
                          <para><guilabel>Method parameters</guilabel> - параметры выбранного метода. Поддерживаются только параметры типа <code>String</code>.</para>
                        </listitem>
                      </itemizedlist></para>
                  </listitem>
                  <listitem>
                    <para><guilabel>Class</guilabel> - задание представляет собой класс, реализующий интерфейс <code>java.util.concurrent.Callable</code>. Класс должен иметь открытый конструктор без параметров. Дополнительные атрибуты:<itemizedlist>
                        <listitem>
                          <para><guilabel>Class name</guilabel> - имя класса</para>
                        </listitem>
                      </itemizedlist></para>
                  </listitem>
                  <listitem>
                    <para><guilabel>Script</guilabel> - задание представляет собой скрипт Groovy. Скрипт выполняется через <code>Scripting.<link linkend="scripting.runGroovyScript">runGroovyScript</link>()</code>. Дополнительные атрибуты:<itemizedlist>
                        <listitem>
                          <para><guilabel>Script name</guilabel> - имя скрипта.</para>
                        </listitem>
                      </itemizedlist></para>
                  </listitem>
                </itemizedlist></para>
            </listitem>
            <listitem>
              <para><guilabel>User name</guilabel> - имя пользователя, от имени которого будет будет выполняться задание. Если не задано, то задание будет выполнено от имени пользователя, указанного в свойстве приложения <property>
                  <link linkend="cuba.jmxUserLogin">cuba.jmxUserLogin</link>
                </property>.</para>
            </listitem>
            <listitem>
              <para><guilabel>Singleton</guilabel> - признак, является ли задание синглтоном, т.е. выполняющимся только на одном сервере системы.</para>
            </listitem>
            <listitem>
              <para><guilabel>Scheduling type</guilabel> - способ планирования задачи:<itemizedlist>
                  <listitem>
                    <para><guilabel>Cron</guilabel> - с помощью Cron-выражения, представляющего собой последовательность из шести полей, разделенных пробелами: секунда, минута, час, день, месяц, день недели. Месяц и день недели могут быть представлены первыми тремя буквами английского названия. Примеры выражений:<itemizedlist>
                        <listitem>
                          <para>0 0 * * * * - начало каждого часа каждого дня.</para>
                        </listitem>
                        <listitem>
                          <para>*/10 * * * * * - каждые 10 секунд.</para>
                        </listitem>
                        <listitem>
                          <para>0 0 8-10 * * * - в 8, 9 и 10 часов каждого дня.</para>
                        </listitem>
                        <listitem>
                          <para>0 0/30 8-10 * * * - 8:00, 8:30, 9:00, 9:30 и 10 часов каждого дня.</para>
                        </listitem>
                        <listitem>
                          <para>0 0 9-17 * * MON-FRI - каждый час с 9 до 17 по рабочим дням.</para>
                        </listitem>
                        <listitem>
                          <para>0 0 0 7 1 ? - каждое Рождество в полночь.</para>
                        </listitem>
                      </itemizedlist></para>
                  </listitem>
                  <listitem>
                    <para><guilabel>Period</guilabel> - с помощью интервала между выполнениями.</para>
                  </listitem>
                </itemizedlist></para>
            </listitem>
            <listitem>
              <para><guilabel>Period</guilabel> - период запуска задания в секундах для Scheduling type = Period. </para>
            </listitem>
            <listitem>
              <para><guilabel>Timeout</guilabel> - время в секундах, по истечении которого считается, что задание закончило выполнение, независимо от того, есть ли информация о завершении задания, или нет. Если  timeout не задан явно, он принимается равным 3 часам. </para>
            </listitem>
            <listitem>
              <para><guilabel>Start date</guilabel> - дата/время первого запуска для Scheduling type = Period. Если не установлено, то задание запускается сразу при старте сервера. Если установлено, то задание запускается в момент <code>startDate + period * N</code>, где N - целое число. </para>
              <para>Start date имеет смысл указывать только для &quot;нечастых&quot; заданий - раз в 1 час, 1 сутки и т.п. </para>
            </listitem>
            <listitem>
              <para><guilabel>Time frame</guilabel> - в случае заданного Start date или Cron expression определяет временное окно в секундах, в течение которого будет запущено задание, если время <code>startDate + period * N</code> прошло. Если Time frame не задано явно, оно принимается равным <code>period / 2</code>. </para>
              <para>Если Start date не указано, то Time frame не принимается во внимание, т.е. задание будет запущено в любое время после прохождения промежутка времени Period после предыдущего выполнения задания. </para>
            </listitem>
            <listitem>
              <para><guilabel>Permitted servers</guilabel>
- список перечисленных через запятую <link linkend="serverId">идентификаторов серверов</link>, на которых возможен запуск данного задания. Если список не задан, то задание может выполняться на любом сервере. </para>
              <para>Для синглтон-заданий порядок перечисления серверов указывает их приоритет - первый имеет больший приоритет чем последний. Сервер с большим приоритетом перехватит выполнение синглтона следующим образом: если сервер с большим приоритетом обнаруживает, что предыдущий раз задание было выполнено сервером с меньшим приоритетом, то он запускает задание независимо от того, пройден ли Period или нет. <warning>
                  <para>Приоритет серверов работает только в случае Scheduling type = Period и не указанного атрибута Start date. Если Start date указан, старт происходит в одно и то же время, и перехват невозможен.</para>
                </warning></para>
            </listitem>
            <listitem>
              <para><guilabel>Log start</guilabel> - признак регистрации факта запуска задания в таблице <code>SYS_SCHEDULED_EXECUTION</code>, соответствующей сущности <code>ScheduledExecution</code>. </para>
              <para>Если задание является синглтоном, то в текущей реализации регистрация факта запуска производится в любом случае, независимо от данного признака. </para>
            </listitem>
            <listitem>
              <para><guilabel>Log finish</guilabel> - признак регистрации факта завершения задания в таблице <code>SYS_SCHEDULED_EXECUTION</code>, соответствующей сущности <code>ScheduledExecution</code>. </para>
              <para>Если задание является синглтоном, то в текущей реализации регистрация факта завершения производится в любом случае, независимо от данного признака. </para>
            </listitem>
            <listitem>
              <para><guilabel>Description</guilabel> - произвольное текстовое описание задания.</para>
            </listitem>
          </itemizedlist></para>
        <para>Задание также имеет признак активности, который устанавливается в экране списка заданий. Неактивные задания не запускаются. </para>
      </section>
      <section>
        <title>Управление обработкой заданий</title>
        <itemizedlist>
          <listitem>
            <para>Для запуска обработки назначенных заданий необходимо перед стартом сервера установить свойство приложения <property>
                <link linkend="cuba.schedulingActive">cuba.schedulingActive</link>
              </property> в значение <code>true</code>.</para>
          </listitem>
          <listitem>
            <para>Для оперативного управления обработкой заданий можно использовать JMX-бин <code>app-core.cuba:type=Scheduling</code>, атрибут <code>Active</code> которого запускает/останавливает обработку заданий для текущего сеанса работы сервера. После перезапуска сервера обработка будет запущена только при установленном в <code>true</code> свойстве приложения <property>cuba.schedulingActive</property>.</para>
          </listitem>
          <listitem>
            <para>Все изменения в заданиях, сделанные через экраны системы, вступают в силу немедленно для всех серверов кластера. </para>
          </listitem>
          <listitem>
            <para>Для  удаления старой истории выполнения заданий можно использовать метод <code>removeExecutionHistory()</code> JMX-бина <code>app-core.cuba:type=Scheduling</code>. У него имееется два параметра:<itemizedlist>
                <listitem>
                  <para><code>age</code> - время в часах, прошедшее после выполнения задания.</para>
                </listitem>
                <listitem>
                  <para><code>maxPeriod</code> - максимальный период заданий в часах, выполнения которых надо удалять. Это позволяет удалять только историю &quot;частых&quot; задач, а историю выполняемых, например, раз в сутки и реже, хранить без ограничений.</para>
                </listitem>
              </itemizedlist></para>
            <para>Данный метод можно вызывать автоматически, для этого достаточно создать новое задание и установить для него следующие параметры:<itemizedlist>
                <listitem>
                  <para><guilabel>Bean name</guilabel> - cuba_SchedulingMBean</para>
                </listitem>
                <listitem>
                  <para><guilabel>Method name</guilabel> - removeExecutionHistory(String age, String maxPeriod) </para>
                </listitem>
                <listitem>
                  <para><guilabel>Method parameters</guilabel> - например age = 72, maxPeriod = 12.</para>
                </listitem>
              </itemizedlist></para>
          </listitem>
        </itemizedlist>
      </section>
      <section>
        <title>Особенности реализации</title>
        <itemizedlist>
          <listitem>
            <para>Период вызова обработки заданий (метода <code>SchedulingAPI.processScheduledTasks()</code>) задается в <filename>cuba-spring.xml</filename> и по умолчанию равен 1 сек. Он задает минимальное значение периода запуска задания, которое должно быть в 2 раза больше, т.е. 2 сек. Уменьшать эти времена не рекомендуется. </para>
          </listitem>
          <listitem>
            <para>Текущая реализация планировщика основана на синхронизации с помощью блокировки строк в таблице базы данных. Это означает, что при значительной нагрузке БД может не успевать вовремя отвечать планировщику, и необходимо увеличивать период запуска (&gt;1сек), и, соответственно, минимальный период запуска заданий также будет увеличиваться.</para>
          </listitem>
          <listitem>
            <para>Синглтон-задания в случае незаданного атрибута Permitted servers выполняются только на мастер-узле кластера (при выполнении прочих условий). Следует иметь в виду, что отдельный  сервер вне кластера также является мастером. </para>
          </listitem>
          <listitem>
            <para>Задание не запускается, если оно в данный момент не закончило предыдущее выполнение, и не истек указанный Timeout. Для синглтон-заданий в текущей реализации это обеспечивается информацией в базе данных, для не-синглтонов поддерживается таблица статуса выполнения в памяти сервера. </para>
          </listitem>
          <listitem>
            <para>Механизм выполнения создает и кэширует <link linkend="userSession">пользовательские сессии</link> в соответствии с указанными для заданий User name, либо свойством приложения <property>
                <link linkend="cuba.jmxUserLogin">cuba.jmxUserLogin</link>
              </property>. Сессия доступна в потоке выполнения запускаемого задания обычным способом - через интерфейс <code>
                <link linkend="userSessionSource">UserSessionSource</link>
              </code>.</para>
          </listitem>
        </itemizedlist>
        <warning>
          <para>Для нормальной работы синглтон-заданий необходима точная синхронизация серверов <structname>Middleware</structname> по времени!</para>
        </warning>
      </section>
    </section>
  </section>
  <section id="email_sending">
    <title>Отправка email</title>
    <para>Платформа предоставляет средства отправки сообщений электронной почты со следующими возможностями:<itemizedlist>
        <listitem>
          <para>Синхронная или асинхронная отправка. В случае синхронной отправки вызывающий код ожидает, пока сообщение не будет передано на SMTP сервер. При асинхронной отправке сообщение сохраняется в базе данных, и управление немедленно возвращается вызывающему коду. Отправка производится позже путем вызова из <link linkend="scheduled_tasks">назначенного задания</link>.  </para>
        </listitem>
        <listitem>
          <para>Надежная фиксация факта отправки и ошибок в базе данных, как для синхронной, так и для асинхронной отправки.</para>
        </listitem>
        <listitem>
          <para>Пользовательский интерфейс для поиска и просмотра информации о посылаемых сообщениях, включая все атрибуты и содержимое сообщений, а также статус отправки и количество предпринятых попыток.</para>
        </listitem>
      </itemizedlist></para>
    <section>
      <title>Методы отправки</title>
      <para>Для отправки email на <structname>Middleware</structname> следует использовать бин <code>EmailerAPI</code>, на клиентском уровне - сервис <code>EmailService</code>.</para>
      <para>Рассмотрим основные методы этих компонентов:<itemizedlist>
          <listitem>
            <para><code>sendEmail()</code> -  синхронная отправка сообщения. Вызывающий код блокируется на время отправки сообщения SMTP серверу.</para>
            <para>Сообщение может быть передано как в виде набора параметров (список адресатов через запятую, тема, содержимое, массив вложений), так и в виде специального объекта <code>EmailInfo</code>, инкапсулирующего всю эту информацию, плюс позволяющего явно задать адрес отправителя и сформировать тело письма по шаблону <application>FreeMarker</application>.</para>
            <para>При синхронной отправке может быть сгенерировано исключение <code>EmailException</code>, несущее в себе информацию о том, по каким адресам отправка не удалась, и соответствующие им сообщения об ошибках.</para>
            <para>В процессе работы метода для каждого адресата в базе данных создается экземпляр сущности <code>SendingMessage</code>, который сначала получает статус <code>SendingStatus.SENDING</code>, а после успешной отправки - <code>SendingStatus.SENT</code>. В случае ошибки отправки статус сообщения меняется на <code>SendingStatus.NOTSENT</code>.</para>
          </listitem>
          <listitem>
            <para><code>sendEmailAsync()</code> - асинхронная отправка сообщения. Данный метод возвращает список (по числу получателей) экземпляров <code>SendingMessage</code> со статусом <code>SendingStatus.QUEUE</code>, созданных  в базе данных. Собственно отправка производится при последующем вызове метода <code>EmailManagerAPI.queueEmailsToSend()</code>, который необходимо зарегистрировать в механизме <link linkend="scheduled_tasks">назначенных заданий</link> с желаемой периодичностью.</para>
          </listitem>
        </itemizedlist></para>
    </section>
    <section>
      <title>Вложения</title>
      <para>Объект <code>EmailAttachment</code> - обёртка, хранящая вложение в виде массива байт (поле <code>data</code>), имя файла (поле <code>name</code>), и при необходимости, уникальный для данного сообщения идентификатор вложения (необязательное, но полезное поле <code>contentId</code>). </para>
      <para>Идентификатор вложения  может быть использован для вставки в сообщение изображений следующим образом:
при создании <code>EmailAttachment</code> задаётся уникальный <code>contentId</code>, например, <code>myPic</code>. В теле письма для вставки вложения необходимо в качестве пути использовать запись вида: <code>cid:myPic</code>. Т.е. для вставки изображения нужно указать следующий элемент HTML:<programlisting language="xml">&lt;img src=&quot;cid:myPic&quot;/&gt;</programlisting></para>
    </section>
    <section id="email_sending_properties">
      <title>Настройка параметров отправки email</title>
      <para>Параметры отправки  email могут быть настроены с помощью перечисленных ниже <link linkend="app_properties">свойств приложения</link>. Все они являются параметрами времени выполнения и хранятся в базе данных, однако могут быть переопределены для конкретного блока <structname>Middleware</structname> в его файле <filename>app.properties</filename>.</para>
      <para>Все параметры отправки email доступны через конфигурационный интерфейс <code>EmailerConfig</code>.</para>
      <itemizedlist>
        <listitem>
          <para><property>cuba.email.fromAddress</property> - адрес отправителя по умолчанию. Принимается во внимание, если не указан атрибут <code>EmailInfo.from</code>.</para>
          <para>Значение по умолчанию: <literal>DoNotReply@localhost</literal></para>
        </listitem>
        <listitem>
          <para><property>cuba.email.smtpHost</property> - адрес SMTP сервера.</para>
          <para>Значение по умолчанию: <literal>test.host</literal></para>
        </listitem>
        <listitem>
          <para><property>cuba.email.smtpPort</property> - порт SMTP сервера.</para>
          <para>Значение по умолчанию: <literal>25</literal></para>
        </listitem>
        <listitem>
          <para><property>cuba.email.smtpAuthRequired</property> - требуется ли аутентификация на SMTP сервере. Соответствует параметру <literal>mail.smtp.auth</literal>, передаваемому при создании объекта <code>javax.mail.Session</code>.</para>
          <para>Значение по умолчанию: <literal>false</literal></para>
        </listitem>
        <listitem>
          <para><property>cuba.email.smtpStarttlsEnable</property> - задает использование команды <literal>STARTTLS</literal> при аутентификации на SMTP сервере. Соответствует параметру <literal>mail.smtp.starttls.enable</literal>, передаваемому при создании объекта <code>javax.mail.Session</code>.</para>
          <para>Значение по умолчанию: <literal>false</literal></para>
        </listitem>
        <listitem>
          <para><property>cuba.email.smtpUser</property> - имя пользователя для аутентификации на SMTP сервере.</para>
        </listitem>
        <listitem>
          <para><property>cuba.email.smtpPassword</property> - пароль пользователя для аутентификации на SMTP сервере.</para>
        </listitem>
        <listitem>
          <para><property>cuba.email.delayCallCount</property> - используется при асинхронной отправке email из очереди для пропуска нескольких первых вызовов <code>EmailManager.queueEmailsToSend()</code> сразу после старта сервера, чтобы снизить нагрузку во время инициализации приложения. Отправка email начнется следующим вызовом.</para>
          <para>Значение по умолчанию: <literal>2</literal></para>
        </listitem>
        <listitem>
          <para><property>cuba.email.messageQueueCapacity</property> - при асинхронной отправке количество сообщений, читаемое из очереди и отправляемое за один вызов <code>EmailManager.queueEmailsToSend()</code>.</para>
          <para>Значение по умолчанию: <literal>100</literal></para>
        </listitem>
        <listitem>
          <para><property>cuba.email.defaultSendingAttemptsCount</property> - при асинхронной отправке email количество попыток отправки по умолчанию. Принимается во внимание, если при вызове <code>Emailer.sendEmailAsync()</code> не указан параметр <code>attemptsCount</code>.</para>
          <para>Значение по умолчанию: <literal>10</literal></para>
        </listitem>
        <listitem>
          <para>cuba.email.maxSendingTimeSec - максимальное предполагаемое время в секундах, требуемое для отправки сообщения на SMTP сервер. Используется при асинхронной отправке для оптимизации выборки объектов <code>SendingMessage</code> из очереди в БД.</para>
          <para>Значение по умолчанию: 120</para>
        </listitem>
        <listitem>
          <para><property>cuba.email.sendAllToAdmin</property> - указывает, что все сообщения должны отправляться на адрес <property>cuba.email.adminAddress</property>, независимо от указанного адреса получателя. Этот параметр рекомендуется использовать во время отладки системы.</para>
          <para>Значение по умолчанию: <literal>false</literal></para>
        </listitem>
        <listitem>
          <para><property>cuba.email.adminAddress</property> - адрес, на который отправляются все сообщения при включенном свойстве <property>cuba.email.sendAllToAdmin</property>.</para>
          <para>Значение по умолчанию: <literal>admin@localhost</literal></para>
        </listitem>
        <listitem>
          <para><property>cuba.emailerUserLogin</property> - логин пользователя системы, под которым регистрируется механизм асинхронной отправки email для того, чтобы иметь возможность сохранить информацию в базе данных. Рекомендуется создать отдельного пользователя (например <literal>emailer</literal>) без пароля, чтобы под его именем нельзя было войти через пользовательский интерфейс приложения. Это полезно для поиска в логе сервера сообщений, касаемых отсылки email.</para>
          <para>Значение по умолчанию: <literal>admin</literal></para>
        </listitem>
      </itemizedlist>
      <para>Просмотреть текущие значения параметров, а также отправить тестовое сообщение, можно с помощью JMX-бина <code>app-core.cuba:type=Emailer</code>.</para>
    </section>
  </section>
  <section id="dynamic_attributes">
    <title>Динамические атрибуты</title>
    <para>
      <firstterm>Динамические атрибуты</firstterm>
      - это дополнительные поля сущности, которые можно добавлять без изменения схемы БД и перезагрузки
      приложения. Механизм динамических атрибутов предназначен для описания новых свойств сущностей на этапе настройки и
      эксплуатации системы.
    </para>
    <para>Динамические атрибуты CUBA являются реализацией концепции
      <ulink url="http://en.wikipedia.org/wiki/Entity%E2%80%93attribute%E2%80%93value_model">Entity-Attribute-Value</ulink>.
    </para>
    <figure>
      <title>Диаграмма классов механизма динамических атрибутов</title>
      <mediaobject>
        <imageobject>
          <imagedata align="center" fileref="img/dynamic_attributes.png"/>
        </imageobject>
      </mediaobject>
    </figure>
    <itemizedlist>
      <listitem>
        <para>
          <code>Category</code> - определяет <firstterm>категорию</firstterm>
          объектов, которая содержит описание структуры динамических атрибутов. Каждая категория относится к некоторому
          типу сущности.
        </para>
        <para>Например, имеется сущность типа <emphasis>Автомобиль</emphasis>. Для нее можно определить две категории:
          <emphasis>Грузовой</emphasis> и <emphasis>Пассажирский</emphasis>. При этом категория
          <emphasis>Грузовой</emphasis> будет содержать атрибуты
          <emphasis>Грузоподъемность</emphasis> и <emphasis>Вид кузова</emphasis>, а категория
          <emphasis>Пассажирский</emphasis> - атрибуты
          <emphasis>Количество мест</emphasis> и <emphasis>Наличие детского сидения</emphasis>.
        </para>
      </listitem>
      <listitem>
        <para>
          <code>CategoryAttribute</code> - определяет динамический атрибут, относящийся к некоторой категории.
          Каждый атрибут описывает одно поле  определенного типа. У каждого атрибута имеется обязательное поле
          <code>Код</code> (<code>code</code>), которое используется в качестве его системного имени.
          <code>Имя</code> атрибута (<code>name</code>) используется для отображения пользователю.
        </para>
      </listitem>
      <listitem>
        <para>
          <code>CategoryAttributeValue</code>
          - значение динамического атрибута для конкретного экземпляра сущности. Физически значения динамических
          атрибутов хранятся в специальной таблице <code>SYS_ATTR_VALUE</code>. У каждой записи этой таблицы есть ссылка
          на определенную сущность (колонка <code>ENTITY_ID</code>).
        </para>
      </listitem>
    </itemizedlist>
    <para>Экземпляр сущности может иметь атрибуты одновременно из всех категорий, связанных с этим типом сущности.
      Если необходимо, чтобы некоторый экземпляр сущности принадлежал только одной категории с соответствующим
      набором атрибутов (Автомобиль может быть либо Грузовым, либо Пассажирским), класс сущности должен
      реализовывать интерфейс <link linkend="categorized_entity">Categorized</link>. В этом случае экземпляр
      сущности будет содержать ссылку на категорию и динамические атрибуты только выбранной категории.
    </para>
    <section id="dynamic_attributes_usage">
      <title>Применение динамических атрибутов</title>
      <para>Управление категориями и описаниями атрибутов осуществляется с помощью специальных экранов, доступных через
        меню <guimenu>Administration &gt; Categories</guimenu>.
      </para>
      <figure>
        <title>Экран списка категорий</title>
        <mediaobject>
          <imageobject>
            <imagedata align="center" fileref="img/categoryBrowser.png"/>
          </imageobject>
        </mediaobject>
      </figure>
      <para>Редактор категорий позволяет создать категорию для выбранного типа сущности и добавить в нее набор
        динамических атрибутов. Для категории обязательно указывается имя и соответствующий тип сущности.
        Флажок <guilabel>Default</guilabel> указывает, что данная категория будет автоматически выбрана
        для нового экземпляра сущности, реализующей интерфейс <code>Categorized</code>.
      </para>
      <figure>
        <title>Экран редактирования категории</title>
        <mediaobject>
          <imageobject>
            <imagedata align="center" fileref="img/categoryEditor.png"/>
          </imageobject>
        </mediaobject>
      </figure>
      <para>Редактор динамического атрибута позволяет задать имя, системный код, тип значения и значение атрибута по умолчанию.</para>
      <figure>
        <title>Редактор динамического атрибута</title>
        <mediaobject>
          <imageobject>
            <imagedata align="center" fileref="img/runtimePropertyEditor.png"/>
          </imageobject>
        </mediaobject>
      </figure>
      <para>Динамический атрибут также имеет настройки видимости, описывающие, на каких экранах его нужно отображать. По
        умолчанию атрибут не отображается нигде.
      </para>
      <figure>
        <title>Настройки видимости динамического атрибута</title>
        <mediaobject>
          <imageobject>
            <imagedata align="center" fileref="img/runtimePropertyVisibility.png"/>
          </imageobject>
        </mediaobject>
      </figure>
      <para>Кроме экрана можно также указать компонент, в котором атрибут должен появляться (например, для экранов, где
        несколько компонентов <link linkend="gui_FieldGroup">FieldGroup</link> показывают поля одной и той же сущности).
      </para>
      <para>Если атрибут отмечен как видимый на каком-либо экране, он автоматически отобразится во всех группах полей и
        таблицах, отображающих объекты данного типа в данном экране.
      </para>
      <para>Доступ к динамическим атрибутам также может быть ограничен через настройки в
        <link linkend="roles">ролях пользователей</link>. Настройки осуществляются так же, как для обычных атрибутов.
      </para>
      <para>Для того чтобы изменения в атрибутах и настройках видимости вступили в силу, необходимо нажать кнопку
        <guibutton>Применить изменения</guibutton> на экране со списком категорий. Изменения также можно применить
        через <guimenu>Administration &gt; JMX Console</guimenu>, вызвав метод <code>clearDynamicAttributesCache()</code>
        JMX бина <code>app-core.cuba:type=CachingFacade</code>.
      </para>
      <para>Ниже изображен динамический атрибут, добавленный в экран автоматически путем задания настроек
        отображения атрибута:
        <mediaobject>
          <imageobject>
            <imagedata align="center" fileref="img/runtimePropsApplyChanges.png"/>
          </imageobject>
        </mediaobject>
      </para>
      <para>Динамические атрибуты можно добавить в экран вручную. Для этого необходимо выполнить следующее:</para>
      <itemizedlist>
        <listitem>
          <para>В секции <code>dsContext</code> XML-дескриптора экрана для источника данных с загружаемой
            сущностью (сущностями) установить в <code>true</code> признак
            <code>loadDynamicAttributes</code> для источника данных с загружаемой
            сущностью (сущностями), например:
          </para>
          <programlisting language="xml"><![CDATA[
<dsContext>
  <datasource id="carDs" class="com.company.sample.entity.Car" view="_local" loadDynamicAttributes="true"/>
</dsContext>]]></programlisting>
        </listitem>
        <listitem>
          <para>В описании визуального компонента в качестве <code>property</code>
            нужно использовать код динамического атрибута с префиксом <code>+</code>:
          </para>
          <programlisting language="xml"><![CDATA[
<textField id="numberOfSeats" datasource="carDs" property="+numberOfSeats"/>]]></programlisting>
        </listitem>
      </itemizedlist>
    </section>
    <section id="categorized_entity">
      <title>Категоризируемые сущности</title>
      <para>Если сущность реализует интерфейс <code>com.haulmont.cuba.core.entity.Categorized</code>,
        то для работы с ее динамическими атрибутами
        можно использовать компонент <code>com.haulmont.cuba.gui.components.RuntimePropertiesFrame</code>.
        Этот компонент позволяет пользователю выбрать для экземпляра сущности некоторую категорию и указать
        значения динамических атрибутов этой категории.</para>
      <para>Для использования <code>RuntimePropertiesFrame</code> в экране редактирования необходимо выполнить следующее:
        <itemizedlist>
          <listitem>
            <para>В секции <code>dsContext</code> необходимо объявить два источника данных:
              <itemizedlist>
                <listitem>
                  <para>
                    <code>runtimePropsDatasource</code> - специфический источник, в который будут загружены экземпляры
                    <code>CategoryAttributeValue</code>. Атрибут <code>mainDs</code>
                    должен ссылаться на главный источник данных, содержащий редактируемую сущность.
                  </para>
                </listitem>
                <listitem>
                  <para>обычный <code>collectionDatasource</code> для загрузки списка категорий данного типа сущности.</para>
                </listitem>
              </itemizedlist>
            </para>
            <para>Например:
              <programlisting language="xml"><![CDATA[
<dsContext>
  <datasource id="carDs"
      class="com.company.sample.entity.Car"
      view="carEdit"/>

  <runtimePropsDatasource id="runtimePropsDs"
      mainDs="carDs"/>

  <collectionDatasource id="categories"
      class="com.haulmont.cuba.core.entity.Category"
      view="_local">
    <query>
         select c from sys$Category c where c.entityType='sample$Car'
    </query>
  </collectionDatasource>
</dsContext>]]></programlisting>
            </para>
          </listitem>
          <listitem>
            <para>После этого можно включить в XML-дескриптор экрана визуальный компонент <code>runtimeProperties</code>:
              <programlisting language="xml"><![CDATA[
<runtimeProperties id="runtimePropsFrame"
  runtimeDs="runtimePropsDs"
  categoriesDs="categories"/>]]></programlisting>
            </para>
          </listitem>
        </itemizedlist>
      </para>
    </section>
    <section id="dynamic_attributes_in_rest_api">
      <title>Динамические атрибуты в REST API</title>
      <para>
        <link linkend="rest_api">REST API</link> поддерживает загрузку и сохранение динамических атрибутов. Для этого
        достаточно добавить в URL запроса <code>find</code> or <code>query</code> параметр <code> dynamicAttributes=true</code>:
      </para>
      <programlisting><![CDATA[
app-portal/api/find.xml?e=sample$Car-9f789ba9-ca15-4758-a8b8-77e434f1d438&s=9f789ba9-ca15-4758-a8b8-77e434f1d438&dynamicAttributes=true]]>
      </programlisting>
      <para>Динамические атрибуты в JSON и XML документах представляются так же как и обычные атрибуты, с той разницей,
        что имя динамического атрибута представляет собой его код с префиксом <code>+</code>.</para>
      <para>REST API также сохраняет динамические атрибуты, переданные в <code>commit</code>.</para>
    </section>
  </section>
  <section id="pessimistic_locking">
    <title>Пессимистичная блокировка</title>
    <para>В данном разделе описано применение пессимистичной блокировки  в CUBA-приложениях.</para>
    <section>
      <title>Блокировка редактирования сущностей</title>
      <para>Пессимистичная блокировка сущностей применяется, если велика вероятность одновременного редактирования одного и того же экземпляра, и стандартная <link linkend="optimistic_locking">оптимистичная блокировка</link>, основанная на версионности сущностей, порождает слишком много коллизий.</para>
      <para>Пессимистичная блокировка использует явное блокирование экземпляра сущности при открытии его в <link linkend="screen_edit">экране редактирования</link>. В результате только один пользователь  в некоторый момент времени может редактировать данный экземпляр сущности.</para>
      <para>Режим пессимистичной блокировки может быть задан для любого класса сущности в процессе настройки или эксплуатации системы. Для этого достаточно выполнить следующие действия:<itemizedlist>
          <listitem>
            <para>вставить в таблицу <database>SYS_LOCK_CONFIG</database> запись со следующими значениями полей:<itemizedlist>
                <listitem>
                  <para><database>ID</database> - произвольный идентификатор типа UUID.</para>
                </listitem>
                <listitem>
                  <para><database>NAME</database> - наименование блокируемого объекта. Для сущности это должно быть имя ее <link linkend="metaClass">мета-класса</link>. </para>
                </listitem>
                <listitem>
                  <para><database>TIMEOUT_SEC</database> - таймаут истечения блокировки в секундах.</para>
                </listitem>
              </itemizedlist></para>
            <para>Например: <programlisting>insert into sys_lock_config (id, create_ts, name, timeout_sec) values (newid(), current_timestamp, &apos;sales$Order&apos;, 300)</programlisting></para>
          </listitem>
          <listitem>
            <para>перезапустить сервер или выполнить метод <code>reloadConfiguration()</code> JMX-бина <code>app-core.cuba:type=LockManager</code>.</para>
          </listitem>
        </itemizedlist></para>
    </section>
    <section>
      <title>Блокировка произвольных процессов</title>
      <para>Механизм пессимистичной блокировки можно использовать также для управления совместным выполнением произвольных процессов. Причем блокировки являются распределенными, т.к. информация о них реплицируется в кластере  <structname>Middleware</structname>. </para>
      <para>Подробнее см. JavaDoc интерфейсов <code>LockManagerAPI</code> и <code>LockService</code>.</para>
    </section>
    <section>
      <title>Мониторинг блокировок</title>
      <para>Текущее состояние блокировок можно отслеживать через JMX-бин <code>app-core.cuba:type=LockManager</code>, или через специальный экран, доступный в меню <guimenu>Администрирование</guimenu> -&gt; <guimenuitem>Блокировки</guimenuitem>. Экран также позволяет разблокировать любой объект принудительно. </para>
    </section>
  </section>
  <section id="entity_statistics">
    <title>Статистика сущностей</title>
    <para>Механизм статистики сущностей  предоставляет данные о текущем количестве экземпляров сущностей в базе данных. Эти данные используются для автоматического принятия решений о выборе способа поиска связанных сущностей и ограничении размера выборок в экранах пользовательского интерфейса.</para>
    <para>Статистика хранится  в таблице <database>SYS_ENTITY_STATISTICS</database>, соответствующей сущности <code>EntityStatistics</code>. Заполнить статистику можно как вручную, внося соответствующие записи в таблицу, так и автоматически с помощью метода <code>refreshStatistics()</code> JMX-бина <code>
        <link linkend="persistenceManagerMBean">PersistenceManagerMBean</link>
      </code>. При указании в качестве параметра имени сущности статистика будет собрана только для данной сущности, в противном случае - для всех. Сбор статистики может занять значительное время и вызвать нежелательную нагрузку на БД, поэтому выполнять его нужно либо вручную, либо <link linkend="scheduled_tasks_cuba">назначенным заданием</link>   в подходящее время.</para>
    <para>Программный доступ к статистике осуществляется с помощью интерфейса <code>PersistenceManagerAPI</code> на <structname>Middleware</structname> и <code>PersistenceManagerService</code> на клиентском уровне. Статистика кэшируется в памяти, поэтому если изменения статистики вносятся напрямую в базу данных, для вступления их в силу необходимо перезапустить сервер или вызвать метод <code>PersistenceManagerMBean.flushStatisticsCache()</code>.</para>
    <para>Рассмотрим атрибуты <code>EntityStatistics</code> и их влияние на поведение системы.<itemizedlist>
        <listitem>
          <para><code>name</code> (колонка <database>NAME</database>) - тип сущности в виде имени <link linkend="metaClass">мета-класса</link>, например, <code>sales$Customer</code>.</para>
        </listitem>
        <listitem>
          <para><code>instanceCount</code> (колонка <database>INSTANCE_COUNT</database>) - примерное текущее количество экземпляров сущности. </para>
        </listitem>
        <listitem>
          <para><code>fetchUI</code> (колонка <database>FETCH_UI</database>) - размер страницы данных, предлагаемый пользователю при извлечении списков сущностей. </para>
          <para>Например, компонент <link linkend="gui_Filter">
              <code>Filter</code>
            </link> устанавливает это число в поле <guilabel>Показывать N строк</guilabel>.</para>
        </listitem>
        <listitem>
          <para><code>maxFetchUI</code> (колонка <database>MAX_FETCH_UI</database>) - максимальное количество экземпляров сущности, которое может быть извлечено и передано на клиентский уровень. </para>
          <para>Данный параметр играет роль при отображении списков сущностей в компонентах типа <code>
              <link linkend="gui_LookupField">LookupField</link>
            </code> и <code>
              <link linkend="gui_LookupPickerField">LookupPickerField</link>
            </code>, а также в таблицах без универсального <link linkend="gui_Filter">фильтра</link>, то есть когда на связанный <link linkend="datasources">источник данных</link> не налагается ограничений методом <code>CollectionDatasource.setMaxResults()</code>.  В этом случае сам источник данных ограничивает количество извлекаемых экземпляров значением <code>maxFetchUI</code>.</para>
        </listitem>
        <listitem>
          <para><code>lookupScreenThreshold</code> (колонка <database>LOOKUP_SCREEN_THRESHOLD</database>) - порог количества экземпляров сущности, при превышении которого в универсальных механизмах пользовательского интерфейса для поиска связанных сущностей будут использоваться <link linkend="screen_lookup">экраны выбора</link>  вместо выпадающих списков. </para>
          <para>В частности, этот параметр принимается во внимание компонентом <code>
              <link linkend="gui_Filter">Filter</link>
            </code> при выборе параметров фильтрации: до достижения порога используется компонент <code>
              <link linkend="gui_LookupField">LookupField</link>
            </code>, при превышении порога - компонент <code>
              <link linkend="gui_PickerField">PickerField</link>
            </code>. Поэтому, если необходимо заставить фильтр отображать выбор параметра некоторого типа через экран выбора, достаточно внести запись статистики для этой сущности со значением <code>lookupScreenThreshold</code> меньшим, чем <code>instanceCount</code>.</para>
        </listitem>
      </itemizedlist></para>
    <para>JMX-бин <code>PersistenceManagerMBean</code> в атрибутах <code>DefaultFetchUI</code>, <code>DefaultMaxFetchUI</code>, <code>DefaultLookupScreenThreshold</code> позволяет задать значения вышеперечисленных параметров по умолчанию. В результате, если для некоторой сущности статистика отсутствует (что является обычной ситуацией), будет использоваться соответствующий параметр по умолчанию. </para>
    <para>Кроме того, JMX-бин <code>PersistenceManagerMBean</code> позволяет ввести данные статистики для конкретной сущности с помощью операции <code>enterStatistics()</code>. Например, для того, чтобы для сущности <code>sales$Customer</code> установить размер страницы данных по умолчанию в 1000, а максимальное количество извлекаемых экземпляров в компонентах <link linkend="gui_LookupField">LookupField</link> в 30000, следует вызвать операцию <code>enterStatistics()</code> со следующими параметрами:<programlisting>entityName: sales$Customer
fetchUI: 1000
maxFetchUI: 30000</programlisting></para>
  </section>
  <section id="entity_log">
    <title>Журнал изменений сущностей</title>
    <para>Механизм журналирования предназначен для отслеживания изменений атрибутов произвольных сущностей в процессе работы приложения. Измененные значения сохраняются в специальной таблице базы данных, список изменений для конкретного экземпляра сущности может быть отображен в пользовательском интерфейсе.</para>
    <para>Данный механизм перехватывает сохранение сущностей в БД  на уровне <link linkend="entity_listeners">Entity Listeners</link>, т.е. гарантированно отслеживаются все изменения, проходящие через персистентный контекст <code>
        <link linkend="entityManager">EntityManager</link>
      </code>. Непосредственное изменение сущностей в базе данных с помощью SQL, в том числе изнутри системы через <link linkend="nativeQuery">
        <code>NativeQuery</code>
      </link> и <code>
        <link linkend="queryRunner">QueryRunner</link>
      </code>, в журнал не попадает.  </para>
    <para>Измененные экземпляры сущностей перед сохранением в БД отправляются в  методы <code>registerCreate()</code>, <code>registerModify()</code>, <code>registerDelete()</code> бина <code>EntityLogAPI</code>. Параметр <code>auto</code> этих методов позволяет отделить автоматическое журналирование посредством Entity Listeners от ручного вызова этих же методов в прикладном коде. При вызове из Entity Listeners в параметре <code>auto</code> передается <code>true</code>. </para>
    <para>Журнал содержит информация о том, кто и  когда изменил данный экземпляр, а также новые значения измененных атрибутов. Записи журнала сохраняются в таблице <database>SEC_ENTITY_LOG</database> базы данных, соответствующей сущности <code>EntityLogItem</code>. Измененные значения атрибутов хранятся в этой же таблице в колонке <database>CHANGES</database>, а при чтении на <structname>Middleware</structname> преобразуются в экземпляры сущности <code>EntityLogAttr</code>. </para>
    <section>
      <title>Настройка журналирования</title>
      <para>Аудит настраивается при помощи сущностей <code>LoggedEntity</code> и <code>LoggedAttribute</code> (соответствующих таблицам <database>SEC_LOGGED_ENTITY</database> и <database>SEC_LOGGED_ATTR</database>).</para>
      <para><code>LoggedEntity</code> описывает тип сущности, изменения которой необходимо журналировать. Атрибуты <code>LoggedEntity</code>:</para>
      <itemizedlist>
        <listitem>
          <para><code>name</code> (колонка <database>NAME</database>) - тип сущности в виде имени <link linkend="metaClass">мета-класса</link>, например, <code>sales$Customer</code>.</para>
        </listitem>
        <listitem>
          <para><code>auto</code> (колонка <database>AUTO</database>) - нужно ли журналировать изменения при вызове <code>EntityLogAPI</code> с параметром <code>auto = true</code> (т.е. из <link linkend="entity_listeners">Entity Listeners</link>).</para>
        </listitem>
        <listitem>
          <para><code>manual</code> (колонка <database>MANUAL</database>) - нужно ли журналировать изменения при вызове <code>EntityLogAPI</code> с параметром <code>auto = false</code>.</para>
        </listitem>
      </itemizedlist>
      <para><code>LoggedAttribute</code> описывает журналируемый атрибут сущности и содержит ссылку на <code>LoggedEntity</code> и имя атрибута.</para>
      <para>Для настройки журналирования некоторой сущности достаточно внести соответствующие записи в таблицы <database>SEC_LOGGED_ENTITY</database> и <database>SEC_LOGGED_ATTR</database>. Например, для ведения журнала изменений атрибутов <code>name</code>  и <code>grade</code> сущности <code>Customer</code>, необходимо выполнить:<programlisting>insert into SEC_LOGGED_ENTITY (ID, CREATE_TS, CREATED_BY, NAME, AUTO, MANUAL)
values (&apos;25eeb644-e609-11e1-9ada-3860770d7eaf&apos;, now(), &apos;admin&apos;, &apos;sales$Customer&apos;, true, true);

insert into SEC_LOGGED_ATTR (ID, CREATE_TS, CREATED_BY, ENTITY_ID, NAME)
values (newid(), now(), &apos;admin&apos;, &apos;25eeb644-e609-11e1-9ada-3860770d7eaf&apos;, &apos;name&apos;);

insert into SEC_LOGGED_ATTR (ID, CREATE_TS, CREATED_BY, ENTITY_ID, NAME)
values (newid(), now(), &apos;admin&apos;, &apos;25eeb644-e609-11e1-9ada-3860770d7eaf&apos;, &apos;grade&apos;);</programlisting></para>
      <para>Для активации механизма журналирования необходимо установить в <code>true</code> атрибут <code>Enabled</code> JMX-бина <code>app-core.cuba:type=EntityLog</code>. Для вступления в силу изменений настройки журналирования, произведенных во время работы приложения, необходимо перезапустить сервер или вызвать метод <code>invalidateCache()</code> этого же бина.</para>
    </section>
    <section>
      <title>Отображение журнала</title>
      <para>Для просмотра журнала изменений некоторого экземпляра сущности достаточно обычным способом загрузить в источники данных экрана коллекцию экземпляров <code>EntityLogItem</code> и ассоциированных с ними <code>EntityLogAttr</code>, и  создать визуальные компоненты, связанные с этими источниками. Например:<programlisting language="xml">&lt;dsContext&gt;
  &lt;datasource id=&quot;customerDs&quot;
              class=&quot;com.sample.sales.entity.Customer&quot;
              view=&quot;customerEdit&quot;/&gt;

  &lt;collectionDatasource id=&quot;logDs&quot;
                        class=&quot;com.haulmont.cuba.security.entity.EntityLogItem&quot;
                        view=&quot;logView&quot;&gt;
      &lt;query&gt;
          select i from sec$EntityLog i
          where i.entityId = :ds$customerDs order by i.eventTs
      &lt;/query&gt;

      &lt;collectionDatasource id=&quot;logAttrDs&quot;
                            property=&quot;attributes&quot;/&gt;
  &lt;/collectionDatasource&gt;
&lt;/dsContext&gt;
&lt;layout&gt;
...
  &lt;split orientation=&quot;vertical&quot; width=&quot;100%&quot; height=&quot;100%&quot;&gt;

      &lt;table id=&quot;logTable&quot; width=&quot;100%&quot; height=&quot;100%&quot;&gt;
          &lt;columns&gt;
              &lt;column id=&quot;eventTs&quot;/&gt;
              &lt;column id=&quot;user.login&quot;/&gt;
              &lt;column id=&quot;type&quot;/&gt;
          &lt;/columns&gt;
          &lt;rows datasource=&quot;logDs&quot;/&gt;
      &lt;/table&gt;

      &lt;table id=&quot;logAttrTable&quot; width=&quot;100%&quot; height=&quot;100%&quot;&gt;
          &lt;columns&gt;
              &lt;column id=&quot;name&quot;/&gt;
              &lt;column id=&quot;value&quot;/&gt;
          &lt;/columns&gt;
          &lt;rows datasource=&quot;logAttrDs&quot;/&gt;
      &lt;/table&gt;

  &lt;/split&gt;
...
&lt;/layout&gt;</programlisting></para>
      <para>Для отображения локализованных значений журналируемых атрибутов эти атрибуты должны содержать аннотацию <link linkend="localizedValue_annotation">
          <code>@LocalizedValue</code>
        </link>. При ее наличии механизм журналирования заполняет поле <code>EntityLogAttr.messagesPack</code>, и таблица, отображающая значения атрибутов из примера выше может использовать колонку <code>locValue</code> вместо <code>value</code>:<programlisting language="xml">&lt;table id=&quot;logAttrTable&quot; width=&quot;100%&quot; height=&quot;100%&quot;&gt;
  &lt;columns&gt;
      &lt;column id=&quot;name&quot;/&gt;
      &lt;column id=&quot;locValue&quot;/&gt;
  &lt;/columns&gt;
  &lt;rows datasource=&quot;logAttrDs&quot;/&gt;
&lt;/table&gt;</programlisting></para>
    </section>
  </section>
  <section id="entity_snapshots">
    <title>Снимки сущностей</title>
    <para>Механизм сохранения снимков сущностей, так же как и <link linkend="entity_log">журнал изменений</link>, предназначен для отслеживания изменений данных в процессе работы приложения. Его отличительными особенностями являются:<itemizedlist>
        <listitem>
          <para>Сохраняются не изменения некоторых атрибутов одного экземпляра, а состояние (снимок) целого графа сущностей, определяемого заданным <link linkend="views">представлением</link>.</para>
        </listitem>
        <listitem>
          <para>Процесс сохранения снимка вызывается явно из кода клиентского уровня.</para>
        </listitem>
        <listitem>
          <para>Платформа предоставляет возможность просмотра  и сравнения между собой сохраненных снимков.</para>
        </listitem>
      </itemizedlist></para>
    <section>
      <title>Сохранение снимков</title>
      <para>Для сохранения снимка некоторого графа сущностей достаточно вызвать метод <code>EntitySnapshotService.createSnapshot()</code> и передать ему основную сущность графа и  <link linkend="views">представление</link>, описывающее граф. Снимок создается по загруженной сущности, никаких обращений к базе данных не производится, поэтому снимок в результате содержит не больше полей, чем представление, с которым была загружена основная сущность.</para>
      <para>Граф Java объектов преобразуется в XML и сохраняется в базе данных вместе со ссылкой на основную сущность в таблице <database>SYS_ENTITY_SNAPSHOT</database>, соответствующей сущности <code>EntitySnapshot</code>.  </para>
      <para>Как правило, снимки требуется сохранять после коммита <link linkend="screen_edit">экрана редактирования</link>. Для этого можно переопределить метод <code>postCommit()</code> контроллера экрана, например:<programlisting language="java">public class CustomerEditor extends AbstractEditor&lt;Customer&gt; {

  @Inject
  protected Datasource&lt;Customer&gt; customerDs;

  @Inject
  protected EntitySnapshotService entitySnapshotService;

...
  @Override
  protected boolean postCommit(boolean committed, boolean close) {
      if (committed) {
          entitySnapshotService.createSnapshot(customerDs.getItem(), customerDs.getView());
      }
      return super.postCommit(committed, close);
  }
}</programlisting></para>
    </section>
    <section>
      <title>Отображение снимков</title>
      <para>Для отображения сохраненных для некоторой сущности снимков можно использовать фрейм <filename>com/haulmont/cuba/gui/app/core/entitydiff/diff-view.xml</filename>, например:<programlisting language="xml">&lt;iframe id=&quot;diffFrame&quot;
      src=&quot;/com/haulmont/cuba/gui/app/core/entitydiff/diff-view.xml&quot;
      width=&quot;100%&quot;
      height=&quot;100%&quot;/&gt;</programlisting></para>
      <para>В контроллере экрана редактирования необходимо вызвать загрузку снимков во фрейм:<programlisting language="java">public class CustomerEditor extends AbstractEditor&lt;Customer&gt; {

  @Inject
  protected EntityDiffViewer diffFrame;

...
  @Override
  protected void postInit() {
      if (!PersistenceHelper.isNew(getItem())) {
          diffFrame.loadVersions(getItem());
      }
  }
}</programlisting></para>
      <para>Фрейм <filename>diff-view.xml</filename> отображает список сохраненных для данной сущности снимков с возможностью их сравнения. Для каждого снимка указывается пользователь, дата и время сохранения. При выборе из списка некоторого снимка сущности в таблице сравнения показываются изменения  данных по сравнению с предыдущим снимком. В первом снимке измененными считаются все атрибуты. Если выбрано два снимка, то в таблицу   выводится результат их сравнения.
</para>
      <para>В таблице сравнения отображаются имена атрибутов и их новые значения, при выборе строки показывается детальная информация по изменениям атрибута в двух снимках. Ссылочные поля выводятся в соответствии с их шаблоном <link linkend="namePattern">
          <code>@NamePattern</code>
        </link>. При сравнении коллекций добавленные и удаленные элементы выделяются цветом (зеленый, красный), а элементы с измененными атрибутами остаются без выделения. Изменение позиций элементов не учитывается.  </para>
    </section>
  </section>
  <section id="file_storage">
    <title>Хранилище файлов</title>
    <para>Хранилище файлов обеспечивает загрузку, хранение и выгрузку произвольных файлов, ассоциированных с сущностями системы. Стандартная реализация сохраняет файлы вне основной базы данных, в специальной структуре файловой системы.</para>
    <para>Механизм работы с  файлами состоит из следующих частей:<itemizedlist>
        <listitem>
          <para>Сущность <code>FileDescriptor</code> - описатель загруженного файла (не путать с <code>java.io.FileDescriptor</code>), позволяющий ссылаться на файл из объектов модели данных.</para>
        </listitem>
        <listitem>
          <para>Интерфейс <code>FileStorageAPI</code> - доступ к хранилищу файлов на <link linkend="app_tiers">уровне</link> <structname>Middleware</structname>. Основные методы:<itemizedlist>
              <listitem>
                <para><code>saveStream()</code> - сохранить содержимое файла, переданное в <code>InputStream</code>, по данным указанного <code>FileDescriptor</code>.</para>
              </listitem>
              <listitem>
                <para><code>openStream()</code> - вернуть содержимое файла, указанного объектом <code>FileDescriptor</code>,  в виде открытого <code>InputStream</code>.</para>
              </listitem>
            </itemizedlist></para>
        </listitem>
        <listitem>
          <para>Класс <code>FileUploadController</code> - контроллер Spring MVC, позволяющий отправлять файлы с клиентского    уровня на  <structname>Middleware</structname> посредством HTTP POST запросов.</para>
        </listitem>
        <listitem>
          <para>Класс <code>FileDownloadController</code> - контроллер Spring MVC, позволяющий получать файлы с <structname>Middleware</structname> на клиентский уровень посредством HTTP GET запросов.</para>
        </listitem>
        <listitem>
          <para>Визуальные компоненты <code>
              <link linkend="gui_FileUploadField">FileUpload</link>
            </code> и <code>
              <link linkend="gui_FileMultiUploadField">FileMultiUpload</link>
            </code> - позволяют загрузить файлы с компьютера пользователя на клиентский уровень приложения, и затем организовать их передачу на <structname>Middleware</structname>.</para>
        </listitem>
        <listitem>
          <para>Интерфейс <code>FileUploadingAPI</code> - промежуточное хранилище загружаемых файлов на клиентском уровне. Используется вышеупомянутыми компонентами для загрузки файлов на клиентский уровень. В прикладном коде используется метод <code>putFileIntoStorage()</code>, перемещающий файл в постоянное хранилище на <structname>Middleware</structname>.</para>
        </listitem>
        <listitem>
          <para><code>ExportDisplay</code> - интерфейс клиентского уровня, позволяющий выгружать различные ресурсы приложения на компьютер пользователя. Для получения файлов из хранилища можно использовать метод <code>show()</code>, принимающий <code>FileDescriptor</code>. Экземпляр <code>ExportDisplay</code> можно получить либо вызовом статического метода <code>AppConfig.createExportDisplay()</code>, либо <link linkend="screen_controller_injection">инжекцией</link> в класс контроллера.</para>
        </listitem>
      </itemizedlist></para>
    <para>Передача файлов между пользовательским компьютером и хранилищем в обе стороны производится только путем копирования данных между потоками ввода-вывода. Ни на каком уровне приложения файл не оказывается целиком в памяти, поэтому возможна передача файлов практически любых размеров.</para>
    <section id="file_upload">
      <title>Загрузка файлов</title>
      <para>Для загрузки файлов с компьютера пользователя в хранилище следует использовать компоненты <code>
          <link linkend="gui_FileUploadField">FileUpload</link>
        </code> и <code>
          <link linkend="gui_FileMultiUploadField">FileMultiUpload</link>
        </code>. Примеры использования приведены в описании компонентов.</para>
      <para>Промежуточное хранилище клиентского уровня <code>FileUploadingAPI</code> для хранения временных файлов использует каталог, заданный свойством приложения <property>
          <link linkend="cuba.tempDir">cuba.tempDir</link>
        </property>.  В случае сбоев в нем могут оставаться временные файлы, для  удаления которых желательно в клиентских блоках приложения периодически вызывать метод <code>clearTempDirectory()</code> бина <code>cuba_FileUploading</code>. Это можно сделать, создав задание планировщика в файле <filename>
          <link linkend="spring.xml">spring.xml</link>
        </filename> модуля <structname>web</structname> (и/или <structname>desktop</structname>) проекта приложения, например:<programlisting language="xml">&lt;task:scheduled-tasks scheduler=&quot;scheduler&quot;&gt;
  &lt;task:scheduled ref=&quot;cuba_FileUploading&quot; method=&quot;clearTempDirectory&quot; cron=&quot;0 0 0 * * 2,4,6&quot;/&gt;
&lt;/task:scheduled-tasks&gt;</programlisting></para>
      <para>В данном случае очистка будет производиться в 00:00:00 каждый вторник, четверг и субботу.</para>
    </section>
    <section id="file_download">
      <title>Выгрузка данных</title>
      <para>Для выгрузки файлов на клиентском уровне следует использовать интерфейс <code>ExportDisplay</code>, получив ссылку на него вызовом статического метода <code>AppConfig.createExportDisplay()</code>, либо <link linkend="screen_controller_injection">инжекцией</link> в класс контроллера. Например:<programlisting language="java">AppConfig.createExportDisplay(this).show(fileDescriptor);</programlisting></para>
      <para>Метод <code>show()</code> может принимать дополнительный параметр типа <code>ExportFormat</code>, в котором можно задать тип содержимого и расширение имени файла. Если формат не передан, расширение берется из <code>FileDescriptor</code>, а типом содержимого принимается <code>application/octet-stream</code>. </para>
      <para>При использовании пользователем веб-интерфейса от расширения имени файла зависит, будет ли файл выгружаться через диалог сохранения или открытия файлов браузера (<code>Content-Disposition = attachment</code>), или браузер попытается отобразить содержимое прямо в своем окне (<code>Content-Disposition = inline</code>). Список расширений файлов, отображаемых в окне браузера, задается свойством приложения <property>
          <link linkend="cuba.web.viewFileExtensions">cuba.web.viewFileExtensions</link>
        </property>.</para>
    </section>
    <section id="file_storage_impl">
      <title>Стандартная реализация хранилища</title>
      <para>Стандартная реализация хранит файлы в специальной структуре каталогов на одном или нескольких файловых ресурсах.</para>
      <para>Корни структуры можно задать в свойстве приложения <property>
          <link linkend="cuba.fileStorageDir">cuba.fileStorageDir</link>
        </property>. Формат - список путей через запятую. Например: <programlisting>cuba.fileStorageDir=/work/sales/filestorage,/mnt/backup/filestorage</programlisting></para>
      <para>Если данное свойство не задано, хранилище будет создано в подкаталоге <filename>filestorage</filename> <link linkend="work_dir">рабочего каталога</link> <structname>Middleware</structname>. В стандартном варианте развертывания в Tomcat это каталог <filename>tomcat/work/app-core/filestorage</filename>. </para>
      <para>В случае указания нескольких ресурсов хранилище ведет себя следующим образом: <itemizedlist>
          <listitem>
            <para>Первый каталог в списке является <firstterm>основным</firstterm>, остальные - <firstterm>резервными</firstterm>. </para>
          </listitem>
          <listitem>
            <para>Запись сохраняемых файлов производится в основной каталог, а затем файл копируется во все резервные каталоги. </para>
            <para>Перед записью проверяется доступность каждого каталога. Если недоступен основной каталог, выбрасывается исключение и запись не производится. Если недоступен какой-то из резервных каталогов, запись все равно производится, в лог выводится сообщение об ошибке. </para>
          </listitem>
          <listitem>
            <para>Чтение производится из основного каталога. </para>
            <para>При недоступности основного каталога чтение производится из первого резервного каталога, в котором имеется данный файл. В лог выводится сообщение об ошибке. </para>
          </listitem>
        </itemizedlist></para>
      <para>Файловая структура хранилища организована следующим образом:<itemizedlist>
          <listitem>
            <para>Имеется три уровня каталогов, соответствующих дате загрузки файла - год, месяц, день.</para>
          </listitem>
          <listitem>
            <para>Файл сохраняется в каталоге дня. Именем файла является  идентификатор соответствующего объекта <code>FileDescriptor</code>. Расширение файла - исходное.</para>
          </listitem>
          <listitem>
            <para>В корне структуры хранилища ведется файл <filename>storage.log</filename>, содержащий информацию о том, какой файл, когда и каким пользователем был записан в хранилище. Этот журнал не несет никакой функциональности, но может быть полезен при поиске проблем.</para>
          </listitem>
        </itemizedlist></para>
      <para>JMX-бин <code>app-core.cuba:type=FileStorage</code> отображает текущий список корней хранилища, а также предоставляет следующие методы для поиска проблем:<itemizedlist>
          <listitem>
            <para><code>findOrphanDescriptors()</code> - найти в базе данных все экземпляры <code>FileDescriptor</code>, для которых не имеется соответствующего файла в хранилище.</para>
          </listitem>
          <listitem>
            <para><code>findOrphanFiles()</code> - найти файлы в хранилище, для которых не имеется соответствующего экземпляра <code>FileDescriptor</code> в БД.</para>
          </listitem>
        </itemizedlist></para>
    </section>
  </section>
  <section id="uniqueNumbers">
    <title>Генерация последовательностей</title>
    <para>Данный механизм позволяет  генерировать уникальные последовательности чисел через единый API, независимо от используемой СУБД. </para>
    <para>Основной частью данного механизма является <link linkend="managed_beans">бин</link> <code>UniqueNumbers</code> с интерфейсом <code>UniqueNumbersAPI</code>, доступный в блоке Middleware. Методы интерфейса:<itemizedlist>
        <listitem>
          <para><code>getNextNumber()</code> - получить следующее значение последовательности. Механизм позволяет вести одновременно несколько последовательностей, идентифицируемых простыми строками. Имя последовательности, из которой нужно получить значение, передается в параметре <code>domain</code>.</para>
          <para>Последовательности не требуют предварительной  инициализации - при первом вызове <code>getNextNumber()</code> соответствующая последовательность будет создана и вернет значение 1. </para>
        </listitem>
        <listitem>
          <para><code>getCurrentNumber()</code> - получить текущее, то есть последнее сгенерированное, значение последовательности. Параметр <code>domain</code> - имя последовательности.</para>
        </listitem>
        <listitem>
          <para><code>setCurrentNumber()</code> - установить текущее значение последовательности. Следующий вызов <code>getNextNumber()</code> вернет значение, увеличенное на 1.</para>
        </listitem>
      </itemizedlist></para>
    <para>Пример получения следующего значения последовательности в бине блока Middleware:<programlisting language="java">@Inject
private UniqueNumbersAPI uniqueNumbers;

private long getNextValue() {
  return uniqueNumbers.getNextNumber(&quot;mySequence&quot;);
}</programlisting></para>
    <para>Для получения значений последовательностей в клиентских блоках используется метод <code>getNextNumber()</code><link linkend="services"> сервиса</link> <code>UniqueNumbersService</code>.</para>
    <para>Для управления последовательностями можно использовать <link linkend="jmx_beans">JMX-бин</link> <code>app-core.cuba:type=UniqueNumbers</code> с методами, дублирующими методы <code>UniqueNumbersAPI</code>.</para>
    <para>Реализация механизма генерации последовательностей зависит от типа используемой СУБД. Для <application>HSQL</application>, <application>PostgreSQL, <application>Microsoft SQL Server 2012+</application></application> и <application>Oracle</application> каждой  последовательности <code>UniqueNumbersAPI</code> соответствует последовательность (sequence) <code>sec_un_{domain}</code> в базе данных. Для <application>Microsoft SQL Server</application> версии ниже 2012 каждой последовательности соответствует таблица <code>sec_un_{domain}</code> с автоинкрементным полем. В связи с этим управлять параметрами последовательности можно также напрямую в БД.</para>
  </section>
  <section id="queryRunner">
    <title>Выполнение SQL с помощью QueryRunner</title>
    <para><code>QueryRunner</code> - класс, предназначенный для выполнения SQL. Его следует использовать вместо <application>JDBC</application> везде, где есть необходимость работы с SQL и нежелательно применение аналогичных <link linkend="nativeQuery">средств ORM</link>. </para>
    <para>QueryRunner платформы является вариантом <ulink url="http://commons.apache.org/dbutils/apidocs/org/apache/commons/dbutils/QueryRunner.html">Apache DbUtils QueryRunner</ulink>, усовершенствованным для использования Java Generics.</para>
    <para>Пример использования: <programlisting language="java">

QueryRunner runner = new QueryRunner(persistence.getDataSource());
try {
  Set&lt;String&gt; scripts = runner.query(&quot;select SCRIPT_NAME from SYS_DB_CHANGELOG&quot;,
          new ResultSetHandler&lt;Set&lt;String&gt;&gt;() {
              public Set&lt;String&gt; handle(ResultSet rs) throws SQLException {
                  Set&lt;String&gt; rows = new HashSet&lt;String&gt;();
                  while (rs.next()) {
                      rows.add(rs.getString(1));
                  }
                  return rows;
              }
          });
  return scripts;
} catch (SQLException e) {
  throw new RuntimeException(e);
}</programlisting></para>
    <para>Есть два варианта использования <code>QueryRunner</code> - либо в текущей транзакции, либо в отдельной в режиме autocommit.<itemizedlist>
        <listitem>
          <para>Для выполнения запроса в текущей транзакции необходимо  создать экземпляр <code>QueryRunner</code> конструктором без параметров, не передавая <code>DataSource</code>. После этого нужно вызывать методы <code>query()</code> или <code>update()</code>, передавая в них <code>Connection</code>, полученный вызовом <code>EntityManager.getConnection()</code>. После выполнения закрывать <code>Connection</code> не нужно, он будет закрыт при коммите транзакции. </para>
        </listitem>
        <listitem>
          <para>Для выполнения запроса в отдельной транзакции необходимо создать экземпляр <code>QueryRunner</code> конструктором с параметром <code>DataSource</code>, получив экземпляр <code>DataSource</code> вызовом <code>Persistence.getDataSource()</code>. После этого нужно вызывать методы <code>query()</code> или <code>update()</code> без передачи какого-либо <code>Connection</code>, оно будет создано из указанного <code>DataSource</code> и затем сразу закрыто.</para>
        </listitem>
      </itemizedlist> </para>
  </section>
  <section>
    <title>Интеграция с MyBatis</title>
    <para>В состав платформы включен фреймворк <ulink url="http://www.mybatis.org">MyBatis</ulink>, обладающий, по сравнению с <link linkend="nativeQuery">ORM</link> и <link linkend="queryRunner">QueryRunner</link>,  более  широкими возможностями по выполнению SQL и отображению результатов на объекты предметной области.</para>
    <para>Для использование MyBatis в проекте необходимо добавить следующие бины в файл <filename>
        <link linkend="spring.xml">spring.xml</link>
      </filename> модуля <structname>core</structname>:<programlisting language="xml">&lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;
  &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;
  &lt;property name=&quot;configLocation&quot; value=&quot;cuba-mybatis.xml&quot;/&gt;
  &lt;property name=&quot;mapperLocations&quot; value=&quot;classpath*:com/sample/sales/core/sqlmap/*.xml&quot;/&gt;
&lt;/bean&gt;

&lt;bean id=&quot;sqlSession&quot; class=&quot;org.mybatis.spring.SqlSessionTemplate&quot;&gt;
  &lt;constructor-arg index=&quot;0&quot; ref=&quot;sqlSessionFactory&quot; /&gt;
&lt;/bean&gt;</programlisting></para>
    <para>В параметре <code>mapperLocations</code> задается путь (по правилам интерфейса <code>ResourceLoader</code> <application>Spring</application>)  к файлам отображений <application>MyBatis</application>. </para>
    <para>Пример файла отображения для загрузки экземпляра сущности <code>Заказ</code> вместе со связанным <code>Покупателем</code> и коллекцией <code>Пунктов заказа</code>:<programlisting language="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper
      PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
      &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;mapper namespace=&quot;com.sample.sales&quot;&gt;

  &lt;select id=&quot;selectOrder&quot; resultMap=&quot;orderResultMap&quot;&gt;
      select
          o.ID as order_id,
          o.DATE as order_date,
          o.AMOUNT as order_amount,
          c.ID as customer_id,
          c.NAME as customer_name,
          c.EMAIL as customer_email,
          i.ID as item_id,
          i.QUANTITY as item_quantity,
          p.ID as product_id,
          p.NAME as product_name
      from
          SALES_ORDER o
          left join SALES_CUSTOMER c on c.ID = o.CUSTOMER_ID
          left join SALES_ITEM i on i.ORDER_ID = o.id and i.DELETE_TS is null
          left join SALES_PRODUCT p on p.ID = i.PRODUCT_ID
      where
          c.id = #{id}
  &lt;/select&gt;

  &lt;resultMap id=&quot;orderResultMap&quot; type=&quot;com.sample.sales.entity.Order&quot;&gt;
      &lt;id property=&quot;id&quot; column=&quot;order_id&quot;/&gt;
      &lt;result property=&quot;date&quot; column=&quot;order_date&quot;/&gt;
      &lt;result property=&quot;amount&quot; column=&quot;order_amount&quot;/&gt;

      &lt;association property=&quot;customer&quot; column=&quot;customer_id&quot; javaType=&quot;com.sample.sales.entity.Customer&quot;&gt;
          &lt;id property=&quot;id&quot; column=&quot;customer_id&quot;/&gt;
          &lt;result property=&quot;name&quot; column=&quot;customer_name&quot;/&gt;
          &lt;result property=&quot;email&quot; column=&quot;customer_email&quot;/&gt;
      &lt;/association&gt;

      &lt;collection property=&quot;items&quot; ofType=&quot;com.sample.sales.entity.Item&quot;&gt;
          &lt;id property=&quot;id&quot; column=&quot;item_id&quot;/&gt;
          &lt;result property=&quot;quantity&quot; column=&quot;item_quantity&quot;/&gt;
          &lt;association property=&quot;product&quot; column=&quot;product_id&quot; javaType=&quot;com.sample.sales.entity.Product&quot;&gt;
              &lt;id property=&quot;id&quot; column=&quot;product_id&quot;/&gt;
              &lt;result property=&quot;name&quot; column=&quot;product_name&quot;/&gt;
          &lt;/association&gt;
      &lt;/collection&gt;
  &lt;/resultMap&gt;

&lt;/mapper&gt;</programlisting></para>
    <para>Для получения результатов запроса в приведенном выше примере можно использовать следующий код:<programlisting language="java">Transaction tx = persistence.createTransaction();
try {
  SqlSession sqlSession = AppBeans.get(&quot;sqlSession&quot;);
  Order order = (Order) sqlSession.selectOne(&quot;com.sample.sales.selectOrder&quot;, orderId);
  tx.commit();
} finally {
  tx.end();
}</programlisting></para>
    <tip>
      <para>Объекты, загруженные с помощью <application>MyBatis</application>, можно изменять и передавать в <code>EntityManager.merge()</code> для сохранения в базе данных. При этом в апдейт будут включены только не-<code>null</code> атрибуты, то есть если атрибут не был загружен, или специально установлен в значение <code>null</code>, соответствующее поле в БД не будет изменено.</para>
      <para>Такое поведение определяется параметром ORM <code>openjpa.DetachState=loaded</code>, установленным по умолчанию.</para>
    </tip>
  </section>
  <section id="folders_pane">
    <title>Панель папок</title>
    <para>Панель папок предназначена для быстрого доступа пользователя к часто используемой информации. Она представляет собой скрываемую панель в левой части главного окна приложения, в которой располагается иерархическая структура, нажатие на элементы которой (папки) приводит к отображению соответствующих экранов системы с определенными параметрами.</para>
    <para>На момент написания данного руководства панель папок реализована  только для <link linkend="app_tiers">
        <structname>Web Client</structname>
      </link>. </para>
    <para>Платформа поддерживает три вида папок: <firstterm>папки приложения</firstterm>, <firstterm>папки поиска</firstterm> и <firstterm>наборы</firstterm> записей. Папки приложения отображаются в верхней части панели в отдельной иерархии, папки поиска и наборы - в нижней части панели в совместной иерархии. <itemizedlist>
        <listitem>
          <para id="application_folder">Папки приложения:<itemizedlist>
              <listitem>
                <para>Открывают  экраны с <link linkend="gui_Filter">фильтром</link> или без него.</para>
              </listitem>
              <listitem>
                <para>Набор папок может зависеть от текущего сеанса пользователя. Видимость конкретной папки определяется путем выполнения скрипта Groovy.</para>
              </listitem>
              <listitem>
                <para>Пользователь может создавать или изменять папки приложения, только если у него есть специальное право.</para>
              </listitem>
              <listitem>
                <para>В заголовке папки может отображаться текущее количество входящих в папку записей, вычисляемое скриптом Groovy. </para>
              </listitem>
              <listitem>
                <para>Заголовки папок приложения обновляются по таймеру, тем самым может изменяться счетчик записей и стиль отображения каждой папки.</para>
              </listitem>
            </itemizedlist></para>
        </listitem>
        <listitem>
          <para id="search_folder">Папки поиска:<itemizedlist>
              <listitem>
                <para>Открывают экраны с <link linkend="gui_Filter">фильтром</link>. </para>
              </listitem>
              <listitem>
                <para>Могут быть как локальными - доступными только пользователю, их создавшему, так и глобальными - доступными всем пользователям.</para>
              </listitem>
              <listitem>
                <para>Локальные папки может создавать и изменять любой пользователь, глобальные - только имеющий специальное право.</para>
              </listitem>
            </itemizedlist></para>
        </listitem>
        <listitem>
          <para>Наборы: <itemizedlist>
              <listitem>
                <para>Открывают экраны с <link linkend="gui_Filter">фильтром</link>, содержащим условие отбора отдельных записей по их идентификаторам.</para>
              </listitem>
              <listitem>
                <para>Содержимое набора редактируется с помощью специальных <link linkend="gui_Action">действий</link> таблицы: <guibutton>Добавить в набор</guibutton>, <guibutton>Удалить из набора</guibutton>.</para>
              </listitem>
              <listitem>
                <para>Наборы локальны, то есть доступны только создавшему их пользователю.</para>
              </listitem>
            </itemizedlist></para>
        </listitem>
      </itemizedlist></para>
    <para>На функционирование панели папок влияют следующие свойства приложения:<itemizedlist>
        <listitem>
          <para><link linkend="cuba.web.foldersPaneEnabled">
              <property>cuba.web.foldersPaneEnabled</property>
            </link></para>
        </listitem>
        <listitem>
          <para><link linkend="cuba.web.foldersPaneVisibleByDefault">
              <property>cuba.web.foldersPaneVisibleByDefault</property>
            </link></para>
        </listitem>
        <listitem>
          <para><link linkend="cuba.web.foldersPaneDefaultWidth">
              <property>cuba.web.foldersPaneDefaultWidth</property>
            </link></para>
        </listitem>
        <listitem>
          <para><link linkend="cuba.web.appFoldersRefreshPeriodSec">
              <property>cuba.web.appFoldersRefreshPeriodSec</property>
            </link></para>
        </listitem>
        <listitem>
          <para><link linkend="cuba.web.showFolderIcons">
              <property>cuba.web.showFolderIcons</property>
            </link></para>
        </listitem>
      </itemizedlist></para>
    <section>
      <title>Папки приложения</title>
      <para>Для создания папок приложения пользователь должен иметь специфическое право <guilabel>Создание/изменение папок приложения</guilabel> (код <literal>cuba.gui.appFolder.global</literal>).</para>
      <para>Простейшая папка приложения может быть создана из контекстного меню панели папок. Такая папка не связана с экранами системы и предназначена только для группировки других папок в иерархии.</para>
      <para>Для создания папки, открывающей некоторый экран с фильтром, необходимо выполнить следующее:<itemizedlist>
          <listitem>
            <para>Открыть экран и отобрать записи по нужному фильтру.</para>
          </listitem>
          <listitem>
            <para>В меню кнопки <guibutton>Фильтр...</guibutton> выбрать команду <guimenuitem>Сохранить как папку приложения</guimenuitem>.</para>
          </listitem>
          <listitem>
            <para>В окне добавления заполнить атрибуты папки:<itemizedlist>
                <listitem>
                  <para>Наименование папки</para>
                </listitem>
                <listitem>
                  <para>Заголовок окна - строка, добавляемая к заголовку окна, когда он открывается из папки</para>
                </listitem>
                <listitem>
                  <para>Родительская папка - определяет место создаваемой папки в иерархии</para>
                </listitem>
                <listitem>
                  <para>Скрипт видимости - скрипт Groovy, выполняемый в начале сеанса пользователя, и определяющий доступность для него данной папки. </para>
                  <para>Скрипт должен вернуть булевское значение. Если скрипт не задан, либо возвращает null, папка доступна. Пример:<programlisting>userSession.currentOrSubstitutedUser.login == &apos;admin&apos;</programlisting></para>
                </listitem>
                <listitem>
                  <para>Cкрипт количества - скрипт Groovy, выполняемый в начале сеанса пользователя и по таймеру, для вычисления количества записей для данной папки и ее стиля отображения.</para>
                  <para>Скрипт должен вернуть числовое значение, целая часть которого будет использована в качестве счетчика. Если скрипт не задан, либо возвращает <code>null</code>, счетчик не будет отображаться. Кроме возвращаемого значения скрипт может установить переменную <code>style</code>, которая будет использована как имя стиля отображения папки. Пример:<programlisting language="java">import com.haulmont.cuba.core.EntityManager
import com.haulmont.cuba.core.Query

EntityManager em = persistence.getEntityManager()
Query q = em.createQuery(&apos;select count(o) from sales$Order o&apos;)
Number count = q.getSingleResult()

style = count &gt; 0 ? &apos;emphasized&apos; : null
return count</programlisting></para>
                  <para>Для отображения указанного скриптом стиля тема приложения должна содержать описание этого стиля для элемента  <code>v-tree-node</code> внутри  <code>folderspane</code>, например:<programlisting language="css">.folderspane .v-tree-node.emphasized {
  font-weight: bold;
}</programlisting></para>
                </listitem>
              </itemizedlist></para>
          </listitem>
        </itemizedlist></para>
      <para>В скриптах доступны следующие переменные, установленные в контексте <code>groovy.lang.Binding</code>:<itemizedlist>
          <listitem>
            <para><code>folder</code>  - экземпляр сущности <code>AppFolder</code> - папка, для которой выполняется скрипт</para>
          </listitem>
          <listitem>
            <para><code>userSession</code> - экземпляр <code>UserSession</code> - текущая <link linkend="userSession">пользовательская сессия</link> </para>
          </listitem>
          <listitem>
            <para><code>persistence</code> - реализация интерфейса <link linkend="persistence">
                <code>Persistence</code>
              </link></para>
          </listitem>
          <listitem>
            <para><code>metadata</code> - реализация интерфейса <link linkend="metadata">
                <code>Metadata</code>
              </link></para>
          </listitem>
        </itemizedlist>При обновлении папок для всех скриптов используется один экземпляр <code>groovy.lang.Binding</code>, поэтому между ними можно передавать переменные для исключения дублирующихся запросов и повышения производительности. </para>
      <para>Тексты скриптов могут содержаться либо непосредственно в атрибутах сущности <code>AppFolder</code>, либо в отдельных файлах. В последнем случае атрибут должен содержать путь к файлу скрипта (обязательно с расширением &quot;.groovy&quot;) по правилам интерфейса <code>
          <link linkend="resources">Resources</link>
        </code>. Таким образом, если содержимое атрибута представляет собой строку, заканчивающуюся на &quot;.groovy&quot;, текст скрипта загружается из указанного файла, в противном случае в качестве скрипта используется само содержимое атрибута.</para>
      <para>Папки приложения представляют собой экземпляры сущности <code>AppFolder</code> и хранятся в связанных таблицах <database>SYS_FOLDER</database> и <database>SYS_APP_FOLDER</database>.</para>
    </section>
    <section>
      <title>Папки поиска</title>
      <para>Папки поиска создаются пользователями аналогично папкам приложения - группирующие папки непосредственно из контекстного меню панели папок, связанные с экранами - из меню кнопки <guibutton>Фильтр...</guibutton> экрана командой <guimenuitem>Сохранить как папку поиска</guimenuitem>.</para>
      <para>Для создания глобальной папки пользователь должен иметь специфическое право <guilabel>Создание/изменение глобальных папок поиска</guilabel> (код <literal>cuba.gui.searchFolder.global</literal>). </para>
      <para>Фильтр папки поиска можно изменить после ее создания - для этого достаточно открыть папку и  в экране изменить фильтр <guilabel>Папка: {имя папки}</guilabel>. После сохранения фильтра он будет изменен и в папке тоже.</para>
      <para>Папки поиска  представляют собой экземпляры сущности <code>SearchFolder</code> и хранятся в связанных таблицах <database>SYS_FOLDER</database> и <database>SEC_SEARCH_FOLDER</database>.</para>
    </section>
    <section>
      <title>Наборы</title>
      <para>Использование наборов в экране возможно, если для компонента <code>
          <link linkend="gui_Filter">Filter</link>
        </code> в атрибуте <sgmltag>applyTo</sgmltag> указан соответствующий компонент <code>
          <link linkend="gui_Table">Table</link>
        </code>. Например:<programlisting language="xml">&lt;layout&gt;
  &lt;filter id=&quot;customerFilter&quot;
          datasource=&quot;customersDs&quot;
          applyTo=&quot;customersTable&quot;/&gt;

  &lt;groupTable id=&quot;customersTable&quot;
              width=&quot;100%&quot;&gt;
      &lt;buttonsPanel&gt;
          &lt;button action=&quot;customersTable.create&quot;/&gt;
...
      &lt;/buttonsPanel&gt;
...</programlisting></para>
      <para>При этом в контекстном меню таблицы появятся команды <guibutton>Добавить в набор</guibutton> или <guibutton>Добавить в тек. набор</guibutton> / <guibutton>Удалить из набора</guibutton>. Если таблица содержит внутри себя компонент <sgmltag>buttonsPanel</sgmltag> (как в приведенном выше примере), команды контекстного меню будут продублированы соответствующими кнопками.</para>
      <para>Наборы  представляют собой экземпляры сущности <code>SearchFolder</code> и хранятся в связанных таблицах <database>SYS_FOLDER</database> и <database>SEC_SEARCH_FOLDER</database>.</para>
    </section>
  </section>
  <section id="link_to_screen">
    <title>Ссылки на экраны</title>
    <para>Блок <link linkend="app_tiers">
        <structname>Web Client</structname>
      </link> позволяет открывать экраны приложения по команде, переданной в URL. Причем если в данный момент в браузере нет сессии приложения с зарегистрированным пользователем, то сначала будет отображено окно логина, и сразу после успешной регистрации - главное окно приложения с требуемым экраном.</para>
    <para>Набор возможных команд указывается в свойстве приложения <property>
        <link linkend="cuba.web.linkHandlerActions">cuba.web.linkHandlerActions</link>
      </property>, по умолчанию это команды  <code>open</code> и <code>o</code>.  При обработке HTTP запроса анализируется последняя часть URL, и если она совпадает с одной из команд, управление передается бину <code>LinkHandler</code>. Стандартная реализация этого бина позволяет указывать следующие параметры:<itemizedlist>
        <listitem>
          <para><code>screen</code> - имя экрана, указанное в <filename>
              <link linkend="screens.xml">screens.xml</link>
            </filename>, например:<programlisting>http://localhost:8080/app/open?screen=sec$User.browse</programlisting></para>
        </listitem>
        <listitem>
          <para><code>item</code> - экземпляр сущности для передачи в <link linkend="screen_edit">экран редактирования</link>, закодированный по правилам класса <code>EntityLoadInfo</code>, т.е. <code>entityName-instanceId</code> или <code>entityName-instanceId-viewName</code>. Для открытия экрана создания нового экземпляра сущности в данном параметре нужно передать строку вида <code>NEW-entityName</code>. Примеры:<programlisting>http://localhost:8080/app/open?screen=sec$User.edit&amp;item=sec$User-60885987-1b61-4247-94c7-dff348347f93

http://localhost:8080/app/open?screen=sec$User.edit&amp;item=sec$User-60885987-1b61-4247-94c7-dff348347f93-user.edit

http://localhost:8080/app/open?screen=sec$User.edit&amp;item=NEW-sec$User</programlisting></para>
        </listitem>
        <listitem>
          <para><code>params</code> - параметры экрана, передаваемые в метод <code>init()</code> <link linkend="screen_controller">контроллера</link>. Параметры кодируются в виде <code>name1:value1,name2:value2</code>. Значениями параметров могут быть экземпляры сущностей, в свою очередь закодированные по правилам класса <code>EntityLoadInfo</code>. Примеры:<programlisting>http://localhost:8080/app/open?screen=sales$Customer.lookup&amp;params=p1:v1,p2:v2

http://localhost:8080/app/open?screen=sales$Customer.lookup&amp;params=p1:sales$Customer-01e37691-1a9b-11de-b900-da881aea47a6</programlisting></para>
        </listitem>
      </itemizedlist></para>
    <para>Бин <code>LinkHandler</code> может быть переопределен в проекте приложения для обеспечения специфической
      обработки ссылок. <code>LinkHandler</code> является прототипом, поэтому обязательно укажите атрибут <code>scope</code>
      при определении вашего бина в <link linkend="spring.xml">spring.xml</link>, например:
    <programlisting language="xml"><![CDATA[
<!-- web-spring.xml -->
<bean id="cuba_LinkHandler" class="com.company.sample.web.MyLinkHandler" scope="prototype"/>]]></programlisting></para>
  </section>
  <section>
    <title>Инспектор сущностей</title>
    <para>Инспектор сущностей позволяет работать с любыми объектами предметной области без создания специфических экранов. Инспектор динамически генерирует экраны просмотра списка и редактирования экземпляра выбранной сущности.</para>
    <para>Это дает возможность администратору системы просматривать и редактировать данные, которые недоступны в стандартных экранах в силу их дизайна, а  на этапе прототипирования создать только модель данных и пункты главного меню, ссылающиеся на инспектор сущностей.</para>
    <para>Точкой входа в инспектор является экран <filename>com/haulmont/cuba/gui/app/core/entityinspector/entity-inspector-browse.xml</filename>. </para>
    <para>Если в экран передан параметр <code>entity</code> типа <code>String</code> с именем сущности, то инспектор отобразит список экземпляров этой сущности с возможностью фильтрации, выбора и редактирования экземпляров. Параметр может быть указан при регистрации экрана в <link linkend="screens.xml">
        <filename>screens.xml</filename>
      </link>, например:</para>
    <para><filename>screens.xml</filename><programlisting language="xml">&lt;screen id=&quot;sales$Product.lookup&quot;
      template=&quot;/com/haulmont/cuba/gui/app/core/entityinspector/entity-inspector-browse.xml&quot;&gt;
  &lt;param name=&quot;entity&quot;
         value=&quot;sales$Product&quot;/&gt;
&lt;/screen&gt;</programlisting></para>
    <para><filename>menu.xml</filename><programlisting language="xml">&lt;item id=&quot;sales$Product.lookup&quot;/&gt;</programlisting></para>
    <para>Идентификатор экрана вида <code>{имя_сущности}.lookup</code>  дает возможность использовать этот экран компонентам <code>
        <link linkend="gui_PickerField">PickerField</link>
      </code> и <code>
        <link linkend="gui_LookupPickerField">LookupPickerField</link>
      </code> в стандартном действии <code>PickerField.LookupAction</code>.</para>
    <para>В общем случае данный экран можно вызывать без передачи параметров, тогда в его верхней части отображается поле для выбора сущности. В базовом проекте <structname>cuba</structname> экран инспектора зарегистрирован с идентификатором <code>entityInspector.browse</code>, поэтому для его вызова достаточно наличия пункта меню:<programlisting language="xml">&lt;item id=&quot;entityInspector.browse&quot;/&gt;</programlisting></para>
  </section>
  <section id="credits">
    <title>Информация об используемом ПО</title>
    <para>Платформа предоставляет средства для регистрации и отображения в пользовательском интерфейсе информации об используемом в приложении стороннем программном обеспечении (credits). Информация включает в себя название, ссылку на веб-сайт и текст лицензии.</para>
    <para><link linkend="base_projects">Базовые проекты</link> платформы содержат собственные файлы описаний <filename>cuba-credits.xml</filename>, <filename>reports-credits.xml</filename> и т.д. В проекте приложения можно создать аналогичный файл и в свойстве приложения <property>
        <link linkend="cuba.creditsConfig">cuba.creditsConfig</link>
      </property> определить список файлов описаний в зависимости от используемых базовых проектов.</para>
    <para>Структура файла <filename>credits.xml</filename>: <itemizedlist>
        <listitem>
          <para>Элемент <sgmltag>items</sgmltag> - перечисление используемых библиотек с указанием текста лицензии либо во вложенном элементе <sgmltag>license</sgmltag>, либо атрибутом <sgmltag>license</sgmltag> со ссылкой на текст в секции <sgmltag>licenses</sgmltag>.</para>
          <para>Cсылаться можно на лицензии, объявленные не только в этом же файле, но и в любом другом файле, объявленном в переменной <property>cuba.creditsConfig</property> раньше, чем текущий. </para>
        </listitem>
        <listitem>
          <para>Элемент <sgmltag>licenses</sgmltag> - перечисление текстов общеупотребительных лицензий.</para>
        </listitem>
      </itemizedlist></para>
    <para>Для отображения общего списка используемого ПО  предназначен фрейм <filename>com/haulmont/cuba/gui/app/core/credits/credits-frame.xml</filename>, загружающий информацию из файлов, заданных в свойстве <property>cuba.creditsConfig</property>. Пример использования фрейма в экране:<programlisting language="xml">&lt;layout expand=&quot;creditsBox&quot;&gt;
  &lt;groupBox id=&quot;creditsBox&quot;
            caption=&quot;msg://credits&quot;
            width=&quot;100%&quot;&gt;
      &lt;iframe id=&quot;credits&quot;
              src=&quot;/com/haulmont/cuba/gui/app/core/credits/credits-frame.xml&quot;
              width=&quot;100%&quot;
              height=&quot;100%&quot;/&gt;
  &lt;/groupBox&gt;
&lt;/layout&gt;</programlisting></para>
    <para>Если экран с фреймом открывается в модальном режиме (<code>WindowManager.OpenType.DIALOG</code>), ему необходимо задать высоту, иначе возможна неправильная работа скроллинга. Это можно сделать, например, в контроллере экрана, выводящего фрейм: <programlisting language="java">@Override
public void init(Map&lt;String, Object&gt; params) {
  getDialogParams().setWidth(500).setHeight(400);
}</programlisting></para>
  </section>
</section>
