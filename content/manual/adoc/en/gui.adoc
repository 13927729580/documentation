[[gui_framework]]
=== Generic User Interface

Generic user interface (Generic UI, GUI) subsystem allows you to create UI screens using XML and Java. The screens created using this approach work identically in both standard client <<app_tiers,blocks>>: Web Client and Desktop Client. 

.The Structure of Generic User Interface 
image::ClientStructure.png[align="center"]

Main components of Generic UI screens are marked as green:

* <<screen_xml,XML-descriptors>> – XML files containing information about datasources and screen layout.
* <<screen_controller,Controllers>> – Java classes containing logic for screen initialization and handling of events generated by UI controls.

The code of application screens included in the *gui* <<app_modules,module>> interacts with visual component interfaces (VCL Interfaces) implemented separately in the *web* and *desktop* modules of the *cuba* <<base_projects,base project>>. For Web Client the implementation is based on the *Vaadin* framework, for Desktop Client on the *Java Swing* framework.

<<gui_vcl,Visual Components Library>> (VCL)contains a large set of ready-to-use components.

<<datasources,Datasources>> mechanism provides a unified interface that ensures functioning of data-aware visual components.

Client's infrastructure (Infrastructure) includes main application window, mechanisms for display and interaction of UI screens and means of interaction with the middleware.

[[screens]]
==== Screens

A generic UI screen is defined by an <<screen_xml,XML-descriptor>> and a <<screen_controller,controller>> class. The descriptor has a link to the controller class.

In order to be able to invoke the screen from the main menu or from Java code (e.g. from controller of a different screen) the XML-descriptor should be registered in the project's <<screens.xml,screens.xml>> file.

The main menu of an application is generated separately for the Web Client and the Desktop Client based on the <<menu.xml,menu.xml>> files, located in the project's *web* and *desktop* modules.

[[screen_types]]
===== Screen Types

This section describes the following basic types of screens:

* <<frame,Frame>>
* <<screen_simple,Simple Screen>>
* <<screen_lookup,Lookup Screen>>
* <<screen_edit,Edit Screen>>

[[frame]]
====== Frame

Frames are parts of the screen intended for decomposition and reuse.

The <<gui_Frame,frame>> element of the screen's XML is used to add a frame to the screen. It defines either path to the frame's XML descriptor, or its identifier, if the frame is registered in <<screens.xml,screens.xml>>.

A frame controller should be derived from the `AbstractFrame` class.

Rules for interaction between a screen and its enclosed frame are the following:

* Frame components can be referenced from a screen using a dot: `++frame_id.component_id++`

* List of screen components can be obtained from a frame controller by invoking `++getComponent(component_id)++` method but only if there is no component with the same name in the frame itself. I.e. frame components mask screen components.

* Screen <<datasources,datasource>> can be obtained from a frame by invoking `++getDsContext().get(ds_id)++` method or <<screen_controller_injection,injection>>, or using `++ds$ds_id++` in <<datasource_query,query>>, but only if the data source with a matching name is not declared in the frame itself (same as for components).

* From a screen, frame data source can be obtained only by iterating `getDsContext().getChildren()` collection.

Screen commit also causes commits of modified datasources of the frame it uses.

[[screen_simple]]
====== Simple Screen

Simple screens enable displaying and editing of arbitrary information including individual instances and lists of entities. This screen type has only core functionality to display it in the application's main window, close it and to work with <<datasources,datasources>>.

Screen identifier in <<screens.xml,screens.xml>> may have an arbitrary format.

The controller of a simple screen should be inherited from the `AbstractWindow` class.

[[screen_lookup]]
====== Lookup Screen

When a lookup screen is invoked by `openLookup()` method, it displays a panel at the bottom with the buttons designed to pass an instance of the currently selected entity to the calling code. That is the main difference between lookup and simple screen. When being invoked by `openWindow()` method or, for example, from the main menu, the panel with the buttons is not displayed.

Lookup screens are recommended to be used to display lists of entities. Visual components intended to display and edit links between entities (such as <<gui_PickerField,PickerField>>, <<gui_LookupPickerField,LookupPickerField>>, <<gui_SearchPickerField,SearchPickerField>>) invoke lookup screens to find related entities.

For <<standard_actions,standard actions>> to work correctly, an identifier of a lookup screen in <<screens.xml,screens.xml>> should have the format of `++{entity_name}.lookup++`, for example, `sales$Customer.lookup`.

The controller of a lookup screen should be inherited from the `AbstractLookup` class. The `lookupComponent` attribute of the screen's XML should refer to the component (for example <<gui_Table,Table>>), from which the selected entity instance should be taken as a result of the lookup.

[[screen_edit]]
====== Edit Screen

Edit screen is designed to display and edit entity instances. It initializes the instance being edited and supports <<gui_Action,actions>> for committing changes to the database. Edit screen should be opened by the `openEditor()` method passing an entity instance as an argument.

For <<standard_actions,standard actions>> to work correctly, an identifier of an edit screen in<<screens.xml,screens.xml>> should have the format of `++{entity_name}.edit++`, for example, `sales$Customer.edit`.

Edit screen controller should be inherited from the `AbstractEditor` class. The `datasource` attribute of a screen's XML should refer to a data source containing the edited entity instance. The following standard button frames in the XML can be used to display actions that commit or cancel changes:

* `editWindowActions` (file `com/haulmont/cuba/gui/edit-window.actions.xml`) – contains *OK* and *Cancel* buttons

* `extendedEditWindowActions` (file `com/haulmont/cuba/gui/extended-edit-window.actions.xml`) – contains *OK & Close*, *OK* and *Cancel*

The following actions are implicitly initialized in the edit screen:

* `windowCommitAndClose` (corresponds to the `++Window.Editor.WINDOW_COMMIT_AND_CLOSE++` constant) – an action committing changes to the database and closing the screen. The action is initialized if the screen has a visual component with `windowCommitAndClose` identifier. The action is displayed as an *OK & Close* button when the mentioned above standard `extendedEditWindowActions` frame is used.

* `windowCommit` (corresponds to the `++Window.Editor.WINDOW_COMMIT++` constant) – an action which commits changes to the database. In absence of `windowCommitAndClose` action, closes the screen after committing. The action is always displayed as an *OK* button if the screen has the abovementioned standard frames.

* `windowClose` (corresponds to the `++Window.Editor.WINDOW_CLOSE++` constant) – which closes the screen without committing any changes. The action is always initialized. If the screen has the abovementioned standard frames, it is displayed as *Cancel* button.

Thus, if the screen contains an `editWindowActions` frame, the *OK* button commits the changes and closes the screen, and the *Cancel* button – closes the screen without committing the changes. If the screen contains an `extendedEditWindowActions` frame, the *OK* button only commits the changes, *OK & Close* button commits the changes and closes the screen, and the *Cancel* button closes the screen without committing the changes.

Instead of standard frames actions can be visualized using arbitrary components, for example, <<gui_LinkButton,LinkButton>>. 

[[screen_xml]]
===== XML-Descriptor

XML-descriptor is a file in XML format describing <<datasources,datasources>> and screen layout.

XML schema is available at {xsd_url}/window.xsd.

Descriptor has the following structure:

`window` − root element.

`window` attributes:

* `class` − name of a <<screen_controller,controller>> class.

* `messagesPack` − a default <<message_packs,message pack>> for the screen. It is used to obtain localized messages in the controller using `getMessage()` method and in the XML descriptor using message key without specifying the pack.

* `caption` − window caption, can contain a <<messageTools.loadString,link to a message>> from the above mentioned pack, for example, 
+
[source, properties]
----
caption="msg://credits"
----

* `focusComponent` − identifier of a component which should get input focus when the screen is displayed.

* `lookupComponent` – mandatory attribute for a <<screen_lookup,lookup screen>>; defines the identifier of a visual component that the entity instance should be selected from. Supports the following types of components (and their subclasses):

** `Table`

** `Tree`

** `LookupField`

** `PickerField`

** `OptionsGroup`

* `datasource` – mandatory attribute for an <<screen_edit,edit screen>> which defines the identifier of the <<datasources,data source>> containing the edited entity instance.

`window` elements:

* `metadataContext` − the element initializing the <<views,views>> required for the screen. It is recommended to define all views in a single <<views.xml,views.xml>> file, because all view descriptors are deployed into a common repository, so it is difficult to ensure unique names if the descriptors are scattered across multiple files.

* `dsContext` − defines <<datasources,data source>> for the screen.

* `actions` – defines the list of <<gui_Action,actions>> for the screen.

* `timers` – defines the list of timers for the screen.

* `companions` – defines the list of <<companions,companion>> classes for the screen controller.
+
--
Elements of `companions`:

** `web` – defines a companion implemented in the *web* module.

** `desktop` – defines a companion implemented in the *desktop* module.

Each of these elements contains `class` attribute defining the companion class.
--

* `layout` − root element of the screen layout, a container with a vertical layout of components, similar to <<gui_BoxLayout,vbox>>.
+
Attributes of `layout`:

** <<gui_attr_basic_spacing,spacing>>

** <<gui_attr_basic_margin,margin>>

** <<gui_attr_basic_expand,expand>>

** <<gui_attr_basic_stylename,stylename>>

** <<gui_attr_basic_height,height>>

** <<gui_attr_basic_width,width>>

[[screen_controller]]
===== Screen Controller

Screen controller is a Java or Groovy class, linked to an <<screen_xml,XML-descriptor>> and containing screen initialization and events handling logic.

Controller should be inherited from one of the following base classes:

* <<``,AbstractFrame>> − for implementation of <<frame,frames>>.

* <<abstractWindow,AbstractWindow>> − for implementation of <<screen_simple,simple screens>>.

* <<abstractLookup,AbstractLookup>> − for implementation of <<screen_lookup,lookup screens>>.

* <<abstractEditor,AbstractEditor>> − for implementation of <<screen_edit,edit screens>>.

[TIP]
====
If a screen does not need additional logic, it can use the base class itself as a controller – `AbstractWindow`, `AbstractLookup` or `AbstractEditor`, by specifying it in the XML-descriptor (these classes are not actually abstract in a sense of impossibility of instantiating). For frames, controller class can be omitted.
====

Controller class should be registered in `class` attribute of the root element `window` in a screen's XML descriptor.

.Controller Base Classes
image::Controllers.png[align="center"]

[[abstractFrame]]
====== AbstractFrame

`AbstractFrame` is the root of the controller class hierarchy. Below is the description of its main methods:

* `init()` is called by the framework after creating components tree described by an XML-descriptor, but before a screen is displayed.
+
init() method accepts a map of parameters that can be used in controller. These parameters can be passed both from the controller of the calling screen (using `openWindow()`, `openLookup() `or `openEditor()` methods) or defined in the screen registration file <<screens.xml,screens.xml>>.
+
`init()` method should be implemented if it is necessary to initialize screen components, for example: 
+
[source, java]
----
include::{sourcesdir}/gui/abstractframe_1.java[]
---- 

* `getMessage()`, `formatMessage()` – methods for retrieving localized messages from a <<message_packs,pack>>, defined for a screen in the XML-descriptor. They work as shortcuts for calling the corresponding methods of the <<messages,Messages>> interface.

* `getDialogParams()` – returns a `DialogParams` object to set up dialog window display properties (height, width, etc.). The values defined in this object affect the next screen opened as a modal dialog (`WindowManager.OpenType.DIALOG`). The settings are reset to defaults after the dialog has been displayed.
+
Thus, the properties of `DialogParams` object should be set immediately before opening another modal screen using `openWindow()`, `openLookup()`, `openEditor()`. For example: 
+
[source, java]
----
include::{sourcesdir}/gui/abstractframe_2.java[]
---- 
+
If the current screen itself is modal it is possible to adjust its display properties by changing `DialogParams` object in its `init()` method. Please note that the properties defined in `init()` method have priority over the ones defined in the calling code.

* `openFrame()` – loads a frame according to an identifier registered in <<screens.xml,screens.xml>> file. If the method receives a container component from the invoking code, the frame is shown within the container. The method returns frame controller. For example: 
+
[source, java]
----
include::{sourcesdir}/gui/abstractframe_3.java[]
---- 
+
It is not required to pass the container immediately via `openFrame()` method, instead it is possible to load the frame first and then add it to the necessary container: 
+
[source, java]
----
include::{sourcesdir}/gui/abstractframe_4.java[]
---- 

* `openWindow()`, `openLookup()`, `openEditor()` – open a simple screen, a lookup screen, or an edit screen respectively. Methods return a controller of the created screen.
+
`CloseListener` can be added in order to perform actions after the invoked screen closes, for example: 
+
[source, java]
----
include::{sourcesdir}/gui/abstractframe_5.java[]
---- 

* `showMessageDialog()` – shows a dialog box with a message.

* `showOptionDialog()` – shows a dialog box with a message and an option for user to invoke certain actions. Actions are defined by an array of <<gui_Action,Action>> type items displayed as buttons in the dialog.
+
It is recommended to use `DialogAction` objects for display of standard buttons such as *OK*, *Cancel* and other, for example:
+
[source, java]
----
include::{sourcesdir}/gui/abstractframe_6.java[]
---- 

* `showNotification()` – shows a pop up notification.

* `showWebPage()` – opens specified web page in a browser.

[[abstractWindow]]
====== AbstractWindow

`AbstractWindow` is a subclass of <<abstractFrame,AbstractFrame>> and defines the following methods:

* `ready()` - a template method that can be implemented in controller to intercept the moment of screen opening. It is invoked when the screen is fully initialized and opened.

* `validateAll()` – validates a screen. The default implementation calls `validate()` for all screen components implementing the `Component.Validatable` interface, collects information about exceptions and displays corresponding message. Method returns `false`, if any exceptions were found; and `true` otherwise.
+
This method should be overridden only if it is required to override screen validation procedure completely. It is sufficient to implement a special template method – `postValidate()`, if validation should be just supplemented.

* `postValidate()` – a template method that can be implemented in controller for additional screen validation. The method stores validation errors information in `ValidationErrors` object which is passed to it. Afterwards this information is displayed together with the errors of standard validation. For example: 
+
[source, java]
----
include::{sourcesdir}/gui/abstractwindow_1.java[]
---- 

* `close()` – closes this screen. 
+
The method accepts string value, which is then passed to `preClose()` template method and to `CloseListener` listeners. Thus, the information about the reason why the window was closed can be obtained from the code that initiated the closing event. It is recommended to use the following constants for closing edit screens: `++Window.COMMIT_ACTION_ID++` after committing changes, `++Window.CLOSE_ACTION_ID++` – without committing changes.
+
If any of the datasources contains unsaved changes, a dialog with a corresponding message will be displayed before the screen is closed. Notification type may be adjusted using the <<cuba.gui.useSaveConfirmation,cuba.gui.useSaveConfirmation>> application property.
+
A variant of `close()` method with `force = true` parameter closes the screen without calling `preClose()` and without a notification regardless of any unsaved changes.
+
`close()` method returns `true`, if the screen is closed successfully, and `false` – if closing procedure was interrupted.

* `preClose()` is a template method which can be implemented in a controller to intercept the moment when the window closes. The method receives a string value provided by the closing initiator when invoking `close()` method.
+
If the `preClose()` method returns `false`, the window closing process is interrupted.

[[abstractLookup]]
====== AbstractLookup

`AbstractLookup` is the base class for <<screen_lookup,lookup screen>> controllers. It is a subclass of <<abstractWindow,AbstractWindow>> and defines the following own methods:

* `setLookupComponent()` – sets the component, which will be used to select entity instances.
+
As a rule, component for selection is defined in screen XML-descriptor and there is no need to call this method in the application code.

* `setLookupValidator()` – sets `Window.Lookup.Validator` object to the screen, which `validate()` method is invoked by the framework before returning selected entity instances. If `validate()` method returns `false`, the lookup and window closing process is interrupted.
+
By default, the validator is not set.

[[abstractEditor]]
====== AbstractEditor

`AbstractEditor` is the base class for <<screen_edit,edit screen>> controller. It is a subclass of <<abstractWindow,AbstractWindow>>.

When creating a controller class, it is recommended to parameterize `AbstractEditor` with the edited entity class. This enables `getItem()` and `initItem()` methods work with the specified entity type and application code does not need to do additional type conversion. For example: 

[source, java]
----
include::{sourcesdir}/gui/abstracteditor_1.java[]
---- 

`AbstractEditor` defines the following own methods:

* `getItem()` – returns an instance of the entity being edited, which is set in the main <<datasources,data source>> of the screen (i.e. specified in the `datasource` attribute of the root element of the XML-descriptor).
+
If the instance being edited is not a new one, screen opening procedure will reload the instance from the database with the required <<views,view>> as set for the main data source.
+
Changes made to the instance returned by `getItem()`, are reflected in the state of the data source and will be sent to the Middleware at commit.
+
[WARNING]
====
It should be considered that `getItem()` returns a value only after screen is initialized with `setItem()` method. Until this moment, this method returns `null`, for instance when calling from inside `init()` or `initItem()`. 

However, in the `init()` method, an instance of an entity passed to `openEditor()` can be retrieved from parameters using the following approach: 

[source, java]
----
include::{sourcesdir}/gui/abstracteditor_2.java[]
---- 

`initItem()` method requires an instance to be passed explicitly and of an appropriate type.

In both cases the obtained entity instance will be reloaded afterwards unless it is a new one. Therefore you should not change it or save it in a field for future use.
====

* `setItem()` – invoked by the framework when a window is opened using `openEditor()` to set the instance being edited to the main data source. By the moment of invocation all screen components and datasources will have been created and the controller's `init()` method will have been executed.
+
It is recommended to use template methods `initNewItem()` and `postInit()`, instead of overriding `setItem()` in order to initialize a screen. 

* `initNewItem()` – a template method invoked by the framework before setting the edited entity instance into the main data source. 
+
The `initNewItem()` method is called for newly created entity instances only. The method is not called for <<entity_states,detached>> instances. This method can be implemented in the controller, if new entity instances must be initialized before setting them in the data source. For example: 
+
[source, java]
----
include::{sourcesdir}/gui/abstracteditor_3.java[]
---- 
+
A more complex example of using the `initNewItem()` method can be found in <<dev_recipes,development recipes>> section. 

* `postInit()` – a template method invoked by the framework immediately after the edited entity instance is set to the main data source. In this method, `getItem()` can be called to return a new entity instance or an instance re-loaded during screen initialization.
+
This method can be implemented in controller for final screen initialization, for example: 
+
[source, java]
----
include::{sourcesdir}/gui/abstracteditor_4.java[]
---- 

* `commit()` – validates the screen and submits changes to the Middleware via <<dataSupplier,DataSupplier>>.
+
If a method is used with `validate = false`, commit does not perform a validation.
+
It is recommended to use specialized template methods – `postValidate()`, `preCommit()` and `postCommit()` instead of overriding this method.

* `commitAndClose()` – validates the screen, submits changes to the Middleware and closes the screen. The value of the `++Window.COMMIT_ACTION_ID++` will be passed to the `preClose()` method and registered `CloseListener` listeners. 
+
It is recommended to use specialized template methods – `postValidate()`, `preCommit()` and `postCommit()` instead of overriding this method.

* `preCommit()` – a template method invoked by the framework during the commit process, after a successful validation, but before the data is submitted to the Middleware.
+
This method can be implemented in controller. If the method returns `false`, commit process gets interrupted, as well as window closing process (if `commitAndClose()` was invoked). For example: 
+
[source, java]
----
include::{sourcesdir}/gui/abstracteditor_5.java[]
---- 

* `postCommit()` – a template method invoked by the framework at the final stage of committing changes. Method parameters are:

** `committed` – set to `true`, if the screen had changes and they have been submitted to Middleware.

** `close` – set to `true`, if the screen should be closed after the changes are committed.
+
If the screen does not close the default implementation of this method displays a message about successful commit and invokes `postInit()`.
+
This method can be overridden in controller in order to perform additional actions after successful commit, for example: 
+
[source, java]
----
include::{sourcesdir}/gui/abstracteditor_6.java[]
---- 

The diagrams below show initialization sequence and different ways to commit changes for an edit screen.

.Edit Screen Initialization
image::EditorInit.png[align="center"]

.Committing And Closing a Window With an editWindowActions Frame
image::EditorCommit.png[align="center"]

.Committing a Screen With an extendedEditWindowActions Frame
image::ExtendedEditorCommit.png[align="center"]

.Committing a Screen With an extendedEditWindowActions Frame
image::ExtendedEditorCommitAndClose.png[align="center"]

[[screen_controller_injection]]
====== Controller Dependency Injection

Dependency Injection in controllers can be used to acquire references to utilized objects. For this purpose it is required to declare either a field of the corresponding type or a write access method (setter) with an appropriate parameter type and with one of the following annotations:

* `@Inject` – the simplest option, where an object for injection will be found according to the field/method type and the name of the field or attribute corresponding to the method according to JavaBeans rules.

* `@Named("someName")` – explicitly defines the name of the target object.

The following objects can be injected into controllers: 

* This screen's visual components defined in the XML-descriptor. If the attribute type is derived from `Component`, the system will search for a component with the corresponding name within the current screen. 

* Actions defined in the XML-descriptor – see <<gui_Action>>.

* <<datasources,Datasources>> defined in the XML-descriptor. If the attribute type is derived from `Datasource`, the system will search for a data source with the corresponding name in the current screen.

* `UserSession`. If the attribute type is <<userSession,UserSession>>, the system will inject an object of the current user session.

* `DsContext`. If the attribute type is `DsContext`, the system will inject the `DsContext` of the current screen.

* `WindowContext`. If the attribute type is `WindowContext`, the system will inject the `WindowContext` of the current screen. 

* `DataSupplier`. If the attribute type is <<dataSupplier,DataSupplier>>, the corresponding instance will be injected.

* Any bean defined in the context of a given client block, including:

**  Middleware <<services,services>> imported by Client

** `ComponentsFactory`

** `WindowConfig`

** `ExportDisplay`

** <<background_tasks,BackgroundWorker>>

* If nothing of the mentioned above is appropriate and the controller has <<companions,companions>>, a companion for the current client type will be injected, if the types match. 
+
It is possible to inject the parameters passed in the map to the `init()` method into the controller using special annotation `@WindowParam`. The annotation has a `name` attribute which contains the parameter name (a key in the map) and an optional required attribute. If `required = true` and the map does not contain the corresponding parameter a `WARNING` message is added to the log.An example of an injection of a Job-type object passed to the controller's `init()` method: 
+
[source, java]
----
include::{sourcesdir}/gui/cdi_1.java[]
---- 

[[companions]]
====== Controller Companions

Controller base classes are located in the *gui *<<app_modules,module>> of the *cuba* <<base_projects,base project>> and do not contain references to implementation of visual component classes (*Swing* or *Vaadin*). This allows you to use them in both types of clients. Instead, base controller classes implement an additional interface – `Window.Wrapper` – and delegate execution to the wrapped window.

At the same time concrete controller classes may be contained in *gui*, *web* or *desktop* modules, depending on screen specifics and client client <<app_tiers,blocks>> used in the project. If controller is universal and additional functionality is required for different client types it can be implemented in so-called _companion classes_.

Companion class is located in client module of the corresponding client type (web or desktop) and implements an interface defined in the controller which uses the companion class. A companion class should be defined in the `companions` element of the screen XML-descriptor. Controller can retrieve a reference to the companion instance using injection or by invoking `getCompanion()`, and then pass control to the companion instance when appropriate, e.g. for extended initialization of visual components in a way specific to a given client type.

include::gui_vcl.adoc[]

[[datasources]]
==== Datasources

Datasources provide work of data-aware components.

Visual components themselves do not access *Middleware* and get entity instances from related datasources. Furthermore, one data source can work with multiple visual components if they need the same instance or set of instances.

* When the user changes the value in the component, the new value is set for the entity attribute in the data source

* When the entity attribute is modified in the code, the new value is set and displayed in the visual component 

* User input can be monitored both by the <<datasource_listeners,datasource listener>> and the value listener of the component – they are fired sequentially. 

* To read or write the value of an attribute in the application code, it is recommended to use the data source, rather than the component. Below is an example of reading the attribute: 
+
[source, java]
----
include::{sourcesdir}/gui/datasources_1.java[]
---- 
+
As can be seen, working entity attribute values through the component requires type casting and, in case of the <<gui_FieldGroup,FieldGroup>>, specifying the attribute name as a string. At the same time, if the instance is obtained from the datasource via the `getItem()` method, the values of attributes can be read and modified directly. 

[WARNING]
====
Typically, the visual component is bound to the attribute that directly belongs to the entity in the data source. In the example above, the component is bound to the `customer` attribute of the `Order` entity. 

A component can be associated with an attribute of a related entity, for example, `customer.name`. In this case, the component will display the value of the name attribute, however when the user changes the value, the datasource listeners will not be invoked and the changes will not be saved. Therefore, it makes sense to bind the component to second-order entity attributes only if they are intended for display. For example in a <<gui_Label,Label>>, a <<gui_Table,Table>> column, or in a <<gui_TextField,TextField>>, where `editable = false`.
====

datasources also track changes in entities contained therein and can send modified instances back to *Middleware* for storing in a database.

The basic sources of interfaces are described below.

.Data source interfaces
image::Datasources.png[align="center"]

* `Datasource` is a simple data source designed to work with one entity instance. The instance is set by the `setItem()` method and is accessed via `getItem()`. 
+
`DatasourceImpl` class is the standard implementation of such source, which is used, for instance, as a main data source on entity <<screen_edit,edit screens>>.

* `CollectionDatasource` is a data source designed to work with a collection of entity instances. The collection is loaded with the invocation of the `refresh()` method, instance keys are accessible through the `getItemIds()` method. The `setItem()` method sets the "current" instance of the collection and `getItem()` returns it, i.e., for example, the one that corresponds to the currently selected table row.
+
The way to load collections is determined by implementation. The most typical one is loading from Middleware via <<dataManager,DataManager>>; in this case, `setQuery()`, `setQueryFilter()` are used to form a JPQL query.
+
`CollectionDatasourceImpl` class is the standard implementation of such sources, which is used on screens with entity lists.

** `GroupDatasource` is a subtype of `CollectionDatasource`, designed to work with the <<gui_GroupTable,GroupTable>> component.
+
Standard implementation is the `GroupDatasourceImpl` class.

** `HierarchicalDatasource` is a subtype of `CollectionDatasource`, designed to work with the <<gui_Tree,Tree>> and <<gui_TreeTable,TreeTable>> components.
+
Standard implementation is the `HierarchicalDatasourceImpl` class.

* `NestedDatasource` is a data source designed to work with instances that are loaded in an attribute of another entity. In this case, a source that contains a parent entity is accessible via `getMaster()`, and <<metaProperty,meta property>> that corresponds to the parent attribute containing instances of this source is accessible via `getProperty()`.
+
For example an entity instance `Order` which contains a reference to the `Customer` instance is set in the `dsOrder` source. Then, to link the `Customer` instance with visual components, it is enough to create `NestedDatasource` with `dsOrder as parent` and meta property to point to the `Order.customer` attribute.

** `PropertyDatasource` is a subtype of `NestedDatasource`, designed to work with one instance or collection of related entities that are not embedded.
+
Standard implementations: for working with one instance – `PropertyDatasourceImpl`, with a collection – `CollectionPropertyDatasourceImpl`, `GroupPropertyDatasourceImpl`, `HierarchicalPropertyDatasourceImpl`. The latter also implement the `CollectionDatasource` interface, however some of its irrelevant methods associated with loading like `setQuery()` throw `UnsupportedOperationException`.

** `EmbeddedDatasource` is a subtype of `NestedDatasource`, which contains an instance of an embedded entity.
+
Standard implementation is the `EmbeddedDatasourceImpl class`.

* `RuntimePropsDatasource` is a specific source, designed to work with <<dynamic_attributes,dynamic attributes>> of entities.

Typically, datasources are declared in the `dsContext` section of a <<screen_xml,screen descriptor>>.

===== Creating Datasources

Data source objects can be created both declaratively, using an XML screen descriptor, and programmatically in a controller. Typically, standard implementation of sources is used, however, you can create your own class that is inherited from a standard one, if necessary.

====== Declarative Creation

Typically, datasources are declared in the `dsContext` element of a screen descriptor. Depending on the relative position of declaration elements, sources of two varieties are created:

* if an element is located directly in `dsContext`, a normal `Datasource` or `CollectionDatasource`, which contains an independently loaded entity or collection, is created;

* if an element is located inside an element of another source, `NestedDatasource` is created and the external source becomes its parent.

Below is an example of declaring a data source: 

[source, xml]
----
include::{sourcesdir}/gui/datasources_2.xml[]
---- 

In the example above, `carDs` contains one entity instance, `Car`, and nested `allocationsDs` and `repairsDs` contain collections of related entities from the `Car.driverAllocations` and `Car.repairs` attributes, respectively. The `Car` instance together with related entities is set into the data source from the outside. If this screen is an <<screen_edit,edit screen>>, it happens automatically when opening the screen. The `colorsDs` data source contains a collection of instances of the `Color` entity, which is loaded by the source itself using the specified JPQL <<datasource_query,query>> with the _local <<views,view>>.

Below is the XML scheme. 

`dsContext` – root element.

`dsContext` elements:

* `datasource` – defines a data source that contains a single entity instance.
+
Attributes:

** `id` – source identifier, must be unique for this `DsContext`.

** `class` – Java class of an entity that will be contained in this source.

** `view` – name of entity <<views,view>>. If the source itself loads instances, then this view will be used during loading. Otherwise, this view makes signals to external mechanisms on how to load an entity for this source.

** `allowCommit` – if set to `false`, the `isModified()` method of this source always returns `false` and the `commit()` method does nothing. Thus, changes in entities that are contained in the source are ignored. By default, it is set to `true`, i.e., changes are traced and can be saved.

** `datasourceClass` is a custom class of data source implementation, if necessary.

* `collectionDatasource` – defines a data source that contains a collection of instances.
+
--
`collectionDatasource` attributes:

** `refreshMode` – a source update mode, default is `ALWAYS`. In the `NEVER` mode, when `refresh()` method is invoked, the source does not load data and only changes its state to `Datasource.State.VALID`, notifies listeners and sorts available instances. The `NEVER` mode is useful if you need to programmatically fill `CollectionDatasource` with preloaded or created entities. For example: 
+
[source, java]
----
include::{sourcesdir}/gui/datasources_3.java[]
---- 

** `softDeletion` – the false value disables the <<soft_deletion,soft deletion>> mode when loading entities, i.e., deleted instances will also be loaded. Default value is `true`.

`collectionDatasource` elements:

** `query` – query to load entities
--

* `groupDatasource` – completely similar to `collectionDatasource`, but creates data source implementation that is suitable to use in conjunction with the <<gui_GroupTable,GroupTable>> component.

* `hierarchicalDatasource` – similar to `collectionDatasource`, and creates data source implementation that is suitable to use in conjunction with the <<gui_Tree,Tree>> and <<gui_TreeTable,TreeTable>> components.
+
`hierarchyProperty` is a specific attribute. It specifies an attribute name, upon which a hierarchy is built.

A source implementation class is selected implicitly based on the name of the XML element and, as mentioned above, the mutual arrangement of elements. However, if you need to apply a custom data source, you can explicitly specify its class in the `datasourceClass` attribute.

====== Programmatic Creation

If you need to create a data source in the Java code, it is recommended to use a special class, `DsBuilder`.

The `DsBuilder` instance is parameterized by an invocation chain of its methods in the fluent interface style. If the `master` and `property` parameters are set, then `NestedDatasource` will be created, otherwise – `Datasource` or `CollectionDatasource`.

Example: 

[source, java]
----
include::{sourcesdir}/gui/datasources_4.java[]
---- 

====== Proper Implementation Classes

Typically, custom implementation of a data source is required to change the loading process of a collection of entities. When creating a class of this source it should be inherited from `CollectionDatasourceImpl`, or from `GroupDatasourceImpl`, or `HierarchicalDatasourceImpl`, and the `loadData()` method should be overridden.

Example: 

[source, java]
----
include::{sourcesdir}/gui/datasources_5.java[]
---- 

In the example above, `data` is a base class field that stores a collection of loaded instances. The base class methods, `detachListener()` and `attachListener()`, control the assignment of a listener to loaded entities. The listener notifies the data source on changes in instance fields.

To create a custom data source declaratively, a class in the `datasourceClass` attribute of an XML element should be specified. In case of programmatic creation via `DsBuilder`, a source class is specified by invoking `setDsClass()`.

[[datasource_query]]
===== CollectionDatasourceImpl Queries

The `CollectionDatasourceImpl` class and its inheritors, `GroupDatasourceImpl`, `HierarchicalDatasourceImpl` are standard implementation of datasources that work with collections of independent entity instances. These sources load data via `DataManager` by sending a JPQL query to *Middleware*. The format of these queries is described below.

[[datasource_query_results]]
====== Returned values

A query should return entities of the type which is specified at the moment of creating a data source. In case of declarative creation, the entity type is specified in the `class` attribute of an XML element, if `DsBuilder` is used – in the `setJavaClass()` or `setMetaClass()` method.

Furthermore, the object type in the `from` query statement should match the source type. This is necessary for automatic query transformations if security limitations, etc. are applied.

For example, a query of the data source of the `Customer` type may look as follows:

[source, plain]
----
select c from sales$Customer c
----

Below are examples of invalid queries for a source of the `Customer` type:

[source, plain]
----
select c.id, c.name from sales$Customer c /* invalid – returns single fields, not the whole Customer object */

select o.customer from sales$Order o /* invalid – the 'from' type (Order) is different from the resulting type  (Customer) */
----

[[datasource_query_params]]
====== Query Parameters

A JPQL query in a data source may contain parameters of several types. A parameter type is determined by a prefix of a parameter name. A prefix is a part of the name before the $ character. The interpretation of the name after $ is described below.

* The `ds` prefix
+
The parameter value is data from another data source that is registered in the same `DsContext`. For example: 
+
[source, xml]
----
include::{sourcesdir}/gui/datasources_6.xml[]
---- 
+
In the example above, a query parameter of the `ordersDs` data source will be a current entity instance located in the `customersDs` data source.
+
If parameters with the `ds` prefix are used, dependencies between datasources are created automatically. They lead to updating the source if its parameter are changed. In the example above, if the selected Customer is changed, the list of its Orders is changed automatically. 
+
Please note that in the example of the parameterized query, the left part of the comparison operator is the value of the `o.customer.id` identifier, and the right part – the `Customer` instance that is contained in the `customersDs` source. This comparison is valid since when running a query at *Middleware*, the implementation of the <<query,Query>> interface, by assigning values to query parameters, automatically adds entity ID instead of a passed entity instance.
+
A path through the entity graph to an attribute (from which the value should be used) can be specified in the parameter name after the prefix and name of a source, for example: 
+
[source, xml]
----
include::{sourcesdir}/gui/datasources_7.xml[]
---- 
+
or 
+
[source, xml]
----
include::{sourcesdir}/gui/datasources_8.xml[]
---- 

* The `custom` prefix. 
+
A parameter value will be taken from the `Map<String, Object>` object that is passed into the `refresh()` method of a data source. For example:
+
[source, xml]
----
include::{sourcesdir}/gui/datasources_9.xml[]
----
+
[source, java]
----
include::{sourcesdir}/gui/datasources_10.java[]
---- 
+
Bringing an instance to its identifier, if necessary, is performed similarly to parameters with the `ds` prefix. The path through the entity graph in the parameter name is not supported in this case.

* The `param` prefix.
+
A parameter value is taken from the `Map<String, Object>` object that is passed into the `init()` method of a <<screen_controller,controller>>.
+
Bringing an instance to its identifier, if necessary, is performed similarly to parameters with the `ds` prefix. The path through the entity graph in the parameter name is supported in this case. 

* The `component` prefix.
+
A parameter value will be a current value of a visual component, which path is specified in the parameter name. For example: 
+
[source, xml]
----
include::{sourcesdir}/gui/datasources_11.xml[]
---- 
+
The path to a component should include all nested <<frame,frames>>.
+
Bringing an instance to its identifier, if necessary, is similar to `ds` parameters. The path through the entity graph in the parameter name is supported as the continuation of the path to a component in this case. 

* The `session` prefix. 
+
--
A parameter value will be a value of the <<userSession,user session>> attribute specified in the parameter name.

The value is extracted by the `UserSession.getAttribute()` method, so predefined names of session attributes are also supported. 

** `userId` – ID of the currently registered or substituted user;

** `userLogin` – login of the currently registered or substituted user in lowercase.

Example: 

[source, xml]
----
include::{sourcesdir}/gui/datasources_12.xml[]
---- 

Bringing an instance to its identifier, if necessary, is similar to `ds` parameters. In this case, the path through the entity graph in the parameter name is not supported.
--

[[datasource_query_filter]]
====== Query Filter

A data source query can be modified during the work of the application, depending on conditions entered by the user. This allows you to efficiently filter data at the level of selection from DB.

The easiest way to provide such ability is to connect a special visual component, <<gui_Filter,Filter>>, to a data source.

If by any reason the use of a universal filter is unwanted, a special XML markup can be embedded into a query text. This will allow to create a resulting query based on values entered by the user into any visual components of the screen.

In this filter the following elements can be used:

* `filter` – a root element of the filter. It can directly contain only one condition.

** `and`, `or` – logical conditions, may contain any number of other conditions and statements. 

** `c` – JPQL statement, which is added into the `where` section. It contains only the text and an optional `join` attribute, which value will be added into a corresponding place of the query. 

Conditions and statements are added into the resulting query only if parameters inside contain values, i.e., they are not `null`.

Example: 

[source, xml]
----
include::{sourcesdir}/gui/datasources_13.xml[]
---- 

In this case, if `state` and `initiator` parameters are passed into the `refresh()` method of a data source, and a visual component, `barCodeFilterField`, has some value specified, then the resulting query will be as follows:

[source, jpql]
----
select distinct d from app$GeneralDoc d, app$DocRole dr
where
(
  (dr.doc.id = d.id and d.processState = :custom$state)
  and
  (d.barCode like :component$barCodeFilterField)
)
or
(dr.doc.id = d.id and dr.user.id = :custom$initiator)
----

If, for example, the `barCodeFilterField` component is empty and only one parameter, initiator, was passed into the `refresh()` method, the query will be as follows:

[source, jpql]
----
select distinct d from app$GeneralDoc d, app$DocRole dr
where
(dr.doc.id = d.id and dr.user.id = :custom$initiator)
----

[WARNING]
====
Do not use <<datasource_query_params_ds,ds-parameters>> in query filters. They are intended for linking datasources and treated in a special way. 
====

[[datasource_query_case_insensitive]]
====== Case-Insensitive Search for a Substring

It is possible to use a special feature of JPQL queries execution in datasources, described for the <<query,Query>> interface of the *Middleware* level: for easy creation of case-insensitive search condition of any substring, `(?i)` prefix can be used. However, due to the fact that the query value is usually passed implicitly, the following differences take place:

* The `(?i)` prefix should be specified before a parameter name and not inside the value.

* The parameter value will be automatically converted to lowercase.

* If the parameter value does not have `%` characters, they will be added to the beginning and the end.

Below is an example of how to process the following query:

[source, jpql]
----
select c from sales$Customer c where c.name like :(?i)component$customerNameField
----

In this case, the parameter value taken from the `customerNameField` component will be converted to lowercase and will be framed with `%` characters, and then an SQL query with a `lower(C.NAME) like ?` condition will be executed in the database.

Please note that with this search, an index created in the DB by the `NAME` field, will not be used. 

[[datasource_listeners]]
===== Datasource Listeners

<<datasources,Datasource>> listeners receive notifications of changes in the state of datasources and entities contained in them.

There are four types of listeners. Three of them: `ItemPropertyChangeListener`, `ItemChangeListener` and `StateChangeListener` are defined in the `Datasource` interface and can be used in any datasource. `CollectionChangeListener` is defined in `CollectionDatasource` and can be used only in datasources working with collections of entities.

Example of using datasource listeners:

[source, java]
----
include::{sourcesdir}/gui/datasources_14.java[]
----

The listener interfaces are described below.

* `ItemPropertyChangeListener` is added by the `Datasource.addItemPropertyChangeListener()` method. The listener is invoked when an attribute of an entity contained in the datasource is changed. The modified entity instance itself, the name of changed attribute, old and new values can be obtained from the event object passed to the listener.
+
The `ItemPropertyChangeListener` can be used to react to changes made in an entity instance by UI components, i.e. when a user edits input fields.

* `ItemChangeListener` is added by the `Datasource.addItemChangeListener()` method. The listener is invoked when a selected entity instance returned by the `Datasource.getItem()` method is changed.
+
For `Datasource`, it happens when another instance (or `null`) is set to the datasource with `setItem()` method.
+
For `CollectionDatasource`, this listener is invoked when a selected element is changed in a linked visual component. For example, it may be a selected table row, tree element or item in a drop-down list.

* `StateChangeListener` is added by the `Datasource.addStateChangeListener()` method. The listener is invoked when a state of the datasource is changed. The data source can be in one of three states corresponding to the `Datasource.State` enumeration:
+
--
** `++NOT_INITIALIZED++` – datasource has just been created.

** `INVALID` – the whole <<dsContext,DsContext>>, which this source is related to, is created.

** `VALID` – datasource is ready: `Datasource` contains an entity instance or null, `CollectionDatasource` – collection of instances or an empty collection.

Receiving a notification about changes in datasource state may be important for complex <<screen_edit,editors>>, which consist of several <<frame,frames>> where it is difficult to trace the moment of setting an edited entity into the datasource. In this case, `StateChangeListener` can be used for the delayed initialization of certain screen elements:

[source, java]
----
include::{sourcesdir}/gui/datasources_17.java[]
---- 
--

* `CollectionChangeListener` is added by the `CollectionDatasource.addCollectionChangeListener()` method. The listener is invoked when a entity collection, which is stored in the datasource, is changed. The event object provides the `getOperation()` method returning value of type `CollectionDatasource.Operation`: `REFRESH`, `CLEAR`, `ADD`, `REMOVE`, `UPDATE`. It indicates the operation that caused the collection changes.

[[dsContext]]
===== DsContext

All datasources that are created declaratively are registered in the `DsContext` object which belongs to a screen. A reference to `DsContext` can be obtained using the `getDsContext()` method of a screen controller or via <<screen_controller_injection>>.

`DsContext` is designed for the following tasks:

. Organizes dependencies between datasources when navigation through a record set in one datasource (i.e. changing a "current" instance with the `setItem()` method) causes a related datasource to be updated. These dependencies allow you to organize master-detail relationships between visual components on screens.
+
Dependencies between datasources are organized using <<datasource_query,query parameters>> with the `ds$` prefix.

. Collects all changed entity instances and sends them to *Middleware* in a single invocation of `DataManager.commit()`, i.e. to save them into the database in a single transaction.
+
As an example, let's assume that some screen allows a user to edit an instance of the `Order` entity and a collection of `OrderLine` instances belonging to it. The `Order` instance is located in `Datasource`; the `OrderLine` collection – in nested `CollectionDatasource`, which is created using the `Order.lines` attribute. If user changes some attribute of `Order` and creates a new instance, `OrderLine`. Then, when a screen is committed to <<dataManager,DataManager>>, two instances – changed `Order` and new `OrderLine` – will be sent simultaneously. After that, they will together be merged into one <<entityManager,persistent context>> and saved into the database on the transaction commit. The `OrderLine` instance is also contained in the `Order.lines` collection, but if it's not passed into persistent context independently, the cascade merging between `Order` and `OrderLines` at the ORM level should be set. Tight cascade relations at the ORM level sometimes cause unwanted consequences in unexpected places, so it is better to avoid them, as described in the `DsContext` mechanism.
+
As a result of committing the transaction, `DsContext` receives a set of saved instances from *Middleware* (in the case of optimistic locking they, at least, have an increased value of the `version` attribute), and sets these instances in datasources replacing old ones. It allows you to work with the latest instances immediately after committing without an extra datasource refresh that produces queries to *Middleware* and the database.

. Declares two listeners: `BeforeCommitListener` and `AfterCommitListener`. They receive notifications before and after committing modified instances. `BeforeCommitListener` enables to supplement a collection of entities sent to <<dataManager,DataManager>> to save arbitrary entities in the same transaction. A collection of saved instances that are returned from `DataManager` can be obtained after commit in the `AfterCommitListener` listener.
+
This mechanism is required if some entities, with which a screen works, are not under control of datasources, but are created and changed directly in the controller code. For example, a visual component, <<gui_FileUploadField,FileUploadField>>, after uploading a file, creates a new entity instance, `FileDescriptor`, which can be saved together with other screen entities by adding to `CommitContext` in `BeforeCommitListener`.
+
In the following example, a new instance of `Customer` will be sent to Middleware and saved to the database together with other modified screen entities when the screen is committed:
+
[source, java]
----
include::{sourcesdir}/gui/dscontext_1.java[]
---- 

[[dataSupplier]]
===== DataSupplier

`DataSupplier` – interface, through which the datasources refer to Middleware for loading and saving entities. The standard implementation simply delegates to <<dataManager,DataManager>>. A screen can define its implementation of the `DataSupplier` in `dataSupplier` attribute of the `window` element. Such own implementation may, for example, call an additional middleware block for loading data for the screen from different database.

A reference to `DataSupplier` can be obtained either by injection into a screen controller or through the `DsContext` or `Datasource` instances. In both cases, an own implementation is returned if defined for the screen.

[[gui_Action]]
==== Actions. The Action Interface

`Action` is an interface that abstracts an action (in other words, some function) from a visual component. It is particularly useful when the same action can be invoked from different visual components ((for example, from button and table context menu). In addition, this interface allows you to provide the action with additional properties, such as name, flags of accessibility and visibility, etc.

Below are the `Action` interface methods:

* `actionPerform()` is invoked by a visual component associated with this action. An instance of the caller is passed to the method.

* `getId()` returns an identifier of the action. The identifier is usually set by a constructor of a class that implements `Action` and does not change throughout the lifecycle of the created action object.

* Methods for getting and setting `caption`, `description`, `shortcut`, `icon`, `enabled`, `visible` properties. Typically, all these properties are used by related visual components to set their own corresponding properties.

* `addPropertyChangeListener()`, `removePropertyChangeListener()` methods used to add and remove listeners which handle changes to the abovementioned properties. A listener receives notification of `java.beans.PropertyChangeEvent` type, which contains the name of the changed property, its old and new values.

* `refreshState()` - a method that can be implemented in a particular action class to initialize the abovementioned properties in accordance to some external factors, such as user rights. It is usually invoked in constructors of implementing classes or from related visual components.

* `addOwner()`, `removeOwner()`, `getOwner()`, `getOwners()` – methods used to control relation between the action and visual components.

It is recommended to implement actions using the <<declarative_actions,declarative creation>> or by inheriting from the <<baseAction,BaseAction>> class. Furthermore, there is a set of <<standard_actions,standard actions>> applicable for tables and picker components. You can also derive action classes from standard actions to modify their behavior or to intercept events.

Visual components associated with an action can be of two types:

* Visual component with a single action implements the `Component.ActionOwner` interface. These are <<gui_Button,Button>> and <<gui_LinkButton,LinkButton>>.
+
Action is linked to the component by the invocation of the `ActionOwner.setAction()` component method. At this point, the component replaces its properties with corresponding properties of the action (see components overview for details).

* Visual component containing several actions implements the `Component.ActionsHolder` interface. These are `Window`, `Frame`, <<gui_Table,Table>> and its inheritors, <<gui_Tree,Tree>>, <<gui_PopupButton,PopupButton>>, <<gui_PickerField,PickerField>>, <<gui_LookupPickerField,LookupPickerField>>.
+
The `ActionsHolder.addAction()` method is used to add actions to the component. Implementation of this method in the component checks whether it already contains an action with the same identifier. If yes, then the existing action will be replaced with the new one. Therefore, it is possible, for example, to declare a standard action in a screen descriptor and then create a new one in the controller with overridden methods and add it to the component.

[[declarative_actions]]
===== Declarative Creation of Actions

You can specify a set of <<gui_Action,actions>> in an XML screen descriptor for any component that implements the `Component.ActionsHolder` interface, including the entire screen or frame. This is done in the `actions` element, which contains nested `action` elements.

The `action` element can have the following attributes:

* `id` − identifier, which should be unique within the `ActionsHolder` component.

* `caption` – action name.

* `description` – action description.

* `enable` – accessibility flag (`true` / `false`).

* `icon` – action icon.

* `invoke` - name of the controller method to be invoked. The method should be `public` `void`, and either not have arguments or have one argument of the `Component` type. If the method has a `Component` argument, then an instance of the visual component that launches this action will be passed to it when invoked.

* `shortcut` - keyboard shortcut for invocation. Possible modifiers, `ALT`, `CTRL`, `SHIFT`, are separated by the "-" character. For example:ALT-CTRL-C.

* `visible` – visibility flag (`true` / `false`).

The examples of declaration are provided below.

* Declaring actions at the screen level: 
+
[source, xml]
----
include::{sourcesdir}/gui/actions_1.xml[]
----
+
[source, java]
----
include::{sourcesdir}/gui/actions_2.java[]
----
+
In the example above, an action with `sayHelloAction` identifier and a name from <<message_packs,message pack>> is declared. This action is bound with a button, which caption will be set to the action name. The action will invoke the `sayHello()` controller method when clicking on the button, or when pressing the ALT-T shortcut if at that moment the screen has input focus.

* Declaring actions for <<gui_PopupButton,PopupButton>>: 
+
[source, xml]
----
include::{sourcesdir}/gui/actions_3.xml[]
---- 

* Declaring actions for <<gui_Table,Table>>: 
+
[source, xml]
----
include::{sourcesdir}/gui/actions_4.xml[]
----
+
In this example `copy` and `changePassw` actions are declared in addition to `create` and `edit` standard actions of the table. These actions invoke corresponding methods of the controller. In addition, the `trackSelection="true"` attribute is specified for them, which means that the action and corresponding button become disabled if no row is selected in the table. It is useful if the action is intended to be executed over a currently selected table row.
+
An optional `openType` attribute can be specified for create and edit actions to define edit screen opening mode, as described for the `setOpenType()` method of the <<createAction,CreateAction>> class.

* Declaring <<gui_PickerField,PickerField>> actions: 
+
[source, xml]
----
include::{sourcesdir}/gui/actions_5.xml[]
----
+
In the example above, the standard `lookup` action and an additional `show` action invoking the `showColour()` method of the controller, are declared for the `PickerField` component. Since `PickerField` buttons that display actions use icons instead of captions, the caption attribute is explicitly set to an empty string, otherwise action name and button caption would be set to the action identifier. The `description` attribute allows you to display a tooltip when hovering over the action button.

You can obtain references to any declared actions in the screen controller either directly by <<screen_controller_injection,injection>>, or from components that implement the `Component.ActionsHolder` interface. This can be useful to set action properties programmatically. For example: 

[source, java]
----
include::{sourcesdir}/gui/actions_6.java[]
---- 

[[standard_actions]]
===== Standard Actions

Standard <<gui_Action,actions>> are classes that implement the `Action` interface and are intended to solve common tasks, such as invocation of an edit screen for an entity selected in a table. Standard actions have strictly defined identifiers; therefore, for the declaration of a standard action in XML, it is enough to specify its identifier.

There are two types of standard actions:

* <<list_actions,Actions over collections>> of entities that are displayed in tables or trees.

* <<picker_actions,Picker field actions>>.

[[list_actions]]
====== Standard Actions over Collection

For inheritors of `ListComponent` (<<gui_Table,Table>>, <<gui_GroupTable,GroupTable>>, <<gui_TreeTable,TreeTable>> and <<gui_Tree,Tree>>) the set of standard actions is defined in `ListActionType` enumeration; their implementation classes are located in `com.haulmont.cuba.gui.components.actions` package. 

The example of using standard actions in a table: 

[source, xml]
----
include::{sourcesdir}/gui/listActions_1.xml[]
---- 

These actions are described in details below.

[[createAction]]
*CreateAction*

`CreateAction` – action with *create* identifier. It is intended to create new entity instance and open its edit screen. If the edit screen successfully commits a new instance to the database, `CreateAction` adds this new instance to the table data source and makes it selected.

The following specific methods are defined in the `CreateAction` class: 

* `setOpenType()` allows you to specify new entity edit screen open mode. `++THIS_TAB++` by default. 
+
Since it is quite often required to open edit screens in another mode (typically, `DIALOG`), you can specify an `openType` attribute with desired value in the `action` element when using declarative creation of the `create` action. This eliminates the need to obtain action reference in the controller and set this property programmatically. For example: 
+
[source, xml]
----
include::{sourcesdir}/gui/createAction_1.xml[]
----

* `setWindowId()` allows you to specify the identifier of the entity edit screen. By default, `++{entity_name}.edit++` is used, for example `sales$Customer.edit`.

* `setWindowParams()` allows you to set edit screen parameters passed into its `init()` method.

* `setInitialValues()` allows you to set initial values of attributes of the entity being created. It takes a `Map` object, where keys are attribute names, and values are attribute values. For example: 
+
[source, java]
----
include::{sourcesdir}/gui/createAction_2.java[]
----
+
An example of `setInitialValues()` usage is also provided in the section of <<init_values_in_CreateAction,development recipes>>.

* `afterCommit()` is invoked by the action after the new entity has been successfully committed and the edit screen has been closed. This method does not have implementation and can be overridden in inheritors to handle this event.

* `setAfterCommitHandler()` allows you to provide a handler which will be called after the new entity has been successfully committed and the edit screen has been closed. This handler can be used instead of overriding `afterCommit()` to avoid creating the action subclass. For example: 
+
[source, java]
----
include::{sourcesdir}/gui/createAction_3.java[]
---- 

* `afterWindowClosed()` is the last method invoked by the action after closing the edit screen regardless of whether the new entity has been committed or not. This method does not have implementation and can be overridden in inheritors to handle this event.

* `setAfterWindowClosedHandler()` allows you to provide a handler which will be called after closing the edit screen regardless of whether the new entity has been committed or not. This handler can be used instead of overriding `afterWindowClosed()` to avoid creating the action subclass. 

[[editAction]]
*EditAction*

`EditAction` is an action with *edit* identifier, intended to open an edit screen for a selected entity instance. If the edit screen successfully commits the instance to the database, then `EditAction` updates this instance in the table data source.

The following specific methods are defined in the `EditAction` class: 

* `setOpenType()` allows you to specify entity edit screen open mode. `++THIS_TAB++` by default. 
+
Since it is quite often required to open edit screens in another mode (typically `DIALOG`), you can specify `openType` attribute with desired value in the `action` element when creating the action declaratively. This eliminates the need to obtain action reference in the controller and set this property programmatically. For example: 
+
[source, xml]
----
include::{sourcesdir}/gui/editAction_1.xml[]
---- 

* `setWindowId()` allows you to specify entity edit screen identifier. `++{entity_name}.edit++` is used by default, for example, `sales$Customer.edit`.

* `setWindowParams()` allows you to set edit screen parameters, passed to its `init()` method.

*  `afterCommit()` is invoked by the action after the entity has been successfully committed and the edit screen has been closed. This method does not have implementation and can be overridden in inheritors to handle this event. 

* `setAfterCommitHandler()` allows you to provide a handler which will be called after the new entity has been successfully committed and the edit screen has been closed. This handler can be used instead of overriding `afterCommit()` to avoid creating the action subclass. For example: 
+
[source, java]
----
include::{sourcesdir}/gui/editAction_2.java[]
---- 

*  `afterWindowClosed()` is the last method invoked by the action after closing the edit screen regardless of whether the edited entity has been committed or not. This method does not have implementation and can be overridden in inheritors to handle this event. 

* `setAfterWindowClosedHandler()` allows you to provide a handler which will be called after closing the edit screen regardless of whether the new entity has been committed or not. This handler can be used instead of overriding `afterWindowClosed()` to avoid creating the action subclass. 

[[removeAction]]
*RemoveAction*

`RemoveAction` - action with *remove* identifier, intended to remove a selected entity instance.

The following specific methods are defined in the `RemoveAction` class: 

* `setAutocommit()` allows you to control the moment of entity removal from the database. By default `commit()` method is invoked after triggering the action and removing the entity from the data source. As result, the entity is removed from the database. You can set `autocommit` property into false using `setAutocommit()` method or corresponding parameter of the constructor. In this case you will need to explicitly invoke the data source `commit()` method to confirm the removal after removing the entity from the data source.
+
The value of `autocommit` does not affect datasources in the `Datasource.CommitMode.PARENT` mode, i.e. the datasources that provide <<composition_annotation,composite>> entities editing.

* `setConfirmationMessage()` allows you to set message text for the removal confirmation dialog.

* `setConfirmationTitle()` allows you to set removal confirmation dialog title.

*  `afterRemove()` is invoked by the action after the entity has been successfully removed. This method does not have implementation and can be overridden. 

* `setAfterRemoveHandler()` allows you to provide a handler which will be called after the new entity has been successfully removed. This handler can be used instead of overriding `afterRemove()` to avoid creating the action subclass. For example: 
+
[source, java]
----
include::{sourcesdir}/gui/removeAction_1.java[]
----  

[[refreshAction]]
*RefreshAction*

`RefreshAction` - an action with *refresh* identifier. It is intended to update (reload) entities collection. When triggered, it invokes `refresh()` method of a <<datasources,data source>> associated with the corresponding component. 

The following specific methods are defined in the `RefreshAction` class:

* `setRefreshParams()` allows you to set parameters passed into the `CollectionDatasource.refresh()` method to be used in the <<datasource_query,query>>. By default, no parameters are passed.

[[addAction]]
*AddAction*

`AddAction` – action with *add* identifier, intended for selecting an existing entity instance and adding it to the collection. When triggered, opens entities <<screen_lookup,lookup screen>>.

The following specific methods are defined in the `AddAction` class:

* `setOpenType()` allows you to specify entity selection screen open mode. `++THIS_TAB++` by default.
+
Since it is often required to open the lookup screens in a different mode (usually `DIALOG`), the `openType` attribute can be specified in the action element, when creating the `add` action declaratively. This eliminates the need to get a reference to the action in the controller and set this property programmatically. For example:
+
[source, xml]
----
include::{sourcesdir}/gui/addaction_1.xml[]
----

* `setWindowId()` allows you to specify entity selection screen identifier. `++{entity_name}.lookup++` by default, for example, `sales$Customer.lookup`. If such screen does not exist, attempts to open `++{entity_name}.browse++` screen, for example, `sales$Customer.browse`.

* `setWindowParams()` allows you to set selection screen parameters, passed into its `init()` method.

* `setHandler()` allows you to set an object implementing `Window.Lookup.Handler` interface which will be passed to the selection screen. By default, `AddAction.DefaultHandler` object is used.

[[excludeAction]]
*ExcludeAction*

`ExcludeAction` - an action with *exclude* identifier. It allows a user to exclude entity instances from a collection without removing them from the database. The class of this action is an inheritor of `RemoveAction`, however, when triggered it invokes `excludeItem()` of `CollectionDatasource` instead of `removeItem()`. In addition, for an entity in a nested datasource, the `ExcludeAction` disconnects the link with the parent entity. Therefore this action can be used for editing one-to-many associations.

The following specific methods are defined in the `ExcludeAction` class in addition to `RemoveAction`:

* `setConfirm()` – flag to show the removal confirmation dialog. You can also set this property via the action constructor. By default it is set to `false`.

[[excelAction]]
*ExcelAction*

`ExcelAction` - an action with *excel* identifier, intended to export table data into XLS and download the resulting file. You can add this action only to <<gui_Table,Table>>, <<gui_GroupTable,GroupTable>> and <<gui_TreeTable,TreeTable>> components.

When creating the action programmatically, you can set the following constructor parameters:

* `display` – `ExportDisplay` interface implementation for file download. Standard implementation is used by default..

* `parameterized` - if set to true, the action shows a special window with `excelExport` identifier, which allows a user to choose table columns for export.

[[picker_actions]]
====== Standard Actions of the Picker Field

For <<gui_PickerField,PickerField>>, <<gui_LookupPickerField,LookupPickerField>> and <<gui_SearchPickerField,SearchPickerField>> components, a set of standard actions is defined in the `PickerField.ActionType` enumeration. Implementations are inner classes of the `PickerField` interface, which are described in details below. 

The example of standard actions usage in a picker component: 

[source, xml]
----
include::{sourcesdir}/gui/pickerActions_1.xml[]
---- 

[[lookupAction]]
*LookupAction*

`LookupAction` – action with *lookup* identifier, intended for selecting an entity instance and setting it as the component's value. When triggered, it opens an entities <<screen_lookup,lookup screen>>.

The following specific methods are defined in the `LookupAction` class:

* `setLookupScreenOpenType()` allows you to specify entity selection screen open mode. `++THIS_TAB++` by default.

* `setLookupScreenDialogParams()` allows you to set the window properties for a lookup screen that is opened in the `DIALOG` mode (see previous method). Other modes are not affected. 

* `setLookupScreen()` allows you to specify entity selection screen identifier. `++{entity_name}.lookup++` by default, for example, `sales$Customer.lookup`. If such screen does not exist, attempts to open `++{entity_name}.browse++` screen, for example, `sales$Customer.browse`.

* `setLookupScreenParams()` allows you to set selection screen parameters, passed into its `init()` method.

* `afterSelect()` is invoked by the action after the selected instance is set as the component's value. This method does not have implementation and can be overridden.

* `afterCloseLookup()` is the last method invoked by the action after closing the lookup screen regardless of whether an instance has been selected or not. This method does not have implementation and can be overridden.

[[clearAction]]
*ClearAction*

`ClearAction` - an action with *clear* identifier, intended for clearing (i.e. for setting to`null`) the value of the component. 

[[openAction]]
*OpenAction*

`OpenAction` - action with *open* identifier, intended for opening an edit screen for the entity instance which is the current value of the component.

The following specific methods are defined in the `OpenAction` class:

* `setEditScreenOpenType()` allows you to specify entity selection screen open mode. `++THIS_TAB++` by default.

* `setEditScreenDialogParams()` allows you to set the window properties for an edit screen that is opened in the `DIALOG` mode (see previous method). Other modes are not affected. 

* `setEditScreen()` allows you to specify entity edit screen identifier. `++{entity_name}.edit++` screen is used by default, for example, `sales$Customer.edit`. 

* `setEditScreenParams()` allows you to set edit screen parameters, passed to its `init()`method.

* `afterWindowClosed()` is invoked by the action after closing the edit screen. This method does not have implementation and can be overridden in inheritors to handle this event. 

[[baseAction]]
===== BaseAction

`BaseAction` is a base class for <<gui_Action,actions>> implementation. It is recommended to derive custom actions from it when <<declarative_actions,declarative actions creation>> functionality is insufficient.

When creating a custom action class, you should implement `actionPerform()` method and pass action identifier to the `BaseAction` constructor. You can override any property getters: `getCaption()`, `getDescription()`, `getIcon()`, `getShortcut()`, `isEnabled()`, `isVisible()`. Standard implementations of these methods return values set by setter methods, except the `getCaption()` method. If the action name is not explicitly set by `setCaption()` method, it retrieves message using action identifier as key from the the <<message_packs,localized message pack>> corresponding to the action class package. If there is no message with such key, then the key itself, i.e. the action identifier, is returned.

`BaseAction` can change its `enabled` and `visible` properties depending on user <<permissions,permissions>> and current context.

`BaseAction` is visible if the following conditions are met: 

* `setVisible(false)` method was not called;

* there is no `*hide*` UI permission for this action.

The action is enabled if the following conditions are met: 

* `setEnabled(false)` method was not called;

* there are no `*hide*` or read-only UI permissions for this action;

* `isPermitted()` method returns true;

* `isApplicable()` method returns true. 

Usage examples:

* <<gui_Button,Button>> action: 
+
[source, java]
----
include::{sourcesdir}/gui/baseAction_1.java[]
----
+
In this example, the `helloBtn` button caption will be set to the string located in the message pack with the `hello` key. You can override the `getCaption()` action method to initialize button name in a different way.

* Action of a programmatically created <<gui_PickerField,PickerField>>: 
+
[source, java]
----
include::{sourcesdir}/gui/baseAction_2.java[]
----
+
In this example an anonymous `BaseAction` derived class is used to set the action of the picker field button. The button caption is not displayed, as an icon with a description, which pops up when hovering mouse cursor, is used instead.

* <<gui_Table,Table>> action: 
+
[source, java]
----
include::{sourcesdir}/gui/baseAction_3.java[]
----
+
In this example, the `HelloAction` class is declared, and its instance is added to the table's actions list. The action is enabled for users who have `*myapp.allow-greeting*` security permission and only when a single table row is selected. The latter is possible because BaseAction's `target` property is automatically assigned to the action when it is added to a `ListComponent` descendant (`Table` or `Tree`).

* If you need an action, which becomes enabled when one or more table rows are selected, use BaseAction's descendant - `ItemTrackingAction`, which adds default implementation of `isApplicable()` method: 
+
[source, java]
----
include::{sourcesdir}/gui/baseAction_4.java[]
---- 

[[dialogs_and_notifications]]
==== Dialogs and Notifications

Dialogs and notifications can be used to display messages to users.

Dialogs have a title with a closing button and are always displayed in the center of the application main window. Notifications can be displayed both in the center and in the corner of the window, and can automatically disappear.

[[dialogs]]
===== Dialogs

Dialogs are invoked by `showMessageDialog()` and `showOptionDialog()` methods of the `Frame` interface. This interface is implemented by <<screen_controller,screen controller>>, so these methods can be invoked directly in the controller code.

* `showMessageDialog()` is intended to display a message. The method has the following parameters:
+
--
** `title` – dialog title.

** `message` - message. For HTML type (see below), you can use HTML tags for formatting the message. When using HTML, make sure you escape data loaded from the database to avoid code injection in web client. You can use `\n` characters for line breaks in non-HTML messages.

** `messageType` – message type. Possible types:

*** `CONFIRMATION`, `++CONFIRMATION_HTML++` – confirmation dialog. 

*** `WARNING`, `++WARNING_HTML++` – warning dialog.The difference in message types is reflected in desktop user interface only.

An example of showing a dialog: 

[source, java]
----
include::{sourcesdir}/gui/dialogs_1.java[]
---- 
--

* `showOptionDialog()` is intended to display a message and buttons for user actions. In addition to parameters described for `showMessageDialog()`, the method takes an array or a list of actions. A button is created for each dialog action. After a button is clicked, the dialog closes invoking `actionPerform()` method of the corresponding action.
+
It is convenient to use anonymous classes derived from `DialogAction` for buttons with standard names and icons. Five types of actions defined by the `DialogAction.Type` enum are supported: `OK`, `CANCEL`, `YES`, `NO`, `CLOSE`. Names of corresponding buttons are extracted from the <<main_message_pack,main message pack>>.
+
Below is an example of a dialog invocation with `Yes` and `No` buttons and with a caption and messages taken from the message pack of the current screen: 
+
[source, java]
----
include::{sourcesdir}/gui/dialogs_2.java[]
---- 

[[notifications]]
===== Notifications

Notifications can be invoked using `showNotification()` method of the `Frame` interface. This interface is implemented by <<screen_controller,screen controlller>>, so this method can be invoked directly from the controller code.

`showNotification()` method takes the following parameters:

* `caption` - notification text. In case of HTML-type (see below), you can format message text using HTML-tags. When using HTML, don't forget to escape data to prevent code injection in the web-client. You can use `\n` characters for line breaks in non-HTML messages.

* `description` – an optional description displayed under the caption. You can also use `\n` character or HTML-formatting.

* `type` – notification type. Possible values:

** `TRAY`, `++TRAY_HTML++` - a notification is displayed in the bottom right corner of the application and disappears automatically.

** `HUMANIZED`, `++HUMANIZED_HTML++` – a standard notification displayed in the center of the screen, disappears automatically.

** `WARNING`, `++WARNING_HTML++` – a warning. Disappears when clicked.

** `ERROR`, `++ERROR_HTML++` – a notification about an error. Disappears when clicked.

Examples of invoking a notification: 

[source, java]
----
include::{sourcesdir}/gui/notifications_1.java[]
---- 

[[background_tasks]]
==== Background Tasks

Background tasks can be used at the client tier to perform tasks asynchronously without locking the user interface.

===== Using Background Tasks

. A task is defined as an inheritor of an abstract class `BackgroundTask`. A link to a screen controller which will be associated with the task and the task timeout should be passed to the task constructor.
+
Closing the screen will interrupt the tasks associated with it. Additionally, the task will be interrupted automatically after the specified timeout.
+
Actual actions performed by the task are implemented in the `run()` method.

. An object of "`BackgroundTaskHandler`" class controlling the task is created by passing a task instance to the `handle()` method of the `BackgroundWorker` bean. A link to a `BackgroundWorker` can be obtained by an injection in a <<screen_controller,screen controller>>, or a static method of the `AppBeans` class.
+
Example:
+
[source, java]
----
include::{sourcesdir}/gui/backgroundtasks_1.java[]
----

Detailed information about methods is provided in JavaDocs for `BackgroundTask`, `TaskLifeCycle`, `BackgroundTaskHandler` classes. 

Please note the following:

* `BackgroundTask<T, V>` is a parameterized class:

** `T` − the type of objects displaying task progress. Objects of this type are passed to the task's `progress()` method during an invocation of `TaskLifeCycle.publish()` in the working thread.

** `V` − task result type passed to the `done()` method. It can also be obtained by invoking `BackgroundTaskHandler.getResult()` method, which will wait for a task to complete.

* `canceled()` method is invoked only during a controlled cancelation of a task, i.e. when `cancel()` is invoked in the `TaskHandler`.

* If task timeout expires, or a window where it was running closes, the task is stopped without notifications. In the *Web Client* block, timeout-based interruption is performed with a delay specified in the <<cuba.backgroundWorker.maxClientLatencySeconds,cuba.backgroundWorker.maxClientLatencySeconds>> application property.

* `run()` method of a task should support external interruptions. To ensure this, we recommend checking the `TaskLifeCycle.isInterrupted()` flag periodically during long processes and stopping execution when needed. Additionally, you should not silently discard `InterruptedException` (or any other exceptions) - instead you should either exit the method correctly or not handle the exception at all.

* `BackgroundTask` objects are stateless. If you did not create fields for temporary data when implementing task class, you can start several parallel processes using a single task instance.

* `BackgroundHandler` object (its `execute()` method) can only be started once. If you need to restart a task frequently, use `BackgroundTaskWrapper` class.

* Use `BackgroundWorkWindow` or `BackgroundWorkProgressWindow` classes with a set of static methods to show a modal window with progress indicator and *Cancel* button. You can define progress indication type and allow or prohibit cancellation of the background task for the window.

* If you need to use certain values of visual components in the task thread, you should implement their acquisition in `getParams()` method, which runs in the UI thread once, when a task starts. In the run() method, these parameters will be accessible via the `getParams()` method of the `TaskLifeCycle` object.

* If any exception occurs, the framework invokes `BackgroundTask.handleException()` method in the UI thread, which can be used to display the error.

===== Setting Up Environment

In order for background tasks to work correctly, the following configuration should be performed for the application project:

* Timeout-based task interruption is implemented by the `WatchDog` bean. To ensure that it is invoked periodically, you should add the following declaration to the <<spring.xml,spring.xml>> files of the *Web Client *and *Desktop Client* blocks: 
+
[source, xml]
----
include::{sourcesdir}/gui/backgroundtasks_2.xml[]
---- 

* In the *Web Client* block task state polling is initiated by the client code running in web-browser. Polling interval is defined by the <<cuba.backgroundWorker.uiCheckInterval,cuba.backgroundWorker.uiCheckInterval>> application property; the default value is 2 seconds.
+
Additionally, background tasks running in the *Web Client* block are affected by <<cuba.backgroundWorker.maxActiveTasksCount,cuba.backgroundWorker.maxActiveTasksCount>> and <<cuba.backgroundWorker.maxClientLatencySeconds,cuba.backgroundWorker.maxClientLatencySeconds>> application properties.

[[gui_themes]]
==== Creating Application Themes

Theme is used to manage visual presentation of an application.

[[web_theme]]
===== Themes in Web Applications

A theme consists of SCSS files and other resources like images.

[[web_theme_usage]]
====== Using Existing Themes

The platform includes two ready to use themes: Halo and Havana. By default, the application will use the one specified in the <<cuba.web.theme,cuba.web.theme>> application property. The user may select the other theme in the standard *Help* > *Settings* screen. If you want to disable the option to select new themes for users, register the `settings` screen in the <<screens.xml,web-screens.xml>> file of your project and set the `changeThemeEnabled = false` parameter for it:

[source, xml]
----
include::{sourcesdir}/gui/themes_1.xml[]
---- 

Some branding parameters can be configured for default themes, such as icons, login and main application window captions, and the website icon (`favicon.ico`). This can be done in the following way:

. Create the following files structure in the `modules/web` directory of the project:
+
[source, plain]
----
themes/
  havana/
    branding/
      myapp-login.png
      myapp-menu.png
    favicon.ico
---- 
+
Here, havana is the directory of the theme, `favicon.ic`o is the website icon, myapp-login.png - login window logo image, myapp-menu.png - main window logo image.

. Open *Project properties* > *Edit* in *CUBA Studio* and click *Branding* at the bottom of the page. Set the paths to icon files for application and login window using *Set application logo image* and *Set login window logo image* links. The path is specified relatively to the theme directory. Other links can be used to set window captions and the login window welcome text.
+
These parameters are saved in the <<main_message_pack,main message pack>> of the *gui* module (i.e the `modules/gui/<root_package>/gui/messages.properties` file and its variants for different locales). Message packs allow you to use different image files for different user locales. A sample `messages.properties` file:
+
[source, properties]
----
application.caption = MyApp
application.logoImage = branding/myapp-menu.png

loginWindow.caption = MyApp Login
loginWindow.welcomeLabel = Welcome to MyApp!
loginWindow.logoImage = branding/myapp-login.png
---- 
+
You should not specify the path to `favicon.ico`, since it must be located in the root directory of the theme.

Image files that will be used in the <<gui_attr_basic_icon,icon>> properties for <<gui_Action,actions>> and visual components, e.g. <<gui_Button,Button>>, can be also added to default themes. 

For example, to add an icon to the Havana theme, you just have to add the image file to the `modules/web/themes/havana` directory described above (it is recommended to create a subfolder):

[source, plain]
----
themes/
  havana/
    images/
      address-book.png
----

After that, you can use the icon in the application by specifying the path relatively to the theme directory in the `icon` property: 

[source, xml]
----
include::{sourcesdir}/gui/themes_2.xml[]
---- 

Font elements of link:http://fortawesome.github.io/Font-Awesome[Font Awesome] can be used instead of icons. You should just specify the name of the required constant of the `com.vaadin.server.FontAwesome` in the `icon` property with a `font-icon:` prefix, for example:

[source, xml]
----
include::{sourcesdir}/gui/themes_3.xml[]
---- 

Images used for standard actions and screens of the platform can be replaced in the project. To replace a Havana theme icon, you should just copy the required image file to the `modules/web/themes/havana/icons` directory of the project. For example, create.png file should be created to replace the icon for the standard `create` action (the file name can be easily identified by URL of the corresponding `img` HTML-element in the running application):

[source, plain]
----
themes/
  havana/
    icons/
      create.png
----

In Halo theme, Font Awesome icons are used for standard actions and platform screens by default (if <<cuba.web.useFontIcons,cuba.web.useFontIcons>> is enabled). In this case, you can replace a standard icon only by creating a custom theme based on Halo (see <<web_theme_creation,below>>) and setting the required correlation between the icon and the font element name in `<your_theme>-theme.properties` file:

[source, properties]
----
cuba.web.icons.create.png = PLUS
---- 

If `cuba.web.useFontIcons` property is disabled, the icons for standard actions and screens are loaded similar to Havana theme - from image files in the `icons` subfolder. They can be replaced in the manner described for Havana.

Halo theme supports the <<cuba.web.useInverseHeader,cuba.web.useInverseHeader>> property, which controls the colour of the application header. By deafult, this property is set to `true`, which sets a dark (inverse) header.You can make a light header without any changes to the theme, simply by setting this property to `false`.

[[web_theme_extension]]
====== Extending an Existing Theme

A platform theme can be modified in the project. Themes are described in link:http://sass-lang.com[SCSS] files, that is why the simplest way to modify the theme is to modify the base SCSS variables that control application background colour, component size, or margins. Changing specific component parameters requires some expertise in CSS.

To adapt (extend) a theme in the project, you should create a specific file structure in the *web* module. A convenient way to do this is to use *CUBA Studio*: open the *Project properties* section and click *Create theme extension*. Select the theme you want to extend in the popup window. As a result, a directory structure, similar to the one described in the <<web_theme_usage,previous>> section, will be created. Apart from that, the <<build.gradle,build.gradle>> script will be complemented with the `buildScssThemes` task, which is executed automatically each time the *web* module is built.

Below is the example of a Halo theme extension, since it is based on link:https://vaadin.com/valo[Valo] theme from *Vaadin*, and provides the widest range of options for customization.

The `themes/halo/halo-ext-defaults.scss` file is intended for theme variables. Most of the Halo variables correspond to those described in the link:https://vaadin.com/api/valo[Valo documentation]. Below are the most common variables:

[source, plain]
----
include::{sourcesdir}/gui/themes_4.scss[]
---- 

A sample `halo-ext-defaults.scss` for a theme with a dark background and slightly minimized margins is provided below:

[source, plain]
----
include::{sourcesdir}/gui/themes_5.scss[]
----

To modify parameters for specific components, you should add the corresponding CSS code to `@mixin halo-ext {...}` block of the `halo-ext.scss` file. For example, to display the application menu items in bold, the contents of the `halo-ext.scss` file should be as follows:

[source, plain]
----
include::{sourcesdir}/gui/themes_6.scss[]
---- 

[[web_theme_creation]]
====== Creating a Custom Theme

You can create one or several application themes in the project and give the users an opportunity to select the most appropriate one. Creating new themes also allows you to override the variables in the `++*-theme.properties files++`, which set a few server-side parameters:

* Default dialog window size.

* Default input field width.

* Dimensions of some components (<<gui_Filter,Filter>>, <<gui_FileMultiUploadField,FileMultiUploadField>>).

* Correlation between icon names and constants of the `com.vaadin.server.FontAwesome` enumeration for using *Font Awesome* in standard actions and screens of the platform, if <<cuba.web.useFontIcons,cuba.web.useFontIcons>> is enabled.

Below is the example of creating a Halo-based Facebook theme, which resembles the interface of a popular social network.

. Open *Project properties* section in *CUBA Studio* and click *Create theme extension*. Select `halo` and click *Create*. A Halo theme extension will be created in the project as described in the previous section.

. Rename the `themes/halo` directory in the *web* module to `themes/facebook`, then rename the `halo-ext.scss` file inside it to `facebook.scss`, and `halo-ext-defaults.scss` to `facebook-defaults.scss`.

. Edit the styles.scss file by changing the `halo-ext` imports and the `halo` root selector: 
+
[source, scss]
----
include::{sourcesdir}/gui/themes_7.scss[]
---- 

. Edit the `facebook.scss` file and replace `@mixin halo-ext`:
+
[source, scss]
----
include::{sourcesdir}/gui/themes_8.scss[]
---- 

. Copy the following variables to `facebook-defaults.scss`:
+
[source, plain]
----
include::{sourcesdir}/gui/themes_9.scss[]
---- 

. Create a `facebook-theme.properties` file in the src directory of the *web* module:
+
[source, properties]
----
@include=halo-theme.properties
----
+
If necessary, you can use this file to override server-side theme variables from the `halo-theme.properties` file of the platform.

. Add the following properties to the `web-app.properties` file:
+
[source, properties]
----
cuba.web.theme = facebook
cuba.themeConfig = havana-theme.properties halo-theme.properties facebook-theme.properties
---- 

. Rebuild the application and start the server. Now the user will see the application in Facebook theme on first login, and will be able to choose between Facebook, Halo and Havana in the *Help* > *Settings* menu.

[[desktop_theme]]
===== Themes in Desktop Applications

The base theme for desktop applications is `Nimbus`.

To add any changes to the standard theme, you need to create a `res.nimbus` package in the `com.sample.sales.desktop` package of the *desktop* module. Theme files will be stored in the `res.nimbus` package.

.
image::gui_themes_desktop_structure.png[align="center"]

The `icons` folder contains icon files, the `nimbus.xml` file contains the description of the theme style.

The <<app_properties,properties file>> of a desktop application should have `cuba.desktop.resourceLocations` property defined (defines a set of folders containing the style files): 

[source, properties]
----
cuba.desktop.resourceLocations = \
com/haulmont/cuba/desktop/res \
com/sample/sales/desktop/res
----

*Examples*

. Adding an icon.
+
If you need to add a new icon to a desktop application, for example an icon for a button, you should create a `res.nimbus.icons` package within the `com.sample.sales.desktop `package of the *desktop* module and put the corresponding icon there.
.
image::gui_themes_example4.png[align="center"]
+
Description of a <<gui_Button,button>> in the <<screen_xml_glossentry,descriptor>> with a path to an icon set in the <<gui_attr_basic_icon,icon>> attribute:
+
[source, xml]
----
include::{sourcesdir}/gui/themes_10.xml[]
----
+
Below you can see a button with the attention.png icon.
+
image::gui_themes_example5.png[align="center"]

. Redefining default values of theme properties.
+
For example, let us change text field background color for mandatory fields.
+
The `nimbus.xml` file with the following content should be created in the `res.nimbus` package:
+
[source, xml]
----
include::{sourcesdir}/gui/themes_11.xml[]
---- 
+
The `ui-defaults` element redefines the values of platform theme properties set by default.
+
The `ui-defaults` element includes both the properties contained in a standard `Nimbus` (http://docs.oracle.com/javase/tutorial/uiswing/lookandfeel/_nimbusDefaults.html) theme and the properties created in the CUBA platform.
+
In this example, we redefined the value of the CUBA property – `cubaRequiredBackground`, which stores the background color for required fields. This change will affect all required input fields.

. Creating a style for an element using standard tools.
+
Let's consider an example of highlighting a text in bold.
+
To create a style like that you need to define `style` element in the theme file `nimbus.xml` in the following way:
+
[source, xml]
----
include::{sourcesdir}/gui/themes_12.xml[]
---- 
+
`style` element can also contain other elements which can define different properties: `background`, `foreground`, `icon`.
+
You should add <<gui_attr_basic_stylename,stylename>> attribute with the name of the created style into the description of the corresponding label in an <<screen_xml_glossentry,xml-descriptor>>. 
+
[source, xml]
----
include::{sourcesdir}/gui/themes_13.xml[]
---- 
+
In such way the style will be applied only to the labels that have <<gui_attr_basic_stylename,stylename>> attribute with the value of `boldlabel`.

. Creating a custom style.
If standard style adjustment capabilities are insufficient, you can create a custom style.+
Let us create a custom style that will be applied to the <<gui_Label,Label>> component. With this style, the content of the <<gui_Label,Label>> will be displayed as underlined..
+
First, let us create a decorator class `UnderlinedLabelDecorator`: 
+
[source, java]
----
include::{sourcesdir}/gui/themes_14.java[]
---- 
+
Let us define a custom style in `nimbus.xml`:
+
[source, xml]
----
include::{sourcesdir}/gui/themes_15.xml[]
---- 
+
The `component` attribute of the `style` element contains the name of the component that the style with the name `label-underlined` can be applied to.
+
The `custom` element should contain path to the decorator class defined above.
+
When describing a label element that should be affected by the custom style, you should specify the style name in the `stylename` attribute: 
+
[source, xml]
----
include::{sourcesdir}/gui/themes_16.xml[]
---- 

.A label component with a custom style
image::gui_themes_example6.png[align="center"]

[[gui_web]]
==== Web Client Specifics

Implementation of the generic user interface of the *Web Client* <<app_tiers,block>> is based on the *Vaadin* framework. The main classes available in the web client infrastructure are described below.

.Web Client Infrastructure Classes
image::WebClientInfrastructure.png[align="center"]

* `App` - the central class of the application infrastructure. Contains links to `Connection`, `AppWindow` and other infrastructure objects. Only one instance of `App` exists for a given HTTP-session.
+
Each application typically has its own `App` class class inherited from the `DefaultApp` and thus from the basic abstract `App` class of the platform. It allows you to override `createAppWindow()` and `createLoginWindow()` methods to create custom implementations of the main window and the login window.
+
The `App` class of an application should be registered in the `application` parameter of the `++app_servlet++` in the <<web.xml,web.xml>> file of the *web* module.

* `Connection` is the interface providing functionality of connecting to middleware and storing <<userSession,user sessions>>. `DefaultConnection` is a standard implementation of this interface.

* `AppUI` is a platform class inherited from `com.vaadin.ui.UI` class. There is one instance of this class for each open tab of a web browser. Contains a link to the `UIView` object – either a `LoginWindow` or `AppWindow`.
+
`AppUI` application class should be registered in the `UI` parameter of the `++app_servlet++` in the web/WEB-INF/web.xml file of the *web* module. In most cases, standard platform class is used.

* `LoginWindow` – the window displayed before a user logs in. In your application you can create an inheritor of `LoginWindow` and redefine the `createLoginWindow()` method of the `App` class to use it.

* `AppWindow` – main application window displayed after a user logs in. In your application, you can create an inheritor of `AppWindow` and override the `createAppWindow()` method of the `App` class to use it.
+
`onHistoryBackPerformed()` method allows you to handle browser *Back* button. This method is invoked instead of standard browser behavior if <<cuba.web.allowHandleBrowserHistoryBack,cuba.web.allowHandleBrowserHistoryBack>> application property is true.
+
You can control certain main window parameters without creating `AppWindow` inheritor, using the following application properties:

** <<cuba.web.useLightHeader,cuba.web.useLightHeader>> - switches on compact window header - logo, menu bar, user name and log out button in one line. When switched off, `AppWindow.createTitleLayout()` method creates additional area at the top.

** <<cuba.web.foldersPaneEnabled,cuba.web.foldersPaneEnabled>> - enables creation of <<folders_pane,folders pane>> by `AppWindow.createFoldersPane()` method.

** <<cuba.web.appWindowMode,cuba.web.appWindowMode>> – sets default mode for the main window: tabbed or single screen (`TABBED` or `SINGLE`). Users can change the mode later using *Help* > *Settings* screen.

** <<cuba.web.maxTabCount,cuba.web.maxTabCount>> – when the main window is in the tabbed mode, this property sets the maximum number of tabs that a user can open. The default value is 7.

* `WindowManager` - the central class implementing application screens management logic. `openWindow()`, `openEditor()`, `showMessageDialog()` and other methods of the `Frame` interface implemented by screen <<screen_controller,controllers>> delegate to the window manager. `WindowManager` class is located in the platform's common *gui* module and is abstract. The *web* module has a dedicated `WebWindowManager` class that implements web client specifics.
+
Normally, the `WindowManager` is not used in the application code directly.

* `ExceptionHandlers` - contains a collection of <<exceptionHandlers,client-level exception handlers>>.

[[webComponentsHelper]]
===== Working with Vaadin Components

In order to work directly with Vaadin components implementing interfaces of the <<gui_vcl,visual components library>> in the *Web Client* <<app_tiers,block>> you should use the `WebComponentsHelper` class. It has two static methods to retrieve links to Vaadin components:

* `unwrap` – retrieves a Vaadin component for a given CUBA component.

* `getComposition` - retrieves a Vaadin component that is the outmost external container in the implementation of a given CUBA component. For simple components, such as <<gui_Button,Button>> this method returns the same object as `unwrap()` - `com.vaadin.ui.Button`. For complex components, such as <<gui_Table,Table>>, `unwrap()` will return the corresponding object - `com.vaadin.ui.Table`, while `getComposition()` will return `com.vaadin.ui.VerticalLayout`, which contains the table together with <<gui_ButtonsPanel,ButtonsPanel>> and `RowsCount` defined with it.

Please note that if a screen is located in the project's *gui* module, you can only work with generalized interfaces of CUBA components. In order to use `WebComponentsHelper.unwrap()` you should either put the entire screen into the *web* module, or use the mechanism of <<companions,controller companions>>.

[[main_window_layout]]
===== Main Window Layout

The mechanism described below allows you to design the application main window layout with CUBA Generic UI technology by creating an XML-descriptor and Java controller, and using <<gui_vcl,UI components>> and <<datasources,data sources>>. 

The main window is defined by a specific screen with `mainWindow` identifier. Its controller should be derived from the `AbstractMainWindow` class. 

The following special components may be used in the main window in addition to the standard UI components:

* `AppMenu` - main application menu.

* `FoldersPane` - application and search <<folders_pane,folders panel>>.

*  `AppWorkArea` - work area, the required component for opening screens in the `++THIS_TAB++`, `++NEW_TAB++` and `++NEW_WINDOW++` modes. 

* `UserIndicator` - the field which displays the name of the current user, as well as enables selecting substituted users, if any.

* `NewWindowButton` - the button which opens a new main window in a separate browser tab.

* `LogoutButton` - the application logout button.

* `TimeZoneIndicator` - the label displaying the current user's <<timeZone,time zone>>.

* `FtsField` - the full text search field.

In order to define the special components, add the `xmlns:main` namespace to the screen: 

[source, xml]
----
include::{sourcesdir}/gui/main_window_1.xml[]
----

The `AppWorkArea` component is designed to show application screens. If the <<cuba.web.appWindowMode,cuba.web.appWindowMode>> application property is `TABBED` (default), the work area shows a TabSheet with open screens. Otherwise a single open screen is shown. When no screens are opened, the work area shows components defined in the `initialLayout` internal element: 

[source, xml]
----
include::{sourcesdir}/gui/main_window_2.xml[]
---- 

The initial screen layout (`initialLayout`) is removed from `AppWorkArea` when the first application screen is opened, and added back when all screens are closed. You can add `AppWorkArea.StateChangeListener` to handle changing the work area between the initial layout and application screens. Such listener can, for example, refresh the initial layout data. 

The platform includes the standard main window implementation in `/com/haulmont/cuba/web/app/mainwindow/mainwindow.xml` XML descriptor and corresponding `AppMainWindow` controller class. The standard implementation can be extended in the project, like any other application screen. Example of an extending screen:

[source, xml]
----
include::{sourcesdir}/gui/main_window_3.xml[]
----

This screen should be registered in <<screens.xml,screens.xml>> with the `mainWindow` identifier.

The standard main window implementation may be fully replaced with a custom one. For example: 

[source, xml]
----
include::{sourcesdir}/gui/main_window_4.xml[]
---- 

The resulting main window is shown below: 

image::main_window_1.png[align="center"]

 

The same main window with an open screen: 

image::main_window_2.png[align="center"]

 

The <<cuba.web.showBreadCrumbs,cuba.web.showBreadCrumbs>> application property allows you to hide the navigation panel (breadcrumbs) above the opened screen. 

[[gui_desktop]]
==== Desktop Client Specifics

Implementation of the generic user interface in the *Desktop Client* <<app_tiers,block>> is based on *Java Swing*. The main classes available in the desktop client infrastructure are described below..Classes of the Desktop Client Infrastructure
image::DesktopClientInfrastructure.png[align="center"]

* `App` – central class of the desktop application infrastructure. Contains links to `Connection` and main `TopLevelFrame`, as well as methods for initialization and retrieval of application settings.
+
In your application, you should create a custom class – inheritor of `App` and override the following methods:

** `getDefaultAppPropertiesConfig()` - should return a string where all <<app_properties_files,application properties files>> should be listed separated by spaces: 
+
[source, java]
----
include::{sourcesdir}/gui/desktopclient_1.java[]
---- 

** `getDefaultHomeDir()` - should return path to the folder, where temporary and work files should be stored. For example: 
+
[source, java]
----
include::{sourcesdir}/gui/desktopclient_2.java[]
---- 

** `getDefaultLogConfig()` - should return name of the *Logback* configuration file, if it is defined for the project. For example:
+
[source, java]
----
include::{sourcesdir}/gui/desktopclient_3.java[]
---- 
+
Additionally, for your custom class inheriting from the `App` you should define `main()` method in the following way: 
+
[source, java]
----
include::{sourcesdir}/gui/desktopclient_4.java[]
---- 

* `Connection` - is a class that provides the functionality of connecting to middleware and storing a <<userSession,user session>>. 

* `LoginDialog` – the dialog to enter credentials. In your application you can create an inheritor of `LoginDialog` and redefine the `createLoginDialog()` method of the `App` class to use it.

* `TopLevelFrame` – inheritor of `JFrame`, which is the top level window. The application has at least one instance of this class created when application is started and containing the main menu. This instance is returned by the `getMainFrame()` method of the `App` class.
+
When a user detaches tabs from the main window or a <<gui_TabSheet,TabSheet>> (see `detachable` attribute), additional instances of `TopLevelFrame` that do not contain main menu are created.

* `WindowManager` - the central class implementing application screens management logic. `openEditor()`, `showMessageDialog()` and other methods of the `Frame` interface implemented by screen <<screen_controller,controllers>> delegate to the window manager. `WindowManager` class is located in the platform's common *gui* module and is abstract. The *desktop* desktop module has a dedicated `DesktopWindowManager` class that implements desktop client specifics.
+
Typically, `WindowManager` is not used in the application code directly.

* `ExceptionHandlers` - contains a collection of <<exceptionHandlers,client-level exception handlers>>.

[[desktopComponentsHelper]]
===== Working with Swing Components

`DesktopComponentsHelper` class should be used to work directly with Swing components that implement interfaces of the <<gui_vcl,visual components library>> in the *Desktop Client* <<app_tiers,block>>. It has two static methods to retrieve links to Swing components:

* `unwrap` – retrieves a Swing component for a given CUBA component.

* `getComposition` - retrieves a Swing component that is the outmost external container in the implementation of a given CUBA component. For simple components, such as <<gui_Button,Button>>, this method returns the same object as `unwrap()` - `javax.swing.JButton`. For complex components, such as <<gui_Table,Table>>, `unwrap()` will return the corresponding `org.jdesktop.swingx.JXTable` instance, while `getComposition()` will return an instance of `javax.swing.JPanel`, which contains a table together with <<gui_ButtonsPanel,ButtonsPanel>> and `RowsCount` defined with it.

Please note that if a screen is located in the project's *gui* module, you can only work with generalized interfaces of CUBA-components. In order to use `DesktopComponentsHelper.unwrap()` you should either put the entire screen in the *desktop* module, or use the mechanism of <<companions,companion controllers>>.

[[own_components]]
==== Creating Custom Components

This section covers the process of creating and using custom visual components in the application. To begin with, we will take a third party component available as Vaadin add-on, include it in the project and use it directly in the screen. Then we will perform a tighter integration, by creating a new <<gui_framework,GUI>> interface and an XML loader for the component, which will allow us to use it in the same way as other platform components. 

[[vaadin_addon]]
===== Using Third-Party Vaadin Components

You can use third-party Vaadin components, distributed as add-ons, in the Web Client. Currently, the Vaadin library https://vaadin.com/directory has over 200 CUBA-compatible visual components. The main requirement for compatibility is the component's support of Vaadin 7+. 

The following should be done to integrate a third-party component into the project:

. Add *web-toolkit* module to the project. This module integrates with the client (browser) part of Vaadin components. The easiest way to do this is to run the *Create web toolkit module* command on the *Project properties* panel of the <<cubaStudio_install,CUBA Studio>> navigator. 

. Add the add-on dependency to the *web* module in the project's <<build.gradle,build.gradle>>. For example: 
+
[source, java]
----
include::{sourcesdir}/gui/vaadinaddon_1.gradle[]
---- 

. Include the add-on widget set to the `AppWidgetSet.gwt.xml` file, created in Step 1:
+
[source, xml]
----
include::{sourcesdir}/gui/vaadinaddon_2.xml[]
---- 

. In a *web* module screen (or in a corresponding <<companions,companion>>), get a link to the Vaadin container using the <<webComponentsHelper,WebComponentsHelper>> class, create a new component instance and add it to the container.

. To change the component's look, create a <<web_theme,theme extension>> and make the required changes in the `<theme>-ext.scss` file. The easiest way to create a theme file is to run the *Create theme extension* command on the *Project properties* panel of the Studio navigator.

<<vaadin_addon_sample>> covers the process of including and using the *Stepper* add-on, which enables stepping through the values.

[[own_gui_component]]
===== Integration with Generic UI

Integration of a native component into the generic user interface enables using such component in a large number of screens with little effort, just like the basic platform components. Full integration requires the following steps:

. Create the component interface. Interfaces are usually located in the GUI module, available to both client types – *Web* and *Desktop*. If the component should be implemented for one client type only, it can be placed in the *Web* or *Desktop* module directly. The example below implements the component for *Web Client* only. 
+
The component interface should be derived from `com.haulmont.cuba.gui.components.Component` or any of its inheritors, for example `DatasourceComponent` or `Field`: 
+
[source, java]
----
include::{sourcesdir}/gui/customcomponent_1.java[]
---- 
+
It is recommended to define the `NAME` constant in the interface. The constant should define the name of the component as a string, used for obtaining the component through the `ComponentsFactory`. This is also used as the name of the component's XML element in the XML screen descriptors.

. Create the component implementation class in the *web* module.
+
It is recommended to derive the class from `com.haulmont.cuba.web.gui.components.WebAbstractComponent` or one of its inheritors, for example `WebAbstractField`. A native component instance should be created in the class constructor, and the GUI interface calls should be delegated to it: 
+
[source, java]
----
include::{sourcesdir}/gui/customcomponent_2.java[]
---- 

. Create a class implementing the `ComponentPalette` interface and return a map of custom components and their implementation classes from the `getComponents()` method: 
+
[source, java]
----
include::{sourcesdir}/gui/customcomponent_3.java[]
---- 
+
The instance of the component palette must be registered in the application. This can be done in the <<gui_web,App>> class initialization block: 
+
[source, java]
----
include::{sourcesdir}/gui/customcomponent_4.java[]
---- 

. At this point, the new GUI component can be retrieved via the `ComponentsFactory`: 
+
[source, java]
----
include::{sourcesdir}/gui/customcomponent_5.java[]
---- 

. In order to support component declaration in screen XML-descriptors, create a component loader class, implementing `com.haulmont.cuba.gui.xml.layout.ComponentLoader`. It is recommended to derive the loader class from `com.haulmont.cuba.gui.xml.layout.loaders.ComponentLoader` or any of its inheritors. The loader operates with the component GUI interface only, so it is common for all client types, and can be located in the *gui* module. The minimal implementation should call the `loadComponent()` method, which creates the component instance and sets its common properties, such as ID or size, taken from XML. Any custom component properties can be initialized afterwards: 
+
[source, java]
----
include::{sourcesdir}/gui/customcomponent_6.java[]
---- 
+
The loader must be registered by the `getLoaders()` method of the previously created component palette: 
+
[source, java]
----
include::{sourcesdir}/gui/customcomponent_7.java[]
---- 

. Now the component can be used in XML-descriptors of your project: 
+
[source, xml]
----
include::{sourcesdir}/gui/customcomponent_8.xml[]
---- 
+
In order to enable autocomplete for component name and attributes in IDE, define your own XSD and include it in the screens: 
+
[source, xml]
----
include::{sourcesdir}/gui/customcomponent_9.xml[]
---- 

<<own_gui_component_sample>> covers the process of integrating the *IntStepper* component, used for changing integer values incrementally.

[[shortcuts]]
==== Keyboard Shortcuts

This section provides a list of keyboard shortcuts used in the generic user interface of the application. All the <<app_properties,application properties>> listed below belong to the `ClientConfig` interface and can be used in Web Client and Desktop Client application blocks. 

* Main application window.

** *CTRL-SHIFT-PAGE_DOWN* – switch to the next tab. Defined by the `cuba.gui.nextTabShortcut` property.

** *CTRL-SHIFT-PAGE_UP* – switch to the previous tab. Defined by the `cuba.gui.previousTabShortcut` property.

* Screens.

** *ESCAPE* – close the current <<abstractWindow,screen>>. Defined by the `cuba.gui.closeShortcut` property.

** *CTRL-ENTER* – close the current <<abstractEditor,editor>> and save the changes. Defined by the `cuba.gui.commitShortcut` property.

* Standard actions for list components (<<gui_Table,Table>>, <<gui_GroupTable,GroupTable>>, <<gui_TreeTable,TreeTable>>, <<gui_Tree,Tree>>). In addition to these application properties, a shortcut for a particular action can be set by calling it's `setShortcut()` method.

** *CTRL-\* – call the <<createAction,CreateAction>>. Defined by the `cuba.gui.tableInsertShortcut` property.

** *CTRL-ALT-\* – call the <<addAction,AddAction>>. Defined by the `cuba.gui.tableAddShortcut` property.

** *ENTER* – call the <<editAction,EditAction>>. Defined by the `cuba.gui.tableEditShortcut` property.

** *CTRL-DELETE* – call the <<removeAction,RemoveAction>> and <<excludeAction,ExcludeAction>>. Defined by the `cuba.gui.tableRemoveShortcut` property.

* Drop-down lists (<<gui_LookupField,LookupField>>, <<gui_LookupPickerField,LookupPickerField>>).

** *SHIFT-DELETE* – clear the value.

* Standard actions for lookup fields (<<gui_PickerField,PickerField>>, <<gui_LookupPickerField,LookupPickerField>>, <<gui_SearchPickerField,SearchPickerField>>). In addition to these application properties, a shortcut for a particular action can be set by calling its `setShortcut()` method.
+
--
** *CTRL-ALT-L* – call the <<lookupAction,LookupAction>>. Defined by the `cuba.gui.pickerShortcut.lookup`.

** *CTRL-ALT-O* – call the <<openAction,OpenAction>>. Defined by the `cuba.gui.pickerShortcut.open` property.

** *CTRL-ALT-C* – call the <<clearAction,ClearAction>>. Defined by the `cuba.gui.pickerShortcut.clear` property.

In addition to these shortcuts, lookup fields support action calls with CTRL-ALT-1, CTRL-ALT-2 and so on, depending on the number of actions. If you click CTRL-ALT-1 the first action in the list will be called; clicking CTRL-ALT-2 calls the second action, etc. The CTRL-ALT combination can be replaced with any other combination specified in `cuba.gui.pickerShortcut.modifiers` property.
--

* <<gui_Filter,Filter>> component.

** *SHIFT-BACKSPACE* – open the filter selection popup. Defined by the `cuba.gui.filterSelectShortcut` property.

** *SHIFT-ENTER* – apply the selected filter. Defined by the `cuba.gui.filterApplyShortcut` property.