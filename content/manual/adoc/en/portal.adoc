[[portal]]
=== Portal Components

In this manual, a _portal_ is a client <<app_tiers,block>>, which can solve the following problems:

* provide an alternative web-interface, which is usually intended for users outside of the organization;

* provide an interface for integration with mobile applications and third-party systems.

A specific application may contain several portal modules intended for different purposes; for example, in an application, which automates business tasks, it can be a public web site for customers, an integration module for a mobile application for ordering a taxi, an integration module for a mobile application for drivers, etc.

The *cuba* <<base_projects,base project>> of the platform includes the *portal* module, which is a template to create portals in projects. First, it provides basic functionality of the client block to work with Middleware, and second, it includes the universal <<rest_api,REST API>> to work with entities.

[[portal_basic_func]]
==== Basic Functionality

Below is an overview of the main components provided by the platform to build a portal.

* `PortalAppContextLoader` – the <<appContext,AppContext>> loader; must be registered in the `listener` element of the `web.xml` file.

* `PortalDispatcherServlet` – the central servlet that distributes requests to *Spring MVC* controllers, for both the web interface and REST API. The set of files of the Spring context config is defined by the <<cuba.dispatcherSpringContextConfig,cuba.dispatcherSpringContextConfig>> application property. This servlet must be registered in `web.xml` and displayed in the root URL of the web application.

* `App` – the object that contains information on the current HTTP request and the reference to `Connection` object. The `App` instance can be obtained in the application code by calling the `App.getInstance()` static method.

* `Connection` – allows a user to log in/out of the *Middleware*.

* `PortalSession` – the object of a <<userSession,user session>> that is specific for the portal. It is returned by the <<userSessionSource,UserSessionSource>> infrastructure interface and by the `PortalSessionProvider.getUserSession()` static method.
+
It has an additional `isAuthenticated()` method, which returns `true` if this session belongs to a non-anonymous user, i.e. a user explicitly registered with the login and password.
+
When a user first accesses the portal, the `SecurityContextHandlerInterceptor` creates an anonymous session for him (or ties to an already existing one) by registering at Middleware with a user name specified in the <<cuba.portal.anonymousUserLogin,cuba.portal.anonymousUserLogin>> application property. The registration is made by <<login, loginTrusted()>> method, so it is necessary to set the <<cuba.trustedClientPassword,cuba.trustedClientPassword>> property in the portal block as well. Thus, any anonymous user of the portal can work with *Middleware* with `cuba.portal.anonymousUserLogin` user rights.
+
If the portal contains user registration page with name and password `SecurityContextHandlerInterceptor` assigns the session of the explicitly registered user to the execution thread after `Connection.login()` is executed, and the work with *Middleware* is performed on this user's behalf.

* `PortalLogoutHandler` – handles the navigation to the logout page. It must be registered in the `portal-security-spring.xml` project file.

[[rest_api]]
==== REST API

The universal REST API of the platform enables loading and saving any entities defined in the application data model by sending simple HTTP requests. This provides easy way to integrate with a wide range of third-party applications – from the JavaScript code executed in the browser to arbitrary systems running on Java, .NET, PHP or any other platform.

Key API features:

* Loading entity instances from the database by identifier or by JPQL query with parameters.

* Saving new and modified instances, deleting instances.

* Obtaining a description of the data model in HTML format.

* Data representation in JSON and XML formats.

* Middleware service calls.

* User authentication.

[[rest_api_adding]]
===== Including in a Project

REST API is implemented in the *portal* module of the *cuba* base project, therefore you need to create *portal* module in your application project. The easiest way to do this is to run the *Create portal module* command on the *Project properties* panel of the <<cubaStudio_install,CUBA Studio>> navigator.

Key configuration elements:

* Add REST API controllers to Spring context defined by the <<dispatcher-spring.xml,portal-dispatcher-spring.xml>> file: 
+
[source, xml]
----
include::{sourcesdir}/portal/project_1.xml[]
---- 

* Set access mode in `portal-security-spring.xml`:
+
[source, xml]
----
include::{sourcesdir}/portal/project_2.xml[]
---- 

[[rest_api_func]]
===== Describing Functions

With standard settings of the *portal* module, all requests to REST API must have the URL starting with `{host:port}/app-portal/api`.

All functions require an authenticated user session, which means that you must perform the login first and then pass the resulting session identifier to subsequent requests.

[[rest_api.login]]
====== Login

Login can be performed by either GET or POST request.

GET request:: 
+
--
For GET request, create the URL `{host:port}/app-portal/api/login` with the following parameters:

* *u* − user login

* *p* − user password

* *l* − user locale (optional)

For example:

[source, url]
----
http://localhost:8080/app-portal/api/login?u=admin&p=admin&l=ru
----
--

POST request:: 
+
--
To perform login using POST, execute request by `{host:port}/app-portal/api/login` address, passing JSON (`Content-Type` header has the value `application/json`) or form (`Content-Type` header has the value `application/x-www-form-urlencoded`) in request body. 

Example of the JSON format:

[source, json]
----
include::{sourcesdir}/portal/restapi_1.json[]
----

Example of the form:

[source, json]
----
username: admin
password: admin
locale: en
----
--

The service will return `userSessionId` in response body and status 200 or status 401 if the authentication fails.

To login through REST API, the user must have `cuba.restApi.enabled` specific <<permissions,permission>>. Notice that the user will have the permission if there are no <<roles,roles>> explicitly revoking it.

[[rest_api.logout]]
====== Logout

Logout can also be performed by either GET or POST request.

GET request:: 
+
--
To perform login using GET, construct the URL `{host:port}/app-portal/api/logout` with the *session* parameter containing the current session ID obtained by calling `login`.

For example:

[source, url]
----
http://localhost:8080/app-portal/api/logout?session=64f7d59d-2cf5-acfb-f4d3-f55b7882da72
----
--

POST request:: 
+
--
To perform login using POST, send request to `{host:port}/app-portal/api/logout` URL, passing JSON (`Content-Type` header has the value `application/json`) or form (`Content-Type` header has the value `application/x-www-form-urlencoded`) in the request body.

Example of the JSON format:

[source, json]
----
include::{sourcesdir}/portal/restapi_2.json[]
----

Example of the form:

[source, json]
----
session: 64f7d59d-2cf5-acfb-f4d3-f55b7882da72
----
--

The service will return status 200.

[[rest_api.find]]
====== Loading a Persistent Object Instance From the Database by Identifier

To load an object, you should perform GET request `{host:port}/app-portal/api/find.<format>` with the following parameters:

* *e* − the description of the required object in `<entity-id>` or `<entity-id-view>` format (see <<link_to_screen,EntityLoadInfo>>). For example, `++sales$Order-43c61345-d23c-48fe-ab26-567504072f05-_local++`. Thus, the format allows you to specify required <<views,view>> of the loaded object.

* *s* − current session identifier.

*format* element of the request specifies the result format. It takes two values: `xml` and `json`.

Example of a request, which returns the result in `xml` format:

[source, url]
----
http://localhost:8080/app-portal/api/find.xml?e=sales$Order-60885987-1b61-4247-94c7-dff348347f93-orderWithCustomer&s=c38f6bf4-fae7-4ee6-a412-9d93ff243f23
----

Example of request, which returns the result in `json` format:

[source, url]
----
http://localhost:8080/app-portal/api/find.json?e=sales$Order-60885987-1b61-4247-94c7-dff348347f93-orderWithCustomer&s=c38f6bf4-fae7-4ee6-a412-9d93ff243f23
----

[[rest_api.query]]
====== Executing JPQL Query to Retrieve Data

To execute a query, the `{host:port}/app-portal/api/query.<format>` GET request should be performed with the following parameters:

* *e* − the name of the entity.

* *q* − a <<jpql,JPQL>> data query. The request may contain parameters. Their values are provided as values of same-named parameters of HTTP query.

* *s* − the identifier of the current session.

* *view* (optional) − the <<views,view>>, which should be used to load data.

* *max* (optional) − maximum number of rows in resulting dataset (similar to JPA `setMaxResults`).

* *first* (optional) − number of the first row of resulting dataset (similar to JPA `setFirstResult`).

*format* specifies the format of obtaining the result. It takes two values: `xml` or `json`.

Examples:

[source, url]
----
http://localhost:8080/app-portal/api/query.json?e=sales$Customer&q=select+c+from+sales$Customer+c&s=748e5d3f-1eaf-4b38-bf9d-8d838587367d&view=_local
----

[source, url]
----
http://localhost:8080/app-portal/api/query.json?e=sales$Customer&q=select+c+from+sales$Customer+c+where+c.name=:name&s=748e5d3f-1eaf-4b38-bf9d-8d838587367d&name=Smith
----

For each of the passed parameters, the type can be explicitly specified by adding the parameter of the same name and the `++_type++` suffix to the request. For example:

[source, url]
----
http://localhost:8080/app-portal/api/query.json?e=sales$Customer&q=select+c+from+sales$Customer+c+where+c.name=:name&s=748e5d3f-1eaf-4b38-bf9d-8d838587367d&name=Smith&name_type=string
----

Specifying parameter type is optional, however it allows you to avoid parsing errors if the system cannot determine the type automatically.

Normally, the type should be specified only for string parameters, which for some reason have a more specific format types (dates, numbers, UUID), but must be interpreted as strings.

The list of available types can be found in meta-model description (*Help* -> *Data Model*) or by obtaining the <<getHTMLModel,HTML-description of the model>>.

[[rest_api.commit]]
====== Committing New and Modified Instances, Removal

The commit function enables performing operations on objects passed to it and returning their new state. The format of the result depends on format (JSON or XML) used for the request (the `Content-Type` header).

JSON format:: 
+
--
`application/json` should be used as the value of the `Content-Type` header.

Creating a `Customer` entity with an automatically generated identifier:

[source, json]
----
include::{sourcesdir}/portal/restapi_3.json[]
----

Creating a `Customer` entity with a specified identifier:

[source, json]
----
include::{sourcesdir}/portal/restapi_4.json[]
----

Creating the `Order` entity, specifying a link to a new `Customer` entity and filling the `Customer` entity with attributes:

[source, json]
----
include::{sourcesdir}/portal/restapi_5.json[]
----

Changing two `Customer` entities simultaneously:

[source, json]
----
include::{sourcesdir}/portal/restapi_6.json[]
----

Removing the `Customer` entity with <<soft_deletion,soft deletion>> support:

[source, json]
----
include::{sourcesdir}/portal/restapi_7.json[]
----

* The `commitInstances` array contains created and modified entities.

** When creating an entity, `id` or `NEW-<entityName>` should be specified as the value of the `NEW-<entityName>-<uuid>` field.

** When changing an entity, `<entityName>-<uuid>` should be specified as the value of the `id` field.

** Next, attribute names and values for created or modified entity should be provided in the list of elements, separated by commas.
+
If any attribute should be set to `null` while editing the entity, you must specify the view that includes this attribute, in the identifier. For example:
+
[source, json]
----
include::{sourcesdir}/portal/restapi_8.json[]
----
+
Here, the `customer-edit` view must contain the `channel` attribute, otherwise the value will not change.

* The `removeInstances` array contains removed entities. When removing an entity, you must specify the value of the `id` field. Before deletion, `merge()` will be executed for the provided object, which enables checking if the version of the removed object has changed.

* The `softDeletion` field controls <<soft_deletion,soft deletion>> mode.

The function is called by a POST request to `{host:port}/app-portal/api/commit?s=<sessionId>`. JSON is passed in the request body. The function returns a JSON objects array. For example, the following JSON objects array will be returned when the `email` field of the `Customer` entity is changed:

[source, json]
----
include::{sourcesdir}/portal/restapi_9.json[]
----
--

XML format:: 
+
--
`text/xml` should be used as the value of `Content-Type` header. 

XML format example:

[source, xml]
----
include::{sourcesdir}/portal/restapi_10.xml[]
----

XML document fields semantics is defined in {xsd_url}/restapi-commit-v2.xsd scheme.

In case of an XML request, fields are set to null with the help of the `null="true"` attribute. In addition to that, the identifier must contain the <<views,view>>, which contains the attribute. For example: 

[source, xml]
----
include::{sourcesdir}/portal/restapi_11.xml[]
---- 

The function is called with a POST request to `{host:port}/app-portal/api/commit?s=<sessionId>`. XML is passed in the request body. The request returns array of XML objects similar to the one below: 

[source, xml]
----
include::{sourcesdir}/portal/restapi_12.xml[]
----

The schema containing the description of the function call result is located at {xsd_url}/restapi-instance-v2.xsd
--

[[rest_upload_file]]
====== Uploading Files to Storage

To upload a file to <<file_storage,FileStorage>>, use the POST request `{host:port}/app-portal/api/upload` with the following parameters:

* *s* − current session ID.

* *name* - file name

* *ext* - file extension

* *size* - file size in bytes

File is sent in the request body.

[[rest_download_file]]
====== Downloading Files from Storage

To download a file from <<file_storage,FileStorage>>, use the GET request `{host:port}/app-portal/api/download` with the following parameters:

* *f* − the ID of the corresponding `FileDescriptor` instance.

* *s* − current session ID.

For example:

[source, xml]
----
http://localhost:8080/app-portal/api/download?s=abbfb51c-715d-ced5-cc00-ee355278ea21&f=dbea7543-7761-3680-9b6c-c06f7fdb3738
----


[[getHTMLModel]]
====== Obtaining Data Model Description in HTML Format

The `/printDomain?s=<sessionId>` GET request allows a developer to obtain data model description. The service returns a simple HTML, which contains basic data types list and description of all meta-model entities, their attributes and <<views,views>> defined for entities.

[[rest_api.deployViews]]
====== Creating New Views on Server

The `/deployViews?s=<sessionId>` POST request enables loading to middleware descriptions of <<views,view>> objects, required for the client. The view objects are sent as standard XML description of a view used in the platform. XML is placed in the request body. For more information about the format, see <<views>>.

[[rest_api.invokeService]]
====== Service Calls

<<services,Service>> methods available for API calls are listed in a configuration file. The name of the file is defined by the <<cuba.restServicesConfig,cuba.restServicesConfig>> property.

A sample REST API services configuration file:

[source, xml]
----
include::{sourcesdir}/portal/restapi_13.xml[]
----

Service method call can be performed both by GET and POST requests. Additionally, POST requests allow passing entities or entity collections to the invoked method.

*Service Call by GET Request*

Request format:

[source, url]
----
{host:port}/app-portal/api/service.<format>?service=<serviceName>&method=<methodName>&view=<view>&param0=<value 0>&paramN=<value N>&param0_type=<type 0>&paramN_type=<type N>&s=<sessionId>
----

* `format` - defines the output format. Two values are accepted: `xml` or `json`.

* `service` - the name of the service called.

* `method` - the name of the method invoked.

* `param0 .. paramN` - parameter values of the method.

* `++param0_type .. paramN_type++` - parameter types of the method.

* `s` - the current session identifier.

If a service has a single method with the specified name and number of parameters, explicit parameter type definition is not required. In other cases, parameter type must be specified.

*Service Call by POST Request*

Request format:

[source, url]
----
{host:port}/app-portal/api/service?s=<sessionId>
----

* `s` - the current session identifier.

JSON or XML with the description of the method call is passed in the request body.

JSON format:: 
+
--
The `Content-Type` header value is `application/json`.

[source, json]
----
include::{sourcesdir}/portal/restapi_14.json[]
----

Properties of the passed object:

* `service` - the name of the service called.

* `method` - the name of the method invoked.

* `param0 .. paramN` - method parameter values.

* `++param0_type .. paramN_type++` - method parameter types.

--

XML format:: 
+
--
The `Content-Type` header value is `text/xml`.

[source, xml]
----
include::{sourcesdir}/portal/restapi_15.xml[]
----

The main elements of the passed document are:

* `service` - the name of the service called.

* `method` - the name of the method invoked.

* `param` - the value of the parameter method or the parameter type. The name of the parameter (`name` attribute) must have the format `param0 .. paramN` or `++param0_type .. paramN_type++`.

If a service has a single method with the specified name and number of parameters, explicit parameter type definition is not required. In other cases, parameter types must be specified.

`<param>` element may contain both plain text (for setting primitive type values) and nested `<instance>` elements for entities or `<instances>` for entity collections.

The XSD of the request is available at {xsd_url}/restapi-service-v2.xsd.
--

*Supported Service Method Parameter Types*

* primitive Java types. `long`, `int`, `boolean`, etc. should be specified as the type name.

* primitive Java type wrappers. The full class name should be specified as the type name: `java.lang.Boolean`, `java.lang.Integer`, etc.

* string (`java.lang.String`).

* date (`java.util.Date`).

* UUID (`java.util.UUID`).

* BigDecimal (`java.math.BigDecimal`)

* entity (for POST requests only). The full class name should be specified as the type name, e.g. `com.haulmont.cuba.security.entity.User`.

* entity collections (for POST requests only). The full class or collection interface name should be specified as the type name, e.g. `java.util.List`.

*Service Call Result*

The result may be in JSON or XML, depending on the method call declaration. Currently, methods can return primitive data types, entities and entity collections.

Example of a JSON result::: 
+
--
Primitive data type:

[source, json]
----
include::{sourcesdir}/portal/restapi_16.json[]
----

Entity:

[source, json]
----
include::{sourcesdir}/portal/restapi_17.json[]
----
--

Example of XML result::: 
+
--
Primitive data type:

[source, xml]
----
include::{sourcesdir}/portal/restapi_18.xml[]
----

Entity:

[source, xml]
----
include::{sourcesdir}/portal/restapi_19.xml[]
----

The XSD of the result is available at {xsd_url}/restapi-service-v2.xsd.
--