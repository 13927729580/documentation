[[chapter_security]]
== Security Subsystem

The CUBA platform uses the following methods to control access rights: 

* The <<roles,role-based>> system for assigning user <<permissions,permissions>>. A set of roles and permissions can be configured by the system administrator during the system deployment or later in production.

* A hierarchical structure of <<groups,access groups>> with <<constraints,constraint>> inheritance.

* Access control at the following levels: 

** Operations on entities (read, create, update, delete): for example, user Smith can view documents, but cannot create, update or delete them.

** Entity attributes (modify, read, access denied): user Smith can view all document attributes except for `amount`.

** Access to particular entity instances (access control at the row level): user Smith can view the documents that have been created in their department only.

* Integration with <<ldap,LDAP>> with an ability to implement SSO (Single Sign-On) for *Windows* users. 

[[security_components]]
=== Security Subsystem Components

The main CUBA security subsystem components are shown in the diagram below. 

.Security Subsystem Components Diagram
Below is an overview of these components. 

Security management screens – screens available to system administrator for configuring <<users,user>> access rights.

Login screen − system <<login_screen,login>> window. This window provides user authentication by username and password. The database stores password hashes for security.

The <<userSession,UserSession>> object is created upon login. This is the central security element associated with the currently authenticated user and containing information on data access rights.

The user login process is described in <<login,>>.

Roles − user roles. A <<roles,role>> is a system object, which, on the one hand, matches the <<permissions,permission>> set required to perform specific functions, and on the other hand, the subset of users who must have these permissions.

The permissions can have the following types:

* Screen Permissions − an ability to open a screen.

* Entity Operation Permissions − an ability to perform operations with an entity: read, create, update, delete.

* Entity Attribute Permissions − access to an arbitrary entity attribute: modify, read only, access denied.

* Specific Permissions − permissions for some named functionality.

* UI Permissions − control access to screen elements. 

Access Groups − user access groups. The <<groups,groups>> have a hierarchical structure, with each element defining a set of <<constraints,constraints>>, allowing controlling access to individual entity instances (at table row level). For example, users can view the documents that have been created in their department only.

[[login_screen]]
==== Login Screen

The login screen provides ability to register within the system with a username and password.

The login is case-insensitive.

The Web Client screen class is `LoginWindow`, the Desktop Client class is `LoginDialog`. These classes can be extended to provide additional functionality in the application. Override the following methods to register extended classes:

*  `createLoginWindow()` method of the `com.haulmont.cuba.web.App` class for the <<gui_web,Web Client>>.

*  `createLoginDialog()` method of the `com.haulmont.cuba.desktop.App` class for the <<gui_desktop,Desktop Client>>.

The Web Client&rsquo;s *Remember Me* checkbox can be configured by using the <<cuba.web.rememberMeEnabled,cuba.web.rememberMeEnabled>> application property.

The drop-down list of supported languages on the standard login screen can be configured with the <<cuba.localeSelectVisible,cuba.localeSelectVisible>> and <<cuba.availableLocales,cuba.availableLocales>> application properties.

[[users]]
==== Users

Each system user has a corresponding instance of `sec$User` entity, containing unique login, password hash, reference to access group and list of roles, and other attributes. User management is carried out using the *Administration* &gt; *Users screen*: 

image::security_user_browser.png[align="center"]

In addition to the standard actions to create, update and delete records, the following actions are available:

* *Copy* – quickly creates a new user based on the selected one. The new user will have the same access group and role set. Both can be changed in the new user edit screen.

* *Copy settings* – allows copying user interface settings from one user to several others. The settings include the <<gui_Table_presentations,table presentations>>, the <<gui_SplitPanel,SplitPanel>> separator position, <<gui_Filter,filters>> and <<folders_pane,search folders>>.

* *Change password* – allowing changing password for a selected user.

* *Reset passwords* – allows performing the following actions on selected users:

** If *Generate new passwords* flag is not selected in the *Reset passwords for selected users* dialog, the *Change password at next logon* flag will be assigned to selected users. These users will be asked to change the password on the next successful login.

** If *Generate new passwords flag* is selected, new random passwords will be generated for selected users and displayed to the system administrator. The list of passwords can be exported to XLS and sent to related users. Additionally, the *Change password at next logon* flag will be set for each user, ensuring that users change the password on next login.

** If *Send emails with generated passwords* flag is selected in addition to *Generate new passwords*, the automatically generated one-time passwords will be sent to corresponding users directly, and not shown to system administrator.

The user edit screen is described below:

image::security_user_editor.png[align="center"]

* *Login* – unique login name (required).

* *Group* – <<groups,access group>>.

* *Last name*, *First name*, *Middle name* – parts of user&rsquo;s full name.

* *Name* – automatically generated user&rsquo;s full name. Based on full name parts above and a rule defined in the <<cuba.user.fullNamePattern,cuba.user.fullNamePattern>> application property. The name can also be changed manually.

* *Position* – job position.

* *Language* – the user interface language that will be set for the user, if the ability to choose a language on login is turned off using the <<cuba.localeSelectVisible,cuba.localeSelectVisible>> application property.

* *Time Zone* – the <<timeZone,time zone>> that will be used for displaying and entering timestamp values.

* *Email* – email address.

* *Active* – if not set, the user is unable to login to the system.

* *Permitted IP Mask* – IP address mask, defining addresses from which the user is allowed to login.
+
The mask is a list of IP addresses, separated with commas. Both the IPv4 and IPv6 address formats are supported. IPv4 address should consist of four numbers separated with periods. IPv6 address represents eight groups of four hexadecimal characters separated with colons.The "*&rdquo; symbol can be used in place of an address part, to match any value. Only one type of address format (IPv4 or IPv6) can be used in the mask at the same time. 
+
Example: `++192.168.*.*++`

* *Roles* – user <<roles,roles>> list.

* *Substituted Users* – <<user_substitution,substituted>> users list.

[[user_substitution]]
===== User Substitution

The system administrator can give a user an ability to substitute another user. The substituting user will have the same <<userSession,session>>, but a different set of <<roles,roles>>, <<constraints,constraints>> and <<session_attr,attributes>>, assigned from the substituted user.

[TIP]
====
It is recommended to use the `UserSession.getCurrentOrSubstitutedUser()` method for retrieving the current user in the application code, which returns the substituted user, if there is an active substitution. The platform audit mechanisms (the `createdBy` and `updatedBy` attributes, <<entity_log,change log>> and <<entity_snapshots,entity snapshots>>) always register the real logged-in user. 
====

If the user has substituted users, a drop-down list will be shown in the application upper right corner instead of the plain text with the current user name:

image::user_subst_select.png[align="center"]

If another user is selected in this list, all opened screens will be closed and the substitution will be made active. The `UserSession.getUser()` method will still return the user that has logged in, however, the `UserSession.getSubstitutedUser()` method will return the substituted user. If there is no substitution, the `UserSession.getSubstitutedUser()` method will return `null`. 

Substituted users can be managed through the *Substituted Users* table in the user edit screen. The user substitution screen is described below:

image::user_subst_edit.png[align="center"]

* *User* – the edited user. This user will substitute another user.

* *Substituted user* – the substituted user.

* *Start date*, *End date* – optional substitution period. User substitution will be unavailable outside of this period. If no period is specified, substitution will be available until this table entry is removed.

[[timeZone]]
===== Time Zone

By default, all temporal values are displayed in the server's time zone. The server's time zone is the one returned by `TimeZone.getDefault()` method of an application <<app_tiers,block>>. This default time zone is typically obtained from the operating system but can be set explicitly by `user.timezone` Java system property. For example, to set the time zone to GMT for web client and middleware running on Tomcat under Unix, add the following line to tomcat/bin/setenv.sh file: 

[source, properties]
----
CATALINA_OPTS="$CATALINA_OPTS -Duser.timezone=GMT"
---- 

A user can view and edit timestamp values in a time zone different from server's time zone. There are two ways to manage user's time zone: 

* An administrator can do it in the User editor screen.

* The user can change his time zone in the *Help &gt; Settings* window. 

In both cases, the time zone settings consist of two fields: 

* Time zone name dropdown allows a user to select the time zone explicitly.

* *Auto* checkbox indicates that the time zone will be obtained from the current environment (web browser for the web client or OS for the desktop client). 

If both fields are empty, no time zone conversions are performed for the user. Otherwise, the platform saves time zone in the <<userSession,UserSession>> object when user logs in and uses it for displaying and entering timestamp values. The application code can also use the value returned by `UserSession.getTimeZone()` for custom functionality.

If a time zone is in use for the current session, its short name and offset from GMT are displayed in the application main window next to the current user's name.

[TIP]
====
Time zone conversions are performed only for <<datatype,DateTimeDatatype>> entity attributes, i.e., timestamps. Attributes storing date (`DateDatatype`) and time (`TimeDatatype`) separately are not affected. You can also deny conversions for a timestamp attribute by annotating it with <<ignoreUserTimeZone,@IgnoreUserTimeZone>>.
====

[[permissions]]
==== Permissions

The permission determines the user&rsquo;s right to any system object or functionality, such as screen, entity operation, etc. The permission can either grant the user the right to the object, or revoke it (in essence, it is actually a prohibition).

[TIP]
====
By default, the user has the right to an object, unless explicitly denied by a permission.
====

The permissions are granted by the `sec$Permission` entity instances and contain the following attributes:

* `type` – permission type: determines the object type the permission is imposed on.

* `target` – permission object: determines the specific object the permission is imposed on. The format of the attribute depends on the permission type.

* `value` – permission value. The value range depends on the permission type.

The permission types are described below:

* `PermissionType.SCREEN` – screen permission.
+
The screen identifier should be specified in the `target` attribute; the `value` attribute can be 0 or 1 (the screen is denied or allowed, respectively).
+
The screen permissions are checked when building the system main menu and with each invocation of the `openWindow()`, `openEditor()`, `openLookup()` methods of the <<abstractFrame,IFrame>> interfaces.
+
To check the screen permission in the application code, use the `isScreenPermitted()` method of the <<security,Security>> interface.

* `++PermissionType.ENTITY_OP++` – entity operation permission.
+
The entity name should be specified in the `target` attribute, followed by a colon, and then an operation type: `create`, `read`, `update`, `delete`. For example: library$Book:delete. The `value` attribute can be 0 or 1 (the operation is denied or allowed, respectively).
+
The entity operation permissions are checked when working with data through the <<dataManager,DataManager>>, in data aware <<gui_components,visual components>>, and in <<standard_actions,standard actions>>, which work with entity lists. As a result, the operation permissions affect the behavior of the client blocks and the <<rest_api,REST API>>. The permissions are not checked when working with data on the Middleware directly via the <<entityManager,EntityManager>>.
+
To check the entity operation permission in the application code, use the `isEntityOpPermitted()` method of the <<security,Security>> interface.

* `++PermissionType.ENTITY_ATTR++` – entity attribute permission.
+
The entity name should be specified in the `target` attribute, followed by a colon, and then an attribute name. For example: library$Book:name. The `value` attribute can be 0, 1 or 2 (the attribute is hidden, read-only or read-write, respectively).
+
The entity attribute permissions are only checked in the data aware <<gui_components,visual components>> and the <<rest_api,REST API>>.
+
To check the entity attribute permission in the application code, use the `isEntityAttrPermitted()` method of the <<security,Security>> interface.

* `PermissionType.SPECIFIC` – permission on an arbitrary named functionality.
+
The functionality identifier should be specified in the `target` attribute; the `value` attribute can be 0 or 1 (denied or allowed, respectively).
+
Specific permissions for this project are set in the configuration file <<permissions.xml,permissions.xml>>.
+
For example:
+
[source, java]
----
@Inject
private Security security;

private void calculateBalance() {
    if (!security.isSpecificPermitted("myapp.calculateBalance"))
        return;
    ...
}
----

* `PermissionType.UI` – arbitrary screen component permission.
+
The screen identifier should be specified in the `target` attribute, followed by a colon, and then a component path. The format of the component path is described in the next section.

[TIP]
====
To check permissions, instead of directly using methods of the `UserSession` class, it is recommended to use the same methods of <<security,Security>> interface that works with possible entity <<entity_extension,extension>>.
====

[[roles]]
==== Roles

The role combines a set of <<permissions,permissions>> that can be granted to the user.

The user may have several roles, in which case a logical sum (OR) is devised from all of the assigned roles. For example, if a user has roles A, B and C, role A denies X, role B allows X, role C does not set explicit permissions on X, then X will be allowed.

If no user roles explicitly define permission on the object, the user will have the permission for this object. Therefore, the users have rights to all the objects if they have no roles that explicitly define the permission, or have at least one role that grants the permission.

[WARNING]
====
If a user has a single role without explicitly set permissions, or does not have any roles at all, he will have all rights to all objects. 
====

The role list is displayed in the *Administration* &gt; *Roles screen*. In addition to the standard actions to create, update, and delete records, the screen has the *Assign to users* button, allowing assigning the selected role to multiple users.

The role edit screen is described below. The role attributes are displayed in the upper part: 

image::role_attributes.png[align="center"]

* *Name* – unique role name or id (required). The name cannot be changed after the role has been created.

* *Localized name* – user-friendly role name.

* *Description* – arbitrary role description.

* *Type* – role type, can be:

** *Standard* – the role of this type grants only explicitly set permissions.

** *Super* – the role of this type automatically grants all permissions. It should be assigned to system administrators, since it removes all prohibitions set by other roles.

** *Read-only* – the role of this type automatically denies the permissions for the following entity operations: CREATE, UPDATE, DELETE. Therefore, the user with this role can only read the data and is unable to update it (unless there are other user roles explicitly allowing these operations).

**  *Denying* – the role of this type automatically denies the permissions for all objects, except entity attributes. In order to view or update something in the system, the user should be assigned an additional role that explicitly gives the necessary rights. 
+
Permissions can be explicitly set for all the role types; for example, you can add the permissions to modify entities for the *Read-only* role. However, it does not make sense to prohibit anything for the *Super* role, because this special role type removes all prohibitions. 

+
[WARNING]
====
A user with the *Denying* role cannot login to web or desktop client, because this type of role also revokes the `cuba.gui.loginToClient` specific permission (displayed as "Login to client" in the list of specific permissions). Therefore you have to grant this permission to users explicitly - either in another role, or right in the denying role.
====

* *Default role* – default role flag. All roles with this flag are automatically assigned to the newly created users.

The permission management tabs are described below.

* The *Screens* tab configures screen permissions:

image::role_screen_permissions.png[align="center"]

+
The tree in the left part of the tab reflects the structure of the application&rsquo;s main menu. The last tree element is *Other screens*, which contains screens without a main menu item (for example, entity edit screens).

* The *Entities* tab – configures entity operation permissions:

image::role_entity_permissions.png[align="center"]

+
The *Assigned only* is selected by default, so that the table contains only the entities that have explicit permissions in this role. Therefore, the table for a new role will be empty. In order to add permissions, uncheck *Assigned only* and click *Apply*. The entity list can be filtered by entering a part of an entity name in the *Entity* field and clicking *Apply*.
+
*System level* checkbox allows viewing and selecting system entities marked with the `@SystemLevel` annotation, which are not shown by default.

* The *Attributes* tab – configures entity attribute permissions:

image::role_attr_permissions.png[align="center"]

+
The *Permissions* column in the entity table shows the list of the attributes that have explicit permissions. The *modify* (full access) permissions are marked with green, *read-only* (read-only) – with blue, *hide* (the attribute is hidden) – with red.
+
Entity list can be managed similarly to the list in the *Entities* tab.

* The *Specific* tab configures named functionality permissions:

image::role_specific_permissions.png[align="center"]

+
The <<permissions.xml,permissions.xml>> project configuration file defines the object names to which specific permissions can be assigned.

* The *UI* tab configures UI screen component permissions:

image::role_ui_permissions.png[align="center"]

+
The permissions on this screen allow restricting access to any screen component, including the ones not associated with any data (for example, a container). The component identifiersmust be known to create such permissions, therefore access to the screen source code is required.
+
In order to create a constraint, select the desired screen in the *Screen* drop-down list, specify the component path in the *Component* field, and click *Add*. Then set the access mode for the selected component in the *Permissions* panel.
+
The rules to forming the component path are listed below:

** If the component belongs to the screen, simply specify the component identifier, `id`.

** If the component belongs to the frame that is embedded within the screen, specify the frame identifier, and then the component identifier separated with period.

** If configuring permission for the <<gui_TabSheet,TabSheet>> tab or the <<gui_FieldGroup,FieldGroup>> field, specify the component identifier, and then the tab or field identifier in square brackets.

** To configure permission for an <<gui_Action,action>>, specify the component, holding the action, and then the action identifier in angle brackets. For example: `customersTable&lt;changeGrade&gt;`.

[[groups]]
==== Access Groups

With access groups, users can be organized into a hierarchical structure and assigned <<constraints,constraints>> and arbitrary <<session_attr,session attributes>>.

The user can be added to one group only, however the list of constraints and session attributes from all the groups up the hierarchy will be inherited.

User access groups can be managed from the *Administration* &gt; *Access Groups* screen:

image::group_users.png[align="center"]

[[constraints]]
===== Constraints

Constraints allow restricting access to particular entity instances (table records).

Constraints for an entity class are specified using <<jpql,JPQL>> expression fragments. These fragments are appended to all entity instance selection queries, thereby filtering them.

The user gets the constraint list from all the groups, starting with their own one, following up the hierarchy. Thus, the following principle is implemented: the lower the users are in the group hierarchy, the more constraints they have.

In order to create a constraint in the *Access Groups* screen, select the group to create the constraint for, go to the *Constraints* tab and click *Create*:

image::constraint_edit.png[align="center"]

Then, select an entity from the *Entity Name* drop-down list and set the constraint in the *Join Clause* and *Where Clause* fields.
[TIP]
====
The JPQL editor in the *Join Clause* and *Where Clause* fields supports autocompletion for entity names and their attributes. In order to invoke autocompletion, press Ctrl+Space. If the invocation is made after the period symbol, an entity attributes list matching the context will be shown, otherwise – a list of all data model entities.
====

The following JPQL constraint rules apply:

* The `{E}` string should be used as an alias of the entity being extracted. On execution of the query, it will be replaced with a real alias, specified in the query.

* The following predefined constants can be used in JPQL parameters:

** `session$userLogin` – login name of the current user (in case of <<user_substitution,substitution>> – the login name of the substituted user).

** `session$userId` – ID of the current user (in case of substitution – ID of the substituted user).

** `session$userGroupId` – group ID of the current user (in case of substitution − group ID of the substituted user).

** `session$XYZ` – arbitrary attribute of the current <<userSession,user session>>, where XYZ is the attribute name.

* The *Where Clause* field content is added to the `where` query clause using `and` condition. Adding `where` word is not needed, as it will be added automatically.

* The *Join Clause* field content is added to the `from` query clause. It should begin with a comma, `join` or `left join`.

The simplest constraint example is shown in the figure above: the users with this constraint will see the `library$BookPublication` entity instances that they have created themselves only. 

[[session_attr]]
===== Session Attributes

The access group can determine the <<userSession,session>> attribute list for the users in this group. These attributes can be used when setting the <<constraints,constraints>>. The availability of the session attributes can be checked in the application code at the development stage, so the final system behavior for particular user groups can be controlled at the operation stage. 

When logging in, all the attributes set for the user group and for all the groups up the hierarchy will be placed into the user session. If an attribute is found in several levels of the hierarchy, the uppermost group value will be used. Hence, overriding the attribute values at the lower levels of the hierarchy is not possible. In case of the override attempt, the `WARN` level message will be written to the server <<logging_setup_tomcat,log>>. 

In order to create an attribute in the *Access Groups* screen, select the group to create the attribute for, go to the *Session Attributes* tab, and click *Create*:

image::session_attr_edit.png[align="center"]

A unique attribute name, data type, and value must be specified. 

A <<userSession,session>> attribute can be accessed in the application code in the following way:

[source, java]
----
@Inject
private UserSessionSource userSessionSource;
...
Integer accessLevel = userSessionSource.getUserSession().getAttribute("accessLevel");
----

A session attribute can be used in the <<constraints,constraints>> as a JPQL parameter by adding the `session$` prefix:

[source, sql]
----
{E}.accessLevel = :session$accessLevel
----

[[ldap]]
==== Integration with LDAP

CUBA application can be integrated with LDAP to provide the following benefits:

. Keep and manage user passwords centrally in the LDAP database.

. For Windows domain users, allow logging in through Single Sign-On without having to specify the username and password.

To enable login, a user account with all the required properties and permissions must be created in the application. It is recommended to leave the password empty, so that the user could log in using the password from LDAP only. The first authentication attempt is made via LDAP, followed by the standard way of using the password hash from the database. As a result, a user can log in to the system with this password even if the user is not registered in LDAP or has a different LDAP password.

A CUBA-based application interacts with LDAP via the `CubaAuthProvider` interface. The platform includes a single implementation of this interface, `LdapAuthProvider`, which supports LDAP authentication without Single Sign-On. In order to enable advanced Active Directory integration and Single Sign-On, the *Jespa* library can be used with the corresponding `CubaAuthProvider` implementation, as described in <<jespa,>>. A custom `CubaAuthProvider` implementation class can also be used by setting the following application properties:

[source, properties]
----
cuba.web.useActiveDirectory = true
cuba.web.activeDirectoryAuthClass = com.company.sample.web.MyAuthProvider
----

[[ldap_basic]]
===== Basic Active Directory Integration

If the `cuba.web.useActiveDirectory` property is enabled, the `LdapAuthProvider` class is used by default. In this case, *Spring LDAP* library is used for user authentication.

The following Web Client application properties are used to setup:

* `cuba.web.ldap.urls` – Active Directory server URL.

* `cuba.web.ldap.base` – database for username search.

* `cuba.web.ldap.user` – `sAMAccountName` attribute value of the user, which has the right to read the information from the Active Directory.

* `cuba.web.ldap.password` – the password for the LDAP user defined in the `cuba.web.ldap.user` property.

Example of <<app_properties_files,local.app.properties>> file for the Web Client block:

[source, properties]
----
cuba.web.useActiveDirectory = true
cuba.web.ldap.urls = ldap://192.168.1.1:389
cuba.web.ldap.base = ou=Employees,dc=mycompany,dc=com
cuba.web.ldap.user = myuser
cuba.web.ldap.password = mypassword
----

[[jespa]]
===== Setting Up Authentication Using Jespa

Jespa is a Java library that enables integrating Active Directory service and Java applications using NTLMv2. For details, see http://www.ioplex.com. 

====== Including the Library

Download the library at http://www.ioplex.com and place the JAR in a <<artifact_repository,repository>> registered in your <<build.gradle,build.gradle>> script. This can be `mavenLocal()` or an in-house repository.

Add the following dependency to the *web* module configuration section in build.gradle:

[source, groovy]
----
configure(webModule) {
    ...
    dependencies {
        compile('com.company.thirdparty:jespa:1.1.17')
    ...    
----

Create a `CubaAuthProvider` implementation class in the *web* module:

[source, java]
----
package com.company.sample.web;

import com.haulmont.cuba.core.global.AppBeans;
import com.haulmont.cuba.core.global.Configuration;
import com.haulmont.cuba.core.global.GlobalConfig;
import com.haulmont.cuba.core.global.Messages;
import com.haulmont.cuba.core.sys.AppContext;
import com.haulmont.cuba.security.global.LoginException;
import com.haulmont.cuba.web.auth.ActiveDirectoryHelper;
import com.haulmont.cuba.web.auth.CubaAuthProvider;
import com.haulmont.cuba.web.auth.DomainAliasesResolver;
import jespa.http.HttpSecurityService;
import jespa.ntlm.NtlmSecurityProvider;
import jespa.security.PasswordCredential;
import jespa.security.SecurityProviderException;
import org.apache.commons.lang.StringUtils;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

import javax.inject.Inject;
import javax.servlet.*;
import javax.servlet.http.HttpServletRequest;
import java.io.IOException;
import java.util.HashMap;
import java.util.Locale;
import java.util.Map;

public class JespaAuthProvider extends HttpSecurityService implements CubaAuthProvider {

    private static class DomainInfo {
        private String bindStr;
        private String acctName;
        private String acctPassword;

        private DomainInfo(String bindStr, String acctName, String acctPassword) {
            this.acctName = acctName;
            this.acctPassword = acctPassword;
            this.bindStr = bindStr;
        }
    }

    private static Map<String, DomainInfo> domains = new HashMap<>();

    private static String defaultDomain;

    private Log log = LogFactory.getLog(getClass());

    @Inject
    private Configuration configuration;

    @Inject
    private Messages messages;

    @SuppressWarnings("deprecation")
    @Override
    public void init(FilterConfig filterConfig) throws ServletException {

        initDomains();

        Map<String, String> properties = new HashMap<>();

        properties.put("jespa.bindstr", getBindStr());
        properties.put("jespa.service.acctname", getAcctName());
        properties.put("jespa.service.password", getAcctPassword());
        properties.put("jespa.account.canonicalForm", "3");
        properties.put("jespa.log.path", configuration.getConfig(GlobalConfig.class).getLogDir() + "/jespa.log");
        properties.put("http.parameter.anonymous.name", "anon");

        fillFromSystemProperties(properties);

        try {
            super.init(properties);
        } catch (SecurityProviderException e) {
            throw new ServletException(e);
        }
    }

    @Override
    public void destroy() {
    }

    @Override
    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)
            throws IOException, ServletException {
        HttpServletRequest httpServletRequest = (HttpServletRequest) request;
        if (httpServletRequest.getHeader("User-Agent") != null) {
            String ua = httpServletRequest.getHeader("User-Agent").toLowerCase();
            boolean windows = ua.contains("windows");
            boolean gecko = ua.contains("gecko") && !ua.contains("webkit");
            if (!windows && gecko) {
                chain.doFilter(request, response);
                return;
            }
        }
        super.doFilter(request, response, chain);
    }

    @Override
    public void authenticate(String login, String password, Locale loc) throws LoginException {
        DomainAliasesResolver aliasesResolver = AppBeans.get(DomainAliasesResolver.NAME);

        String domain;
        String userName;

        int atSignPos = login.indexOf("@");
        if (atSignPos >= 0) {
            String domainAlias = login.substring(atSignPos + 1);
            domain = aliasesResolver.getDomainName(domainAlias).toUpperCase();
        } else {
            int slashPos = login.indexOf('\\');
            if (slashPos <= 0) {
                throw new LoginException(
                        messages.getMessage(ActiveDirectoryHelper.class, "activeDirectory.invalidName", loc),
                        login
                );
            }
            String domainAlias = login.substring(0, slashPos);
            domain = aliasesResolver.getDomainName(domainAlias).toUpperCase();
        }

        userName = login;

        DomainInfo domainInfo = domains.get(domain);
        if (domainInfo == null) {
            throw new LoginException(
                    messages.getMessage(ActiveDirectoryHelper.class, "activeDirectory.unknownDomain", loc),
                    domain
            );
        }

        Map<String, String> params = new HashMap<>();
        params.put("bindstr", domainInfo.bindStr);
        params.put("service.acctname", domainInfo.acctName);
        params.put("service.password", domainInfo.acctPassword);
        params.put("account.canonicalForm", "3");
        fillFromSystemProperties(params);

        NtlmSecurityProvider provider = new NtlmSecurityProvider(params);
        try {
            PasswordCredential credential = new PasswordCredential(userName, password.toCharArray());
            provider.authenticate(credential);
        } catch (SecurityProviderException e) {
            throw new LoginException(
                    messages.getMessage(ActiveDirectoryHelper.class, "activeDirectory.authenticationError", loc),
                    e.getMessage()
            );
        }
    }

    private void initDomains() {
        String domainsStr = AppContext.getProperty("cuba.web.activeDirectoryDomains");
        if (!StringUtils.isBlank(domainsStr)) {
            String[] strings = domainsStr.split(";");
            for (int i = 0; i < strings.length; i++) {
                String domain = strings[i];
                domain = domain.trim();
                if (!StringUtils.isBlank(domain)) {
                    String[] parts = domain.split("\\|");
                    if (parts.length != 4) {
                        log.error("Invalid ActiveDirectory domain definition: " + domain);
                        break;
                    } else {
                        domains.put(parts[0], new DomainInfo(parts[1], parts[2], parts[3]));
                        if (i == 0)
                            defaultDomain = parts[0];
                    }
                }
            }
        }
    }

    public String getDefaultDomain() {
        return defaultDomain != null ? defaultDomain : "";
    }

    public String getBindStr() {
        return getBindStr(getDefaultDomain());
    }

    public String getBindStr(String domain) {
        initDomains();
        DomainInfo domainInfo = domains.get(domain);
        return domainInfo != null ? domainInfo.bindStr : "";
    }

    public String getAcctName() {
        return getAcctName(getDefaultDomain());
    }

    public String getAcctName(String domain) {
        initDomains();
        DomainInfo domainInfo = domains.get(domain);
        return domainInfo != null ? domainInfo.acctName : "";
    }

    public String getAcctPassword() {
        return getAcctPassword(getDefaultDomain());
    }

    public String getAcctPassword(String domain) {
        initDomains();
        DomainInfo domainInfo = domains.get(domain);
        return domainInfo != null ? domainInfo.acctPassword : "";
    }

    public void fillFromSystemProperties(Map<String, String> params) {
        for (String name : AppContext.getPropertyNames()) {
            if (name.startsWith("jespa.")) {
                params.put(name, AppContext.getProperty(name));
            }
        }
    }
}
----

====== Setting Up Configuration

* Follow the steps described in *Installation* -&gt; *Step 1: Create the Computer Account for NETLOGON Communication* of the *Jespa Operator's Manual*, which is available at http://www.ioplex.com/support.html.

* Set domain parameters in the `cuba.web.activeDirectoryDomains` property in the <<app_properties_files,local.app.properties>> file. Each domain descriptor should have the following format: `++domain_name|full_domain_name|service_account_name|service_account_password++`. Domain descriptors are separated by semicolons. 
+
Example:
+
[source, properties]
----
cuba.web.activeDirectoryDomains = MYCOMPANY|mycompany.com|JESPA$@MYCOMPANY.COM|password1;TEST|test.com|JESPA$@TEST.COM|password2
----

* Enable the Active Directory integration by setting the `cuba.web.useActiveDirectory` property in the local.app.properties file:
+
[source, properties]
----
cuba.web.useActiveDirectory = true
----

* Configure additional Jespa properties in the local.app.properties file (see *Jespa Operator's Manual*). For example:
+
[source, properties]
----
jespa.log.level=3
----

* Add the server address to the local intranet in the browser settings:

** For *Internet Explorer* and *Chrome*: Settings -&gt; Security -&gt; Local intranet -&gt; Sites -&gt; Advanced

** For * Firefox*: about:config -&gt; network.automatic-ntlm-auth.trusted-uris=http://myapp.mycompany.com

[[security_examples]]
=== Access Control Examples

This section provides some practical recommendations on how to configure data access for users.

[[roles_example]]
==== Configuring Roles

The recommended way to configure <<roles,roles>> and <<permissions,permissions>> is as follows:

. Create a Default role, which denies all system rights. Create a role with *Denying* type and select the *Default role* checkbox to automatically assign this role to all new users.

. Create a set of roles for granting specific rights to different user categories. There are two strategies for creating such roles:

* Coarse-grained roles – each role has a permission set for the full range of user responsibilities in the system. For example, Sales Manager, Accountant. Only one role is assigned to each user when using this strategy, excluding the Default role.

* Fine-grained roles – each role has a small permission set to execute specific functions within the system. For example, Task Creator, References Editor. Each user will then be assigned numerous roles according to their range of responsibilities.
+
The strategies can also be combined.

. It is possible to leave the system administrator without any assigned roles, in which case, they will have all the rights to all the system objects. Alternatively a *Super* type role, overriding any restriction imposed by other roles, can be assigned.

[[local_admins_example]]
==== Creating Local Administrators

The hierarchical structure of <<groups,access groups>> combined with the <<constraints,constraints>> inheritance allows creating _local administrators_, by delegating creation and configuration of users and their rights under organization departments.

The local administrators have access to the security subsystem screens; however they only see the users and groups in their access group and below. Local administrators can create subgroups and users and <<roles,assign>> roles available in the system, however they will have at least the same constraints as the administrator who created them.

The global administrator in the root access group should create the roles that will be available to the local administrators for assigning to the users. The local administrators should not be able to create and update the roles.

An example access group structure is presented below:

image::local_admins_groups.png[align="center"]

Problem:

* The users under the Departments group should only see the users of their own group and the groups below.

* Each subgroup – Dept 1, Dept 2, etc. should have its own administrator, who can create users and assign them the available roles.

Solution:

* Add the following constraints for the Departments group:

image::local_admins_constraints.png[align="center"]

** For the `sec$Group` entity:
+
[source, sql]
----
{E}.id in (
  select h.group.id from sec$GroupHierarchy h
  where h.group.id = :session$userGroupId or h.parent.id = :session$userGroupId
)
----
+
With this constraint, the users will not be able to see the groups higher than their own.

** For the `sec$User` entity:
+
[source, sql]
----
{E}.group.id in (
  select h.group.id from sec$GroupHierarchy h
  where h.group.id = :session$userGroupId or h.parent.id = :session$userGroupId
)
----
+
With this constraint, the users will not be able to see the users in groups higher than their own.

** For the `sec$User` entity:
+
[source, sql]
----
({E}.description is null or {E}.description not like '[hide]')
----
+
With this constraint, the users will not be able to view the roles that have the [hide] string in the `description` attribute.

* Create a role that denies editing roles and permissions:

image::local_admins_role.png[align="center"]

** Select the *Default* role checkbox:

** Add the [hide] string to the *Description* field.

** In the *Entities* tab, deny *create*, *update* and *delete* operations for the `sec$Role` and `sec$Permission` entities (to add permissions for the `sec$Permission` object, select the *System level* checkbox).
+
All created users, including the local administrators, will get the local_user role. This role is invisible to the users in the Departments group, so even the local administrators are unable to unassign this role from themselves. Local administrators can only operate on the existing roles that have been created for them by the global administrator. Obviously, the roles available to department users should not remove restrictions imposed by the local_user role.