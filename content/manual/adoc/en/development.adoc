[[development]]
== Application Development

This chapter contains practical information on how to create platform-based applications.

[[recommended_code_style]]
=== Recommended Code Style

*Code Formatting*

* For Java and Groovy code, it is recommended to follow the standard style described in link:http://www.oracle.com/technetwork/java/codeconvtoc-136057.html[Code Conventions for the Java Programming Language]. When programming in *IntelliJ IDEA*, you can just use the default style and Ctrl-Alt-L shortcut for formatting.
+
The maximum line length is 120 characters. The indentation is 4 characters; using spaces instead of tabs is enabled.

* XML code: indentation is 4 characters; using spaces instead of tabs is enabled.

*Naming Conventions*

[cols="3*.^", frame="all", options="header"]
|===

^| Identifier ^| Naming Rule ^| Example

3+^| *Java and Groovy classes*

| Screen controller class
| UpperCamelCase

Browse screen controller `− {EntityClass}Browse`

Edit screen controller `− {EntityClass}Edit`.

| `CustomerBrowse`

`OrderEdit`

3+^| *XML screen descriptors*

| Component identifier, parameter names in queries
| lowerCamelCase, only letters and numbers.
| `attributesTable`

`:component$relevantTo`

`:ds$attributesDs`

| Datasource identifier
| lowerCamelCase, only letters and numbers ending with `Ds`.
| `attributesDs`

3+^| *SQL scripts*

| Reserved words| lowercase| `create table`

| Tables| UPPER_CASE. The name is preceded by the project name to form a namespace. It is recommended to use singular form in table names.| `++SALES_CUSTOMER++`

| Columns| UPPER_CASE| `CUSTOMER`

`++TOTAL_AMOUNT++`

| Foreign key columns| UPPER_CASE. Consists of the table referred by the column (without the project prefix) and the _ID suffix.| `++CUSTOMER_ID++`

| Indexes| UPPER_CASE. Consists of the IDX_ prefix, name of the table that the index is created for (with the project prefix) and names of the fields included in the index.| `++IDX_SALES_CUSTOMER_NAME++`

|===

[[project_file_structure]]
=== Project File Structure

Below is the project file structure of a simple application, *Sales*, consisting of the *Middleware*, *Web Client* and *Web Portal* <<app_tiers,blocks>>.

.Project File Structure
image::project_structure.png[align="center"]

The project root contains build scripts (`build.gradle`, `settings.gradle`) and *IntelliJ IDEA* project files.

The `modules` directory includes the subdirectories of the project <<app_modules,modules>> − *global*, *core*, *gui*, *portal, web*.

.The global Module Structure
image::project_structure_global.png[align="center"]

The *global* module contains the source code directory, `src`, with configuration files – <<metadata.xml,metadata.xml>>, <<persistence.xml,persistence.xml>> and <<views.xml,views.xml>>. The `com.sample.sales.core` package contains interfaces of the *Middleware* services; the `com.sample.sales.entity` package contains <<data_model,entity>> classes and <<message_packs,localization files>> for them.

.The core Module Structure
image::project_structure_core.png[align="center"]

The *core* module contains the following directories:

* `db` – directory with the database <<db_scripts,create and update scripts>>.

* `src` – source code directory; its root contains the <<app_properties_files,application properties>> file of the *Middleware* block and the <<spring.xml,spring.xml>> configuration file. The `com.samples.sales.core` package contains the *Middleware* classes: implementations of <<services,services>>, <<managed_beans,managed beans>> and <<jmx_beans,JMX beans>>.

* `web` – directory with the configuration files of the web application built from the *Middleware* block: <<context.xml,context.xml>> and <<web.xml,web.xml>>.

.The gui Module Structure
image::project_structure_gui.png[align="center"]

The *gui* module includes the source code directory, `src`, with the <<screens.xml,screens.xml>> configuration file. The `com.sample.sales.gui` package contains XML descriptors and screen controllers, and <<message_packs,localization files>> for them.

.The web Module Structure
image::project_structure_web.png[align="center"]

The *web* module contains the following directories:

* `src` – source code directory with the <<app_properties_files,application properties>> file of the *Web Client* block and configuration files – <<menu.xml,web-menu.xml>>, <<permissions.xml,web-permissions.xml>>, <<screens.xml,web-screens.xml>> and <<spring.xml,web-spring.xml>>. The `com.samples.sales.web` package contains the main class of the *Web Client* block (inheritor of `DefaultApp`) and the <<main_message_pack,main localized messages pack>>.

* `web` – directory with configuration files of the web application built from the *Web Client*: <<context.xml,context.xml>> and <<web.xml,web.xml>>.

[[build_scripts]]
=== Build Scripts

Platform based projects are built using *Gradle* build system. Build scripts are two files in the project root directory:

* `settings.gradle` – defines the project name and the set of <<app_modules,modules>>.

* `build.gradle` – defines the build configuration.

This section describes the structure of the scripts and the purpose and parameters of Gradle tasks.

[[build.gradle]]
==== Structure of build.gradle

This section describes the structure and main elements of the `build.gradle` script.

buildscript::
+
--
The `buildscript` section of the script defines the following:

* A version of the platform.

* A set of <<artifact_repository, repositories>> for loading project dependencies. See how to configure access to the repositories <<access_to_repo,below>>.

* Dependencies used by the build system, including the CUBA Gradle plugin.

Below the `buildscript` section, a few variables are defined. They are used in the script later.
--

cuba::
+
--
The CUBA-specific build logic is encapsulated in the `cuba` Gradle plugin. It is included in the root of the script and in the `configure` section of all modules by the following statement:

[source, groovy]
----
apply(plugin: 'cuba')
----

The settings of the *cuba* plugin are defined in `cuba` section:

[source, groovy]
----
include::{sourcesdir}/development/build_gradle_1.groovy[]
----

Let us consider the available options:

* `artifact` - this section defines the group and version of the project <<artifact, artifacts>> being built. Artifact names are based on module names specified in `settings.gradle`.

** `group` - artifact group.
** `version` - artifact version.
** `isSnapshot` - if `true`, artifact names will have the `SNAPSHOT` suffix.

* `tomcat` - this section defines the settings of the Tomcat server which is used for <<fast_deployment, fast deployment>>.

** `dir` - location of the Tomcat <<build.gradle_setupTomcat, installation>> directory.
** `port` - listening port; 8080 by default.
** `debugPort` - Java debug listening port; 8787 by default.
** `shutdownPort` - port listening to the `SHUTDOWN` command; 8005 by default.
** `ajpPort` - AJP connector port; 8009 by default.

* `ide` - this section contains instructions for Studio and IDE.

** `vcs` - a version control system for the project. Only `Git` and `svn` are currently supported.
** `copyright` - copyright text to be inserted into beginning of each source file.
** `classComment` - comment text to be placed above class declarations in Java source files.

* `uploadRepository` - this section defines the settings of the <<artifact_repository, repository>> where assembled project artifacts will be uploaded to upon completion of the `uploadArchives` task.
+
** `url` - the repository URL. If not specified, Haulmont's repository is used.
** `user` - the repository user.
** `password` - the repository password.
+
You can pass the upload repository parameters from the command line with the following arguments:
+
[source]
----
gradlew uploadArchives -PuploadUrl=http://myrepo.com/content/repositories/snapshots -PuploadUser=me -PuploadPassword=mypassword
----
--

dependencies::
+
--
This section contains a set of <<app_components,application components>> used by the project. Components are specified by their *global* module artifact. In the following example, three components are used: `com.haulmont.cuba` (*cuba* component of the platform), `com.haulmont.reports` (*reports* premium add-on) and `com.company.base` (a custom component):

[source, groovy]
----
dependencies {
  appComponent("com.haulmont.cuba:cuba-global:$cubaVersion")
  appComponent("com.haulmont.reports:reports-global:$cubaVersion")
  appComponent("com.company.base:base-global:0.1-SNAPSHOT")
}
----
--

configure::
+
--
The `configure` sections contain configuration of <<app_modules,modules>>. The most important part of the configuration is the declaration of dependencies. For example:

[source,groovy]
----
include::{sourcesdir}/development/build_gradle_2.groovy[]
----

Non-standard module dependencies can be specified in Studio on the *Project properties > Advanced* tab. See Studio context help for details.
--

[[access_to_repo]]
==== Configuring Access to Repository

CUBA Studio Server window contains a field where you can select an artifact repository. By default, it contains two entries:

* `++https://repo.cuba-platform.com/content/groups/work++` - a repository located at Haulmont's server. It requires common credentials which are specified right in the build script (`cuba` / `cuba123`).

* `++https://dl.bintray.com/cuba-platform/main++` - a repository hosted at https://bintray.com[JFrog Bintray]. It has anonymous access.

Both repositories have identical contents for the latest platform versions. We assume that Bintray is more reliable for worldwide access.

When you create a new project in CUBA Studio, it's `build.gradle` contains the link to the repository which is selected in the Studio server window. In case of Bintray, the build script is also configured to use Maven Central, JCenter and Vaadin Add-ons repositories separately.

If your project uses CUBA Premium Add-ons, Studio adds one more repository:

* In case of `repo.cuba-platform.com` it is `++https://repo.cuba-platform.com/content/groups/premium++`

* In case of Bintray it is `++https://cuba-platform.bintray.com/premium++`

Both Premium Add-ons repositories require a user name and a password which are provided by per-developer subscription. The first part of your license key before dash is the repository user name, the part after dash is the password. For example, if your key is `111111222222-abcdefabcdef`, then the user name is `111111222222` and the password is `abcdefabcdef`.

When you build the project from Studio, it passes repository credentials to Gradle automatically. If you want to build the project outside Studio, you can pass `premiumRepoUser` and `premiumRepoPass` in the command line arguments with `-P` prefix. In case of Bintray, the user name must be followed by `@cuba-platform`.

Example of building with `repo.cuba-platform.com`:

[source]
----
gradlew assemble -PpremiumRepoUser=111111222222 -PpremiumRepoPass=abcdefabcdef
----

Example of building with Bintray:

[source]
----
gradlew assemble -PpremiumRepoUser=111111222222@cuba-platform -PpremiumRepoPass=abcdefabcdef
----

Instead of passing credentials each time you build the project from the command line, you can once set the following environment variables:

* `CUBA_PREMIUM_USER` - will be used if `premiumRepoUser` is not passed.

* `CUBA_PREMIUM_PASSWORD` - will be used if `premiumRepoPass` is not passed.

[[build.gradle_tasks]]
==== Build Tasks

_Tasks_ are executable units in Gradle. They are defined both in the plugins and in the build script itself. Below are CUBA-specific tasks; their parameters can be configured in `build.gradle`.

[[build.gradle_buildUberJar]]
===== buildUberJar

`buildUberJar` – the task of the `CubaUberJarBuilding` type that creates JAR files containing the application code and all its dependencies together with embedded Jetty HTTP server. Separate JARs are created for each application <<app_tiers,block>>, e.g. `app-core.jar` for the middleware and `app.jar` for the web client.

The task must be declared in the root of `build.gradle`. The resulting JAR files are located in the `build/distributions` project subdirectory. See the <<uberjar_deployment>> section for how to run the generated JAR files.

[TIP]
====
The task can be configured using the *Deployment settings > Uber JAR* page in Studio.
====

Task parameters:

* `coreJettyEnvPath` - required parameter that defines a relative path to a file which contains JNDI resource definitions for Jetty HTTP server. The file must at least contain definition of a JDBC data source for the main database. Studio can generate this file on the basis of entered database connection parameters. Can also be set at run time using the `-jettyEnvPath` <<uberjar_deployment,command line>> argument.

* `appProperties` - a map defining application properties. These properties will be added to the `/WEB-INF/local.app.properties` files inside generated JARs.

* `corePort` - port for core JAR embedded HTTP server, `8079` if not defined. Can also be set at run time using the `-port` <<uberjar_deployment,command line>> argument.

* `webPort` - port for web JAR embedded HTTP server, `8080` if not defined. Can also be set at run time using the `-port` command line argument.

* `portalPort` - port for portal JAR embedded HTTP server, `8081` if not defined. Can also be set at run time using the `-port` command line argument.

* `appName` - name of the application, which is `app` by default. You can change it for the whole project if you set *Module prefix* field on the *Project Properties > Advanced* tab in Studio, or you can set it only for the `buildUberJar` task using this parameter. For example:
+
[source, groovy]
----
task buildUberJar(type: CubaUberJarBuilding) {
    coreJettyEnvPath = 'modules/core/web/META-INF/jetty-env.xml'
    appProperties = ['cuba.automaticDatabaseUpdate' : true]
    appName = 'sales'
}
----
+
After changing the application name to `sales` the task will generate `sales-core.jar` and `sales.jar` files and the web client will be available at `++http://localhost:8080/sales++`. You can also change web contexts at run time without changing the application name using the `-contextName` <<uberjar_deployment,command line>> argument.
+
[WARNING]
====
Please note that current implementation of Polymer UI requires manual setting of `<base>` tag to the actual web context available at run time. So changing the context by using *Module prefix*, `appName` task parameter or `-frontContextName` <<uberjar_deployment,command line>> argument can make the Polymer UI inaccessible.
====

* `coreProject` - a Gradle project representing the *core* module (Middleware). If not defined, the standard *core* module is used.

* `webProject` - a Gradle project representing the *web* module (Web Client). If not defined, the standard *web* module is used.

* `portalProject` - a Gradle project representing the *portal* module (Web Portal). If not defined, the standard *portal* module is used.

* `polymerProject` - a Gradle project representing the Polymer UI module. If not defined, the standard *polymer-client* module is used.

* `coreWebXmlPath` - a relative path to a file to be used as a `web.xml` for the core JAR.

* `webWebXmlPath` - a relative path to a file to be used as a `web.xml` for the web JAR.

* `portalWebXmlPath` - a relative path to a file to be used as a `web.xml` for the portal JAR.

* `excludeResources` - a file pattern of resources to not include in JARs.

* `mergeResources` - a file pattern of resources to be merged in JARs.

* `webContentExclude` - a file pattern of web content to not include in web JAR.

[[build.gradle_buildWar]]
===== buildWar

`buildWar` – the task of the `CubaWarBuilding` type, which builds a WAR file from the application code and its dependencies. It should be declared in the root of `build.gradle`. The resulting WAR file(s) are located in the `build/distributions` project subdirectory.

Any CUBA application consists of at least two <<app_tiers,blocks>>: Middleware and Web Client. So the most natural way to deploy an application is to create two separate WAR files: one for Middleware and one for Web Client. This also allows you to <<scaling,scale>> your application when the number of users grows. However, separate WAR files contain some duplicated dependencies that increase overall size. Besides, extended deployment options are often not needed and rather complicate the process. The `CubaWarBuilding` task can create both types of WAR files: one per block or single WAR containing both blocks. In the latter case, the application blocks are loaded into separate class loaders inside one web application.

Creating separate WAR files for Middleware and Web Client::
+
--
To create separate WAR files for Middleware and Web Client, use the following task configuration:

[source, groovy]
----
include::{sourcesdir}/development/build_gradle_buildWar_2.groovy[]
----

Task parameters:

* `appHome` – the path to the application home directory. The home directory will contain the <<conf_dir,configuration>>, <<temp_dir,temporary>> and <<work_dir,work>> directories of the application.
+
In the `appHome` parameter, you can specify an absolute or relative path to the home directory, or a Java system variable, which should be set at server start. For example: `appHome = '/work/sales_home'` or `appHome = '${app.home}'`.

* `appProperties` - an optional map defining <<app_properties,application properties>>. These properties will be added to the `/WEB-INF/local.app.properties` files inside generated WAR.
+
`appProperties = ['cuba.automaticDatabaseUpdate': 'true']` will create the database at the first launch, if there wasn't any.

* `singleWar` - should be set to `false` for building separate WAR files.

* `includeJdbcDriver` - include JDBC driver which is currently used in the project. `false` by default.

* `includeContextXml` - include Tomcat `context.xml` file which is currently used in the project. `false` by default.

* `coreContextXmlPath` - the relative path to a file which should be used instead of project's `context.xml` if `includeContextXml` is set to `true`.

* `hsqlInProcess` - if set to `true`, the database URL in `context.xml` will be modified for HSQL in-process mode.

* `coreProject` - the Gradle project representing the *core* module (Middleware). If not defined, the standard *core* module is used.

* `webProject` - the Gradle project representing the *web* module (Web Client). If not defined, the standard *web* module is used.

* `portalProject` - the Gradle project representing the *portal* module (Web Portal). Set this property if the application project contains the *portal* module. For example, `portalProject = project(':app-portal')`.

* `coreWebXmlPath`, `webWebXmlPath`, `portalWebXmlPath` - a relative path to a file to be used as a `web.xml` of the corresponding application block.
+
Example of using custom `web.xml` files:
+
[source, groovy]
----
include::{sourcesdir}/development/build_gradle_buildWar_4.groovy[]
----
--

Creating a single WAR file::
+
--
To create a single WAR file that comprises both Middleware and Web Client blocks, use the following task configuration:

[source, groovy]
----
include::{sourcesdir}/development/build_gradle_buildWar_1.groovy[]
----

The following parameters should be specified in addition to the ones described above:

* `singleWar` - should be omitted or set to `true`.

* `webXmlPath` - the relative path to a file to be used as a `web.xml` of the single WAR. This file defines two servlet context listeners that load the application blocks: `SingleAppCoreServletListener` and `SingleAppWebServletListener`. All initialization parameters are passed to them through context parameters.
+
Example of `single-war-web.xml`:
+
[source, xml]
----
include::{sourcesdir}/development/build_gradle_buildWar_3.xml[]
----

Single WAR contains only *core* and *web* modules (Middleware and Web Client). To deploy the *portal* module, use separate WAR files.
--

See also <<war_deployment>> section for step-by-step instructions on some variants of WAR deployment.

[[build.gradle_buildWidgetSet]]
===== buildWidgetSet

`buildWidgetSet` - the task of the `CubaWidgetSetBuilding` which builds a custom GWT widgetset if the `web-toolkit` module exists in the project. This module enables development of <<own_components,custom visual components>>.

Available parameters:

* `style` - the script output style: `OBF`, `PRETTY` or `DETAILED`. `OBF` by default.

* `logLevel` - the logging level: `ERROR`, `WARN`, `INFO`, `TRACE`, `DEBUG`, `SPAM`, or `ALL`. `INFO` by default.

* `draft` - compile quickly with minimal optimizations. `false` by default.

Example usage:

[source, groovy]
----
include::{sourcesdir}/development/build_gradle_buildWidgetSet_1.groovy[]
----

[[build.gradle_createDb]]
===== createDb

`createDb` – the task of the `CubaDbCreation` type which creates application database by executing the corresponding <<db_scripts,scripts>>. It is declared in the *core* module. Parameters:

* `dbms` – the <<dbms_types, DBMS type>>, specified as the string `hsql`, `postgres`, `mssql`, or `oracle`.

* `dbName` – the database name.

* `dbUser` – the DBMS username.

* `dbPassword` – the DBMS user password.

* `host` – the DBMS host and port (optional) in the `host[:port]` format. If not specified, `localhost` is used.

* `connectionParams` - an optional connection parameters string which will be appended to the end of the connection URL.

* `masterUrl` – the URL used to connect when creating the database. If not specified, the default value that depends on the DBMS type and the `host` parameter is used.

* `dropDbSql` – the SQL command to delete the database. If not specified, the default value that depends on the DBMS type is used.

* `createDbSql` – the SQL command to create a database. If not specified, the default value that depends on the DBMS type is used.

* `driverClasspath` – the list of JAR files containing the JDBC driver. The items in the list are separated by ":" on Linux and by ";" on Windows. If not specified, the system uses the dependencies that are part of the current module's `jdbc` configuration. Explicit definition of `driverClasspath` is necessary when using Oracle, because its JDBC driver is not available in the dependencies.

* `oracleSystemPassword` – the SYSTEM user password for Oracle.

Example for PostgreSQL:

[source, groovy]
----
task createDb(dependsOn: assemble, description: 'Creates local database', type: CubaDbCreation) {
    dbms = 'postgres'
    dbName = 'sales'
    dbUser = 'cuba'
    dbPassword = 'cuba'
}
----

Example for MS SQL Server:

[source, groovy]
----
task createDb(dependsOn: assemble, description: 'Creates local database', type: CubaDbCreation) {
    dbms = 'mssql'
    dbName = 'sales'
    dbUser = 'sa'
    dbPassword = 'saPass1'
    connectionParams = ';instance=myinstance'
}
----

Example for Oracle:

[source, groovy]
----
task createDb(dependsOn: assemble, description: 'Creates database', type: CubaDbCreation) {
    dbms = 'oracle'
    host = '192.168.1.10'
    dbName = 'orcl'
    dbUser = 'sales'
    dbPassword = 'sales'
    oracleSystemPassword = 'manager'
    driverClasspath = "$tomcatDir/lib/ojdbc6.jar"
}
----

[[build.gradle_debugWidgetSet]]
===== debugWidgetSet

`debugWidgetSet` - the task of the `CubaWidgetSetDebug` type which launches GWT Code Server for debugging widgets in the browser.

Example usage:

[source, groovy]
----
include::{sourcesdir}/development/build_gradle_debugWidgetSet_1.groovy[]
----

Ensure that the `web-toolkit` module has a dependency on Servlet API library in the `runtime` configuration:

[source, groovy]
----
include::{sourcesdir}/development/build_gradle_debugWidgetSet_2.groovy[]
----

See <<debug_widgets>> for information on how to debug code in the browser.

[[build.gradle_deploy]]
===== deploy

`deploy` – the task of the `CubaDeployment` type which performs <<fast_deployment,fast deployment>> of a module to Tomcat. It is declared in the *core*, *web* and *portal* modules. Parameters:

* `appName` – name of the web application that will be created from the module. In fact, it is the name of a subdirectory inside `tomcat/webapps`.

* `jarNames` – the list of JAR file names (without versions) produced as a result of building a module and intended to be placed into the `WEB-INF/lib` catalog of the web application. All other module artifacts and dependencies will be copied to `tomcat/shared/lib`.

For example:

[source, groovy]
----
task deploy(dependsOn: assemble, type: CubaDeployment) {
    appName = 'app-core'
    jarNames = ['cuba-global', 'cuba-core', 'app-global', 'app-core']
}
----

[[build.gradle_deployThemes]]
===== deployThemes

`deployThemes` - the task of the `CubaDeployThemeTask` type which builds and deploys <<web_theme,themes>> defined in the project to the running web application deployed by the <<build.gradle_deploy,deploy>> task. Changes in the themes are applied without the server restart.

For example:

[source, groovy]
----
task deployThemes(type: CubaDeployThemeTask, dependsOn: buildScssThemes) {
}
----

[[build.gradle_deployWar]]
===== deployWar

`deployWar` - the task of the `CubaJelasticDeploy` type which deploys the WAR file to Jelastic server.

For example:

[source, groovy]
----
task deployWar(type: CubaJelasticDeploy, dependsOn: buildWar) {
   email = '<your@email.address>'
   password = '<your password>'
   context = '<app contex>'
   environment = '<environment name or ID>'
   hostUrl = '<Host API url>'
}
----

Task parameters:

* `appName` - the name of the web application. By default, it corresponds to the Modules prefix, e.g., `app`.

* `email` - Jelastic server account login.

* `password` - Jelastic account password.

* `context` - the application context. Default value: `ROOT`.

* `environment` - the environment where the application WAR will be deployed. You can set either the environment name or its ID.

* `hostUrl` - URL of the API host. Typically it is `app.jelastic.<host name>`.

* `srcDir` - the directory where the WAR is located. By default it is `"${project.buildDir}/distributions/war"`.

[[build.gradle_enhance]]
===== enhance

`enhance` – the task of the `CubaEnhancing` type which performs bytecode enhancement (weaving) of entity classes. It is declared in the *global* <<app_modules,module>>.

For example:

[source, groovy]
----
task enhance(type: CubaEnhancing)
----

Optional parameters:

* `persistenceConfig` - allows you to specify the set of <<persistence.xml, persistence.xml>> files explicitly. If not set, the task will enhance all persistent entities listed in the `*persistence.xml` files located in the CLASSPATH.

* `metadataXml` - allows you to specify the <<metadata.xml, metadata.xml>> project file explicitly. If not set, the task will enhance all non-persistent entities listed in the `*metadata.xml` files located in the module source tree.

[[build.gradle_restart]]
===== restart

`restart` – the task that stops the local Tomcat server, runs <<fast_deployment,fast deployment>>, and starts the server once again.

[[build.gradle_setupTomcat]]
===== setupTomcat

`setupTomcat` – the task of the `CubaSetupTomcat` type which performs installation and initialization of the local Tomcat server for subsequent <<fast_deployment,fast deployment>> of the application. This task is automatically added to the project when you apply the *cuba* Gradle plugin, so you don't need to declare it in `build.gradle`. Tomcat installation directory is specified by the `tomcat.dir` property of the `cuba` section. By default, it is the project's `build/tomcat` subdirectory.

[[build.gradle_start]]
===== start

`start` – the task of the `CubaStartTomcat` type which starts the local Tomcat server installed by the <<build.gradle_setupTomcat,setupTomcat>> task. This task is automatically added to the project when you add the *cuba* plugin, so you don't need to declare it in `build.gradle`.

[[build.gradle_startDb]]
===== startDb

`startDb` – the task of the `CubaHsqlStart` type which starts the local HSQLDB server. Parameters:

* `dbName` – database name, default is `cubadb`.

* `dbDataDir` – database directory, default is the `deploy/hsqldb` subfolder of the project.

* `dbPort` – server port, default is 9001.

For example:

[source, groovy]
----
include::{sourcesdir}/development/build_gradle_startDb_1.groovy[]
----

[[build.gradle_stop]]
===== stop

`stop` – the task of `CubaStopTomcat` type which stops the local Tomcat server installed by the <<build.gradle_setupTomcat,setupTomcat>> task. This task is automatically added to the project when you include the *cuba* plugin, so you don't need to declare it in `build.gradle`.

[[build.gradle_stopDb]]
===== stopDb

`stopDb` – the task of the `CubaHsqlStop` type which stops the local HSQLDB server. The parameters are similar to `startDb`.

[[build.gradle_tomcat]]
===== tomcat

`tomcat` – the task of the `Exec` type which starts the local Tomcat server in the opened terminal window and keeps it open even if the start failed. This task may be useful for troubleshooting, e.g., to detect problems caused by Java version mismatch etc, on the server start.

[[build.gradle_updateDb]]
===== updateDb

`updateDb` – the task of the `CubaDbUpdate` type which updates the database by executing the corresponding <<db_scripts,scripts>>. It is similar to the `createDb` task, except that the `dropDbSql` and `createDbSql` parameters are omitted.

[[build.gradle_zipProject]]
===== zipProject

`zipProject` is the task of the `CubaZipProject` type which creates a ZIP archive of your project. The archive will not contain IDE project files, build results and Tomcat server. But HSQL database is included to the archive if present in the `build` directory.

This task is automatically added to the project when you apply the *cuba* Gradle plugin, so you don’t need to declare it in `build.gradle`.

[[build_task_start]]
==== Starting Build Tasks

Gradle tasks described in build scripts can be launched in the following ways:

* If you are working with the project in CUBA Studio, all commands under the *Build* and *Run* main menu items actually connect to the Gradle daemon (launched at the start of Studio server) and run corresponding tasks.

* Alternatively, you can use the executable `gradlew` script (Gradle wrapper) included in the project. The script should be located in the project root directory and can be created in Studio using the *Build* > *Create Gradle wrapper* command.

* One more way is to use the manually installed Gradle version {gradleVersion}. In this case, run the `gradle` executable located in the `bin` subdirectory of the Gradle installation.

[TIP]
====
It is recommended to run the `gradlew` and `gradle` commands with the `--daemon` argument; in this case the Gradle daemon is retained in memory, which significantly accelerates the subsequent execution.

To remove the daemon from memory, you can use the `--stop` argument.
====

For example, in order to compile the Java files and build the JAR files for project artifacts, you need to run the following command:

[source]
----
gradlew --daemon assemble
----

[WARNING]
====
If your project uses Premium Add-ons, and you are starting build tasks outside Studio, pass the Premium Add-ons repository credentials in the command line arguments with `-P` prefix, for example:

[source]
----
gradle assemble -PpremiumRepoUser=111111222222 -PpremiumRepoPass=abcdefabcdef
----

See <<build.gradle, above>> for details.
====

Typical build tasks in their normal usage sequence are provided below.

* `idea`, `eclipse` – create IntelliJ IDEA or Eclipse project files. When this task is executed, dependencies with their source code are loaded from the artifact repository to the local Gradle cache.

* `cleanIdea`, `cleanEclipse` – remove IntelliJ IDEA or Eclipse project files.

* `assemble` – compile Java files and build JARs for project artifacts in the `build` subdirectories of the modules.

* `clean` – remove `build` subdirectories of all project modules.

* <<build.gradle_setupTomcat,setupTomcat>> – setup the Tomcat server to the path that is specified by the `cuba..tomcat.dir` property of the `build.gradle` script.

* <<build.gradle_deploy,deploy>> – deploy the application to the Tomcat server that has been pre-installed by the `setupTomcat` task.

* <<build.gradle_createDb,createDb>> – create an application database and run the corresponding <<db_scripts,scripts>>.

* <<build.gradle_updateDb,updateDb>> – update the existing application database by running the corresponding <<db_scripts,scripts>>.

* <<build.gradle_start,start>> – start the Tomcat server.

* <<build.gradle_stop,stop>> – stop the running Tomcat server.

* <<build.gradle_restart,restart>> – sequentially run the `stop`, `deploy`, `start` tasks.

[[private_repo]]
==== Setting Up a Private Artifact Repository

This section describes how to set up a private Maven repository and use it instead of the CUBA public repository for storing the platform artifacts and other dependencies. It is recommended in the following cases:

- You have an unstable or slow connection to the internet. In spite of the fact that Gradle caches downloaded artifacts on the developer's machine, you may need to connect to the artifact repository from time to time, for example when you run build for the first time or switch to a newer version of the platform.
-  You cannot have direct access to the internet due to a security policy of your organization.
-  You are not going to prolong your subscription to CUBA Premium Add-ons, but you need to be able to build your application in the future using the downloaded version of the artifacts.

The process of setting up a private repository consists of the following steps:

- Install the repository manager software in a network connected to the internet.
- Configure the private repository as a proxy for the CUBA public repository.
- Make your project build script use the private repository. It can be done in Studio or right in `build.gradle`.
- Perform full build of your project to cache all required artifacts in the private repository.

[[private_repo_install]]
===== Install the Repository Manager

For the purpose of this example, we will use Sonatype Nexus OSS repository manager and Microsoft Windows operating system.

- link:http://www.sonatype.org/downloads/nexus-latest-bundle.zip[Download] Sonatype Nexus OSS version 2.x (2.14.3 has been tested)
- Unpack zip file to the directory `c:\nexus-2.14.3-02`
- Modify settings located in file `c:\nexus-2.14.3-02\conf\nexus.properties`:
+
** You may configure server port; default is 8081
+
** Configure repository data folder:
+
--
replace
--
+
[source]
----
nexus-work=${bundleBasedir}/../sonatype-work/nexus
----
+
--
with any convenient path to cached data, for example
--
+
[source]
----
nexus-work=${bundleBasedir}/nexus/sonatype-work/content
----
- Navigate to the folder `c:\nexus-2.14.3-02\bin`
- To start and stop Nexus as a service, install the wrapper (run command as Administrator):
+
[source]
----
nexus.bat install
----

- Launch *nexus* service.
- Open `++http://localhost:8081/nexus++` in the web browser and log in with the default credentials: login `admin` and password `admin123`.

[[private_repo_configure]]
===== Configure the Proxy Repository

Click to the *Repositories* link on the left panel.

On the opened *Repositories* page click the *Add* button, then choose *Proxy Repository*. A new repository will be added. Fill in required fields at *Configuration* tab:

- *Repository ID*: `cuba-work`
- *Repository Name*: `cuba-work`
- *Provider*: `Maven2`
- *Remote Storage Location*: `++https://repo.cuba-platform.com/content/groups/work++`
- *Auto Blocking Enabled*: `false`
- Enable *Authentication*, set *Username*: `cuba`, *Password*: `cuba123`
- Click *Save* button.

Create a Repository Group, in Nexus click *Add* button, then choose *Repository Group* and do the following on *Configuration* tab:

- Enter the *Group ID*: `cuba-group`
- Enter the *Group Name*: `cuba-group`
- *Provider*: `Maven2`
- Add the repository *cuba-work* from *Available Repositories* to *Ordered Group Repositories*
- Click *Save* button.

If you have a subscription to the Premium Add-ons, add one more repository with the following settings:

- *Repository ID*: `cuba-premium`
- *Repository Name*: `cuba-premium`
- *Provider*: `Maven2`
- *Remote Storage Location*: `++https://repo.cuba-platform.com/content/groups/premium++`
- *Auto Blocking Enabled*: `false`
- Enable *Authentication*, set the first part of your license key (before dash) in the *Username* field and the second part of your license key (after dash) in the *Password* field.
- Click *Save* button.
- Click *Refresh* button.
- Select the *cuba-group* group.
- On the *Configuration* tab, add *cuba-premium* repository to the group below *cuba-work*.
- Click *Save* button.

[[private_repo_studio_config]]
===== Configuring CUBA Studio to Use the Private Repository

Now your private repository is ready to use. Find the *cuba-group* URL at the top of the screen, for example:
----
http://localhost:8081/nexus/content/groups/cuba-group
----
- Open CUBA Studio Server window and paste the URL into the *Repository* field.
- Click *Auth* button next the *Repository* field and enter login and password: `admin / admin123`.
- Start Studio.
- Open `++http://localhost:8111/studio++` in your browser.
- Open your project.
- Build the project.

During the first build your new repository downloads necessary artifacts and keeps them in the cache for the next usage. You may find them in `c:\nexus-2.14.3-02\sonatype-work` folder.

[WARNING]
====
For CUBA Studio version 6.4 and below, before running Studio with the private repository for the first time, do the following:

- Set the *cuba-group* URL in your `build.gradle` manually.

- Assemble the project from the command line:
+
--
[source]
----
gradle assemble
----
--
====

[[private_repo_in_isolated_network]]
===== Repository in an Isolated Network

If you need to develop on CUBA in a network without connection to the internet, do the following:

- Install a copy of the repository manager in the target network.

- Copy the cached content of the <<private_repo_configure,repository>> from the open network to the isolated one. If you followed the instructions above, the content is stored in
+
----
c:\nexus-2.14.3-02\sonatype-work
----

- Restart the *nexus* service.

If you need to add artifacts of a new platform version to the isolated repository, go to the environment connected to the internet, make a build through its repository and then copy the contents to the isolated environment again.

[[private_repo_studio_in_isolated_network]]
===== CUBA Studio in an Isolated Network

In order to use CUBA Studio in an isolated network, follow the steps below:

- Download https://services.gradle.org/distributions/[Gradle] (version {gradleVersion} is required) and install it onto developers machines.
- Open CUBA Studio Server window.
- Press *Advanced* button and set path to the folder where you have installed Gradle.
- Enter your <<private_repo_in_isolated_network,internal>> repository URL in the *Repository* field, for example, `++http://localhost:8081/nexus/content/groups/cuba-group++`.
- Click *Auth* button next the *Repository* field and enter repository login and password (`admin/admin123` by default).
- Start Studio.
- Open and build your project.

[[project_creation]]
=== Creating a Project

The recommended way to create a new project is to use *CUBA Studio*. An example can be found in the <<qs_create_project,Quick Start>> chapter of this manual.

Once the project is created, you can keep developing it in the Studio, or create *IntelliJ IDEA* or *Eclipse* project files and open the project in the IDE.

[[logging]]
=== Logging

The platform uses *Logback* framework for logging.

To output to the log, use *SLF4J* API: get a logger for the current class and invoke one of its methods, for example:

[source, java]
----
include::{sourcesdir}/development/logging_1.java[]
----

Logs for the Middleware, Web Client and Web Portal <<app_tiers,blocks>> are configured at the application server level; in <<fast_deployment,fast deployment>> mode the server is Tomcat. Logs for the Desktop Client block are configured separately.

[[logging_setup_tomcat]]
==== Setting up Logging in Tomcat

Running Gradle <<build.gradle_setupTomcat,setupTomcat>> task installs the Tomcat server into the project directory and performs its additional configuration. Particularly, `setenv.bat` and `setenv.sh` files are created in the `tomcat/bin` subfolder, and `logback.xml` is created in the `tomcat/conf` subfolder.

Among other things, the `setenv.*` files define loading parameters for the `logback.xml` configuration file using the `CATALINA_OPTS` variable.

`logback.xml` defines logging configuration. The file has the following structure:

* `appender` elements define the "output device" for the log. The main appenders are `FILE` and `CONSOLE`. The `level` parameter of `ThresholdFilter` defines the message threshold. By default, it is `DEBUG` for a file and `INFO` for console. It means that `ERROR`, `WARN`, `INFO` and `DEBUG` messages are written to a file, while `ERROR`, `WARN` and `INFO` are written to console.
+
The path to the log file for the file appender is defined in the `file` parameter. The default is `tomcat/logs/app.log`.

* `logger` elements define the logger parameters that are used to print messages from the program code. Logger names are hierarchical, i.e. the settings of the `com.company.sample` logger have effect on the `com.company.sample.core.CustomerServiceBean` and `com.company.sample.web.CustomerBrowse` loggers, if the loggers do not explicitly override the settings with their own.
+
Minimum logging level is defined by the `level` attribute. For example, if the category is `INFO`, then `DEBUG` and `TRACE` messages will not be logged. It should be kept in mind that message logging is also affected by the level threshold set in the appender.

You can quickly change logger levels and appender thresholds for a running server using the * Administration* > *Server log* screen available in the web client. Any changes to the logging settings are effective only during server runtime and are not saved to a file. The screen also enables viewing and loading log files from the server <<log_dir,logs folder>> (tomcat/logs).

The platform automatically adds the following information to the messages written to the file log:

* _application_ – the name of the web application that has logged the message. This information enables identifying messages from different application blocks (Middleware, Web Client), since they are written into the same file.

* _user_ – the login name of the user who invoked the code logging the message. This helps to track activity of a certain user in the log. If the code that logged a message was not invoked within a specific user session, the user information is not added.

For example, the following message has been written to the log by the code of the Middleware block (`app-core`), running under the `admin` user:

[source, log]
----
16:12:20.498 DEBUG [http-nio-8080-exec-7/app-core/admin] com.haulmont.cuba.core.app.DataManagerBean - loadList: ...
----

[[logging_setup_desktop]]
==== Setting up Logging in The Desktop Client

For the desktop client, the logback.xml file should be located in the source files directory of the project's *desktop* module. When an application is built, it is packed into the corresponding JAR file and is accessible in CLASSPATH.

Make the following steps to set up logging for your project:

* Create a new file, for example `sample-logback.xml`, in the `src` directory of the *desktop* module, and copy the contents of `cuba-logback.xml` to this new file. `cuba-logback.xml` file is located in one of the platform's JAR files and can be easily found using search in the IDE.

* Define path to a log file in the `file` parameter of the `FILE` appender.

* Add settings for loggers of your project.

* In the <<gui_desktop,inheritor class>> of `com.haulmont.cuba.desktop.App` of your project, for example `SampleApp`, override the `getDefaultLogConfig()` method and use it to return the path to your log file relative to the CLASSPATH root. For example:
+
[source, java]
----
include::{sourcesdir}/development/logging_2.java[]
----

* If necessary, you can override the location of the configuration file at the application start using <<logback.configurationFile,logback.configurationFile>> system property.

[[debugging]]
=== Debugging

This section explains how to use step-by-step debugging in CUBA applications.

[[debug_setup]]
==== Connecting a Debugger

You can start Tomcat server in debug mode by either running the <<build_task_start,Gradle task>>

`gradlew start`

or by running the `++bin/debug.*++` command file of the installed *Tomcat*.

After this, the server will accept debugger connections over port 8787. Port number can be changed in the `++bin/setenv.*++` file, in the `++JPDA_OPTS++` variable.

For debugging in *Intellij IDEA* you need to create a new *Remote* type *Run/Debug Configuration* element in the application project and set its *Port* property to 8787.

[[debug_widgets]]
==== Debugging Web Widgets

You can use *GWT Super Dev Mode* to debug web widgets on the browser side.

. Setup the <<build.gradle_debugWidgetSet,debugWidgetSet>> task in `build.gradle`.

. Deploy the application and start Tomcat.

. Run the `debugWidgetSet` task:
+
`gradlew debugWidgetSet`
+
The running GWT Code Server will recompile your widgetset on modification.

. Open `++http://localhost:8080/app?debug&superdevmode++` in Chrome web browser and wait for the widgetset is built for the first time.

. Open the debug console in Chrome:
+
image::debugWidgetSet_chrome_console.png[align="center"]

. After changing the Java code in the `web-toolkit` module, refresh the web page in the browser. The widgetset will be rebuilt incrementally in approximately 8-10 seconds.

[[testing]]
=== Testing

This section covers the ways of testing CUBA applications on different layers.

[[unit_tests]]
==== Unit Tests

Unit tests can be created and run both at the Middleware and the Client <<app_tiers,tiers>>. The platform includes link:http://junit.org[JUnit] and link:http://jmockit.github.io/[JMockit] frameworks for this purpose.

Let us assume you have the following screen controller:

[source, java]
----
include::{sourcesdir}/development/testing_1.java[]
----

You can write the following test checking the `init()` method:

[source, java]
----
include::{sourcesdir}/development/testing_2.java[]
----

[[integration_tests_mw]]
==== Middleware Integration Tests

In the middle tier, you can create integration tests which run in a fully functional Spring container connected to the database. In such tests you can run code from any layer of the Middleware, from services to ORM.

First, create the `test` directory in your *core* module next to the `src` directory. Re-create IDE project files to be able to run tests from the IDE.

The platform contains the `TestContainer` class which can be used as a base class for the test container in the application project. Create a subclass in the `test` directory of your *core* module and, in its constructor, redefine parameters for loading <<app_components, components>> and <<app_properties_files, application properties>> and test database connection parameters. For example:

[source, java]
----
include::{sourcesdir}/development/testing_3.java[]
----

We recommend using a separate test database, which can be created, for example, by the following Gradle <<build.gradle_createDb, task>> defined in `build.gradle`:

[source, groovy]
----
include::{sourcesdir}/development/testing_4.java[]
----

The test container should be used in test classes as a JUnit rule specified by the `@ClassRule` annotation:

[source, java]
----
include::{sourcesdir}/development/testing_5.java[]
----

In the example above, the test container is initialized once for all test methods of this class, and disposed after all of them finished.

As the container startup takes some time, you may want to initialize the container once for all tests contained in several test classes. In this case, create a common singleton instance of your test container:

[source, java]
----
include::{sourcesdir}/development/testing_6.java[]
----

And use it in your test classes:

[source, java]
----
include::{sourcesdir}/development/testing_7.java[]
----

The `TestContainer` class contains the following methods that can be used in the test code (see the `CustomerLoadTest` example above):

* `persistence()` – returns the reference to the <<persistence,Persistence>> interface.

* `metadata()` – returns the reference to the <<metadata,Metadata>> interface.

* `deleteRecord()` – this set of overloaded methods is aimed to be used in `@After` methods to clean up the database after tests.

[[integration_tests_client]]
==== Client Tier Integration Tests

Client tier integration tests can be implemented using link:http://jmockit.github.io[JMockit] framework. It helps isolating the tests from the Middleware and creating the required infrastructure objects.

Client integration test class should be inherited from `CubaClientTestCase`. In the `@Before` method, you should call the inherited methods `addEntityPackage()`, `setViewConfig()` and then `setupInfrastructure()` to create <<metadata,Metadata>> and <<configuration,Configuration>> objects and deploy metadata for selected entities. Then, in the `@Before` method, you can extend the infrastructure with required mock objects using `Expectations` or `NonStrictExpectations`.

An example of an initialized `@Before` method from one of the platform tests:

[source, java]
----
include::{sourcesdir}/development/testing_8.java[]
----

[[dev_recipes]]
=== Development Recipes

This section provides solutions for certain practical tasks.

[[dm_vs_em]]
==== DataManager vs. EntityManager

Both <<dataManager,DataManager>> and <<entityManager,EntityManager>> can be used for operations on entities (CRUD). There are following distinction between these interfaces:

|===
|DataManager |EntityManager

|DataManager is available on both middle and client <<app_tiers,tiers>>.
|EntityManager is available only on the middle tier.

|DataManager is a singleton bean.
|You should obtain a reference to EntityManager through the <<persistence,Persistence>> interface.

|DataManager defines a few high-level methods for working with <<entity_states,detached>> entities: `load()`, `loadList()`, `reload()`, `commit()`.
|EntityManager mostly resembles the standard `javax.persistence.EntityManager`.

|DataManager always starts new <<transactions,transactions>> internally.
|You have to open a transaction before working with EntityManager.

|DataManager loads _partial_ entities according to <<views,views>>.
|EntityManager always loads all local attributes. If a view is used, it affects only reference attributes.

|DataManager queries can return entities only. Queries for single attributes or aggregates (SUM, COUNT) will fail.
|EntityManager can run any JPQL or native queries.

|DataManager applies all <<security_subsystem,security>> restrictions when invoked on the client tier.
|EntityManager does not impose security restrictions.

|===

When you work with data on the client tier, you have only one option - `DataManager`. On the middleware, use `EntityManager` when you need to implement some atomic logic inside a transaction or run a query returning single attributes or aggregates. Otherwise, on the middleware you can use both.

If you need to overcome restrictions of `DataManager` when working on the client tier, create your own <<services,service>> and use `EntityManager` to work with data. In the service, you can check permissions using the <<security,Security>> interface and return data to the client in the form of persistent or non-persistent entities or arbitrary values.

[[getting_messages]]
==== Getting Localized Messages

This section covers ways of getting <<localization,localized messages>> in different application components.

* In screen <<screen_xml,XML-descriptors>>, component attributes for displaying static text (such as <<gui_attr_caption,caption>>) can address localized messages using the rules of <<messageTools.loadString,MessageTools.loadString()>> method. For example:

** `caption="msg://roleName"` – gets a message defined by the `roleName` key in the message pack of the current screen. Screen message pack is defined by the `messagesPack` attribute of the root `window` element.

** `caption="msg://com.company.sample.entity/Role.name"` – gets a message defined by the `Role.name` key in the `com.company.sample.entity` message pack.

* In <<screen_controller,screen controllers>>, localized strings can be retrieved in the following ways:

** From the current screen message pack:

*** Using `getMessage()` method inherited from the <<abstractFrame,AbstractFrame>> base class. For example:
+
[source, java]
----
String msg = getMessage("warningMessage");
----

*** Using `formatMessage()` method inherited from the `AbstractFrame` base class. In this case, the extracted message is used to format submitted parameters according to the rules of `String.format()` method. For example:
+
messages.properties:
+
[source, properties]
----
warningMessage = Invalid email address: '%s'
----
+
Java controller:
+
[source, java]
----
String msg = formatMessage("warningMessage", email);
----

** From an arbitrary messages pack via an injection of <<messages,Messages>> infrastructure interface. For example:
+
[source, java]
----
@Inject
private Messages messages;

@Override
public void init(Map<String, Object> params) {
    String msg = messages.getMessage(getClass(), "warningMessage");
    ...
}
----

* For components managed by a Spring container (<<managed_beans,managed beans>>, <<services,services>>, <<jmx_beans,JMX-beans>>, Spring MVC controllers of the *portal* module), localized messages can be retrieved with the help of the <<messages,Messages>> infrastructure interface injection:
+
[source, java]
----
@Inject
protected Messages messages;
...
String msg = messages.getMessage(getClass(), "warningMessage");
----

* In application code where injection is not possible, the `Messages` interface can be obtained using the static `get()` method of the `AppBeans` class:
+
[source, java]
----
protected Messages messages = AppBeans.get(Messages.class);
...
String msg = messages.getMessage(getClass(), "warningMessage");
----

[[init_values]]
==== Assigning Initial Values

There are different ways to assign initial values to the attributes of new entity instances.

[[init_values_in_class]]
===== Entity Fields Initialization

Simple attributes (`Boolean`, `Integer` etc.) can be initialized in the declaration of the corresponding field of an entity class, for example:

[source, java]
----
public class User extends StandardEntity {
...
    @Column(name = "ACTIVE")
    protected Boolean active = true;
...
}
----

Additionally, a specific initialization method with a <<postConstruct_entity_annotation,@PostConstruct>> annotation can be created in the entity class. In this case, any global <<infrastructure_interfaces,infrastructure interfaces>> and <<managed_beans,beans>> can be invoked during initialization, for example:

[source, java]
----
public class MyEntity extends StandardEntity {
...
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "USER_ID")
    protected User creator;
...
    @PostConstruct
    protected void init() {
       setCreator(AppBeans.get(UserSessionSource.class).getUserSession().getUser());
    }
}
----

[[init_values_in_CreateAction]]
===== Initialization Using CreateAction

If the initial value of an attribute depends on the data of the invoking screen, you can use `setInitialValues()` method of the <<createAction,CreateAction>> class.

Let us look at the example of two linked entities:

image::init_values_recipe_1.png[align="center"]

A fragment of a screen XML descriptor showing the lists of two entities simultaneously:

[source, xml]
----
<dsContext>
    <collectionDatasource id="typesDs"
                          class="com.haulmont.sample.entity.DeviceType"
                          view="_local">
        <query>
            select e from sample$DeviceType e
        </query>
    </collectionDatasource>
    <collectionDatasource id="descriptionsDs"
                          class="com.haulmont.sample.entity.DeviceDescription"
                          view="_local">
        <query>
            select e from sample$DeviceDescription e where e.deviceType.id = :ds$typesDs
        </query>
    </collectionDatasource>
</dsContext>
<layout>
...
        <table id="typeTable">
            <actions>
                <action id="create"/>
                <action id="edit"/>
                <action id="remove"/>
            </actions>
            <columns>
                <column id="name"/>
            </columns>
            <rows datasource="typesDs"/>
        </table>
...
        <table id="descriptionTable">
            <actions>
                <action id="create"/>
                <action id="edit"/>
                <action id="remove"/>
            </actions>
            <columns>
                <column id="description"/>
            </columns>
            <rows datasource="descriptionsDs"/>
        </table>
    </split>
</layout>
----

The screen controller:

[source, java]
----
public class DeviceTypeBrowse extends AbstractLookup {

    @Inject
    private CollectionDatasource<DeviceType, UUID> typesDs;

    @Named("descriptionTable.create")
    private CreateAction descrCreateAction;

    @Override
    public void init(Map<String, Object> params) {
        typesDs.addItemChangeListener(event -> {
            descrCreateAction.setInitialValues(Collections.<String, Object>singletonMap("deviceType", event.getItem()));
        });
    }
}
----

A listener is added in the controller for selected record change event in the `typesDs` datasource. When the selected record is changed, the system invokes the action's `setInitialValues()` method and submits a map with one element whose key is the attribute name (`deviceType`) and value (the selected instance of `DeviceType`). Thus, during the execution of `CreateAction`, the `deviceType` attribute of the new `DeviceDescription` instance will contain the instance of the `DeviceType` that was selected in the table.

[[init_values_in_initNewItem]]
===== Using initNewItem Method

Initial values can also be defined in the <<initNewItem,initNewItem()>> method of the screen controller of the created entity.

Assume we have the following task: a project has an `Employee` entity that should be linked to a platform entity (`User`). When a new employee instance is being created, a new user instance should be created as well.

image::init_values_recipe_2.png[align="center"]

To achieve this, we declare the data source for the employee instance and the nested data source for the linked user in the employee edit screen XML descriptor:

[source, xml]
----
<dsContext>
    <datasource id="employeeDs"
                class="com.haulmont.sample.entity.Employee"
                view="employee-edit">
        <datasource id="userDs"
                    property="user"/>
    </datasource>
</dsContext>
----

In the employee edit screen controller, we declare:

[source, java]
----
@Inject
private Metadata metadata;

private Group defaultGroup;
private Role defaultRole;

@Override
protected void initNewItem(Employee item) {
    User user = metadata.create(User.class);
    user.setGroup(defaultGroup);
    final UserRole userRole = metadata.create(UserRole.class);
    userRole.setUser(user);
    userRole.setRole(defaultRole);
    getDsContext().addBeforeCommitListener(context -> {
        context.getCommitInstances().add(userRole);
    });
    item.setUser(user);
}
----

Here, in the `initNewItem()` method, the new `User` instance is created and assigned the `defaultGroup`. Association with the `defaultRole` is set up using the new instance of `UserRole` entity. To save this relationship to the DB during screen commit the `UserRole` instance is added to the saved entities collection in the `beforeCommit()` method of <<dsContext,DsContext.CommitListener>>.

The new instance of `User` is assigned to the corresponding attribute of the edited `Employee` entity and is thus included in the nested data source `userDs`. This gives us an opportunity to edit necessary user attributes in the employee screen and also leads to automatic saving of the user instance in the same transaction with the other entities when the screen is committed.

[[composition_recipe]]
==== Editing Composite Entities

CUBA platform supports two types of relationship between entities: association and composition. They are called ASSOCIATION and COMPOSITION respectively in the *CUBA Studio* interface. Association is a relationship between the objects that can exist separately from each other. Composition, on the other hand, is used for "master-detail" relations, when the detail instances can exist only as part of the master. A case of an airport and its terminals may be considered an example of composition: a terminal that does not belong to any airport does not make sense.

Typically, the entities belonging to a composition are edited together since it is more convenient. For example, a user opens the airport editing screen and sees the list of terminals, so he can create and edit them, but all changes both for the airport and the terminals are saved to the database together in one transaction, and only after the user confirms saving of the master entity (the airport).

[[composition_impl_recipe]]
===== Implementing a Composition

Let us implement a composition using the `Airport` and the `Terminal` entities as an example:

image::composition_recipe_1.png[align="center"]

. The `Terminal` entity contains a mandatory link to the `Airport`:
+
[source, java]
----
@Entity(name = "sample$Terminal")
@Table(name = "SAMPLE_TERMINAL")
public class Terminal extends StandardEntity {
...
    @ManyToOne(optional = false, fetch = FetchType.LAZY)
    @JoinColumn(name = "AIRPORT_ID")
    private Airport airport;

    public Airport getAirport() {
        return airport;
    }

    public void setAirport(Airport airport) {
        this.airport = airport;
    }
}
----

. The `Airport` entity contains one-to-many collection of terminals. The corresponding field is annotated with <<composition_annotation,@Composition>> in order to implement composition, and <<onDelete_annotation,@OnDelete>> for cascaded soft delete:
+
[source, java]
----
@Entity(name = "sample$Airport")
@Table(name = "SAMPLE_AIRPORT")
public class Airport extends StandardEntity {
...
    @OneToMany(fetch = FetchType.LAZY, mappedBy = "airport")
    @OnDelete(DeletePolicy.CASCADE)
    @Composition
    protected List<Terminal> terminals;

    public List<Terminal> getTerminals() {
        return terminals;
    }

    public void setTerminals(List<Terminal> terminals) {
        this.terminals = terminals;
    }
}
----

.  The <<views,view>> of the airport editing screen should contain the `terminals` attributes collection:
+
[source, xml]
----
<view entity="sample$Airport" name="airport-edit" extends="_local">
    <property name="terminals" view="_local"/>
</view>
----
+
For the `Terminal` entity, we are using the `++_local++` view, although it contains the `airport` link attribute (a link to an airport). The `airport` attribute is set only at the creation of a new `Terminal` instance and never changes after that, so we do not need to load it.

. Next, we define the datasources for the `Airport` instance and its terminals in the XML descriptor of the airport editor:
+
[source, xml]
----
<dsContext>
    <datasource id="airportDs"
                class="com.haulmont.sample.entity.Airport"
                view="airport-edit">
        <collectionDatasource id="terminalsDs" property="terminals"/>
    </datasource>
</dsContext>
----

. Define a table displaying terminals and <<list_actions,standard actions>> for it in the XML descriptor of the airport editor:
+
[source, xml]
----
<table id="terminalsTable">
    <actions>
        <action id="create"/>
        <action id="edit"/>
        <action id="remove"/>
    </actions>
    <buttonsPanel>
        <button action="terminalsTable.create"/>
        <button action="terminalsTable.edit"/>
        <button action="terminalsTable.remove"/>
    </buttonsPanel>
    <columns>
        <column id="code"/>
        <column id="name"/>
        <column id="address"/>
    </columns>
    <rows datasource="terminalsDs"/>
</table>
----

. It is sufficient to define the standard elements in the terminal editor: `datasource` for the `Terminal` instance and visual components related to this `datasource` for editing terminal attributes.

As a result, editing of an airport instance works as follows:

* The airport edit screen shows a list of terminals.

* A user can pick a terminal and open its editor. When *OK* is clicked in the terminal editor, the updated instance of the terminal is not saved to the database, but to the `terminalsDs` datasource of the airport editor.

* The user can create new terminals and delete existing ones. All changes will be saved to the `terminalsDs` datasource.

* When a user clicks OK in the airport edit screen, the updated `Airport` instance together with all the updated `Terminal` instances is submitted to the <<dataManager,DataManager>>.commit() method on the Middleware and saved in the database within a single transaction.

[[composition_deep_recipe]]
===== Deep Composition

Composition can be deeper, with up to two nested levels. Let's extend the example above by adding a `MeetingPoint` entity describing a meeting point at an airport terminal:

image::composition_recipe_2.png[align="center"]

The `Terminal` entity contains the `meetingPoints` attribute – a collection of the `MeetingPoint` instances. In order for all three entities to become a single composition and be edited together, you should do the following in addition to the steps described above:

. Mark the `meetingPoints` attribute of the `Terminal` class as `@Composition` and `@OnDelete` similarly to the `terminals` attribute of the `Airport` class.

. Create a new view for the `Terminal`:
+
[source, xml]
----
<view entity="sample$Terminal" name="terminal-edit" extends="_local">
    <property name="meetingPoints" view="_local"/>
</view>
----
+
Use it in the `Airport` view instead of `++_local++`:
+
[source, xml]
----
<view entity="sample$Airport" name="airport-edit" extends="_local">
    <property name="terminals" view="terminal-edit"/>
</view>
----

. Define datasources for an instance of the `Airport` and nested entities for the entire composition depth in the `Airport` edit screen XML descriptor:
+
[source, xml]
----
<dsContext>
    <datasource id="airportDs"
                class="com.haulmont.sample.entity.Airport"
                view="airport-edit">
        <collectionDatasource id="terminalsDs" property="terminals">
            <collectionDatasource id="meetingPointsDs" property="meetingPoints"/>
        </collectionDatasource>
    </datasource>
</dsContext>
----
+
Here, the `meetingPointsDs` datasource is not associated with any visual components, however it is needed for correct operation of joint editing of the composition.

. Define the nested data source and a corresponding table for the `meetingPoints` collection in the terminal edit screen XML descriptor.

As a result, the updated instances of the `MeetingPoint`, as well as the `Terminal` instances, will be saved to the database only with the `Airport` instance in the same transaction.

[[app_start_recipe]]
==== Running Code at Application Start

Sometimes you may need to run certain code immediately after the application start at the moment when all application functionality is already initialized and ready to work. For this, you can use the <<appContext,AppContext.Listener>>.

Assume we have the following task: a project has an `Employee` entity that should be linked one-to-one to a platform entity (`User`).

image::init_values_recipe_2.png[align="center"]

If the `name` attribute of the `User` entity is changed, for example, through a standard user management screen, the `name` attribute of the related `Employee` should change as well. This is a common task for "denormalized" data, which is typically solved using <<entity_listeners,entity listeners>>. Our case is more complex, since we need to track changes of the platform's `User` entity, and thus we cannot add an entity listener using <<listeners_annotation,@Listeners>> annotation. However, we can add a listener dynamically using the `EntityListenerManager` bean, and it is better to do this on application start.

Let us create the `AppLifecycle` bean implementing the `AppContext.Listener` interface in the application *core* module and register it by invoking `AppContext.addListener()` method in the object constructor:

[source, java]
----
include::{sourcesdir}/development/app_start_recipe_1.java[]
----

[source, java]
----
include::{sourcesdir}/development/app_start_recipe_2.java[]
----

As a result, the `applicationStarted()` method of this bean will be invoked immediately after the start of the Middleware <<app_tiers,block>>. In this method, the `sample_UserEntityListener` bean is registered as an entity listener for the `User` entity.

The `onBeforeUpdate()` method of the `UserEntityListener` class will be invoked every time before the changes in the `User` instances are saved to the database. The method checks if the `name` attribute exists among the updated attributes. If yes, a related `Employee` instance is loaded and its `name` is updated with the new value.

[[images_recipe]]
==== Loading and Displaying Images

Let's consider a task of loading, storing and displaying employee photos:

* An employee is represented by `Employee` entity.

* Image files are stored in the <<file_storage,FileStorage>>. The `Employee` entity contains a link to the corresponding `FileDescriptor`.

* The `Employee` edit screen shows the picture and also supports uploading, downloading and clearing the picture.

Entity class with a link to the image file:

[source, java]
----
include::{sourcesdir}/development/images_1.java[]
----

A <<views,view>> for loading an `Employee` together with `FileDescriptor` should include all local attributes of `FileDescriptor`:

[source, xml]
----
include::{sourcesdir}/development/images_2.xml[]
----

A fragment of the `Employee` edit screen XML descriptor:

[source, xml]
----
include::{sourcesdir}/development/images_3.xml[]
----

Components used to display, upload and download images are contained within the <<gui_GroupBoxLayout,groupBox>> container. Its top part shows a picture using the <<gui_Embedded,embedded>> component, while its bottom part from left to right contains the <<gui_FileUploadField,upload>> component and <<gui_Button,buttons>> to download and clear the image. As a result, this part of the screen should look like this:

image::images_recipe.png[align="center"]

Now, let us have a look at the <<abstractEditor,edit screen controller>>.

[source, java]
----
include::{sourcesdir}/development/images.java[]
----

* The `init()` method first initializes the `uploadField` component that is used for uploading new images. In the case of a successful upload, a new `FileDescriptor` instance is retrieved from the component and the corresponding files are sent from the temporary client storage to `FileStorage` by invoking `FileUploadingAPI.putFileIntoStorage()`. After that, the `FileDescriptor` is saved to the database by invoking  <<dataSupplier,DataSupplier.commit()>>, and the saved instance is assigned to the `imageFile` attribute of the edited `Employee` entity. Then, the controller's `displayImage()` method is invoked to display the uploaded image.
+
After that, a listener is added in the `init()` method to the datasource containing an `Employee` instance. The listener enables or disables download and clear buttons, depending on the fact whether the file has been loaded or not.

* `postInit()` method performs file display and refreshes the button states, depending on the existence of a loaded file.

* `onDownloadImageBtnClick()` is invoked when the `downloadImageBtn` button is clicked; it downloads the file using the <<file_download,ExportDisplay>> interface.

* `onClearImageBtnClick()` is invoked when the `clearImageBtn` is clicked; it clears the `imageFile` attribute of the `Employee` entity. The file is not deleted from storage.

* `displayImage()` loads the file from storage into a byte array, sets the content of the `embeddedImage` component and recalculates its size to preserve image height to width ratio.
+
It should be noted that loading files into byte arrays is acceptable for small files only. If the file size is not predictable, you should only download it using <<file_download,ExportDisplay>>, which sends the file through input and output streams and never keeps the entire file in memory.

[[images_in_table]]
===== Displaying Images in a Table Column

To amplify the previous task, let's add pictures to the table as employees' icons on the `Employee` browse screen.

The pictures can be displayed in a separate column or inside any existing column. In both cases the <<gui_Table_addGeneratedColumn,Table.ColumnGenerator>> interface is used.

Below is a fragment of the `Employee` browse screen XML descriptor:

[source, xml]
----
include::{sourcesdir}/development/images_4.xml[]
----

To display pictures inline with an employee's name in the `name` column, let's change the standard representation of data in this column. We will use the <<gui_BoxLayout,HBoxLayout>> container and place the <<gui_Embedded,Embedded>> component into it:

[source, java]
----
include::{sourcesdir}/development/images_5.java[]
----

* The `init()` method invokes the `addGeneratedColumn()` method that takes two parameters: an identifier of the column and an implementation of the `Table.ColumnGenerator` interface. The latter is used to define the custom representation of data in the `name` column.

* Inside this method we create an `Embedded` component using the `ComponentsFactory` interface. We set the <<gui_Embedded_type,type>> of the component (`IMAGE`) and its size parameters.

* Then we get the `FileDescriptor` instance with the picture stored in the <<file_storage,File Storage>>. The link to this picture is stored in the `imageFile` attribute of the `Employee` entity. Data provider for `FileDescriptor` is used to set the source for the `Embedded` component.

* We will display the `name` attribute in the `Label` component alongside the embedded picture.

* We will wrap both `Embedded` and `Label` components into the `HBoxLayout` container, and make the `addGeneratedColumn()` method return this container as the new table cell layout.

image::image_recipe.png[align="center"]

You can also use a more declarative approach with the <<gui_Table_column_generator,generator>> XML attribute.

[[sending_emails_recipe]]
==== Sending Emails

This section contains a practical guide to sending emails using the CUBA email sending <<email_sending,mechanism>>.

Let us consider the following task:

--
* There are the `NewsItem` entity and the `NewsItemEdit` screen.

* The `NewsItem` entity contains the following attributes: `date`, `caption`, `content`.

* We want to send emails to some addresses every time a new instance of `NewsItem` is created through the `NewsItemEdit` screen. An email should contain `NewsItem.caption` as a subject and the message body should be created from a template including `NewsItem.content`.
--

. Add the following code to `NewsItemEdit.java`:
+
--
[source, java]
----
include::{sourcesdir}/development/sending_emails_1.java[]
----

As you can see, the `sendByEmail()` method invokes the `EmailService` and passes the `EmailInfo` instance describing the the messages. The body of the messages will be created on the basis of the `news_item.txt` template.
--

. Create the body template file `news_item.txt` in the `com.company.demo.templates` package of the *core* module:
+
--
[source, plain]
----
include::{sourcesdir}/development/sending_emails_2.txt[]
----

This is a link:http://freemarker.incubator.apache.org[Freemarker] template which will use parameters passed in the `EmailInfo` instance (`newsItem` in this case).
--

. Launch the application, open the `NewsItem` entity browser and click *Create*. The editor screen will be opened. Fill in the fields and press *OK*. The confirmation dialog with the question about sending emails will be shown. Click *Yes*.

. Go to the *Administration > Email History* screen of your application. You will see two records (by the number of recipients) with the `Queue` status. It means that the emails are in the queue and not yet sent.

. To process the queue, set up a <<scheduled_tasks_cuba,scheduled task>>. Go to the *Administration > Scheduled Tasks* screen of your application. Create a new task and set the following parameters:
+
--
* *Bean Name* - `cuba_Emailer`
* *Method Name* - `processQueuedEmails()`
* *Singleton* - yes (this is important only for a cluster of middleware servers)
* *Period, sec* - 10
--
+
Save the task and click *Activate* on it.
+
If you did not set up the scheduled tasks execution for this project before, nothing will happen on this stage - the task will not be executed until you start the whole scheduling mechanism.

. Open the `modules/core/src/app.properties` file and add the following <<cuba.schedulingActive,property>>:
+
[source, properties]
----
cuba.schedulingActive = true
----
+
Restart the application server. The scheduling mechanism is now active and invokes the email queue processing.

. Go to the *Administration > Email History* screen. The status of the emails will be `Sent` if they were successfully sent, or, most probably, `Sending` or `Queue` otherwise. In the latter case, you can open the application log in `build/tomcat/logs/app.log` and find out the reason. The email sending mechanism will take several (10 by default) attempts to send the messages and if they fail, set the status to `Not sent`.

. The most obvious reason that emails cannot be sent is that you have not set up the SMTP server <<email_sending_properties,parameters>>. You can set the parameters in the database through the `app-core.cuba:type=Emailer` JMX bean or in the application properties file of your middleware. Let us consider the latter. Open the `modules/core/src/app.properties` file and add the required <<email_sending_properties,parameters>>:
+
[source, properties]
----
include::{sourcesdir}/development/sending_emails_3.properties[]
----
+
Restart the application server. Go to *Administration > JMX Console*, find the `Emailer` JMX bean and try to send a test email to yourself using the `sendTestEmail()` operation.

. Now your sending mechanism is set up correctly, but it will not send the messages in the `Not sent` state. So you have to create another `NewsItem` in the editor screen. Do it and then watch how the status of new messages in the *Email History* screen will change to `Sent`.

[[own_component_samples]]
==== Creating Custom Visual Components

As explained in the <<own_components>> section, the standard set of visual components can be extended in your project. You have the following options:

. Integrate a Vaadin add-on. Many third-party Vaadin components are distributed as add-ons and available at https://vaadin.com/directory.

. Integrate a JavaScript component. You can create a Vaadin component using a JavaScript library.

. Create a new Vaadin component with the client part written on GWT.

Futher on, you can integrate the resulting Vaadin component into CUBA Generic UI to be able to use it declaratively in screen XML descriptors and bind to datasources.

And the final step of integration is the support of the new component in the Studio WYSIWYG layout editor.

This section gives you examples of creating new visual components with all the methods described above. Integration to the Generic UI and support in Studio are the same for all methods, so these topics are described only for a new component created on the basis of a Vaadin add-on.

[[vaadin_addon_sample]]
===== Using a Third-party Vaadin Component

This is an example of using the *Stepper* component available at http://vaadin.com/addon/stepper, in an application project. The component enables changing text field value in steps using the keyboard, mouse scroll or built-in up/down buttons.

Create a new project in CUBA Studio and name it `addon-demo`.

A Vaadin add-on may be integrated if the application project has a *web-toolkit* module. Create the module by clicking  the *Create web toolkit module* link of the *Project properties* navigator section.

Then click the *New UI component* link. The *UI component generation* page will open. Select the *Vaadin add-on* value in the *Component type* section.

image::ui_component/studio_vaadin_addon_wizard_no_gui.png[align="center"]

Fill in the following fields:

* The *Add-on Maven dependency* field contains Maven coordinates of the Vaadin add-on. The add-on will be included as a dependency to the project. You can define coordinates in two formats:

. As an XML copied from the add-on web site (http://vaadin.com/addon/stepper):
+
[source, xml]
----
<dependency>
   <groupId>org.vaadin.addons</groupId>
   <artifactId>stepper</artifactId>
   <version>2.2.2</version>
</dependency>
----

. In one line as you add dependencies in <<build.gradle,build.gradle>>: `org.vaadin.addons:stepper:2.2.2`

* The *Inherited widgetset* field contains a widgetset name of the add-on:
+
[source]
----
org.vaadin.risto.stepper.widgetset.StepperWidgetset
----

* *Integrate into generic UI* - deselect this checkbox as we do not integrate the component into the Generic UI in this example.

Press the *OK* button.

If you open the project in the IDE, you can see that Studio has changed two files:

. In `build.gradle`, the *web* module now contains a dependency on the add-on that contains the component.
+
[source, java]
----
configure(webModule) {
    ...
    dependencies {
        ...
        compile("org.vaadin.addons:stepper:2.2.2")
    }
----

. The `AppWidgetSet.gwt.xml` file of the *web-toolkit* module now inherits the add-on widgetset:
+
[source, xml]
----
<module>
    <inherits name="com.haulmont.cuba.web.toolkit.ui.WidgetSet" />

    <inherits name="org.vaadin.risto.stepper.widgetset.StepperWidgetset" />

    <set-property name="user.agent" value="safari" />
----
+
[TIP]
====
You can speed up the widgetset compilation by defining the `user.agent` property. In this example, widgetset will be compiled only for browsers based on WebKit: Chrome, Safari, etc.
====

Now the component from the Vaadin add-on is included to the project. Let's see how to use it in the project screens.

* Create a new entity `Customer` with two fields:

** `name` of type String
** `score` of type Integer

* Generate standard screens for the new entity. Ensure that the *In module* field is set to `Web Module`. Screens that use Vaadin components directly must be placed in the *web* module.
+
[TIP]
====
Actually, screens can be placed in the *gui* module as well, but then the code that uses the Vaadin component should be moved to a separate <<companions,companion>>.
====

* Next, we will add the `stepper` component to the screen. You can place it in a <<gui_FieldGroup,FieldGroup>> or in a separate container. Let's examine both methods.
+
--
. Add the `custom = "true"` attribute to the `score` field of the `fieldGroup` component of the `customer-edit.xml` screen.
+
[source, xml]
----
include::{sourcesdir}/ui_component/vaadin_no_gui/customer-edit-nogui-custom-field.xml[]
----
+
Add the following code to the `CustomerEdit.java` controller:
+
[source, java]
----
include::{sourcesdir}/ui_component/vaadin_no_gui/CustomerEditNoGuiCustomField.java[]
----
+
The `init()` method initializes the custom `score` field. The `ComponentsFactory` creates an instance of <<gui_BoxLayout,BoxLayout>>, retrieves a link to the Vaadin container via <<webComponentsHelper,WebComponentsHelper>>, and adds the new component to it. The `BoxLayout` is then returned to be used in the custom field.
+
Data binding is implemented programmatically by setting a current value to the `stepper` component from the edited `Customer` instance in the `postInit()` method. Additionally, the corresponding entity attribute is updated through the value change listener, when the user changes the value.

. The new component can be used in any part of the screen outside of the `FieldGroup`. In order to do this, declare the `scoreBox` container in the XML-descriptor:
+
[source, xml]
----
include::{sourcesdir}/ui_component/vaadin_no_gui/customer-edit-nogui-container.xml[]
----
+
Inject the container to the screen controller, retrieve a link to the underlying Vaadin container and add the component to it:
+
[source, java]
----
include::{sourcesdir}/ui_component/vaadin_no_gui/CustomerEditNoGuiContainer.java[]
----
+
Data binding is implemented in the same way as described above.
--

* To adapt the component style, create a theme extension in the project. Click the *Create theme extension* link in the *Project properties* navigator section. Select the `halo` theme. After that, open the `themes/halo/halo-ext.scss` file located in the *web* module and add the following code:
+
[source, css]
----
include::{sourcesdir}/ui_component/vaadin_no_gui/halo-ext.scss[]
----

* Start the application server. The resulting editor screen will look as follows:

image::ui_component/customer_edit_result.png[align="center"]

[[vaadin_addon_sample_gui]]
===== Integrating a Vaadin Component into the Generic UI

In the <<vaadin_addon_sample,previous section>>, we have included the third-party Stepper component in the project. In this section, we will integrate it into CUBA Generic UI. This will allow developers to use the component declaratively in the screen XML and bind it to the data model entities through <<datasources,datasources>>.

Create a new project in CUBA Studio and name it `addon-gui-demo`. Type `agd` in the *Project namespace* field.

Create the *web-toolkit* module by clicking the *Create web toolkit module* link of the *Project properties* navigator section.

Then click the *New UI component* link. The *UI component generation* page will open. Select the *Vaadin add-on* value in the *Component type* section.

image::ui_component/studio_vaadin_addon_wizard_gui.png[align="center"]

Fill in the *Add-on Maven dependency* and *Inherited widgetset* as described in the <<vaadin_addon_sample,previous section>>.

Then fill in the fields of the bottom section:

* *Integrate into Generic UI* - defines that a component should be integrated into the Generic UI.

* *Component XML element* - an element to be used in screen XML descriptors. Enter `stepper`.

* *Component interface name* - a name of the component Generic UI interface. Enter `Stepper`.

* *FQN of the Vaadin component from add-on* - fully qualified class name of the Vaadin component from the add-on. In our case it is `org.vaadin.risto.stepper.IntStepper`.

When you click *OK*, Studio will do the following:

* Add the Vaadin add-on as a *web* module dependency in `build.gradle`.

* Include add-on widgetset in `AppWidgetSet.gwt.xml` of *web-toolkit* module.

* Generate stubs for the following files:

** `Stepper` - an interface of the component in the *gui* module.

** `WebStepper` - a component implementation in the *web* module.

** `StepperLoader` - a component XML-loader in the *gui* module.

** `ui-component.xsd` - a new component XML schema definition. If the file already exists, the information about the new component will be added to the existing file.

** `cuba-ui-component.xml` - the file that registers a new component loader in *web* module. If the file already exists, the information about the new component will be added to the existing file.

Open the project in the IDE.

Let's walk through generated files add make necessary changes.

* Open the `Stepper` interface in the *gui* module. Replace its content with the following code:
+
[source, java]
----
include::{sourcesdir}/ui_component/vaadin_gui/Stepper.java[]
----
+
The base interface for the component is `Field`, which is designed to display and edit an entity attribute.

* Open the `WebStepper` class - a component implementation in the *web* module. Replace its content with the following code:
+
[source, java]
----
include::{sourcesdir}/ui_component/vaadin_gui/WebStepper.java[]
----
+
The chosen base class is `WebAbstractField`, which implements the methods of the `Field` interface.

* The `StepperLoader` class in *gui* module loads the component from its representation in XML.
+
[source, java]
----
include::{sourcesdir}/ui_component/vaadin_gui/StepperLoader.java[]
----
+
The `AbstractFieldLoader` class contains code for loading basic properties of the `Field` component. So `StepperLoader` loads only the specific properties of the `Stepper` component.

* The `cuba-ui-component.xml` file in the *web* module registers the new component and its loader. Leave the file unchanged.
+
[source, xml]
----
include::{sourcesdir}/ui_component/vaadin_gui/cuba-ui-component.xml[]
----

* The `ui-component.xsd` file in *gui* module contains XML schema definitions of custom visual components. Add the `stepper` attributes definition.
+
[source, xml]
----
include::{sourcesdir}/ui_component/vaadin_gui/ui-component.xsd[]
----

Let's see how to add the new component to a screen.

* Create a new entity `Customer`. The entity have two fields:

** `name` of type String
** `score` of type Integer

* Generate standard screens for the new entity.

* Add the `stepper` component to the editor screen. You can place it in a <<gui_FieldGroup,FieldGroup>> or in a separate container. We'll examine both methods.

. Using the component inside a container.
+
--
* Open the `customer-edit.xml` file.

* Define the new namespace `xmlns:app="http://schemas.company.com/agd/0.1/ui-component.xsd"`.

* Remove the `score` field from `fieldGroup`.

* Add `stepper` component to the screen.

As a result, the XML descriptor should look like this:

[source, xml]
----
include::{sourcesdir}/ui_component/vaadin_gui/customer-edit-gui-container.xml[]
----

In the example above, the `stepper` component is associated with the `score` attribute of the `Customer` entity. An instance of this entity is managed by the `customerDs` datasource.
--

. Using the new component inside a <<gui_FieldGroup>>:
+
[source, xml]
----
include::{sourcesdir}/ui_component/vaadin_gui/customer-edit-gui-custom-field.xml[]
----
+
[source, java]
----
include::{sourcesdir}/ui_component/vaadin_gui/CustomerEditGuiCustomField.java[]
----

* To adapt the component style, create a theme extension in the project. Click the *Create theme extension* link in the *Project properties* navigator section. Select the `halo` theme. After that, open the `themes/halo/halo-ext.scss` file located in the *web* module and add the following code:
+
[source, css]
----
include::{sourcesdir}/ui_component/vaadin_gui/halo-ext.scss[]
----

* Start the application server. The resulting editor screen will look as follows:

image::ui_component/customer_edit_result.png[align="center"]

[[js_library_sample]]
===== Using a JavaScript library

In this example, we will use the https://jqueryui.com/slider/#range[Slider] component from the *jQuery UI* library. The slider will have two drag handlers that define a values range.

Create a new project in CUBA Studio and name it `jscomponent`.

Click the *New UI component* button on the *Project properties* navigator section. The *UI component generation* will open. Select the `JavaScript component` value in the `Component type` section.

image::ui_component/studio_js_component_wizard.png[align="center"]

Enter `SliderServerComponent` in the *Vaadin component class name* field.

Deselect the *Integrate into Generic UI* flag. The process of integration into the Generic UI is the same as described at <<vaadin_addon_sample_gui>>, so we won't repeat it here.

After clicking the *OK* button Studio will generate the following files:

* `SliderServerComponent` - a Vaadin component integrated with JavaScript.

* `SliderState` - a state class of the Vaadin component.

* `slider-connector.js` - a JavaScript connector for the Vaadin component.

Let's examine the generated files and make necessary changes in the source code.

* `SlideState` state class defines what data is transferred between the server and the client. In our case it is a minimal possible value, maximum possible value and selected values.
+
[source, java]
----
include::{sourcesdir}/ui_component/js/SliderState.java[]
----

* Vaadin server-side component `SliderServerComponent`.
+
[source, java]
----
include::{sourcesdir}/ui_component/js/SliderServerComponent.java[]
----
+
The server component defines getters and setters to work with the slider state and an interface of value change listeners. The class extends `AbstractJavaScriptComponent`.
+
The `addFunction()` method invocation in the class constructor defines a handler for an RPC-call of the `valueChanged()` function from the client.
+
The `@JavaScript` and `@StyleSheet` annotations point to files that must be loaded on the web page. In our example, these are JavaScript files of the jquery-ui library, the connector and the stylesheet for jquery-ui. You should place these files to the Java package of the Vaadin server component.

Download an archive with jQuery UI from http://jqueryui.com/download and put files `jquery-ui.js` and `jquery-ui.css` from the archive to the Java package of the `SliderServerComponent` class. At the jQuery UI download page, you can select which components should be put into the archive. For this demo, it is enough to select only the `Slider` item of the `Widgets` group.

image::ui_component/js_project_structure.png[align="center"]

* JavaScript connector `slider-connector.js`.
+
[source, javascript]
----
include::{sourcesdir}/ui_component/js/slider-connector.js[]
----
+
Connector is a function that initializes a JavaScript component when the web page is loaded. The function name must correspond to the server component class name where dots in package name are replaced with underscore characters.
+
Vaadin adds several useful methods to the connector function. `this.getElement()` returns an HTML DOM element of the component, `this.getState()` returns a state object.
+
Our connector does the following:
+
--
* Initializes the `slider` component of the jQuery UI library. The `slide()` function is invoked when the position of any drag handler changes. This function in turn invokes the `valueChanged()` connector method. `valuedChanged()` is the method that we defined on the server side in the `SliderServerComponent` class.

* Defines the `onStateChange()` function. It is called when the state object is changed on the server side.
--

To demonstrate how the component works, let's create the `Product` entity with three attributes:

* `name` of type String
* `minDiscount` of type Double
* `maxDiscount` of type Double

Generate standard screens for the entity. Ensure that the value of the *In module* field is `Web Module`.

The `slider` component will set minimal and maximum discount values of a product.

Open the `product-edit.xml` file. Make `minDiscount` and `maxDiscount` fields not editable by adding the `editable="false"` attribute to the corresponding elements. Then add the new custom `slider` field to the `fieldGroup`.

As a result, the XML descriptor of the editor screen should look as follows:

[source, xml]
----
include::{sourcesdir}/ui_component/js/product-edit.xml[]
----

Open the `ProductEit.java` file. Replace its content with the following code:

[source, java]
----
include::{sourcesdir}/ui_component/js/ProductEdit.java[]
----

The `initNewItem()` method sets initial values for discounts of a new product.

Method `init()` initializes the `slider` custom field. It sets current, minimal and maximum values of the `slider` and defines the value change listener. When the drag handler moves, a new value will be set to the corresponding field of the editable entity.

Start the application server and open the product editor screen. Changing the drop handler position must change the value of the text fields.

image::ui_component/product_edit.png[align="center"]

[[gwt_component_sample]]
===== Creating a GWT component

In this section, we will cover the creation of a simple GWT component (a rating field consisting of 5 stars) and its usage in application screens.

image::ui_component/rating_field_component.png[align="center"]

Create a new project in CUBA Studio and name it `ratingsample`.

Click the *Create web-toolkit module* link in the *Project properties* navigator section.

Click the *Create new UI component* link. The *New UI component* page will open. Select the *New GWT component* value in the *Component type* section.

image::ui_component/studio_gwt_component_wizard.png[align="center"]

Enter `RatingFieldServerComponent` in the *Vaadin component class name* field.

Deselect the *Integrate into Generic UI* flag. The process of integration into the Generic UI is the same as described at <<vaadin_addon_sample_gui>>, so we won't repeat it here.

After clicking the *OK* button Studio generates the following files:

* `RatingFieldWidget.java` - a GWT widget in *web-toolkit* module.

* `RatingFieldServerComponent.java` - a Vaadin component class.

* `RatingFieldState.java` - a component state class.

* `RatingFieldConnector.java` - a connector that links the client code with the server component.

* `RatingFieldServerRpc.java` - a class that defines a server API for the client.

Let's look at the generated files and make necessary changes in them.

* `RatingFieldWidget` is a GWT widget. Replace its content with the following code:
+
[source, java]
----
include::{sourcesdir}/ui_component/gwt/RatingFieldWidget.java[]
----
+
A widget is a client-side class responsible for displaying the component in the web browser and handling events. It defines interfaces for working with the server side. In our case these are the `setValue()` method and the `StarClickListener` interface.

* `RatingFieldServerComponent` is a Vaadin component class. It defines an API for the server code, accessor methods, event listeners and data sources connection. Developers use the methods of this class in the application code.
+
[source, java]
----
include::{sourcesdir}/ui_component/gwt/RatingFieldServerComponent.java[]
----

* The `RatingFieldState` state class defines what data are sent between the client and the server. It contains public fields that are automatically serialized on server side and deserialized on the client.
+
[source, java]
----
include::{sourcesdir}/ui_component/gwt/RatingFieldState.java[]
----

* The `RatingFieldServerRpc` interface defines a server API that is used from the client-side. Its methods may be invoked by the RPC mechanism built into Vaadin. We will implement this interface in the component.
+
[source, java]
----
include::{sourcesdir}/ui_component/gwt/RatingFieldServerRpc.java[]
----

* The `RatingFieldConnector` connector links client code with the server.
+
[source, java]
----
include::{sourcesdir}/ui_component/gwt/RatingFieldConnector.java[]
----

The `RatingFieldWidget` class does not define the component appearance, it only assigns style names to key elements. To define an appearance of the component, we'll create stylesheet files. Click the *Create theme extension* link on the *Project properties* navigator section. Select the `halo` theme in the dialog. Studio creates SCSS files for theme extension in the `themes` directory of the *web* module. The `halo` theme uses *FonAwesome* font glyphs instead of icons. We'll use this fact.

It is recommended to put component styles into a separate file `componentname.scss` in the `components/componentname` directory in the form of SCSS mixture. Create the `components/ratingfield` directories structure in the `themes/halo` directory of the *web* module. Then create the `ratingfield.scss` file inside the `ratingfield` directory:

image::ui_component/gwt_theme_ext_structure.png[align="center"]

[source, css]
----
include::{sourcesdir}/ui_component/gwt/ratingfield.scss[]
----

Include this file in the `halo-ext.scss`main theme file:

[source, css]
----
include::{sourcesdir}/ui_component/gwt/halo-ext.scss[]
----

To demonstrate how the component works let's create a new screen in the *web* module.

Name the screen file `rating-screen.xml`.

image::ui_component/gwt_rating_screen_designer.png[align="center"]

Add the screen to the application menu. Go to the *Main menu* navigator section and click the *Edit* button. The menu editor will open. Add the screen created earlier to the `application` menu.

Open the `rating-screen.xml` file in the IDE. We need a container for our component. Declare it in the screen XML:

[source, xml]
----
include::{sourcesdir}/ui_component/gwt/rating-screen.xml[]
----

Open the `RatingScreen.java` screen controller and add the code that puts the component to the screen.

[source, java]
----
include::{sourcesdir}/ui_component/gwt/RatingScreen.java[]
----

Start the application server and see the result.

image::ui_component/rating_screen_result.png[align="center"]

[[own_component_in_studio]]
===== Support for Custom Visual Components in CUBA Studio

This section describes how to integrate a new custom visual component into CUBA Studio. As a result of the integration, the component will be available on the component palette of the WYSIWYG screen layout designer. Developers will be able to drag and drop the component to the canvas and edit its properties in the properties panel.

Let's walk through the process of integrating the `stepper` component into Studio. Creation of this component was described in <<vaadin_addon_sample_gui>>.

Open the project containing the `stepper` component.

[TIP]
====
If you didn't create this project, you can still reproduce the steps listed below in a new project. In this case, you will see how Studio supports the component, but you won't be able to run the application.
====

Click the *Extend Studio* link on the *Project properties* navigator section.

image::ui_component/ui_component_extension_window.png[align="center"]

In the *Extend Studio* screen, fill in the following fields:

* *Configuration name* - a configuration identifier. Enter `stepper`.

* *Component XML element* - a component element name to use in screen XML descriptors. It is `stepper` in our case.
+
The *Component class name* and *Component model class name* fields are filled automatically based on the value of the *Component XML element*. Leave the values as is.

* *Component namespace URI* - a namespace from the XSD that describes the Generic UI component. If you've generated the new component with Studio, then you can take the value of this field from the `ui-component.xsd` file located in the *gui* module.

* *Component namespace prefix* - a prefix for the component XML element.

* *Standard properties* - standard properties that should be available for editing in the component properties panel of the Studio screen layout designer.
+
Select `caption`, `datasource` and `property` checkboxes.
+
[TIP]
====
`id`, `align`, `height`, `width`, `enable`, `stylename` and `visible` properties are available to any component by default.
====

* *Custom properties* - this table is used for declaring component specific properties that should be edited in the component properties panel.
+
--
Add the following properties:

* *manualInput* of type `Boolean`, the default value is `true`

* *mouseWheel* of type `Boolean`, the default value is `true`

* *stepAmount*, of type `Integer`, the default value is `0`

* *maxValue*, of type `Integer`, the default value is `0`

* *minValue*, of type `Integer`, the default value is `0`
--

Press the *OK* button.

The custom visual components support is initialized when the Studio server start. Go to the Studio server window, stop the server, exit Studio, then reopen and start it again.

Re-create standard screens for the `Customer` entity to erase the results of our previous experiments.

Then go to the *GENERIC UI* navigator section and open the `customer-edit.xml` screen.

Remove the `score` field from `fieldGroup` because we will use a separate component for editing the score.

Find the new `Stepper` component on the components palette, then drag it to the screen below `fieldGroup`.

image::ui_component/stepper_in_palette.png[align="center"]

Select the `stepper` component and go to the component *Properties* tab.

image::ui_component/stepper_component_properties.png[align="center"]

Fill in the fields:

* *id* - `stepper`

* *caption* - `Stepper`

* *datasource* - `customerDs`

* *property* - `score`

* *maxValue* - `50`

Go to the *XML* tab to see the result.

[source, xml]
----
include::{sourcesdir}/ui_component/studio_support/customer-edit.xml[]
----

There is a new namespace with the `app` prefix in the screen XML, the `stepper` component is added to the screen, and its properties are set correctly.

[[app_components_sample]]
==== Using Application Components

As mentioned in the <<app_components,>> section, any CUBA application can be used as a component of another application. An application component is a full-stack library providing functionality on all layers - from database schema to business logic and UI.

In this section, we'll consider an example of creating an application component and using it in a project. The component will provide a "Customer Management" functionality and include the `Customer` entity and corresponding UI screens. The application will use the `Customer` entity from the component as a reference in its `Order` entity.

image::app_components_sample.png[align="center"]

Creating the Customer Management component::

. Create a new project in Studio and specify the following properties on the *New project* screen:

* *Project name* - `customers`

* *Project namespace* - `cust`

* *Root package* - `com.company.customers`

. Edit *Project properties* and on the *Advanced* tab, set the *Module prefix* to `cust`. This is necessary to assemble component artifacts with names different from the default `app`.

. Create the `Customer` entity with at least the `name` attribute. Switch to the *Instance name* tab and specify add `name` to the name pattern attributes.
+
[WARNING]
====
If your component contains `@MappedSuperclass` persistent classes, make sure they have descendants which are entities (i.e. annotated with `@Entity`) in the same project. Otherwise such base classes will not be properly enhanced and you will not be able to use them in applications.
====

. Generate DB scripts and create standard screens for the `Customer` entity: `cust$Customer.browse` and `cust$Customer.edit`. After that, go to main menu designer and rename the `application` menu item to `customerManagement`.

. Click to the *App component descriptor* link on the *Project properties* panel. Save the generated <<app-component.xml,descriptor>> by clicking *OK*.

. Test the Customer Management functionality: *Run > Create database*, *Run > Start application server*, then open `++http://localhost:8080/cust++` in your web browser.

. Install the application component into the local Maven repository by executing the *Run > Install app component* menu command. This command just runs the `install` Gradle task after stopping Gradle daemons.

Creating the Sales application::

. Create a new project in Studio and specify the following properties on the *New project* screen:

* *Project name* - `sales`

* *Project namespace* - `sales`

* *Root package* - `com.company.sales`

. Edit *Project properties* and on the *App components* panel click the plus button next to *Custom components*. In the *Custom application component* dialog, select the `customers` project in the *Registered project* drop-down list. The list contains all project registered in Studio that have an `app-component.xml` descriptor. Click *OK* in the dialog. The Maven coordinates of the Customer Management component will appear in the list of custom components. Save the project properties by clicking *OK*.

. Create the `Order` entity and add the `date` and `amount` attributes. Then add the `customer` attribute as a many-to-one association with the `Customer` entity - it should be available in the *Type* drop-down list.

. Generate DB scripts and create standard screens for the `Order` entity. When creating standard screens, create a `order-with-customer-view` view that includes the `customer` attribute and use it for the screens.

. Test the application functionality: *Run > Create database*, *Run > Start application server*, then open `++http://localhost:8080/app++` in your web browser. The application will contain two top level menu items: *Customer Management* and *Application* with the corresponding functionality.

Modifying the Customer Management component::

Suppose we have to change the component functionality (add an attribute to `Customer`) and then reassemble the application to incorporate the changes.

. Open the `customers` project in Studio.

. Edit the `Customer` entity and add the `address` attribute. When saving the entity, select both browser and editor screens to include the new attribute.

. Generate DB scripts - a script for altering table will be created. Save the scripts.

. Test the changes in the component: *Run > Update database*, *Run > Start application server*, then open `++http://localhost:8080/cust++` in your web browser.

. Re-install the application component into the local Maven repository by executing the *Run > Install app component* menu command.

. Close the `customers` project and open `sales`.

. Execute *Build > Clean*, then *Build > Assemble project* menu commands.

. Execute *Run > Update database* - the update script from the Customer Management component will be executed.

. Execute *Run > Start application server* and open `++http://localhost:8080/app++` in your web browser - the application will contain the `Customer` entity and screens with the new `address` attribute.

Sharing the Customer Management component::

You can share the application component by uploading it to a remote Maven repository.

. Stop the Studio server.

. Set up a repository as explained in <<private_repo>>.

. Open `build.gradle` of the `customers` project in a text editor. Replace the repository and its credentials in `buildscript/repositories` section and add the `uploadRepository` to the `cuba` section:
+
[source,groovy]
----
include::{sourcesdir}/development/app_comp_upload_1.groovy[]
----

. Open the command line and run `gradle assemble` in the `customers` project root directory. This ensures your new repository caches CUBA artifacts required for working in Studio.

. In the Studio server window, specify your repository and credentials instead of the standard CUBA repository. Start the Studio server.

. Open the `customers` project in Studio.

. In the Studio *Search* dialog (Alt-/), find the `uploadArchives` Gradle task and run it. You can also run this task from the command line. The Customer Management component artifacts will be uploaded to your repository.

. Remove the component artifacts from your local Maven repository to ensure that they will be downloaded from the remote repository when the `sales` application is assembled the next time: just delete the `.m2/repository/com/company` folder located in your user home directory.

. Open the `customers` project in Studio. The repository URL in its `build.gradle` will be automatically changed to the one specified in the Studio server window.

. Now you can assemble and run the application - the Customer Management component will be downloaded from the remote repository.
