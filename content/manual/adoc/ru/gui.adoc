[[gui_framework]]
=== Универсальный пользовательский интерфейс

Подсистема универсального пользовательского интерфейса (Generic UI, GUI) позволяет разрабатывать экраны пользовательского интерфейса, используя XML и Java. Созданные таким образом экраны одинаково работоспособны в двух стандартных клиентских <<app_tiers,блоках>>: *Web Client* и *Desktop Client*.

.Структура универсального пользовательского интерфейса 
image::ClientStructure.png[align="center"]

Здесь в центре изображены основные составляющие экранов универсального пользовательского интерфейса:

* <<screen_xml,XML-дескрипторы>> - файлы XML, содержащие информацию об источниках данных и компоновке экрана

* <<screen_controller,Контроллеры>> - классы Java, содержащие логику инициализации экранаи обработки событий от элементов пользовательского интерфейса.

Код экранов приложения, расположенный в <<app_modules,модуле>> *gui*, взаимодействует с интерфейсами визуальных компонентов (VCL Interfaces), реализованными по-отдельности в модулях *web* и *desktop* <<base_projects,базового проекта>> *cuba*. Для *Web Client* реализация основана на фреймворке *Vaadin*, для *Desktop Client* – на фреймворке *Java Swing*.

<<gui_vcl,Библиотека визуальных компонентов>> (Visual Components Library, VCL) содержит большой набор готовых компонентов для отображения данных.

Механизм <<datasources,источников данных>> (Datasources) предоставляет унифицированный интерфейс, обеспечивающий функционирование связанных с данными визуальных компонентов.

Инфраструктура клиента (Infrastructure) включает в себя главное окно приложения, механизмы отображения и взаимодействия экранов UI, а также средства взаимодействия со средним слоем.

[[screens]]
==== Экраны

Экран универсального пользовательского интерфейса состоит из <<screen_xml,XML-дескриптора>> и класса <<screen_controller,контроллера>>. Дескриптор содержит ссылку на класс контроллера. 

Для того чтобы экран можно было вызывать из главного меню или из Java кода (например, из контроллера другого экрана), XML-дескриптор должен быть зарегистрирован в файле <<screens.xml,screens.xml>> проекта.

Главное меню приложения формируется отдельно для *Web Client* и *Desktop Client* на основе файлов <<menu.xml,menu.xml>>, расположенных соответственно в модулях *web* и *desktop* проекта.

===== Типы экранов

В данном разделе рассматриваются основные типы экранов:

* <<frame,Фрейм>>

* <<screen_simple,Простой экран>>

* <<screen_lookup,Экран выбора>>

* <<screen_edit,Экран редактирования>>

[[frame]]
*Фрейм*

Фреймы представляют собой части экранов, которые применяются для декомпозиции и многократного использования.

Для подключения фрейма в XML экрана используется элемент <<gui_IFrame,iframe>> c указанием либо пути к файлу XML фрейма, либо идентификатора фрейма, если он зарегистрирован в <<screens.xml,screens.xml>>.

Контроллер фрейма должен быть унаследован от класса <<abstractFrame,AbstractFrame>>.

Правила взаимодействия экрана и вложенного в него фрейма:

* Из экрана обращаться к компонентам фрейма можно через точку: `++frame_id.component_id++`

* Из контроллера фрейма получить компонент экрана можно обычным вызовом `++getComponent(component_id)++`, но только в том случае, если компонент с таким именем не объявлен в самом фрейме. То есть компоненты фрейма маскируют компоненты экрана.

* Из фрейма получить <<datasources,источник данных>> экрана можно простым вызовом `++getDsContext().get(ds_id)++` или <<screen_controller_injection,инжекцией>>, либо в <<datasource_query,запросе>> `++ds$ds_id++`, но только в том случае, если источник данных с таким именем не объявлен в самом фрейме (аналогично компонентам).

* Из экрана получить источник данных фрейма можно только через итерацию по `getDsContext().getChildren()`

При коммите экрана вызывается также коммит измененных источников данных фрейма.

[[screen_simple]]
*Простой экран*

Простой экран предназначен для отображения и редактирования произвольной информации, в том числе отдельных экземпляров и списков сущностей. Данный тип экрана имеет только базовую функциональность, позволяющую отобразить его в главном окне системы, закрыть, а также работать с <<datasources,источниками данных>>.

Идентификатор экрана в файле <<screens.xml,screens.xml>> может быть произвольного вида.

Контроллер простого экрана должен быть унаследован от класса <<abstractWindow,AbstractWindow>>. 

[[screen_lookup]]
*Экран выбора*

Экран выбора (lookup) отличается от простого экрана тем, что при вызове методом `openLookup()` отображает внизу панель с кнопками, позволяющими передать вызывающему коду экземпляр выбранной в данный момент в списке сущности. При вызове методом `openWindow()` или, например, из главного меню, панель с кнопками выбора не отображается.

В метод `openLookup()` передается объект с интерфейсом `Window.Lookup.Handler`. Метод `handleLookup()` этого объекта вызывается экраном, и ему передается коллекция выбранных пользователем экземпляров сущности. Тем самым вызывающий код получает из экрана выбранные экземпляры. 

Экраны выбора рекомендуется использовать для отображения списков сущностей. Визуальные компоненты, предназначенные для отображения и редактирования ссылок между сущностями (такие как `<<gui_PickerField,PickerField>>`, `<<gui_LookupPickerField,LookupPickerField>>`, `<<gui_SearchPickerField,SearchPickerField>>`), вызывают экраны выбора для поиска связанных сущностей.

Для корректной работы <<standard_actions,стандартных действий>> идентификатор экрана выбора в файле <<screens.xml,screens.xml>> должен иметь вид `++{имя_сущности}.lookup++`, например, `sales$Customer.lookup`.

Контроллер экрана выбора должен быть унаследован от класса <<abstractLookup,AbstractLookup>>. В XML экрана в атрибуте `lookupComponent` должен быть указан компонент (например, `<<gui_Table,Table>>`), из которого будет взят экземпляр сущности при выборе.

[[screen_edit]]
*Экран редактирования*

Экран редактирования предназначен для отображения и редактирования экземпляра сущности. Поддерживает функциональность установки редактируемого экземпляра и <<gui_Action,действия>> по коммиту изменений в базу данных. Экран редактирования должен вызываться методом `openEditor()` с передачей экземпляра сущности.

Для корректной работы <<standard_actions,стандартных действий>> идентификатор экрана редактирования в файле <<screens.xml,screens.xml>> должен иметь вид `++{имя_сущности}.edit++`, например, `sales$Customer.edit`.

Контроллер экрана редактирования должен быть унаследован от класса <<abstractEditor,AbstractEditor>>. В XML экрана в атрибуте `datasource` указывается источник данных, в который проставляется редактируемый экземпляр сущности. Для отображения действий, выполняющих коммит или отмену изменений, в XML можно использовать следующие стандартные фреймы с кнопками:

* `editWindowActions` (файл `com/haulmont/cuba/gui/edit-window.actions.xml`) - содержит кнопки *OK* и *Cancel*

* `extendedEditWindowActions` (файл `com/haulmont/cuba/gui/extended-edit-window.actions.xml`) - содержит кнопки *OK & Close*, *OK* и *Cancel*

В экране редактирования неявно создаются следующие действия:

* `windowCommitAndClose` (соответствует константе `++Window.Editor.WINDOW_COMMIT_AND_CLOSE++`) - действие, выполняющее коммит изменений в базу данных и закрывающее экран. Создается при наличии в экране визуального компонента с идентификатором `windowCommitAndClose`, в частности, при использовании вышеописанного стандартного фрейма `extendedEditWindowActions` отображается кнопкой *OK & Close*.

* `windowCommit` (соответствует константе `++Window.Editor.WINDOW_COMMIT++`) - действие, выполняющее коммит изменений в базу данных. При отсутствии действия `windowCommitAndClose` после коммита закрывает экран. Создается всегда, и при наличии в экране вышеописанных стандартных фреймов отображается кнопкой *OK*.

* `windowClose` (соответствует константе `++Window.Editor.WINDOW_CLOSE++`) - действие, закрывающее экран без коммита изменений. Создается всегда, и при наличии в экране вышеописанных стандартных фреймов отображается кнопкой *Cancel*.

Таким образом, если в экран добавлен фрейм `editWindowActions`, то кнопка *OK* коммитит изменения и закрывает экран, а кнопка *Cancel* - закрывает без коммита. Если же добавлен фрейм `extendedEditWindowActions`, то кнопка *OK* только коммитит изменения, оставляя экран открытым, кнопка *OK & Close* коммитит и закрывает экран, кнопка *Cancel* - закрывает без коммита.

Вместо стандартных фреймов для отображения действий можно использовать произвольные компоненты, например, `<<gui_LinkButton,LinkButton>>`.

[[screen_xml]]
===== XML-дескриптор

XML-дескриптор - это файл формата XML, описывающий <<datasources,источники данных>> и расположение визуальных компонентов экрана.

Схема XML доступна по адресу link:$$http://schemas.haulmont.com/cuba/5.6/window.xsd$$[http://schemas.haulmont.com/cuba/5.6/window.xsd].

Рассмотрим структуру дескриптора.

`window` − корневой элемент.

Атрибуты `window`:

* `class` − имя класса <<screen_controller,контроллера>>

* `messagesPack` − <<message_packs,пакет сообщений>> данного экрана, который будет использован при получении локализованных строк без указания пакета из XML-дескриптора и из контроллера методом `getMessage()`

* `caption` − заголовок экрана, может содержать <<messageTools.loadString,ссылку на сообщение>> из вышеуказанного пакета, например, 
+
[source, properties]
----
caption="msg://caption"
----

* `focusComponent` − идентификатор компонента, который получит фокус ввода при отображении экрана

* `lookupComponent` - обязательный для <<screen_lookup,экрана выбора>> атрибут, задающий идентификатор визуального компонента, из которого будет выбран экземпляр сущности. Поддерживаются компоненты следующих типов (и их наследников):

** `Table`

** `Tree`

** `LookupField`

** `PickerField`

** `OptionsGroup`

* `datasource` - обязательный для <<screen_edit,экрана редактирования>> атрибут, задающий идентификатор <<datasources,источника данных>>, в который будет проставлен экземпляр редактируемой сущности.

Элементы `window`:

* `metadataContext` − элемент для инициализации <<views,представлений>> (views), необходимых данному экрану. Предпочтительным является определение всех представлений в одном общем файле `<<views.xml,views.xml>>`, так как все описатели представлений разворачиваются в один общий репозиторий, и при рассредоточении описателей по разным файлам трудно обеспечить уникальность имен.

* `dsContext` − определяет <<datasources,источники данных>> данного экрана.

* `actions` - определяет список <<gui_Action,действий>> данного экрана.

* `timers` - определяет список таймеров данного экрана.

* `companions` - определяет список классов-<<companions,компаньонов>> данного контроллера
+
Элементы `companions`:

** `web` - задает компаньон, реализованный в модуле *web*

** `desktop` - задает компаньон, реализованный в модуле *desktop*
+
Каждый из этих элементов содержит атрибут `class`, задающий класс компаньона.

* `layout` − корневой элемент компоновки экрана. Является сам по себе контейнером с вертикальным расположением компонентов, аналогичным <<gui_BoxLayout,vbox>>.
+
Атрибуты `layout`:

** <<gui_attr_basic_spacing,spacing>>

** <<gui_attr_basic_margin,margin>>

** <<gui_attr_basic_expand,expand>>

** <<gui_attr_basic_stylename,stylename>>

** <<gui_attr_basic_height,height>>

** <<gui_attr_basic_width,width>>

[[screen_controller]]
===== Контроллер экрана

Контроллер экрана - это `Java` или `Groovy` класс, связанный с <<screen_xml,XML-дескриптором>>, и содержащий логику инициализации и обработки событий экрана.

Контроллер должен быть унаследован от одного из следующих базовых классов:

* `<<abstractFrame,AbstractFrame>>` − предназначен для реализации <<frame,фреймов>>.

* `<<abstractWindow,AbstractWindow>>` − предназначен для реализации <<screen_simple,простых экранов>>.

* `<<abstractLookup,AbstractLookup>>` − предназначен для реализации <<screen_lookup,экранов выбора>>.

* `<<abstractEditor,AbstractEditor>>` − предназначен для реализации <<screen_edit,экранов редактирования>>.

[TIP]
====
Если экрану не нужна никакая дополнительная логика, то в качестве контроллера можно использовать сам базовый класс `AbstractWindow`, `AbstractLookup` или `AbstractEditor`, указав его в XML-дескрипторе (эти классы на самом деле не являются абстрактными в смысле невозможности создания экземпляров). Для фрейма класс контроллера можно не указывать вообще.
====

Класс контроллера должен быть зарегистрирован в XML-дескрипторе экрана в атрибуте `class` корневого элемента `window`.

.Базовые классы контроллеров
image::Controllers.png[align="center"]

[[abstractFrame]]
*AbstractFrame*

`AbstractFrame` является корнем иерархии классов контроллеров. Рассмотрим его основные методы:

* `init()` - вызывается фреймворком после создания всего дерева компонентов, описанного XML-дескриптором, но до отображения экрана.
+
В метод `init()` из вызывающего кода передается мэп параметров, которые могут быть использованы внутри контроллера. Эти параметры могут быть переданы как из кода контроллера вызывающего экрана (в методе `openWindow()`, `openLookup()` или `openEditor()`), так и установлены в файле регистрации экранов `<<screens.xml,screens.xml>>`.
+
Метод `init()` следует имплементировать при необходимости инициализации компонентов экрана, например:
+
[source, java]
----
@Inject
private Table someTable;

@Override
public void init(Map<String, Object> params) {
  someTable.addGeneratedColumn("someColumn", new Table.ColumnGenerator<Colour>() {
      @Override
      public Component generateCell(Colour entity) {
          ...
      }
  });
}
----

* `getMessage()`, `formatMessage()` - методы получения локализованных сообщений из <<message_packs,пакета>>, заданного для экрана в XML-дескрипторе. Представляют собой просто короткие варианты вызова одноименных методов интерфейса `<<messages,Messages>>`.

* `getDialogParams()` - получить объект `DialogParams` для установки параметров отображения диалоговых окон (высота, ширина и пр.). Значения, установленные в этом объекте, влияют на следующий экран, открываемый в режиме модального диалога (`WindowManager.OpenType.DIALOG`). После отображения диалога они сбрасываются в значения по умолчанию.
+
Таким образом, устанавливать значения в `DialogParams` необходимо непосредственно перед вызовом другого экрана в режиме диалога методами `openWindow()`, `openLookup()`, `openEditor()`. Например:
+
[source, java]
----
getDialogParams().setWidth(400);
openEditor("sales$Customer.edit", customer, WindowManager.OpenType.DIALOG);
----
+
Если же сам текущий экран открывается в режиме модального диалога, то можно управлять параметрами его отображения, устанавливая параметры `DialogParams` в его методе `init()`. При этом установленные в `init()` параметры имеют приоритет над установленными в вызывающем коде.

* `openFrame()` - загрузить фрейм по идентификатору, зарегистрированному в `<<screens.xml,screens.xml>>`, и, если в метод передан компонент-контейнер, отобразить его внутри контейнера. Возвращается контроллер фрейма. Например:
+
[source, java]
----
@Inject
private BoxLayout container;

@Override
public void init(Map<String, Object> params) {
  SomeFrame frame = openFrame(container, "someFrame");
  frame.setHeight("100%");
  frame.someInitMethod();
}
----
+
Контейнер не обязательно сразу передавать в метод `openFrame()`, вместо этого можно загрузить фрейм, а затем добавить его в нужный контейнер:
+
[source, java]
----
@Inject
private BoxLayout container;

@Override
public void init(Map<String, Object> params) {
  SomeFrame frame = openFrame(null, "someFrame");
  frame.setHeight("100%");
  frame.someInitMethod();
  container.add(frame);
}
----

* `openWindow()`, `openLookup()`, `openEditor()` - открыть соответственно простой экран, экран выбора или редактирования. Методы возвращают контроллер созданного экрана.
+
Для выполнения действий после закрытия вызываемого экрана необходимо добавить слушатель типа `CloseListener`, например:
+
[source, java]
----
CustomerEdit editor = openEditor("sales$Customer.edit", customer, WindowManager.OpenType.THIS_TAB);
editor.addListener(new CloseListener() {
  @Override
  public void windowClosed(String actionId) {
      // do something
  }
});
----

* `showMessageDialog()` - отобразить диалоговое окно с сообщением.

* `showOptionDialog()` - отобразить диалоговое окно с сообщением и возможностью выбора пользователем некоторых действий. Действия задаются массивом объектов типа `<<gui_Action,Action>>`, которые в диалоге отображаются посредством соответствующих кнопок.
+
Для отображения стандартных кнопок типа *OK*, *Cancel* и других рекомендуется использовать объекты типа `DialogAction`, например:
+
[source, java]
----
showOptionDialog("PLease confirm", "Are you sure?",
      MessageType.CONFIRMATION,
      new Action[] {
              new DialogAction(DialogAction.Type.YES) {
                  @Override
                  public void actionPerform(Component component) {
                      // do something
                  }
              },
              new DialogAction(DialogAction.Type.NO);
      });
----

* `showNotification()` - отобразить всплывающее окно с сообщением.

* `showWebPage()` - открыть указанную веб-страницу в браузере.

[[abstractWindow]]
*AbstractWindow*

`AbstractWindow` является наследником `<<abstractFrame,AbstractFrame>>`, и определяет следующие собственные методы:

* `ready()` - шаблонный метод, который можно имплементировать в контроллере для перехвата момента открытия экрана. Метод `ready()` вызывается фреймворком после метода `init()` непосредственно перед показом экрана в главном окне приложения.

* `validateAll()` - валидация экрана. Реализация по умолчанию вызывает метод `validate()` у всех компонентов экрана, реализующих интерфейс `Component.Validatable`, накапливает информацию об исключениях, и если таковые имеются, выводит соответствующее сообщение и возвращает `false`, иначе возвращает `true`.
+
Данный метод следует переопределять только в том случае, если необходимо полностью заменить стандартную процедуру валидации экрана. Если же нужно только дополнить ее, достаточно определить специальный шаблонный метод `postValidate()`.

* `postValidate()` - шаблонный метод, который можно имплементировать в контроллере для дополнительной валидации экрана. Получаемый методом объект `ValidationErrors` используется для добавления информации об ошибках валидации, которая будет отображена совместно с ошибками стандартной валидации. Например:
+
[source, java]
----
private Pattern pattern = Pattern.compile("\\d");

@Override
protected void postValidate(ValidationErrors errors) {
  if (getItem().getAddress().getCity() != null) {
      if (pattern.matcher(getItem().getAddress().getCity()).find()) {
          errors.add("City name can't contain digits");
      }
  }
}
----

* `close()` - закрыть данный экран. 
+
Метод принимает строковое значение, передаваемое далее в шаблонный метод `preClose()` и слушателям `CloseListener`. Таким образом, заинтересованный код может получить информацию о причине закрытия экрана от кода, инициирующего закрытие. В частности, в экранах редактирования сущностей при закрытии экрана после коммита изменений рекомендуется использовать константу `++Window.COMMIT_ACTION_ID++`, без коммита изменений - константу `++Window.CLOSE_ACTION_ID++`.
+
Если какой-либо из источников данных содержит несохраненные изменения, перед закрытием экрана будет выдано диалоговое окно с соответствующим предупреждением. Тип предупреждения можно выбрать с помощью свойства приложения `<<cuba.gui.useSaveConfirmation,cuba.gui.useSaveConfirmation>>`.
+
Вариант метода `close()` с параметром `force = true` закрывает экран без вызова `preClose()` и без предупреждения, независимо от наличия несохраненных изменений.
+
Метод `close()` возвращает `true`, если экран был успешно закрыт, и `false` - если закрытие было прервано.

* `preClose()` - шаблонный метод, который можно имплементировать в контроллере для перехвата момента закрытия экрана. Метод получает строковое значение, указанное инициатором закрытия при вызове метода `close()`.
+
Если метод `preClose()` возвращает `false`, то процесс закрытия экрана прерывается.

[[abstractLookup]]
*AbstractLookup*

`AbstractLookup` базовый класс контроллеров <<screen_lookup,экранов выбора>>, является наследником `<<abstractWindow,AbstractWindow>>`, и определяет следующие собственные методы:

* `setLookupComponent()` - установить компонент, из которого будет производиться выбор экземпляров сущности.
+
Как правило, компонент выбора устанавливается в XML-дескрипторе экрана, и вызывать данный метод в прикладном коде нет необходимости.

* `setLookupValidator()` - установить для экрана объект типа `Window.Lookup.Validator`, метод `validate()` которого вызывается фреймворком перед тем как вернуть выбранные экземпляры сущностей. Если `validate()` возвращает `false`, процесс выбора и закрытия экрана прерывается.
+
По умолчанию валидатор не установлен.

[[abstractEditor]]
*AbstractEditor*

`AbstractEditor` − базовый класс контроллеров <<screen_edit,экранов редактирования>>, является наследником `<<abstractWindow,AbstractWindow>>`.

При создании конкретного класса контроллера рекомендуется параметризовать `AbstractEditor` типом редактируемой сущности. При этом методы `getItem()` и `initItem()` будут работать с конкретным типом сущности и прикладному коду не потребуется дополнительных приведений типов. Например:

[source, java]
----
public class CustomerEdit extends AbstractEditor<Customer> {

  @Override
  protected void initItem(Customer item) {
  ...
----

`AbstractEditor` определяет следующие собственные методы:

* `getItem()` - возвращает экземпляр редактируемой сущности, установленный в главном источнике данных экрана (т.е. указанном в атрибуте `datasource` корневого элемента XML-дескриптора).
+
Если редактируется не новый экземпляр, то в момент открытия экрана он перезагружается из базы данных с необходимым <<views,представлением>>, указанным для главного источника данных. 
+
Изменения, вносимые в экземпляр, возвращаемый `getItem()`, отражаются на состоянии источника данных, и будут отправлены на *Middleware* при коммите экрана.
+
[WARNING]
====
Следует иметь в виду, что `getItem()` возвращает значение только после инициализации экрана методом `setItem()`. До этого момента, например, в методах `init()` и `initItem()`, данный метод возвращает `null`.

Однако в методе `init()` экземпляр сущности, переданный в `openEditor()`, можно получить из параметров следующим образом:

[source, java]
----
@Override
public void init(Map<String, Object> params) {
  Customer item = WindowParams.ITEM.getEntity(params);
  // do something
}
----

В метод `initItem()` экземпляр передается явно и нужного типа.

В обоих случаях полученный экземпляр сущности, если он не новый, будет впоследствии перезагружен, и вносить в него изменения или сохранять в поле для последующего использования не имеет смысла.
====

* `setItem()` - вызывается фреймворком при открытии экрана методом `openEditor()` для установки редактируемого экземпляра сущности в главном источнике данных. В момент вызова созданы все компоненты и источники данных экрана, и отработал метод `init()` контроллера.
+
Для инициализации экрана редактирования вместо переопределения `setItem()` рекомендуется имплементировать специальные шаблонные методы `initItem()` и `postInit()`.

* `initNewItem()` - шаблонный метод, вызываемый фреймворком перед установкой редактируемого экземпляра сущности в главном источнике данных.
+
[TIP]
====
Метод `initNewItem()` вызывается только для нового, только что созданного экземпляра сущности. Если редактируется <<entity_states,detached>> экземпляр, метод не вызывается.
====
+
Данный метод можно имплементировать в контроллере при необходимости инициализации нового экземпляра сущности перед его установкой в источник данных, например:
+
[source, java]
----
@Inject
private UserSession userSession;

@Override
protected void initNewItem(Complaint item) {
  item.setOpenedBy(userSession.getUser());
  item.setStatus(ComplaintStatus.OPENED);
}
----
+
Более сложный пример использования `initNewItem()` приведен в разделе <<init_values_in_initNewItem,рецептов разработки>>.

* `postInit()` - шаблонный метод, вызываемый фреймворком сразу после установки редактируемого экземпляра сущности в главном источнике данных. Во время выполнения данного метода можно вызывать `getItem()`, который будет возвращать новый или перезагруженный при инициализации экрана экземпляр сущности.
+
Данный метод можно имплементировать в контроллере для окончательной инициализации экрана, например:
+
[source, java]
----
@Inject
protected EntityDiffViewer diffFrame;

@Override
protected void postInit() {
  if (!PersistenceHelper.isNew(getItem())) {
      diffFrame.loadVersions(getItem());
  }
}
----

* `commit()` - валидировать экран и отправить изменения через `<<dataSupplier,DataSupplier>>` на *Middleware*.
+
Если используется вариант метода с параметром `validate = false`, то валидация перед коммитом не производится.
+
Данный метод не рекомендуется переопределять, лучше использовать специальные шаблонные методы `postValidate()`, `preCommit()` и `postCommit()`.

* `commitAndClose()` - валидировать экран, отправить изменения на *Middleware* и закрыть экран. В метод `preClose()` и зарегистрированным слушателям `CloseListener` будет передано значение константы `++Window.COMMIT_ACTION_ID++`.
+
Данный метод не рекомендуется переопределять, лучше использовать специальные шаблонные методы `postValidate()`, `preCommit()` и `postCommit()`.

* `preCommit()` - шаблонный метод, вызываемый фреймворком в процессе коммита изменений, после того как валидация завершена успешно и перед отправкой данных на *Middleware*.
+
Данный метод можно имплементировать в контроллере. Если метод возвращает `false`, процесс коммита (и закрытия экрана, если был вызван `commitAndClose()`), прерывается. Например:
+
[source, java]
----
@Override
protected boolean preCommit() {
  if (somethingWentWrong) {
      showNotification("Something went wrong", NotificationType.WARNING);
      return false;
  }
  return true;
}
----

* `postCommit()` - шаблонный метод, вызываемый фреймворком на финальной стадии коммита изменений. Параметры метода:

** `committed` - установлен в `true`, если в экране действительно были изменения, и они отправлены на *Middleware*;

** `close` - установлен в `true`, если экран после коммита будет закрыт.
+
Реализация метода по умолчанию, если экран не закрывается, отображает сообщение об успешном коммите изменений и вызывает метод `postInit()`.
+
Данный метод можно переопределить в контроллере для выполнения некоторых действий после успешного коммита, например:
+
[source, java]
----
@Inject
private Datasource<Driver> driverDs;
@Inject
private EntitySnapshotService entitySnapshotService;

@Override
protected boolean postCommit(boolean committed, boolean close) {
  if (committed) {
      entitySnapshotService.createSnapshot(driverDs.getItem(), driverDs.getView());
  }
  return super.postCommit(committed, close);
}
----

Далее приведены диаграммы последовательностей инициализации и различных вариантов коммита экрана редактирования.

.Инициализация экрана редактирования
image::EditorInit.png[align="center"]

.Коммит и закрытие экрана с фреймом editWindowActions
image::EditorCommit.png[align="center"]

.Коммит экрана с фреймом extendedEditWindowActions
image::ExtendedEditorCommit.png[align="center"]

.Коммит и закрытие экрана с фреймом extendedEditWindowActions
image::ExtendedEditorCommitAndClose.png[align="center"]

[[screen_controller_injection]]
*Инжекция зависимостей контроллеров*

В контроллерах можно использовать Dependency Injection для получения ссылок на используемые объекты. Для этого нужно объявить либо поле соответствующего типа, либо метод доступа на запись (setter) с соответствующим типом результата, и добавить ему одну из следующих аннотаций:

* `@Inject` - простейший вариант, поиск объекта для инжекции будет произведен по типу поля/метода и по имени, эквивалентному имени поля либо имени атрибута (по правилам JavaBeans) для метода

* `@Named("someName")` - вариант с явным указанием имени искомого объекта

Инжектировать в контроллеры можно следующие объекты: 

* Визуальные компоненты данного экрана, определенные в XML-дескрипторе. Если тип атрибута унаследован от `Component`, в текущем экране будет произведен поиск компонента с соответствующим именем. 

* Действия, определенные в XML-дескрипторе - см. <<gui_Action,Действия. Интерфейс Action>>

* <<datasources,Источники данных>>, определенные в XML-дескрипторе. Если тип атрибута унаследован от `Datasource`, в текущем экране будет произведен поиск источника данных с соответствующим именем. 

* `UserSession`. Если тип атрибута - `<<userSession,UserSession>>`, будет инжектирован объект текущей пользовательской сессии.

* `DsContext`. Если тип атрибута - `DsContext`, будет инжектирован `DsContext` текущего экрана. 

* `WindowContext`. Если тип атрибута - `WindowContext`, будет инжектирован `WindowContext` текущего экрана. 

* `DataSupplier`. Если тип атрибута - `<<dataSupplier,DataSupplier>>`, будет инжектирован соответствующий экземпляр.

* Любой бин, определенный в контексте данного клиентского блока приложения, в том числе:

** импортируемые клиентом <<services,сервисы>> *Middleware*

** <<config_interfaces,конфигурационные интерфейсы>>

** `ComponentsFactory`

** `WindowConfig`

** `ExportDisplay`

** `<<background_tasks,BackgroundWorker>>`

* Если ничего из вышеперечисленного не подошло и контроллер имеет <<companions,компаньонов>>, в случае совпадения типов будет инжектирован компаньон для текущего типа клиента.

С помощью специальной аннотации `@WindowParam` можно инжектировать в контроллер параметры, передаваемые в мэп метода `init()`. Аннотация имеет атрибут `name`, в котором указывается имя параметра (ключ в мэп), и опциональный атрибут `required`. Если `required = true`, то при отсутствии в мэп соответствующего параметра в лог выводится сообщение с уровнем `WARNING`. 

Пример инжекции объекта типа `Job`, передаваемого в метод `init()` контроллера:

[source, java]
----
@WindowParam(name = "job", required = true)
protected Job job;
----

[[companions]]
*Компаньоны контроллеров*

Базовые классы контроллеров расположены в <<app_modules,модуле>> *gui* <<base_projects,базового проекта>> *cuba* и не содержат ссылок на классы реализации визуальных компонентов (*Swing* или *Vaadin*), что дает возможность использовать их в клиентах обоих типов. Вместо этого базовые классы контроллеров реализуют дополнительный интерфейс `Window.Wrapper` и делегируют выполнение "обернутому" окну. 

В то же время конкретные классы контроллеров могут быть расположены как в модуле *gui*, так и в *web* или *desktop*, в зависимости от применяемых в проекте клиентских <<app_tiers,блоков>> и специфики экрана. Если контроллер является универсальным, но для разных типов клиента требуется дополнительная функциональность, ее можно определить в так называемых _классах-компаньонах_. 

Класс-компаньон располагается в модуле клиента соответствующего типа (*web* или *desktop*) и реализует интерфейс, задаваемый в использующем его контроллере. Класс компаньона задается в элементе `companions` XML-дескриптора экрана. Контроллер может получить ссылку на экземпляр компаньона с помощью инжекции или вызовом `getCompanion()`, и в нужный момент передать ему управление, например, для дополнительной инициализации визуальных компонентов специфичным для данного типа клиента способом. 

Например, необходимо раздельно для веб и десктоп клиентов проинициализировать таблицу некоторого экрана. Тогда в контроллере экрана, расположенном в модуле *gui*, определяем интерфейс компаньона и делегируем ему инициализацию таблицы:

[source, java]
----
public class CustomerBrowse extends AbstractLookup {

  public interface Companion {
      void initTable(Table table);
  }

  @Inject
  protected Table table;

  @Inject
  protected Companion companion;

  @Override
  public void init(Map<String, Object> params) {
      if (companion != null) {
          companion.initTable(table);
      }
  }
}
----

В модулях *web* и *desktop* создаем соответствующие классы реализации компаньона:

[source, java]
----
public class WebCustomerBrowseCompanion implements CustomerBrowse.Companion {
  @Override
  public void initTable(Table table) {
      com.vaadin.ui.Table webTable = (com.vaadin.ui.Table) WebComponentsHelper.unwrap(table);
      // do something specific to Vaadin table
  }
}
----

[source, java]
----
public class DesktopCustomerBrowseCompanion implements CustomerBrowse.Companion {
  @Override
  public void initTable(Table table) {
      javax.swing.JTable desktopTable = (javax.swing.JTable) DesktopComponentsHelper.unwrap(table);
      // do something specific to Swing table
  }
}
----

И регистрируем классы реализации компаньона в XML-дескрипторе экрана:

[source, xml]
----
<window ...
      class="com.company.sample.gui.customers.CustomerBrowse">
  <companions>
      <web class="com.company.sample.web.customers.WebCustomerBrowseCompanion"/>
      <desktop class="com.company.sample.desktop.customers.DesktopCustomerBrowseCompanion"/>
  </companions>
  <dsContext>...</dsContext>
  <layout>...</layout>
</window>
----

Так как классы-компаньоны расположены в *web* и *desktop* модулях, в них можно использовать метод `unwrap()` классов <<webComponentsHelper,WebComponentsHelper>> и <<desktopComponentsHelper,DesktopComponentsHelper>> для извлечения из интерфейса <<gui_Table,Table>> ссылок на реализующие таблицу Vaadin и Swing компоненты, и работать с ними непосредственно.

include::gui_vcl.adoc[]

[[datasources]]
==== Источники данных

Источники данных обеспечивают работу связанных с данными (data-aware) компонентов.

Визуальные компоненты сами не обращаются к *Middleware*, а получают экземпляры сущностей из связанных источников данных. При этом один источник данных может обслуживать несколько визуальных компонентов, если им нужен один и тот же экземпляр или набор экземпляров.

Связь визуального компонента и источника данных проявляется в следующем:

* При изменении пользователем значения в компоненте новое значение проставляется в атрибуте сущности, находящейся в источнике.

* При изменении атрибута сущности из кода новое значение проставляется и отображается в визуальном компоненте. 

* Для слежения за вводом пользователя можно использовать как <<datasource_listeners,слушатель источника данных>>, так и слушатель значения визуального компонента - они срабатывают друг за другом. 

* При необходимости прочитать или записать значение атрибута сущности в коде предпочтительнее использовать источник данных, а не компонент. Рассмотрим пример чтения атрибута: 
+
[source, java]
----
include::{sourcesdir}/gui/datasources_1.java[]
---- 
+
Как видно из примера, работа со значениями атрибутов сущностей через компонент требует приведения типа и, в случае <<gui_FieldGroup,FieldGroup>>, указания имени атрибута в виде строки. В то же время, получив методом `getItem()` из источника данных хранящийся в нем экземпляр, можно напрямую читать и изменять значения его атрибутов.

[WARNING]
====
Как правило, визуальный компонент привязывается к атрибуту, непосредственно принадлежащему сущности, находящейся в источнике данных. В приведенном выше примере компонент привязан к атрибуту `customer` сущности `Order`. 

Можно также привязать компонент к атрибуту связанной сущности, например к `customer.name`. В этом случае компонент будет корректно отображать значение атрибута `name`, но при его изменении пользователем слушатели источника данных вызваны не будут, и изменения не будут сохранены. Поэтому привязывать компонент к атрибутам второго и более порядка имеет смысл только для отображения, например в <<gui_Label,Label>>, колонке <<gui_Table,Table>> или установив для <<gui_TextField,TextField>> свойство `editable = false`.
====

Источники данных также отслеживают изменения содержащихся в них сущностей, и могут отправлять измененные экземпляры обратно на *Middleware* для сохранения в базе данных.

Рассмотрим основные интерфейсы источников.

.Интерфейсы источников данных
image::Datasources.png[align="center"]

* `Datasource` − простейший источник данных, предназначенный для работы с одним экземпляром сущности. Экземпляр устанавливается методом `setItem()` и доступен через `getItem()`.
+
Стандартной реализацией такого источника является класс `DatasourceImpl`, который используется, например, как главный источник данных в <<screen_edit,экранах редактирования>> сущностей.

* `CollectionDatasource` − источник данных, предназначенный для работы с коллекцией экземпляров сущности. Коллекция загружается при вызове метода `refresh()`, ключи экземпляров доступны через метод `getItemIds()`. Метод `setItem()` устанавливает, а `getItem()` возвращает "текущий" экземпляр коллекции, т.е., например, соответствующий выбранной в данный момент строке таблицы.
+
Способ загрузки коллекции сущностей определяется реализацией. Наиболее типичный - загрузка с Middleware через <<dataManager,DataManager>>, при этом для формирования JPQL запроса используются методы `setQuery()`, `setQueryFilter()`.
+
Стандартной реализацией такого источника является класс `CollectionDatasourceImpl`, который используется в экранах, отображающих списки сущностей.

** `GroupDatasource` − подвид `CollectionDatasource`, предназначенный для работы с компонентом `<<gui_GroupTable,GroupTable>>`.
+
Стандартной реализацией является класс `GroupDatasourceImpl`.

** `HierarchicalDatasource` − подвид `CollectionDatasource`, предназначенный для работы с компонентами `<<gui_Tree,Tree>>` и `<<gui_TreeTable,TreeTable>>`.
+
Стандартной реализацией является класс `HierarchicalDatasourceImpl`.

* `NestedDatasource` - источник данных, предназначенный для работы с экземплярами, загруженными в атрибуте другой сущности. При этом источник, содержащий сущность-хозяина, доступен методом `getMaster()`, а <<metaProperty,мета-свойство>>, соответствующее атрибуту хозяина, содержащему экземпляры данного источника, доступно через метод `getProperty()`.
+
Например, в источнике `dsOrder` установлен экземпляр сущности `Order`, содержащий ссылку на экземпляр `Customer`. Тогда для связи экземпляра `Customer` с визуальными компонентами достаточно создать `NestedDatasource`, у которого хозяином является `dsOrder`, а мета-свойство указывает на атрибут `Order.customer`.

** `PropertyDatasource` - подвид `NestedDatasource`, предназначенный для работы с одним экземпляром или коллекцией связанных сущностей, не являющихся встроенными (embedded).
+
Стандартные реализации: для работы с одним экземпляром - `PropertyDatasourceImpl`, для работы с коллекцией - `CollectionPropertyDatasourceImpl`, `GroupPropertyDatasourceImpl`, `HierarchicalPropertyDatasourceImpl`. Последние реализуют также интерфейс `CollectionDatasource`, однако некоторые его нерелевантные методы, связанные с загрузкой, например, `setQuery()`, выбрасывают `UnsupportedOperationException`.

** `EmbeddedDatasource` - подвид `NestedDatasource`, содержащий экземпляр встроенной сущности.
+
Стандартной реализацией является класс `EmbeddedDatasourceImpl`.

* `RuntimePropsDatasource` − специфический источник, предназначенный для работы с <<dynamic_attributes,динамическими атрибутами>> сущностей.

Как правило, источники данных объявляются декларативно в секции `dsContext` <<screen_xml,дескриптора экрана>>.

===== Создание источников данных

Объекты источников данных могут быть созданы как декларативно - путем объявления в XML-дескрипторе экрана, так и программно в контроллере. Обычно используются стандартные реализации интерфейсов источников, однако при необходимости можно создать собственный класс, унаследовав его от стандартного.

*Декларативное создание*

Как правило, источники данных объявляются декларативно в элементе `dsContext` дескриптора экрана. В зависимости от взаимного расположения элементов объявлений создаются источники двух разновидностей:

* если элемент расположен непосредственно в `dsContext`, создается обычный `Datasource` или `CollectionDatasource`, который содержит независимо загруженную сущность или коллекцию;

* если элемент расположен внутри элемента другого источника, создается `NestedDatasource`, при этом внешний источник становится его хозяином. 

Пример объявления источников данных:

[source, xml]
----
<dsContext>
  <datasource id="carDs" class="com.haulmont.sample.entity.Car" view="carEdit">
      <collectionDatasource id="allocationsDs" property="driverAllocations"/>
      <collectionDatasource id="repairsDs" property="repairs"/>
  </datasource>

  <collectionDatasource id="colorsDs" class="com.haulmont.sample.entity.Color" view="_local">
      <query>
          select c from sample$Color c order by c.name
      </query>
  </collectionDatasource>
</dsContext>
----

Здесь источник `carDs` содержит один экземпляр сущности `Car`, а вложенные в него `allocationsDs` и `repairsDs` содержат коллекции связанных сущностей из атрибутов `Car.driverAllocations` и `Car.repairs` соответственно. Экземпляр `Car` вместе со связанными сущностями проставляется в источник данных извне. Если данный экран является <<screen_edit,экраном редактирования>>, то это происходит автоматически при открытии экрана. Источник данных `colorsDs` содержит коллекцию экземпляров сущности `Color`, загружаемую самим источником по указанному JPQL-<<datasource_query,запросу>> с <<views,представлением>> `++_local++`.

Рассмотрим схему XML. 

`dsContext` - корневой элемент.

Элементы `dsContext`:

* `datasource` - определяет источник данных, содержащий единственный экземпляр сущности. 
+
Атрибуты:

** `id` - идентификатор источника, должен быть уникальным для данного `DsContext`.

** `class` - Java класс сущности, которая будет содержаться в данном источнике

** `view` - имя <<views,представления>> сущности. Если источник сам загружает экземпляры, то это представление будет использовано при загрузке. В противном случае это представление сигнализирует внешним механизмам о том, как нужно загрузить сущность для данного источника.

** `allowCommit` - при установке значения `false` метод `isModified()` данного источника всегда возвращает `false`, а метод `commit()` ничего не делает. Таким образом, изменения содержащихся в источнике сущностей игнорируются. По умолчанию `true`, т.е. изменения отслеживаются и могут быть сохранены.

** `datasourceClass` - нестандартный класс реализации источника данных, если необходим.

* `collectionDatasource` - определяет источник данных, содержащий коллекцию экземпляров.
+
Атрибуты `collectionDatasource`:

** `refreshMode` - режим обновления источника, по умолчанию `ALWAYS`. В режиме `NEVER` при вызове `refresh()` источник не производит загрузку данных, а только переходит в состояние `Datasource.State.VALID`, оповещает слушателей и сортирует имеющиеся в нем экземпляры. Режим `NEVER` удобен, если необходимо программно заполнить `CollectionDatasource` предварительно загруженными или созданными сущностями. Например:
+
[source, java]
----
@Override
public void init(Map<String, Object> params) {
  Set<Customer> entities = (Set<Customer>) params.get("customers");
  for (Customer entity : entities) {
      customersDs.includeItem(entity);
  }
  customersDs.refresh();
}
----

** `softDeletion` - значение `false` отключает режим <<soft_deletion,мягкого удаления>> при загрузке сущностей, т.е. будут загружены также и удаленные экземпляры. По умолчанию `true`.
+
Элементы `collectionDatasource`:

** `query` - <<datasource_query,запрос>> для загрузки сущностей

* `groupDatasource` - полностью аналогичен `collectionDatasource`, но создает реализацию источника данных, пригодную для использования совместно с компонентом `<<gui_GroupTable,GroupTable>>`.

* `hierarchicalDatasource` - аналогичен `collectionDatasource`, и создает реализацию источника данных, пригодную для использования совместно с компонентами `<<gui_Tree,Tree>>` и `<<gui_TreeTable,TreeTable>>`.
+
Специфическим атрибутом является `hierarchyProperty`, задающий имя атрибута сущности, по которому строится иерархия.

Класс реализации источника выбирается неявно на основе имени элемента XML и, как было сказано выше, взаимного расположения элементов. Однако если необходимо применить нестандартный источник данных, его класс может быть явно указан в атрибуте `datasourceClass`. 

*Программное создание*

При необходимости создать источник данных в Java коде рекомендуется воспользоваться специальным классом `DsBuilder`. 

Экземпляр `DsBuilder` параметризуется цепочкой вызовов его методов в стиле текучего (fluent) интерфейса. Если установлены параметры `master` и `property`, то в результате будет создан `NestedDatasource`, в противном случае - `Datasource` или `CollectionDatasource`.

Пример:

[source, java]
----
CollectionDatasource ds = new DsBuilder(getDsContext())
      .setJavaClass(Order.class)
      .setViewName(View.LOCAL)
      .setId("ordersDs")
      .buildCollectionDatasource();
----

*Собственные классы реализации*

Как правило, нестандартная реализация источника данных требуется для изменения процесса загрузки коллекции сущностей. При создании класса такого источника рекомендуется унаследовать его от `CollectionDatasourceImpl`, либо от `GroupDatasourceImpl` или `HierarchicalDatasourceImpl`, и переопределить метод `loadData()`.

Пример:

[source, java]
----
public class MyDatasource extends CollectionDatasourceImpl<SomeEntity, UUID> {

  private SomeService someService = AppBeans.get(SomeService.NAME);

  @Override
  protected void loadData(Map<String, Object> params) {
      detachListener(data.values());
      data.clear();

      for (SomeEntity entity : someService.getEntities()) {
          data.put(entity.getId(), entity);
          attachListener(entity);
      }
  }
}
----

Здесь `data` - поле базового класса, хранящее коллекцию загруженных экземпляров. Методы базового класса `detachListener()` и `attachListener()` управляют назначением на загруженные сущности слушателя, который оповещает источник данных об изменениях в полях экземпляров.

Для создания нестандартного источника данных декларативным способом необходимо указать класс в атрибуте `datasourceClass` элемента XML. При программном создании через `DsBuilder` класс источника указывается вызовом `setDsClass()`.

[[datasource_query]]
===== Запросы в CollectionDatasourceImpl

Класс `CollectionDatasourceImpl` и его наследники `GroupDatasourceImpl`, `HierarchicalDatasourceImpl` являются стандартной реализацией источников данных, работающих с коллекциями независимых экземпляров сущностей. Эти источники загружают данные через `DataManager`, отправляя на *Middleware* запрос на языке JPQL. Далее рассматриваются особенности формирования таких запросов.

[[datasource_query_results]]
*Возвращаемые значения*

Запрос должен возвращать сущности того типа, который указан при создании источника данных. Тип сущности при декларативном создании указывается в атрибуте `class` элемента XML, при создании через `DsBuilder` - в методе `setJavaClass()` или `setMetaClass()`.

Кроме того, тип объекта в предложении `from` запроса должен соответствовать типу источника. Это необходимо для проведения автоматических трансформаций запроса при наложении ограничений безопасности и др.

Например, запрос источника данных типа `Customer` может выглядеть следующим образом:

[source, sql]
----
select c from sales$Customer c
----

Примеры недопустимых для источника типа `Customer` запросов:

[source, sql]
----
select c.id, c.name from sales$Customer c /* неверно - возвращает отдельные поля, а не весь объект Customer */

select o.customer from sales$Order o /* неверно - тип from (Order) отличается от типа результата (Customer) */
----

[[datasource_query_params]]
*Параметры запроса*

JPQL-запрос в источнике данных может содержать параметры нескольких видов. Вид параметра определяется по префиксу имени параметра. Префиксом является часть имени до знака "$". Интерпретация имени после "$" рассматривается ниже.

* Префикс `ds`.
+
Значением параметра являются данные другого источника данных, зарегистрированного в этом же `DsContext`. Например:
+
[source, xml]
----
<collectionDatasource id="customersDs" class="com.sample.sales.entity.Customer" view="_local">
  <query>
      select c from sales$Customer c
  </query>
</collectionDatasource>

<collectionDatasource id="ordersDs" class="com.sample.sales.entity.Order" view="_local">
  <query>
      select o from sales$Order o where o.customer.id = :ds$customersDs
  </query>
</collectionDatasource>
----
+
В данном случае параметром запроса источника данных `ordersDs` будет текущий экземпляр сущности, находящийся в источнике данных `customersDs`. 
+
При использовании параметров с префиксом `ds` между источниками данных автоматически создаются зависимости, приводящие к обновлению источника если меняется значение его параметра. В приведенном примере если изменяется выбранный Покупатель, автоматически обновляется список его Заказов. 
+
Обратите внимание, что в примере запроса с параметром левой частью оператора сравнения является значение идентификатора `o.customer.id`, а правой - экземпляр `Customer`, содержащийся в источнике `customersDs`. Такое сравнение допустимо, так как при выполнении запроса на *Middleware* реализация интерфейса <<query,Query>>, присваивая значения параметрам запроса, автоматически подставляет ID сущности вместо переданного экземпляра сущности.
+
В имени параметра после префикса и имени источника может быть также указан путь по графу сущностей к атрибуту, из которого нужно взять значение, например: 
+
[source, xml]
----
<query>
  select o from sales$Order o where o.customer.id = :ds$customersDs.id
</query>
----
+
или
+
[source, xml]
----
<query>
  select o from sales$Order o where o.tagName = :ds$customersDs.group.tagName
</query>
----

* Префикс `custom`. 
+
Значение параметра будет взято из объекта `Map<String, Object>`, переданного в метод `refresh()` источника данных. Например:
+
[source, xml]
----
<collectionDatasource id="ordersDs" class="com.sample.sales.entity.Order" view="_local">
  <query>
      select o from sales$Order o where o.number = :custom$number
  </query>
</collectionDatasource>
----
+
[source, java]
----
Map<String, Object> params = new HashMap<>();
params.put("number", "1");
ordersDs.refresh(params);
----
+
Приведение экземпляра при необходимости к его идентификатору осуществляется аналогично параметрам с префиксом `ds`. Путь по графу сущностей в имени параметра в данном случае не поддерживается. 

* Префикс `param`. 
+
Значение параметра будет взято из объекта `Map<String, Object>`, переданного при открытии экрана в метод `init()` <<screen_controller,контроллера>>.
+
Приведение экземпляра при необходимости к его идентификатору осуществляется аналогично параметрам с префиксом `ds`. Поддерживается путь к атрибуту по графу сущностей в имени параметра. 

* Префикс `component`. 
+
Значением параметра будет текущее значение визуального компонента, путь к которому указан в имени параметра. Например:
+
[source, xml]
----
<query>
  select o from sales$Order o where o.number = :component$filter.orderNumberField
</query>
----
+
Путь к компоненту должен включать все вложенные <<frame,фреймы>>.
+
Приведение экземпляра при необходимости к его идентификатору аналогично параметрам `ds`. Поддерживается путь к атрибуту по графу сущностей в имени параметра как продолжение пути к компоненту.

* Префикс `session`. 
+
Значением параметра будет значение атрибута <<userSession,пользовательской сессии>>, указанного в имени параметра.
+
Значение извлекается методом `UserSession.getAttribute()`, поэтому поддерживаются также предопределенные имена атрибутов сессии: 

** `userId` - ID текущего зарегистрированного или замещенного пользователя;

** `userLogin` - логин текущего зарегистрированного или замещенного пользователя в нижнем регистре.
+
Пример:
+
[source, xml]
----
<query>
  select o from sales$Order o where o.createdBy = :session$userLogin
</query>
----
+
Приведение экземпляра при необходимости к его идентификатору аналогично параметрам `ds`. Путь по графу сущностей в имени параметра в данном случае не поддерживается.

[WARNING]
====
Если значение параметра не найдено по правилам, задаваемым префиксом, для данного параметра устанавливается значение `null`. То есть если, например, в запросе указан параметр с именем `++param$some_name++`, а в мэп параметров экрана нет ключа `++some_name++`, то для параметра `++param$some_name++` устанавливается значение `null`.
====

[[datasource_query_filter]]
*Фильтр запроса*

Запрос источника данных может быть модифицирован во время работы приложения, в зависимости от вводимых пользователем условий, что позволяет эффективно фильтровать данные на уровне выборки из БД.

Простейший способ обеспечения такой возможности - подключение к источнику данных специального визуального компонента <<gui_Filter,Filter>>.

Если по какой-то причине применение универсального фильтра нежелательно, можно встроить в текст запроса специальную разметку на XML, позволяющую сформировать итоговый запрос в зависимости от значений, введенных пользователем в произвольные визуальные компоненты экрана.

В таком фильтре могут быть использованы следующие элементы:

* `filter` - корневой элемент фильтра. Может непосредственно содержать только одно условие.

** `and`, `or` - логические условия, могут содержать любое количество других условий и предложений. 

** `c` - предложение на JPQL, которое добавляется в секцию `where`. Содержит только текст и опционально атрибут `join`, значение которого будет добавлено в соответствующее место запроса, если добавляется данное предложение `where`. 

Условия и предложения добавляются в итоговый запрос, только если присутствующие внутри них параметры получили значения, т.е. не равны `null`. 

Пример:

[source, xml]
----
<query>
  select distinct d from app$GeneralDoc d
  <filter>
      <or>
          <and>
              <c join=", app$DocRole dr">dr.doc.id = d.id and d.processState = :custom$state</c>
              <c>d.barCode like :component$barCodeFilterField</c>
          </and>
          <c join=", app$DocRole dr">dr.doc.id = d.id and dr.user.id = :custom$initiator</c>
      </or>
  </filter>
</query>
----

В данном случае если в метод `refresh()` источника данных переданы параметры `state` и `initiator`, а в визуальном компоненте `barCodeFilterField` установлено некоторое значение, то итоговый запрос примет вид:

[source, sql]
----
select distinct d from app$GeneralDoc d, app$DocRole dr
where
(
  (dr.doc.id = d.id and d.processState = :custom$state)
  and
  (d.barCode like :component$barCodeFilterField)
)
or
(dr.doc.id = d.id and dr.user.id = :custom$initiator)
----

Если же, к примеру, компонент `barCodeFilterField` пуст, а в `refresh()` передан только параметр `initiator`, то запрос получится следующим:

[source, sql]
----
select distinct d from app$GeneralDoc d, app$DocRole dr
where
(dr.doc.id = d.id and dr.user.id = :custom$initiator)
----

[WARNING]
====
Не используйте <<datasource_query_params_ds,ds-параметры>> в фильтрах запросов. Они предназначены для связывания источников данных и обрабатываются специальным образом. 
====

[[datasource_query_case_insensitive]]
*Поиск подстроки без учета регистра*

В источниках данных можно использовать особенность выполнения JPQL-запросов, описанную для интерфейса `<<query,Query>>` уровня *Middleware*: для удобного формирования условия поиска без учета регистра символов и по любой части строки можно использовать префикс `(?i)`. Однако, в связи с тем, что значение параметра обычно передается неявно, имеются следующие отличия:

* Префикс `(?i)` нужно указывать не в значении, а перед именем параметра.

* Значение параметра будет автоматически переведено в нижний регистр.

* Если в значении параметра отсутствуют символы `%`, то они будут добавлены в начало и конец.

Для примера рассмотрим обработку следующего запроса:

[source, sql]
----
select c from sales$Customer c where c.name like :(?i)component$customerNameField
----

В данном случае значение параметра, взятое из компонента `customerNameField`, будет переведено в нижний регистр и обрамлено символами `%`, а затем в базе данных будет выполнен SQL запрос с условием вида `lower(C.NAME) like ?`

Следует иметь в виду, что при таком поиске индекс, созданный в БД по полю `NAME`, не используется. 

[[datasource_listeners]]
===== Слушатели источников данных

Слушатели <<datasources,источников данных>> (datasource listeners) позволяют получать оповещения об изменении состояния источников данных и экземпляров сущностей, в них находящихся.

Для регистрации слушателей используются методы `Datasource.addListener()`, `Datasource.removeListener()`. Пример регистрации слушателя в <<screen_controller,контроллере экрана>>:

[source, java]
----
@Inject
private Datasource<Customer> customerDs;
...
public void init(Map<String, Object> params) {
  ...
  customerDs.addListener(new DatasourceListener<Customer>() {
      // listener methods implementation
  });
}
----

Существует два интерфейса слушателей источников данных: `DatasourceListener` и `CollectionDatasourceListener`. Первый можно использовать для регистрации в любых источниках данных, второй - только в реализующих `CollectionDatasource`. Как правило, на практике требуется получать не все оповещения от слушателя, а только некоторые. Поэтому удобно вместо реализации самих интерфейсов слушателей использовать классы-адаптеры `DsListenerAdapter` и `CollectionDsListenerAdapter`, содержащие пустые реализации всех методов соответствующих интерфейсов.

Рассмотрим методы `DatasourceListener`:

* `valueChanged()` - объявление этого метода наследуется от базового интерфейса `ValueListener`. Данный метод слушателя вызывается, если изменилось значение какого-либо атрибута сущности, находящейся в данный момент в источнике. В метод передается сам измененный экземпляр, имя измененного атрибута, старое и новое значение.
+
Оповещение `valueChanged()` можно использовать для действий в ответ на изменение пользователем сущности из UI, то есть редактирования полей ввода. В следующем примере гипотетический метод `updateSettings()` будет вызван при изменении значения атрибута `active`, и в него будет передано новое значение этого атрибута:
+
[source, java]
----
@Inject
private Datasource<Customer> customerDs;

public void init(Map<String, Object> params) {
  ...
  customerDs.addListener(new DsListenerAdapter<Customer>() {
      @Override
      public void valueChanged(Customer source, String property, Object prevValue, Object value) {
          if ("active".equals(property)) {
              boolean active = BooleanUtils.isTrue((Boolean) value); // converting null to false
              updateSettings(active);
          }
      }
  });
}
----

* `itemChanged()` - вызывается при смене выбранного экземпляра, возвращаемого методом `getItem()`.
+
Для `Datasource` это происходит при установке другого экземпляра (или `null`) методом `setItem()`.
+
Для `CollectionDatasource` данное оповещение вызывается, когда в связанном визуальном компоненте меняется выделенный элемент. Например, это может быть выделенная строка таблицы, элемент дерева, или выделенный элемент выпадающего списка.

Пример использования оповещения `itemChanged()` для управления состоянием действия таблицы:

[source, java]
----
@Inject
protected CollectionDatasource<Customer, UUID> customersDs;

@Named("customersTable.remove")
protected RemoveAction removeAction;

public void init(Map<String, Object> params) {
  ...
  customersDs.addListener(new DsListenerAdapter<Customer>() {
      @Override
      public void itemChanged(Datasource<Customer> ds, Customer prevItem, Customer item) {
          removeAction.setEnabled(canCustomerBeDeleted(item));
      }
  });
}
----

* `stateChanged()` - вызывается при изменении состояния источника данных. Источник данных может находиться в одном из трех состояний, соответствующих перечислению `Datasource.State`:

** `++NOT_INITIALIZED++` - источник только что создан.

** `INVALID` - создан весь `<<dsContext,DsContext>>`, к которому относится данный источник.

** `VALID` - источник данных в рабочем состоянии: `Datasource` содержит экземпляр сущности или `null`, `CollectionDatasource` - коллекцию экземпляров или пустую коллекцию.
+
Получение оповещения об изменении состояния источника может быть актуально для сложных <<screen_edit,редакторов>>, состоящих из нескольких <<frame,фреймов>>, где сложно отследить момент проставления редактируемой сущности в источник. В этом случае можно использовать оповещение `stateChanged()` для отложенной инициализации некоторых элементов экрана: 
+
[source, java]
----
@Inject
protected CollectionPropertyDatasourceImpl<CategoryAttribute, UUID> categoryAttrsDs;

categoryAttrsDs.addListener(new DsListenerAdapter<CategoryAttribute>() {
  @Override
  public void stateChanged(Datasource ds, Datasource.State prevState, Datasource.State state) {
      if (state != Datasource.State.VALID) return;
      initDataTypeColumn();
      initDefaultValueColumn();
  }
});
----

Интерфейс `CollectionDatasourceListener` добавляет еще один метод: 

* `collectionChanged()` - вызывается при изменении коллекции сущностей, хранящейся в источнике данных. В метод передается тип изменения: `REFRESH`,`CLEAR`,`ADD`,`REMOVE`,`UPDATE`.
+
Пример слушателя, вызывающего пересчет стоимости поездки при изменении адреса остановки (сущность `Stop`) или количества остановок:
+
[source, java]
----
protected class StopDsListener extends CollectionDsListenerAdapter<Stop> {
  @Override
  public void valueChanged(Stop source, String property, Object prevValue, Object value) {
      // existing stop address changed
      if ("address".equals(property)) {
          fireRouteChanged();
      }
  }

  @Override
  public void collectionChanged(CollectionDatasource ds, Operation operation) {
      // stop was added or removed
      fireRouteChanged();
  }

  private void fireRouteChanged() {
      // journey route has changed, need to recalculate price, journey time, pickup time delay etc.
  }
}
----

[[dsContext]]
===== DsContext

Все созданные декларативно источники данных регистрируются в объекте `DsContext` экрана. Ссылку на `DsContext` можно получить методом `getDsContext()` контроллера экрана, либо инжекцией в поле класса.

`DsContext` решает следующие задачи:

. Позволяет организовать зависимости между источниками данных, когда при навигации по одному источнику (т.е. при изменении "текущего" экземпляра методом `setItem()`) обновляется связанный источник. Такие зависимости дают возможность в экранах легко организовывать master-detail связи между визуальными компонентами.
+
Зависимости между источниками организуются с помощью <<datasource_query,параметров запросов>> с префиксом `ds$`.

. Позволяет собрать все измененные экземпляры сущностей и отправить их на *Middleware* в одном вызове `DataManager.commit()`, т.е. сохранить в базе данных в одной транзакции. 
+
В качестве примера предположим, что некоторый экран позволяет редактировать экземпляр сущности `Order` и коллекцию принадлежащих ему экземпляров `OrderLine`. Экземпляр `Order` находится в `Datasource`, коллекция `OrderLine` - во вложенном `CollectionDatasource`, созданном по атрибуту `Order.lines`. Допустим, пользователь изменил какой-то атрибут `Order` и создал новый экземпляр `OrderLine`. Тогда при коммите экрана в <<dataManager,DataManager>> будут одновременно отправлены два экземпляра - измененный `Order` и новый `OrderLine`. Далее, они вместе попадут в один <<entityManager,персистентный контекст>> и при коммите транзакции сохранятся в БД. Разумеется, экземпляр `OrderLine` содержится также в коллекции `Order.lines`, но если не передавать его в персистентный контекст независимо, то потребуется установка каскадности сохранения между `Order` и `OrderLines` на уровне ORM. Жесткие отношения каскадности на уровне ORM иногда вызывают нежелательные последствия в неожиданных местах, поэтому лучше их избегать, что и обеспечивает описываемый механизм `DsContext`.
+
В результате коммита `DsContext` получает от *Middleware* набор сохраненных экземпляров (в случае оптимистической блокировки у них, как минимум, увеличено значение атрибута `version`), и устанавливает эти экземпляры в источниках данных взамен устаревших. Это позволяет сразу после коммита работать со свежими экземплярами без необходимости лишнего обновления источников данных, связанного с запросами к *Middleware* и базе данных.

. Объявляет слушателя `DsContext.CommitListener`, позволяющего получать оповещения перед коммитом измененных экземпляров и после него. Перед коммитом можно дополнить коллекцию отправляемых в <<dataManager,DataManager>> на Middleware экземпляров, тем самым обеспечив сохранение в той же транзакции произвольных сущностей. После коммита можно получить коллекцию вернувшихся из `DataManager` сохраненных экземпляров.
+
Данный механизм необходим, если некоторые сущности, с которыми работает экран, находятся не под управлением источников данных, а создаются и изменяются непосредственно в коде контроллера. Например, визуальный компонент `<<gui_FileUploadField,FileUploadField>>` после загрузки файла создает новый экземпляр сущности `FileDescriptor`, который можно сохранить вместе с другими сущностями экрана именно таким способом - добавив в `CommitContext` в методе `DsContext.CommitListener.beforeCommit()`.
+
`DsContext.CommitListener` имеет адаптер `DsContext.CommitListenerAdapter`, который удобно использовать при необходимости определить только один метод.
+
В следующем примере новый экземпляр `Customer` будет отправлен на *Middleware* и сохранен в БД вместе с остальными измененными сущностями экрана при его коммите:
+
[source, java]
----
protected Customer customer;

protected void createNewCustomer() {
  customer = new Customer();
  customer.setName("John Doe");
}

public void init(Map<String, Object> params) {
  getDsContext().addListener(new DsContext.CommitListenerAdapter() {
      @Override
      public void beforeCommit(CommitContext context) {
          if (customer != null)
              context.getCommitInstances().add(customer);
      }
  });
}
----

[[dataSupplier]]
===== DataSupplier

`DataSupplier` - интерфейс, через который источники данных обращаются к Middleware для загрузки и сохранения сущностей. Его стандартная реализация просто делегирует выполнение <<dataManager,DataManager>>. Экран может задать свою реализацию интерфейса `DataSupplier` в атрибуте `dataSupplier` элемента `window`. Собственная реализация может, например, вызывать дополнительный блок Middleware для загрузки данных экрана из другой базы данных.

Ссылку на `DataSupplier` можно получить либо <<screen_controller_injection,инжекцией>> в контроллер экрана, либо через экземпляры `DsContext` или `Datasource`. В обоих случаях возвращается или стандартная, или собственная реализация интерфейса (если таковая определена).

[[gui_Action]]
==== Действия. Интерфейс Action

`Action` − интерфейс, абстрагирующий действие (другими словами, некоторую функцию) от визуального компонента. Он особенно полезен в случаях, когда одно и то же действие может быть вызвано из разных визуальных компонентов. Кроме того, данный интерфейс позволяет снабдить действие дополнительными свойствами, такими как название, признаки доступности и видимости, и другими.

Рассмотрим методы интерфейса `Action`:

* `actionPerform()` - вызывается визуальным компонентом, связанным с данным действием. В метод передается экземпляр вызвавшего компонента.

* `getId()` - возвращает идентификатор данного действия. Идентификатор обычно устанавливается конструктором класса, реализующего `Action`, и не меняется на протяжении жизни созданного объекта действия.

* методы получения и установки свойств `caption`, `description`, `shortcut`, `icon`, `enabled`, `visible`. Все эти свойства обычно используется связанными визуальными компонентами для установки собственных одноименных свойств.

* `addPropertyChangeListener()`, `removePropertyChangeListener()` - подключение слушателей, реагирующих на изменение вышеупомянутых свойств. Слушатель получает уведомление типа `java.beans.PropertyChangeEvent`, в котором содержится имя измененного свойства, его старое и новое значение.

* `refreshState()` - метод, который может быть реализован в конкретном классе действия для инициализации вышеупомянутых свойств в соответствии с какими-либо внешними факторами, например правами пользователя. Вызывается обычно в конструкторах имплементирующих классов или из связанных визуальных компонентов.

* `addOwner()`, `removeOwner()`, `getOwner()`, `getOwners()` - методы для управления связью действия с визуальными компонентами.

Для реализации действий рекомендуется использовать <<declarative_actions,декларативное создание>> действий, либо наследоваться от класса <<baseAction,AbstractAction>>. Кроме того, существует набор <<standard_actions,стандартных действий>>, применимых для работы с таблицами и компонентами выбора. От стандартных действий также можно наследоваться для модификации их поведения или перехвата событий.

Визуальные компоненты, связанные с действием, могут быть двух типов:

* Визуальный компонент, содержащий одно действие, реализует интерфейс `Component.ActionOwner`. Это <<gui_Button,Button>> и <<gui_LinkButton,LinkButton>>.
+
Связь компонента с действием осуществляется путем вызова метода `ActionOwner.setAction()` компонента. В этот момент компонент заменяет свои свойства на соответствующие свойства действия (подробнее см. описание компонентов). 

* Визуальный компонент, содержащий несколько действий, реализует интерфейс `Component.ActionsHolder`. Это `Window`, `IFrame`, <<gui_Table,Table>> и ее наследники, <<gui_Tree,Tree>>, <<gui_PopupButton,PopupButton>>, <<gui_PickerField,PickerField>>, <<gui_LookupPickerField,LookupPickerField>>.
+
Действия добавляются компоненту вызовом метода `ActionsHolder.addAction()`. Реализация этого метода в компоненте проверяет, нет ли уже в нем действия с таким же идентификатором. Если есть, то имеющееся действие будет заменено на новое переданное. Поэтому можно, например, декларировать стандартное действие в дескрипторе экрана, а затем в контроллере создать новое с переопределенными методами и добавить компоненту.

[[declarative_actions]]
===== Декларативное создание действий

В XML-дескрипторе экрана для любого компонента, реализующего интерфейс `Component.ActionsHolder`, в том числе для всего экрана или фрейма, может быть задан набор <<gui_Action,действий>>. Делается это в элементе `actions`, который содержит вложенные элементы `action`.

Элемент `action` может иметь следующие атрибуты:

* `id` − идентификатор, должен быть уникален в рамках данного компонента `ActionsHolder`.

* `caption` - название действия.

* `description` - описание действия.

* `enable` - признак доступности действия (`true` / `false`).

* `icon` - значок действия.

* `invoke` - имя вызываемого метода контроллера. Метод должен быть `public`, не возвращать результата и либо не иметь аргументов, либо иметь один аргумент типа `Component`. Если метод имеет аргумент `Component`, то при вызове в него будет передан экземпляр визуального компонента, запустившего данное действие.

* `shortcut` - комбинация клавиш для вызова. Возможные модификаторы - `ALT`, `CTRL`, `SHIFT` - отделяются символом "-". Например: *ALT-CTRL-C*.

* `visible` - признак видимости действия (`true` / `false`).

Рассмотрим примеры декларативного объявления действий.

* Объявление действий на уровне экрана:
+
[source, xml]
----
<window ...>
  <dsContext/>

  <actions>
      <action id="sayHelloAction" caption="msg://sayHello" shortcut="ALT-T" invoke="sayHello"/>
  </actions>

  <layout>
      <button action="sayHelloAction"/>
  </layout>
</window>
----
+
[source, java]
----
// controller

public void sayHello(Component component) {
  showNotification("Hello!", NotificationType.TRAY);
}
----

Здесь объявляется действие с идентификатором `sayHelloAction` и названием из <<message_packs,пакета сообщений>>. С этим действием связывается кнопка, заголовок которой будет установлен в название действия. Действие вызовет метод `sayHello()` контроллера при нажатии на кнопку, а также при нажатии комбинации клавиш *ALT-T*, если в данный момент экран принимает фокус ввода.

* Объявление действий для <<gui_PopupButton,PopupButton>>:
+
[source, xml]
----
<popupButton caption="Say something">
 <actions>
    <action id="helloAction" caption="Say hello" invoke="sayHello"/>
    <action id="goodbyeAction" caption="Say goodbye" invoke="sayGoodbye"/>
 </actions>
</popupButton>
----

* Объявление действий для <<gui_Table,Table>>:
+
[source, xml]
----
<table id="usersTable" width="100%">
  <actions>
      <action id="create"/>
      <action id="edit"/>
      <action id="copy" caption="msg://copy" icon="icons/copy.png"
              invoke="copy" trackSelection="true"/>
      <action id="changePassw" caption="msg://changePassw" icon="icons/change-pass.png"
              invoke="changePassword" trackSelection="true"/>
  </actions>
  <buttonsPanel>
      <button action="usersTable.create"/>
      <button action="usersTable.edit"/>
      <button action="usersTable.copy"/>
      <button action="usersTable.changePassw"/>
  </buttonsPanel>
  <rowsCount/>
  <columns>
      <column id="login"/>
      ...
  </columns>
  <rows datasource="usersDs"/>
</table>
----

Здесь помимо <<standard_actions,стандартных действий>> таблицы `create` и `edit` объявлены действия `copy` и `changePassw`, вызывающие соответствующие методы контроллера. Для этих действий указан также атрибут `trackSelection="true"`, в результате чего действие и связанная с ним кнопка становятся недоступными, если в таблице не выбрана ни одна строка. Это удобно, если действие предназначено для выполнения над текущей выбранной строкой таблицы. 

Для действий `create` и `edit` можно указать дополнительный атрибут `openType` для указания режима открытия экрана редактирования, как описано для метода `setOpenType()` класса <<createAction,CreateAction>>.

* Объявление действий для <<gui_PickerField,PickerField>>:
+
[source, xml]
----
<pickerField id="colourField" datasource="carDs" property="colour"/>
  <actions>
      <action id="lookup"/>
      <action id="show" icon="icons/show.png"
              invoke="showColour" caption="" description="Show colour"/>
  </actions>
</pickerField>
----

В данном примере для компонента `PickerField` объявлено <<standard_actions,стандартное действие>> `lookup` и действие `show`, вызывающее метод `showColour()` контроллера. Так как в кнопках `PickerField`, отображающих действия, используются значки, а не надписи, атрибут `caption` явно установлен в пустую строку, иначе названием действия и заголовком кнопки стал бы идентификатор действия. Атрибут `description` позволяет отображать всплывающую подсказку при наведении мыши на кнопку действия.

Ссылки на любые декларативно объявленные действия можно получить в контроллере экрана либо непосредственно путем <<screen_controller_injection,инжекции>>, либо из компонентов, реализующих интерфейс `Component.ActionsHolder`. Это может понадобиться для программной установки свойств действия. Например:

[source, java]
----
@Named("carsTable.create")
private CreateAction createAction;

@Named("carsTable.copy")
private Action copyAction;

@Inject
private PickerField colourField;

@Override
public void init(Map<String, Object> params) {
  Map<String, Object> values = new HashMap<>();
  values.put("type", CarType.PASSENGER);
  createAction.setInitialValues(values);

  copyAction.setEnabled(false);

  Action showAction = colourField.getAction("show");
  showAction.setEnabled(false);
}
----

[[standard_actions]]
===== Стандартные действия

Стандартные <<gui_Action,действия>> - это классы, имплементирующие интерфейс `Action`, и предназначенные для решения типовых задач, таких как вызов экрана редактирования для сущности, выбранной в таблице. Стандартные действия имеют строго определенные идентификаторы, поэтому для декларативного объявления некоторого стандартного действия достаточно указать его идентификатор. 

Существует два вида стандартных действий:

* <<list_actions,Действия с коллекцией>> сущностей, отображаемой в таблице или дереве.

* <<picker_actions,Действия поля выбора>> экземпляра сущности.

[[list_actions]]
*Стандартные действия с коллекцией*

Для наследников `ListComponent` (это <<gui_Table,Table>>, <<gui_GroupTable,GroupTable>>, <<gui_TreeTable,TreeTable>> и <<gui_Tree,Tree>>) набор стандартных действий определен в перечислении `ListActionType`, классы их реализации находятся в пакете `com.haulmont.cuba.gui.components.actions`. 

Пример использования стандартных действий в таблице: 

[source, xml]
----
include::{sourcesdir}/gui/listActions_1.xml[]
----

Рассмотрим их подробнее.

[[createAction]]
*CreateAction*

`CreateAction` - действие с идентификатором *create*. Предназначено для создания нового экземляра сущности и открытия экрана редактирования для этого экземпляра. Если экран редактирования успешно закоммитил новый экземпляр в базу данных, то `CreateAction` добавляет этот новый экземпляр в источник данных таблицы и делает его выбранным. 

В классе `CreateAction` определены следующие специфические методы: 

* `setOpenType()` - позволяет задать режим открытия экрана редактирования новой сущности. По умолчанию экран открывается в режиме `++THIS_TAB++`. 
+
Так как довольно часто требуется открывать экраны редактирования в другом режиме (как правило, `DIALOG`), при декларативном создании действия `create` в элементе `action` можно указать атрибут `openType` с нужным значением. Это избавляет от необходимости получать ссылку на действие в контроллере и программно устанавливать данное свойство. Например: 
+
[source, xml]
----
include::{sourcesdir}/gui/createAction_1.xml[]
---- 

* `setWindowId()` - позволяет задать идентификатор экрана редактирования сущности. По умолчанию используется экран `++{имя_сущности}.edit++`, например `sales$Customer.edit`.

* `setWindowParams()` - позволяет задать параметры экрана редактирования, передаваемые в его метод `init()`.

* `setInitialValues()` - позволяет задать начальные значения атрибутов создаваемой сущности. Принимает объект `Map`, в котором ключами являются имена атрибутов, а значениями - значения атрибутов. Например: 
+
[source, java]
----
include::{sourcesdir}/gui/createAction_2.java[]
---- 
+
Пример использования `setInitialValues()` приведен также в разделе <<init_values_in_CreateAction,рецептов разработки>>.

* `afterCommit()` - вызывается действием после того, как экран редактирования успешно закоммитил новую сущность и был закрыт. Данный метод не имеет реализации и может быть переопределен в наследниках для реакции на это событие. 

* `setAfterCommitHandler()` - позволяет задать обработчик, который будет вызван после того, как экран редактирования успешно закоммитил новую сущность и был закрыт. Данный обработчик можно использовать вместо переопределения метода `afterCommit()`, тем самым избавившись от необходимости создания наследника действия. Например: 
+
[source, java]
----
include::{sourcesdir}/gui/createAction_3.java[]
---- 

* `afterWindowClosed()` - вызывается действием в последнюю очередь после закрытия экрана редактирования, независимо от того, была ли закоммичена новая сущность или нет. Данный метод не имеет реализации и может быть переопределен в наследниках для реакции на это событие. 

* `setAfterWindowClosedHandler()` - позволяет задать обработчик, который будет вызван после закрытия экрана редактирования, независимо от того, была ли закоммичена новая сущность или нет. Данный обработчик можно использовать вместо переопределения метода `afterWindowClosed()`, тем самым избавившись от необходимости создания наследника действия.  

[[editAction]]
*EditAction*

`EditAction` - действие с идентификатором *edit*. Открывает экран редактирования для выбранного экземпляра сущности. Если экран редактирования успешно закоммитил экземпляр в базу данных, то `EditAction` обновляет этот экземпляр в источнике данных таблицы.

В классе `EditAction` определены следующие специфические методы:

* `setOpenType()` - позволяет задать режим открытия экрана редактирования сущности. По умолчанию экран открывается в режиме `++THIS_TAB++`. 
+
Так как довольно часто требуется открывать экраны редактирования в другом режиме (как правило, `DIALOG`), при декларативном создании действия `edit` в элементе `action` можно указать атрибут `openType` с нужным значением. Это избавляет от необходимости получать ссылку на действие в контроллере и программно устанавливать данное свойство. Например: 
+
[source, xml]
----
include::{sourcesdir}/gui/editAction_1.xml[]
---- 

* `setWindowId()` - позволяет задать идентификатор экрана редактирования сущности. По умолчанию используется экран `++{имя_сущности}.edit++`, например `sales$Customer.edit`.

* `setWindowParams()` - позволяет задать параметры экрана редактирования, передаваемые в его метод `init()`.

* `afterCommit()` - вызывается действием после того, как экран редактирования успешно закоммитил сущность и был закрыт. Данный метод не имеет реализации и может быть переопределен в наследниках для реакции на это событие. 

* `setAfterCommitHandler()` - позволяет задать обработчик, который будет вызван после того, как экран редактирования успешно закоммитил новую сущность и был закрыт. Данный обработчик можно использовать вместо переопределения метода `afterCommit()`, тем самым избавившись от необходимости создания наследника действия. Например: 
+
[source, java]
----
include::{sourcesdir}/gui/editAction_2.java[]
---- 

* `afterWindowClosed()` - вызывается действием в последнюю очередь после закрытия экрана редактирования, независимо от того, была ли закоммичена редактируемая сущность. Данный метод не имеет реализации и может быть переопределен в наследниках для реакции на это событие. 

* `setAfterWindowClosedHandler()` - позволяет задать обработчик, который будет вызван после закрытия экрана редактирования, независимо от того, была ли закоммичена новая сущность или нет. Данный обработчик можно использовать вместо переопределения метода `afterWindowClosed()`, тем самым избавившись от необходимости создания наследника действия.  

[[removeAction]]
*RemoveAction*

`RemoveAction` - действие с идентификатором *remove*. Предназначено для удаления выбранного экземпляра сущности.

В классе `RemoveAction` определены следующие специфические методы:

* `setAutocommit()` - позволяет управлять моментом удаления сущности из базы данных. По умолчанию после срабатывания действия и удаления сущности из источника данных у источника вызывается метод `commit()`, в результате чего сущность удаляется из базы данных. Cвойство `autocommit` можно установить в `false` либо методом `setAutocommit()`, либо соответствующим параметром конструктора. В результате после удаления сущности из источника данных для подтверждения удаления потребуется явно вызвать метод `commit()` источника данных.
+
Значение `autocommit` не влияет на работу источников данных в режиме `Datasource.CommitMode.PARENT`, то есть тех, которые обеспечивают редактирование <<composition_annotation,композиционных>> сущностей.

* `setConfirmationMessage()` - позволяет задать текст сообщения в диалоге подтверждения удаления. 

* `setConfirmationTitle()` - позволяет задать заголовок диалога подтверждения удаления.

*  `afterRemove()` - вызывается действием после успешного удаления сущности. Данный метод не имеет реализации и может быть переопределен в наследниках для реакции на это событие. 

* `setAfterRemoveHandler()` позволяет задать обработчик, который будет вызван после успешного удаления сущности. Данный обработчик можно использовать вместо переопределения метода `afterWindowClosed()`, тем самым избавившись от необходимости создания наследника действия. Например: 
+
[source, java]
----
include::{sourcesdir}/gui/removeAction_1.java[]
----  

[[refreshAction]]
*RefreshAction*

`RefreshAction` - действие с идентификатором *refresh*. Предназначено для обновления (перезагрузки) коллекции сущностей. При срабатывании вызывает метод `refresh()` <<datasources,источника данных>>, с которым связан компонент.

В классе `RefreshAction` определены следующие специфические методы:

* `setRefreshParams()` - позволяет задать параметры, передаваемые в метод `CollectionDatasource.refresh()`, для использования внутри <<datasource_query,запроса>>. По умолчанию никакие параметры не передаются. 

[[addAction]]
*AddAction*

`AddAction` - действие с идентификатором *add*. Предназначено для выбора существующего экземпляра сущности и добавления его в коллекцию. При срабатывании открывает <<screen_lookup,экран выбора>> сущностей.

В классе `AddAction` определены следующие специфические методы:

* `setOpenType()` - позволяет задать режим открытия экрана выбора сущности. По умолчанию экран открывается в режиме `++THIS_TAB++`. 
+
Так как довольно часто требуется открывать экраны выбора в другом режиме (как правило, `DIALOG`), при декларативном создании действия `add` в элементе `action` можно указать атрибут `openType` с нужным значением. Это избавляет от необходимости получать ссылку на действие в контроллере и программно устанавливать данное свойство. Например:
+
[source, xml]
----
<table id="usersTable">
<actions>
  <action id="add" openType="DIALOG"/>
----

* `setWindowId()` - позволяет задать идентификатор экрана выбора сущности. По умолчанию используется экран `++{имя_сущности}.lookup++`, например `sales$Customer.lookup`. Если такого экрана не существует, то делается попытка открыть экран `++{имя_сущности}.browse++`, например `sales$Customer.browse`.

* `setWindowParams()` - позволяет задать параметры экрана выбора, передаваемые в его метод `init()`.

* `setHandler()` - позволяет задать объект, реализующий интерфейс `Window.Lookup.Handler`, передаваемый в экран выбора. По умолчанию используется объект класса `AddAction.DefaultHandler`.

[[excludeAction]]
*ExcludeAction*

`ExcludeAction` - действие с идентификатором *exclude*. Позволяет исключать экземпляры сущности из коллекции, не удаляя их из базы данных. Класс данного действия является наследником `RemoveAction`, однако при срабатывании вызывает у `CollectionDatasource` не `removeItem()`, а `excludeItem()`. Кроме того, для вложенных источников данных `ExcludeAction` разрывает связь с родительской сущностью, поэтому с помощью данного действия можно организовать редактирование ассоциации one-to-many. 

В классе `ExcludeAction` в дополнение к `RemoveAction` определены следующие специфические методы:

* `setConfirm()` - показывать ли диалог подтверждения удаления. Это свойство можно также установить через конструктор действия. По умолчанию установлено в `false`.

[[excelAction]]
*ExcelAction*

`ExcelAction` - действие с идентификатором *excel*. Предназначено для экспорта данных таблицы в формат XLS и выгрузки соответствующего файла. Данное действие можно связать только с компонентами <<gui_Table,Table>>, <<gui_GroupTable,GroupTable>> и <<gui_TreeTable,TreeTable>>.

При программном создании действия можно задать следующие параметры конструктора:

* `display` - реализация интерфейса `ExportDisplay` для выгрузки файла. По умолчанию используется стандартная реализация.

* `parameterized` - при установке в `true` действие отображает специальное окно с идентификатором `excelExport`, позволяющее пользователю выбрать колонки таблицы для экспорта. 

[[picker_actions]]
*Стандартные действия поля выбора*

Для компонентов <<gui_PickerField,PickerField>>, <<gui_LookupPickerField,LookupPickerField>> и <<gui_SearchPickerField,SearchPickerField>> набор стандартных действий определен в перечислении `PickerField.ActionType`. Реализации являются внутренними классами интерфейса `PickerField`.

Пример использования стандартных действий в компоненте выбора: 

[source, xml]
----
include::{sourcesdir}/gui/pickerActions_1.xml[]
---- 

[[lookupAction]]
*LookupAction*

`LookupAction` - действие с идентификатором *lookup*. Предназначено для выбора экземпляра сущности и установки его в качестве значения компонента. При срабатывании открывает <<screen_lookup,экран выбора>> сущностей.

В классе `LookupAction` определены следующие специфические методы:

* `setLookupScreenOpenType()` - позволяет задать режим открытия экрана выбора сущности. По умолчанию экран открывается в режиме `++THIS_TAB++`. 

* `setLookupScreenDialogParams()` - позволяет задать свойства дилогового окна при открытия экрана выбора сущности в режиме `DIALOG` (см. предыдущий метод). На другие режимы влияния не оказывает.

* `setLookupScreen()` - позволяет задать идентификатор экрана выбора сущности. По умолчанию используется экран `++{имя_сущности}.lookup++`, например `sales$Customer.lookup`. Если такого экрана не существует, то делается попытка открыть экран `++{имя_сущности}.browse++`, например `sales$Customer.browse`.

* `setLookupScreenParams()` - позволяет задать параметры экрана выбора, передаваемые в его метод `init()`.

* `afterSelect()` - вызывается действием после того, как выбранный экземпляр установлен в качестве значения компонента. Данный метод не имеет реализации и может быть переопределен в наследниках для реакции на это событие. 

* `afterCloseLookup()` - вызывается действием в последнюю очередь после закрытия экрана выбора, независимо от того, был сделан выбор или нет. Данный метод не имеет реализации и может быть переопределен в наследниках для реакции на это событие.  

[[clearAction]]
*ClearAction*

`ClearAction` - действие с идентификатором *clear*. Предназначено для очистки (то есть установки в `null`) текущего значения компонента. 

[[openAction]]
*OpenAction*

`OpenAction` - действие с идентификатором *open*. Предназначено для открытия экрана редактирования экземпляра сущности, являющегося текущим значением компонента. 

В классе `OpenAction` определены следующие специфические методы:

* `setEditScreenOpenType()` - позволяет задать режим открытия экрана редактирования сущности. По умолчанию экран открывается в режиме `++THIS_TAB++`. 

* `setEditScreenDialogParams()` - позволяет задать свойства дилогового окна при открытия экрана редактирования в режиме `DIALOG` (см. предыдущий метод). На другие режимы влияния не оказывает. 

* `setEditScreen()` - позволяет задать идентификатор экрана редактирования сущности. По умолчанию используется экран `++{имя_сущности}.edit++`, например `sales$Customer.edit`. 

* `setEditScreenParams()` - позволяет задать параметры экрана редактирования, передаваемые в его метод `init()`.

* `afterWindowClosed()` - вызывается действием после закрытия экрана редактирования. Данный метод не имеет реализации и может быть переопределен в наследниках для реакции на это событие. 

[[baseAction]]
===== BaseAction

`BaseAction` - базовый класс реализации <<gui_Action,действий>>. От него рекомендуется наследовать собственные нестандартные действия, если возможностей <<declarative_actions,декларативного создания действий>> не хватает. 

При создании конкретного класса действия необходимо определить метод `actionPerform()` и передать в конструктор `BaseAction` идентификатор действия. Можно также переопределить любые методы получения свойств действия: `getCaption()`, `getDescription()`, `getIcon()`, `getShortcut()`, `isEnabled()`, `isVisible()`. Стандартные реализации этих методов возвращают значения, установленные соответствующими set-методами. Исключение составляет метод `getCaption()`: если название действия явно не установлено методом `setCaption()`, то он обращается в <<message_packs,пакет локализованных сообщений>> с именем, соответствующим пакету класса действия, и возвращает сообщение с ключом, равным идентификатору действия. Если сообщения с таким ключом нет, то возвращается сам ключ, то есть идентификатор действия. 

`BaseAction` может изменять свои свойства `enabled` и `visible` в соответствии с <<permissions,разрешениями>> пользователя и текущим контекстом.

`BaseAction` видим (visible), если: 

* метод `setVisible(false)` не вызывался;

* для действия не установлено UI разрешение `hide`.

Действие разрешено (enabled), если: 

* метод `setEnabled(false)` не вызывался;

* для действия не установлено UI разрешений `hide` или `read-only`;

* метод `isPermitted()` возвращает true;

* метод `isApplicable()` возвращает true. 

Примеры использования:

* Действие кнопки: 
+
[source, java]
----
include::{sourcesdir}/gui/baseAction_1.java[]
----
+
В данном случае кнопка `helloBtn` получит в качестве заголовка строку, находящуюся в пакете сообщений с ключом `hello`. Для того, чтобы получить название кнопки каким-либо иным способом, можно переопределить метод `getCaption()` действия.

* Действие кнопки программно создаваемого <<gui_PickerField,PickerField>>:
+
[source, java]
----
include::{sourcesdir}/gui/baseAction_2.java[]
----
+
Здесь анонимный класс-наследник `BaseAction` используется для задания действия кнопки поля выбора. Заголовок кнопки не отображается, вместо него используется значок и описание, всплывающее при наведении курсора мыши.

* Действие таблицы:
+
[source, java]
----
include::{sourcesdir}/gui/baseAction_3.java[]
----
+
Здесь объявлен класс `HelloAction`, экземпляр которого добавляется в список действий таблицы. Действие разрешено пользователям, имеющим специфическое разрешение `*myapp.allow-greeting*`, и только когда выбрана одна строка таблицы. Последнее условие реализуется с помощью свойства `target` действия, которое автоматически устанавливается когда действие добавляется в `ListComponent` (`Table` или `Tree`).

* Если необходимо действие, которое доступно, когда выделены одна или более строк таблицы, удобно воспользоваться наследником `BaseAction` - классом `ItemTrackingAction`, который добавляет стандартную реализацию метода `isApplicable()`: 
+
[source, java]
----
include::{sourcesdir}/gui/baseAction_4.java[]
----

[[dialogs_and_notifications]]
==== Диалоговые окна и уведомления

Для вывода сообщений пользователю можно использовать диалоговые окна и уведомления. 

Диалоговые окна имеют заголовок с кнопкой закрытия и отображаются всегда в центре главного окна приложения. Уведомления могут отображаться как в центре, так и в углу приложения, и автоматически исчезать.

[[dialogs]]
===== Диалоговые окна

Диалоговые окна вызываются методами `showMessageDialog()` и `showOptionDialog()` интерфейса `IFrame`. Этот интерфейс реализуется <<screen_controller,контроллером экрана>>, поэтому данные методы можно вызывать напрямую в коде контроллера.

* `showMessageDialog()` предназначен для отображения сообщения. Метод принимает следующие параметры:

** `title` - заголовок диалогового окна.

** `message` - сообщение. В случае HTML-типа (см. ниже) в сообщении можно использовать теги HTML для форматирования. При использовании HTML обязательно экранируйте данных из БД во избежание code injection в веб-клиенте. В не-HTML сообщениях можно использовать символы `\n` для переноса строки. 

** `messageType` - тип сообщения. Возможные типы:

*** `CONFIRMATION`, `++CONFIRMATION_HTML++` - диалог подтверждения. 

*** `WARNING`, `++WARNING_HTML++` - диалог преупреждения.
+
Различие типов сообщений отражается только в пользовательском интерфейсе десктоп-приложений.

Пример вызова диалога:

[source, java]
----
include::{sourcesdir}/gui/dialogs_1.java[]
----
--

* `showOptionDialog()` предназначен для отображения сообщения и кнопок для выбора пользователем. Метод в дополнение к параметрам, описанным для `showMessageDialog()`, принимает массив или список <<gui_Action,действий>>. Для каждого действия в диалоге создается кнопка, при нажатии на которую пользователем диалог закрывается и вызывается метод `actionPerform()` данного действия.
+
В качестве кнопок со стандартными названиями и значками удобно использовать анонимные классы, унаследованные от `DialogAction`. Поддерживаются пять видов действий, определяемых перечислением `DialogAction.Type`: `OK`, `CANCEL`, `YES`, `NO`, `CLOSE`. Названия соответствующих кнопок извлекаются из <<main_message_pack,главного пакета>> локализованных сообщений.
+
Пример вызова диалога с кнопками *Да* и *Нет* и с заголовком и сообщением, взятыми из пакета локализованных сообщений текущего экрана:
+
[source, java]
----
showOptionDialog(
      getMessage("confirmCopy.title"),
      getMessage("confirmCopy.msg"),
      MessageType.CONFIRMATION,
      new Action[]{
              new DialogAction(DialogAction.Type.YES) {
                  public void actionPerform(Component component) {
                      copySettings();
                  }
              },
              new DialogAction(DialogAction.Type.NO)
      }
);
----
--

[[notifications]]
===== Уведомления

Уведомления вызываются методом `showNotification()` интерфейса `IFrame`. Этот интерфейс реализуется <<screen_controller,контроллером экрана>>, поэтому данный метод можно вызывать напрямую в коде контроллера.

Метод `showNotification()` принимает следующие параметры:

* `caption` - текст уведомления. В случае HTML-типа (см. ниже) в сообщении можно использовать теги HTML для форматирования. При использовании HTML обязательно экранируйте данных из БД во избежание code injection в веб-клиенте. В не-HTML сообщениях можно использовать символы `\n` для переноса строки.

* `description` - опциональное описание, которое будет отображено ниже `caption`. Также можно использовать символы `\n` или HTML-форматирование.

* `type` - тип уведомления. Возможные типы:

** `TRAY`, `++TRAY_HTML++` - уведомление показывается в правом нижнем углу приложения и исчезает автоматически. 

** `HUMANIZED`, `++HUMANIZED_HTML++` - стадартное уведомление в центре экрана, исчезает автоматически.

** `WARNING`, `++WARNING_HTML++` - предупреждение. Исчезает при клике пользователя.

** `ERROR`, `++ERROR_HTML++` - уведомление об ошибке. Исчезает при клике пользователя.

Примеры вызова уведомлений:

[source, java]
----
showNotification(getMessage("selectBook.text"), NotificationType.HUMANIZED);

showNotification("Validation error", "<b>Date</b> is incorrect", NotificationType.TRAY_HTML);
----

[[background_tasks]]
==== Фоновые задачи

Фоновые задачи используются на клиентском уровне для асинхронного выполнения длительных операций без заморозки пользовательского интерфейса. 

===== Использование фоновых задач

. Задача описывается как наследник абстрактного класса `BackgroundTask`. В конструктор задачи необходимо передать ссылку на контроллер экрана, с которым будет связана задача, и значение таймаута ее выполнения.
+
Если экран указан, то при его закрытии пользователем активная задача будет прервана. Кроме того, задача будет автоматически прервана по истечении указанного таймаута.
+
Собственно действия, выполняемые задачей, реализуются в методе `run()`.

. Создается объект управления задачей − `BackgroundTaskHandler`. Для этого экземпляр задачи необходимо передать методу `handle()` бина `BackgroundWorker`. Ссылку на `BackgroundWorker` можно получить инжекцией в <<screen_controller,контроллер экрана>>, либо статическим методом класса `AppBeans`.

. Выполняется запуск задачи.

[source, java]
----
@Inject
protected BackgroundWorker backgroundWorker;

@Override
public void init(Map<String, Object> params) {
  // Create task with 10 sec timeout and this screen as owner
  BackgroundTask<Integer, Void> task = new BackgroundTask<Integer, Void>(10, this) {
      @Override
      public Void run(TaskLifeCycle<Integer> taskLifeCycle) throws Exception {
          // Do something in background thread
          for (int i = 0; i < 5; i++) {
              TimeUnit.SECONDS.sleep(1); // time consuming computations
              taskLifeCycle.publish(i); // publish current progress to show it in progress() method
          }
          return null;
      }

      @Override
      public void canceled() {
          // Do something in UI thread if the task is canceled
      }

      @Override
      public void done(Void result) {
          // Do something in UI thread when the task is done
      }

      @Override
      public void progress(List<Integer> changes) {
          // Show current progress in UI thread
      }
  };
  // Get task handler object and run the task
  BackgroundTaskHandler taskHandler = backgroundWorker.handle(task);
  taskHandler.execute();
}
----

Подробная информация о назначении методов приведена в JavaDocs классов `BackgroundTask`, `TaskLifeCycle`, `BackgroundTaskHandler`. 

Ниже приведены моменты, на которые следует обратить внимание:

* `BackgroundTask<T, V>` − параметризованный класс:

** `T` − тип объектов, показывающих прогресс задачи. Объекты этого типа передаются в метод `progress()` задачи при вызове `TaskLifeCycle.publish()` в рабочем потоке.

** `V` − тип результата задачи, он передается в метод `done()`. Его также можно получить вызовом метода `BackgroundTaskHandler.getResult()`, что приведет к ожиданию завершения задачи.

* Метод `canceled()` вызывается только в случае управляемой отмены задачи, то есть при вызове `cancel()` у `TaskHandler`.

* Если у задачи истек таймаут, или было закрыто окно, в котором она исполнялась, то задача будет завершена без уведомлений. В блоке *Web Client* завершение по таймауту производится с задержкой, задаваемой свойством приложения `<<cuba.backgroundWorker.maxClientLatencySeconds,cuba.backgroundWorker.maxClientLatencySeconds>>`.

* Метод `run()` задачи должен поддерживать возможность прерывания извне. Для этого в долгих процессах желательно периодически проверять флаг `TaskLifeCycle.isInterrupted()`, и соответственно завершать выполнение. Кроме того, нельзя тихо проглатывать исключение `InterruptedException` (или вообще все исключения). Вместо этого нужно либо вообще не перехватывать его, либо выполнять корректный выход из метода.

* Объекты `BackgroundTask` не имеют состояния. Если при реализации конкретного класса задачи не заводить полей для хранения промежуточных данных, то можно запускать несколько параллельно работающих процессов, используя единственный экземпляр задачи.

* Объект `BackgroundHandler` можно запускать (т.е. вызывать его метод `execute()`) всего один раз. Если требуется частый перезапуск задачи, то используйте класс `BackgroundTaskWrapper`.

* Для показа пользователю модального окна с прогрессом и кнопкой *Отмена* используйте классы `BackgroundWorkWindow` или `BackgroundWorkProgressWindow` с набором статических методов.Для окна можно задать режим отображения прогресса и разрешить или запретить отмену фоновой задачи.

* Если внутри потока задачи необходимо использовать некоторые значения визуальных компонентов, то нужно реализовать их получение в методе `getParams()`, который выполняется в потоке UI один раз при запуске задачи. В методе run() эти параметры будут доступны через метод `getParams()` объекта `TaskLifeCycle`.

* При возникновении исключительных ситуаций в потоке UI вызывается метод `BackgroundTask.handleException()`, в котором можно отобразить ошибку.

===== Настройка окружения

Для корректной работы фоновых задач в проекте приложения необходимо произвести следующие настройки:

* Прерывание задач по таймауту реализуется бином `WatchDog`. Для его периодического вызова в файлы `<<spring.xml,spring.xml>>` блоков *Web Client* и *Desktop Client* необходимо добавить следующее объявление:
+
[source, xml]
----
<bean id="backgroundWorkerScheduler" class="org.springframework.scheduling.concurrent.ThreadPoolTaskScheduler">
  <property name="daemon" value="true"/>
  <property name="poolSize" value="1"/>
</bean>

<task:scheduled-tasks scheduler="backgroundWorkerScheduler">
  <task:scheduled ref="cuba_BackgroundWorker_WatchDog" method="cleanupTasks" fixed-delay="2000"/>
</task:scheduled-tasks> 
----

* В блоке *Web Client* опрос состояния задачи инициируется клиентским кодом, выполняющимся в веб-браузере. Периодичность опроса задается свойством приложения `<<cuba.backgroundWorker.uiCheckInterval,cuba.backgroundWorker.uiCheckInterval>>`, по умолчанию - 2 секунды.
+
Кроме того, на выполнение фоновых задач в блоке *Web Client* влияют свойства приложения `<<cuba.backgroundWorker.maxActiveTasksCount,cuba.backgroundWorker.maxActiveTasksCount>>` и `<<cuba.backgroundWorker.maxClientLatencySeconds,cuba.backgroundWorker.maxClientLatencySeconds>>`.

[[gui_themes]]
==== Создание темы приложения

Тема служит для управления визуальным представлением приложения. 

[[web_theme]]
===== Тема в веб-приложениях

Тема веб-приложения состоит из файлов SCSS и других ресурсов, в том числе файлов изображений.

[[web_theme_usage]]
*Использование существующих тем*

Платформа включает в себя две готовые темы: Halo и Havana. Приложение будет по умолчанию использовать ту из них, которая указана в свойстве приложения <<cuba.web.theme,cuba.web.theme>>. Пользователь может выбрать другую доступную тему в стандартном экране *Help* → *Settings*. Если вы не хотите, чтобы пользователи имели возможность сами выбирать тему, зарегистрируйте экран `settings` в файле <<screens.xml,web-screens.xml>> проекта с параметром `changeThemeEnabled = false`:

[source, xml]
----
<screen id="settings" template="/com/haulmont/cuba/web/app/ui/core/settings/settings-window.xml">
  <param name="changeThemeEnabled" value="false"/>
</screen>          
----

При использовании существующих тем можно настроить некоторые параметры фирменного стиля (branding): пиктограммы и заголовки окна логина и главного окна, пиктограмму вебсайта `favicon.ico`. Для этого необходимо выполнить следующее:

. Создайте следующую файловую структуру внутри каталога `modules/web` проекта: 
+
[source, plain]
----
themes/
  havana/
    branding/
      myapp-login.png
      myapp-menu.png
    favicon.ico
----
+
Здесь `havana` - каталог с именем используемой темы, `favicon.ico` - пиктограмма вебсайта, `myapp-login.png` - изображение для окна логина, `myapp-menu.png` - изображение для главного окна.

. В *CUBA Studio* откройте *Project properties* → *Edit* и нажмите кнопку *Branding* внизу страницы. Используя ссылки *Set application logo image* и *Set login window logo image* задайте путь к файлам пиктограмм соответственно главного окна и окна логина. Путь указывается относительно каталога темы. Остальные ссылки служат для задания заголовков окон и текста приглашения окна логина.
+
Данные параметры сохраняются в <<main_message_pack,главном пакете сообщений>> модуля *gui* (то есть в файле `modules/gui/<root_package>/gui/messages.properties` и его вариантах для разных локалей). Использование пакетов сообщений дает возможность использовать разные файлы изображений для разных локалей пользователей. Пример содержимого файла `messages.properties`:
+
[source, properties]
----
application.caption = MyApp
application.logoImage = branding/myapp-menu.png

loginWindow.caption = MyApp Login
loginWindow.welcomeLabel = Welcome to MyApp!
loginWindow.logoImage = branding/myapp-login.png
----
+
Путь к `favicon.ico` указывать не нужно, он должен обязательно находится в корне каталога с именем темы.

В существующую тему можно также добавить файлы изображений для использования в свойствах <<gui_attr_basic_icon,icon>> <<gui_Action,действий>> и визуальных компонентов, например <<gui_Button,Button>>. 

Например, чтобы добавить в тему Havana пиктограмму, достаточно в описанный выше каталог `modules/web/themes/havana` добавить файл изображения (желательно в некоторый подкаталог): 

[source, plain]
----
themes/
  havana/
    images/
      address-book.png
----

После этого можно использовать эту пиктограмму, указывая в свойстве `icon` путь к ней относительно каталога темы:

[source, xml]
----
<action id="adresses"
      icon="images/address-book.png"/>
----

Вместо файлов изображений для пиктограмм можно использовать элементы шрифта link:$$http://fortawesome.github.io/Font-Awesome$$[Font Awesome]. Для этого достаточно указать в свойстве `icon` имя нужной константы перечисления `com.vaadin.server.FontAwesome` с префиксом `font-icon:`, например: 

[source, xml]
----
<action id="adresses"
      icon="font-icon:BOOK"/>
----

В проекте можно заменить изображения, используемые в стандартных действиях и экранах платформы. Для замены пиктограммы темы Havana достаточно положить в каталог `modules/web/themes/havana/icons` проекта нужный файл изображения. Например, для замены пиктограммы стандартного действия `create` это будет файл с именем `create.png` (имя файла легко определить по URL соответствующего HTML-элемента `img` в работающем приложении): 

[source, plain]
----
themes/
  havana/
    icons/
      create.png
----

В теме Halo по умолчанию (при включенном свойстве приложения <<cuba.web.useFontIcons,cuba.web.useFontIcons>>) пиктограммы стандартных действий и экранов платформы загружаются из шрифта *Font Awesome*. В этом случае заменить стандартную пиктограмму можно только создав свою тему на базе Halo (см. <<web_theme_creation,далее>>) и задав в файле `<your_theme>-theme.properties` нужное соответствие между именем пиктограммы и именем элемента шрифта, например:

[source, properties]
----
cuba.web.icons.create.png = PLUS
----

При выключенном свойстве `cuba.web.useFontIcons` пиктограммы стандартных действий и экранов платформы для темы Halo загружаются так же, как и для темы Havana - из файлов изображений в подкаталоге `icons`. Поэтому их можно заменить описанным для Havana способом.

Тема Halo поддерживает свойство приложения <<cuba.web.useInverseHeader,cuba.web.useInverseHeader>>, управляющее цветом заголовка приложения. По умолчанию это свойство установлено в `true`, что задает темный (инверсный) заголовок. В проекте можно не изменяя темы сделать заголовок светлым, установив данное свойство в `false`.

[[web_theme_extension]]
*Расширение существующей темы*

Существующая в платформе тема может быть изменена в проекте приложения. Тема описывается в файлах link:$$http://sass-lang.com$$[SCSS] в определенной файловой структуре, поэтому простейший способ адаптации - изменение базовых переменных SCSS, влияющих на цвет фона, размеры компонентов и отступы между ними. Для изменения параметров отдельных компонентов требуется знание CSS.

Для адаптации (расширения) темы в проекте необходимо создать специальную файловую структуру в модуле *web*. Это удобно сделать с помощью *CUBA Studio*: откройте секцию *Project properties* и нажмите ссылку *Create theme extension*. В диалоговом окне выберите тему, которую вы хотите расширить. В результате в проекте будет создана структура каталогов, аналогичная описанной в <<web_theme_usage,предыдущем>> разделе. Кроме того, скрипт сборки <<build.gradle,build.gradle>> будет дополнен задачей `buildScssThemes`, автоматически запускаемой при сборке модуля *web*.

Рассмотрим пример расширения темы Halo, так как она основана на теме link:$$https://vaadin.com/valo$$[Valo] фреймворка *Vaadin*, и предоставляет максимальные возможности адаптации.

Файл `themes/halo/halo-ext-defaults.scss` предназначен для размещения в нем переменных темы. Большинство переменных Halo соответствует описанным в link:$$https://vaadin.com/api/valo$$[документации по Valo], ниже приведены основные:

[source, css]
----
include::{sourcesdir}/gui/themes_4.scss[]
----

Пример содержимого файла `halo-ext-defaults.scss` для темы с темным фоном и немного уменьшенными отступами:

[source, css]
----
include::{sourcesdir}/gui/themes_5.scss[]
----

Для изменения параметров отдельных компонентов необходимо добавить соответствующий код CSS в блок `@mixin halo-ext {...}` файла `halo-ext.scss`. Например, для того, чтобы пункты главного меню отображались жирным шрифтом, содержимое файла `halo-ext.scss` должно быть следующим:

[source, css]
----
include::{sourcesdir}/gui/themes_6.scss[]
----

[[web_theme_creation]]
*Создание новой темы*

В проекте можно создать одну или несколько новых тем и дать возможность пользователям выбирать среди них подходящую. Создание новой темы позволяет также переопределять переменные файла `*-theme.properties`, задающие некоторые параметры, требуемые на стороне сервера:

* Размеры диалоговых окон по умолчанию.

* Ширина полей ввода по умолчанию.

* Размеры некоторых компонентов (<<gui_Filter,Filter>>, <<gui_FileMultiUploadField,FileMultiUploadField>>).

* Соответствие между именами пиктограмм и именами констант перечисления `com.vaadin.server.FontAwesome` для использования элементов шрифта *Font Awesome* в стандартных действиях и экранах платформы при включенном свойстве <<cuba.web.useFontIcons,cuba.web.useFontIcons>>.

Рассмотрим пример создания на основе Halo новой темы Facebook, напоминающей интерфейс сайта известной социальной сети.

. В *CUBA Studio* откройте секцию *Project properties* и нажмите ссылку *Create theme extension*. В диалоговом окне выберите `halo` и нажмите *Create*. В проекте будет создано расширение темы Halo, как описано в предыдущем разделе.

. Переименуйте созданный в модуле *web* каталог `themes/halo` в `themes/facebook`, внутри него файл `halo-ext.scss` переименуйте в `facebook.scss`, `halo-ext-defaults.scss` в `facebook-defaults.scss`.

. Отредактируйте файл `styles.scss`, заменив в нем импорты `halo-ext` и корневой селектор `halo`:
+
[source, css]
----
@import "halo-defaults";
@import "facebook-defaults";
@import "facebook";

.facebook {
@include facebook;
}

.v-theme-version {
display: none;
}
----

. Отредактируйте файл `facebook.scss`, заменив в нем `@mixin halo-ext`:
+
[source, css]
----
@import "../halo/halo";

@mixin facebook {
@include halo;
}
----

. Поместите в файл `facebook-defaults.scss` следующие переменные:
+
[source, css]
----
$v-background-color: #fafafa;
$v-app-background-color: #e7ebf2;
$v-panel-background-color: #fff;
$v-focus-color: #3b5998;

$v-border-radius: 0;
$v-textfield-border-radius: 0;

$v-font-family: Helvetica, Arial, 'lucida grande', tahoma, verdana, arial, sans-serif;
$v-font-size: 14px;
$v-font-color: #37404E;
$v-font-weight: 400;

$v-link-text-decoration: none;
$v-shadow: 0 1px 0 (v-shade 0.2);
$v-bevel: inset 0 1px 0 v-tint;
$v-unit-size: 30px;
$v-gradient: v-linear 12%;
$v-overlay-shadow: 0 3px 8px v-shade, 0 0 0 1px (v-shade 0.7);
$v-shadow-opacity: 20%;
$v-selection-overlay-padding-horizontal: 0;
$v-selection-overlay-padding-vertical: 6px;
$v-selection-item-border-radius: 0;

$v-line-height: 1.35;
$v-font-size: 14px;
$v-font-weight: 400;
$v-unit-size: 25px;

$v-font-size--h1: 22px;
$v-font-size--h2: 18px;
$v-font-size--h3: 16px;

$v-layout-margin-top: 8px;
$v-layout-margin-left: 8px;
$v-layout-margin-right: 8px;
$v-layout-margin-bottom: 8px;

$v-layout-spacing-vertical: 8px;
$v-layout-spacing-horizontal: 8px;

$v-table-row-height: 25px;
$v-table-header-font-size: 13px;
$v-table-cell-padding-horizontal: 5px;

$v-focus-style: inset 0px 0px 1px 1px rgba($v-focus-color, 0.5);
$v-error-focus-style: inset 0px 0px 1px 1px rgba($v-error-indicator-color, 0.5);
----

. Создайте в подкаталоге `src` модуля *web* файл `facebook-theme.properties` со следующим содержимым:
+
[source, properties]
----
@include=halo-theme.properties
----
+
При необходимости в этом файле можно переопределять server-side переменные темы, заданные в файле `halo-theme.properties` платформы.

. В файл `web-app.properties` добавьте следующие свойства:
+
[source, properties]
----
cuba.web.theme = facebook
cuba.themeConfig = havana-theme.properties halo-theme.properties facebook-theme.properties
----

. Пересоберите приложение и запустите сервер. Теперь при первом входе пользователь увидит приложение в теме Facebook, и в окне *Help* → *Settings* сможет выбирать между темами *Facebook*, *Halo*, *Havana*.

[[desktop_theme]]
===== Темы в десктоп-приложениях

В десктоп-приложениях базовой темой является тема `Nimbus`.

Для внесения изменения в стандартную тему нужно создать пакет `res.nimbus` в пакете `com.sample.sales.desktop` модуля *desktop*. В пакете `res.nimbus` будут храниться файлы темы.

image::gui_themes_desktop_structure.png[align="center"]

В папке `icons` хранятся файлы пиктограмм, в файле `nimbus.xml` − описание стиля темы.

В <<app_properties,файле свойств>> для десктоп-приложения нужно установить свойство `cuba.desktop.resourceLocations` (задает набор директорий, в которых расположены файлы стилей):

[source, properties]
----
cuba.desktop.resourceLocations = \
com/haulmont/cuba/desktop/res \
com/sample/sales/desktop/res
----
--

*Примеры*

Добавление пиктограмм::

Если в десктоп-приложении требуется добавить новую пиктограмму, например, для кнопки, нужно создать пакет `res.nimbus.icons` в пакете `com.sample.sales.desktop` модуля *desktop* и поместить в него требуемое изображение.

image::gui_themes_example4.png[align="center"]

Описываем <<gui_Button,кнопку>> в <<screen_xml_glossentry,дескрипторе>>, указывая в атрибуте <<gui_attr_basic_icon,icon>> путь до пиктограммы:

[source, xml]
----
include::{sourcesdir}/gui/themes_10.xml[]
----

Ниже представлена кнопка с пиктограммой `attention.png`

image::gui_themes_example5.png[align="center"]

Переопределение значений свойств темы, установленных по умолчанию::

Рассмотрим на примере изменения цвета фона текстовых полей, обязательных для ввода.

В пакете `res.nimbus` нужно создать файл `nimbus.xml` следующего содержания:

[source, xml]
----
include::{sourcesdir}/gui/themes_11.xml[]
----

Элемент `ui-defaults` служит для переопределения значений свойств темы платформы, установленных по умолчанию.

В элементе `ui-defaults` присутствуют как свойства, содержащиеся в стандартной теме `Nimbus` (link:$$http://docs.oracle.com/javase/tutorial/uiswing/lookandfeel/_nimbusDefaults.html$$[http://docs.oracle.com/javase/tutorial/uiswing/lookandfeel/_nimbusDefaults.html]), так и свойства, созданные в платформе.

В данном примере переопределено значение свойства платформы `cubaRequiredBackground`, хранящего цвет фона поля, обязательного для заполнения. Данное изменение коснется всех полей, обязательных для ввода.Переопределение значений свойств темы, установленных по умолчанию.

Создание стиля для элемента с помощью стандартных средств::

Рассмотрим пример выделения надписи жирным цветом.

Для того чтобы создать такой стиль, необходимо определить элемент `style` в файле темы `nimbus.xml` следующим образом:

[source, xml]
----
include::{sourcesdir}/gui/themes_12.xml[]
----

Элемент `style` может содержать другие элементы, в которых можно определять те или иные свойства: `background`, `foreground`, `icon`.

В описании компонента надписи в <<screen_xml_glossentry,xml-дескрипторе>>, к которой нужно применить созданный стиль, нужно указать атрибут <<gui_attr_basic_stylename,stylename>> с именем стиля:

[source, xml]
----
include::{sourcesdir}/gui/themes_13.xml[]
----

Таким образом, данный стиль будет применен только к тем надписям, для которых определен атрибут <<gui_attr_basic_stylename,stylename>> со значением `boldlabel`.Создание стиля для элемента с помощью стандартных средств.

Создание пользовательского стиля::

Если не хватает стандартных средств изменения стиля компонента, есть возможность создать пользовательский стиль. 

Создадим пользовательский стиль, который будет применяться для компонента <<gui_Label,Label>>. С помощью стиля содержимое компонента <<gui_Label,Label>> будет отображаться подчеркнутым.

В первую очередь создадим класс-декоратор `UnderlinedLabelDecorator`:

[source, java]
----
include::{sourcesdir}/gui/themes_14.java[]
----
--
Определим пользовательский стиль в файле `nimbus.xml`:

[source, xml]
----
include::{sourcesdir}/gui/themes_15.xml[]
----

В атрибуте `component` элемента `style` содержится название компонента, к которому может быть применен стиль с названием `label-underlined`.

В элементе `custom` указывается путь до класса-декоратора, определенного ранее.

При описании элемента надписи, к которой нужно применить пользовательский стиль, нужно в атрибуте `stylename` указать название стиля:

[source, xml]
----
include::{sourcesdir}/gui/themes_16.xml[]
----

.Компонент надписи с пользовательским стилем
image::gui_themes_example6.png[align="center"]


[[gui_web]]
==== Специфика Web Client

Реализация универсального пользовательского интерфейса в <<app_tiers,блоке>> *Web Client* основана на фреймворке *Vaadin*. Рассмотрим основные классы, входящие в состав инфраструктуры веб клиента.

.Классы инфраструктуры Web Client
image::WebClientInfrastructure.png[align="center"]

* `App` - центральный класс инфраструктуры приложения. Позволяет получить ссылки на `Connection`, `AppWindow` и другие объекты инфраструктуры. Экземпляр `App` существует в единственном экземпляре для данной HTTP-сессии пользователя.
+
В конкретном приложении, как правило, создается собственный класс `App`, унаследованный от `DefaultApp` и, соответственно, от базового абстрактного `App` платформы. Это позволяет переопределить методы `createAppWindow()` и `createLoginWindow()` для создания собственных реализаций главного окна и окна логина.
+
Класс `App` приложения должен быть зарегистрирован в параметре `application` сервлета `++app_servlet++` в файле <<web.xml,web.xml>> модуля *web*.

* `Connection` - интерфейс, обеспечивающий функциональность подключения к среднему слою и хранящий пользовательскую сессию <<userSession,UserSession>>. Стандартной реализацией этого интерфейса является класс `DefaultConnection`.

* `AppUI` - класс платформы, унаследованный от класса `com.vaadin.ui.UI`. Экземпляр данного класса соответствует одной открытой вкладке веб браузера. Содержит ссылку на объект `UIView` - это может быть либо `LoginWindow`, либо `AppWindow`.
+
Класс `AppUI` приложения должен быть зарегистрирован в параметре `UI` сервлета `++app_servlet++` в файле `web/WEB-INF/web.xml` модуля *web*. Как правило используется стандартный класс платформы.

* `LoginWindow` - окно, отображаемое до логина пользователя. В конкретном приложении можно создать наследника `LoginWindow` и переопределить метод `createLoginWindow()` класса `App` для его использования.

* `AppWindow` - главное окно приложения, отображаемое после логина пользователя. В конкретном приложении можно создать наследника `AppWindow` и переопределить метод `createAppWindow()` класса `App` для его использования.
+
Метод `onHistoryBackPerformed()` позволяет обработать нажатия на кнопку *Back* браузера. Этот метод вызывается вместо стандартного поведения браузера если свойство приложения <<cuba.web.allowHandleBrowserHistoryBack,cuba.web.allowHandleBrowserHistoryBack>> установлено в true.
+
Без создания собственного наследника `AppWindow` можно управлять некоторыми параметрами главного окна с помощью следующих свойств приложения:

** <<cuba.web.useLightHeader,cuba.web.useLightHeader>> - включает формирование компактной вехней части окна - лого, строка меню, имя пользователя и кнопка логаута в одну строку. В выключенном состоянии методом `AppWindow.createTitleLayout()` формируется дополнительная область сверху.

** <<cuba.web.foldersPaneEnabled,cuba.web.foldersPaneEnabled>> - включает формирование <<folders_pane,панели папок>> методом `AppWindow.createFoldersPane()`.

** <<cuba.web.appWindowMode,cuba.web.appWindowMode>> - задает начальный режим главного окна: с вкладками или одноэкранный (`TABBED` или `SINGLE`). Пользователь впоследствии может задать желаемый режим через экран *Help* → *Settings*.

** <<cuba.web.maxTabCount,cuba.web.maxTabCount>> - в режиме представления главного окна с вкладками задает максимальное количество вкладок, которое может открыть пользователь. По умолчанию 7.

* `WindowManager` - центральный класс, реализующий логику работы экранов системы. Ему делегируются вызовы `openWindow()`, `openEditor()`, `showMessageDialog()` и другие методы интерфейса `IFrame`, реализуемого <<screen_controller,контроллерами>> экранов. Класс `WindowManager` расположен в общем модуле *gui* платформы и является абстрактным. В модуле *web* имеется конкретный класс `WebWindowManager`, реализующий специфику веб клиента.
+
Как правило, `WindowManager` не используется в прикладном коде напрямую.

* `ExceptionHandlers` - содержит коллекцию <<exceptionHandlers,обработчиков исключений клиентского уровня>>.

[[webComponentsHelper]]
===== Работа с компонентами Vaadin

Для работы непосредственно с компонентами Vaadin, реализующими интерфейсы <<gui_vcl,библиотеки визуальных компонентов>> в <<app_tiers,блоке>> *Web Client*, необходимо воспользоваться классом `WebComponentsHelper`. Он имеет два статических метода для получения ссылок на компоненты Vaadin:

* `unwrap` - получить Vaadin-компонент для данного CUBA-компонента.

* `getComposition` - получить Vaadin-компонент, который является наиболее внешним контейнером в реализации данного CUBA-компонента. Для простых компонентов, например <<gui_Button,Button>>, этот метод возвращает тот же объект, что и `unwrap()` - `com.vaadin.ui.Button`. Для сложных компонентов, например <<gui_Table,Table>>, `unwrap()` вернет соответсвующий объект `com.vaadin.ui.Table`, а `getComposition()` - объект `com.vaadin.ui.VerticalLayout`, который содержит таблицу вместе с описанными вместе с ней <<gui_ButtonsPanel,ButtonsPanel>> и `RowsCount`.

Следует иметь в виду, что если экран расположен в модуле *gui* проекта, то в его контроллере можно работать только с обобщенными интерфейсами CUBA-компонентов. Чтобы использовать `WebComponentsHelper.unwrap()` нужно либо расположить весь экран в модуле *web*, либо воспользоваться механизмом <<companions,компаньонов контроллеров>>.

[[main_window_layout]]
===== Компоновка главного окна приложения

Механизм предоставляет возможность задавать компоновку главного экрана веб-приложения с использованием технологии универсального пользовательского интерфейса CUBA - XML-дескриптора и Java-контроллера с применением <<gui_vcl,визуальных компонентов>> и <<datasources,источников данных>>. 

Главное окно - особый экран системы, имеющий идентификатор `mainWindow`. Контроллер главного экрана должен быть наследником класса `AbstractMainWindow`.

Помимо стандартных компонентов GUI в главном экране приложения можно использовать дополнительные компоненты:

* `AppMenu` - главное меню.

* `FoldersPane` - панель <<folders_pane,папок поиска и папок приложения>>.

* `AppWorkArea` - рабочая область, обязательный компонент для работы с экранами в режимах `++THIS_TAB++`, `++NEW_TAB++` и `++NEW_WINDOW++`.

* `UserIndicator` - поле, отображающее имя текущего пользователя, а при наличии замещаемых пользователей позволяет переключаться между ними.

* `NewWindowButton` - кнопка открытия нового окна приложения.

* `LogoutButton` - кнопка выхода из приложения.

* `TimeZoneIndicator` - надпись, которая отображает <<timeZone,часовой пояс>> пользователя.

* `FtsField` - поле полнотекстового поиска.

Для работы с дополнительными компонентами в XML-дескриптор экрана нужно добавить элемент `xmlns:main`:

[source, xml]
----
include::{sourcesdir}/gui/main_window_1.xml[]
----

Специальный компонент `AppWorkArea` представляет собой рабочую область, в которой открываются экраны приложения. Если свойство приложения <<cuba.web.appWindowMode,cuba.web.appWindowMode>> имеет значение `TABBED` (по умолчанию), то на месте рабочей области будет расположен компонент `TabSheet` с экранами приложения. В противном случае рабочая область будет содержать единственный открытый экран. Когда не открыт ни один экран, рабочая область содержит компоненты, определенные во вложенном элементе `initialLayout`: 

[source, xml]
----
include::{sourcesdir}/gui/main_window_2.xml[]
---- 

При открытии экранов компоновка начального экрана (`initialLayout`) удаляется из `AppWorkArea`, при закрытии всех экранов - добавляется обратно. Для реакции на события смены рабочей области на стартовый экран и на отображение экранов приложения можно добавить обработчик `AppWorkArea.StateChangeListener`. Например, в таком слушателе можно разместить код обновления данных стартового экрана. 

В платформе существует стандартная реализация главного окна приложения. Ее XML-дескриптор - `/com/haulmont/cuba/web/app/mainwindow/mainwindow.xml`, соответствующий контроллер - `AppMainWindow`. Стандартная реализация главного окна может быть расширена в проекте, так же как обычный экран системы. Пример расширяющего экрана: 

[source, xml]
----
include::{sourcesdir}/gui/main_window_3.xml[]
----
--
Этот экран должен быть зарегистрирован в <<screens.xml,screens.xml>> с идентификатором `mainWindow`.

Реализация главного окна может быть полностью заменена. Например: 

[source, xml]
----
include::{sourcesdir}/gui/main_window_4.xml[]
---- 
--
В результате главное окно приложения выглядит следующим образом: 

image::main_window_1.png[align="center"]


Оно же с открытым экраном: 

image::main_window_2.png[align="center"]


Свойство приложения <<cuba.web.showBreadCrumbs,cuba.web.showBreadCrumbs>> позволяет скрыть панель навигации (breadcrumbs) над открытым экраном.


[[gui_desktop]]
==== Специфика Desktop Client

Реализация универсального пользовательского интерфейса в <<app_tiers,блоке>> *Desktop Client* основана на *Java Swing*. Рассмотрим основные классы, входящие в состав инфраструктуры десктоп клиента.

.Классы инфраструктуры Desktop Client
image::DesktopClientInfrastructure.png[align="center"]

* `App` - центральный класс инфраструктуры десктоп приложения. Содержит ссылки на `Connection` и главный `TopLevelFrame`, а также методы инициализации и получения параметров приложения (см. ниже).
+
В конкретном приложении необходимо создать собственный класс-наследник `App` и переопределить в нем следующие методы:

** `getDefaultAppPropertiesConfig` - должен возвращать строку, в которой через пробел перечислены <<app_properties_files,файлы свойств приложения>>, например:
+
[source, java]
----
@Override
protected String getDefaultAppPropertiesConfig() {
  return "/cuba-desktop-app.properties /desktop-app.properties";
}
----

** `getDefaultHomeDir` - должен вовращать путь к каталогу, в котором приложение будет хранить временные и рабочие файлы, например:
+
[source, java]
----
@Override
protected String getDefaultHomeDir() {
  return System.getProperty("user.home") + "/.mycompany/sales";
}
----

** `getDefaultLog4jConfig` - должен возвращать имя файла настройки Log4J, если таковой определен в проекте. Например:
+
[source, java]
----
@Override
protected String getDefaultLog4jConfig() {
  return "sales-log4j.xml";
}
----
+
Кроме того, в собственном классе-наследнике `App` необходимо определить метод `main()` следующим образом:
+
[source, java]
----
public static void main(final String[] args) {
  SwingUtilities.invokeLater(new Runnable() {
      public void run() {
          app = new App();
          app.init(args);
          app.show();
          app.showLoginDialog();
      }
  });
}
----

* `Connection` - класс, обеспечивающий функциональность подключения к среднему слою и хранящий пользовательскую сессию <<userSession,UserSession>>. 

* `LoginDialog` - диалог логина пользователя. В конкретном приложении можно создать наследника `LoginDialog` и переопределить метод `createLoginDialog()` класса `App` для его использования.

* `TopLevelFrame` - наследник `JFrame`, являющийся окном самого верхнего уровня. В приложении существует как минимум один экземпляр данного класса, создаваемый при старте приложения и содержащий главное меню. Этот экземпляр возвращается методом `getMainFrame()` класса `App`.
+
При отделении пользователем вкладок главного окна или компонента <<gui_TabSheet,TabSheet>> (см. атрибут `detachable`) создаются дополнительные экземпляры `TopLevelFrame`, не содержащие главного меню.

* `WindowManager` - центральный класс, реализующий логику работы экранов системы. Ему делегируются вызовы `openWindow()`, `openEditor()`, `showMessageDialog()` и другие методы интерфейса `IFrame`, реализуемого <<screen_controller,контроллерами>> экранов. Класс `WindowManager` расположен в общем модуле *gui* платформы и является абстрактным. В модуле *desktop* имеется конкретный класс `DesktopWindowManager`, реализующий специфику десктоп клиента.
+
Как правило, `WindowManager` не используется в прикладном коде напрямую.

* `ExceptionHandlers` - содержит коллекцию <<exceptionHandlers,обработчиков исключений клиентского уровня>>.

[[desktopComponentsHelper]]
===== Работа с компонентами Swing

Для работы непосредственно с компонентами Swing, реализующими интерфейсы <<gui_vcl,библиотеки визуальных компонентов>> в <<app_tiers,блоке>> *Desktop Client*, необходимо воспользоваться классом `DesktopComponentsHelper`. Он имеет два статических метода для получения ссылок на компоненты Swing:

* `unwrap` - получить Swing-компонент для данного CUBA-компонента.

* `getComposition` - получить Swing-компонент, который является наиболее внешним контейнером в реализации данного CUBA-компонента. Для простых компонентов, например <<gui_Button,Button>>, этот метод возвращает тот же объект, что и `unwrap()` - `javax.swing.JButton`. Для сложных компонентов, например <<gui_Table,Table>>, `unwrap()` вернет соответсвующий объект `org.jdesktop.swingx.JXTable`, а `getComposition()` - объект `javax.swing.JPanel`, который содержит таблицу вместе с описанными вместе с ней <<gui_ButtonsPanel,ButtonsPanel>> и `RowsCount`.

Следует иметь в виду, что если экран расположен в модуле *gui* проекта, то в его контроллере можно работать только с обобщенными интерфейсами CUBA-компонентов. Чтобы использовать `DesktopComponentsHelper.unwrap()` нужно либо расположить весь экран в модуле *desktop*, либо воспользоваться механизмом <<companions,компаньонов контроллеров>>.

[[own_components]]
==== Создание собственных компонентов

В данном разделе рассматривается процесс создания и использования собственных визуальных компонентов приложения. Сначала мы возьмем сторонний компонент, доступный в виде дополнения (add-on) Vaadin, подключим его в проект и будем использовать в экране непосредственно. Затем выполним более тесную интеграцию - создадим для компонента новый <<gui_framework,GUI>>-интерфейс и загрузчик из XML, что позволит использовать его аналогично всем остальным компонентам платформы. 

[[vaadin_addon]]
===== Использование сторонних компонентов Vaadin

В веб клиенте приложения можно использовать сторонние компоненты Vaadin, распространяемые в виде дополнений (add-ons). На данный момент в репозитории link:$$https://vaadin.com/directory$$[https://vaadin.com/directory] находится около 200 визуальных компонентов, совместимых с CUBA. Основное условие совместимости - компонент должен поддерживать Vaadin версии 7 и выше. 

Для подключения стороннего компонента в проекте необходимо выполнить следующее:

. Добавить в проект модуль *web-toolkit*, выполняющий интеграцию с клиентской (браузерной) частью Vaadin-компонентов. Проще всего это сделать в *CUBA Studio*, выполнив команду *Create web toolkit module* секции *Project properties* навигатора.
. В <<build.gradle,build.gradle>> проекта добавить зависимость модуля *web* от нужного add-on, например:
+
[source, java]
----
configure(webModule) {
  ...
  dependencies {
      ...
      compile("org.vaadin.addons:some-addon:1.2.3")
  }
----
. В созданный на шаге 1 файл `AppWidgetSet.gwt.xml` подключить набор виджетов add-on:
+
[source, xml]
----
<module>
  ...
  <inherits name="org.vaadin.someaddon.widgetset.SomeAddonWidgetset" />
----

. В экране модуля *web* (либо в соответствующем <<companions,компаньоне>>) получить ссылку на контейнер Vaadin с помощью класса <<webComponentsHelper,WebComponentsHelper>>, создать экземпляр нового компонента, и добавить его в контейнер.

. Для изменения внешнего вида подключенного компонента можно создать в проекте <<web_theme,расширение темы>> и внести в файл `<theme>-ext.scss` нужные изменения. Файлы темы проще всего создать в *Studio* командой *Create theme extension* секции *Project properties* навигатора.

В <<vaadin_addon_sample,Пример использования стороннего компонента Vaadin>> рассмотрен процесс подключения и использования Vaadin-дополнения *Stepper*, содержащего визуальный компонент для пошагового изменения значения.

[[own_gui_component]]
===== Интеграция компонентов в Generic UI

Интеграция "нативного" компонента в универсальный пользовательский интерфейс позволяет использовать его в большом количестве экранов с минимумом усилий - так же как и базовые компоненты платформы. Для полной интеграции необходимо выполнить следующие шаги:

. Создать интерфейс компонента. Обычно интерфейсы располагаются в модуле *gui*, чтобы быть доступными обоим типам клиентов - веб и десктоп. Если же вы уверены, что компонент будет реализован только для одного типа клиента, интерфейс можно расположить в соответствующем модуле - *web* или *desktop*. Далее предполагается что компонент реализован только для веб клиента.
+
Интерфейс компонента должен быть унаследован от `com.haulmont.cuba.gui.components.Component` или какого-либо его наследника, например `DatasourceComponent` или `Field`:
+
[source, java]
----
package com.company.myproject.gui.components;

import com.haulmont.cuba.gui.components.Component;

public interface MyComponent extends Component {

  String NAME = "myComponent";

  int getSomeParameter();
  void setSomeParameter(int value);
}
----
+
В интерфейсе желательно определить константу `NAME`, содержащую строковое имя компонента для его получения через `ComponentsFactory`. Это же имя используется обычно как имя XML-элемента для работы с компонентом в XML-дескрипторах экранов.

. Создать класс имплементации компонента в модуле *web*.
+
Класс компонента рекомендуется унаследовать от `com.haulmont.cuba.web.gui.components.WebAbstractComponent` или какого-либо его наследника, например `WebAbstractField`. В конструкторе класса создается экземпляр "нативного" компонента, и ему делегируются вызовы методов GUI-интерфейса:
+
[source, java]
----
package com.company.myproject.web.components;

import com.company.myproject.gui.components.MyComponent;
import com.haulmont.cuba.web.gui.components.WebAbstractComponent;

public class WebMyComponent
      extends WebAbstractComponent<org.vaadin.someaddon.SomeComponent>
      implements MyComponent {

  public WebMyComponent() {
      component = new org.vaadin.someaddon.SomeComponent();
  }

  @Override
  public int getSomeParameter() {
      return component.getSomeParameter();
  }

  @Override
  public void setSomeParameter(boolean value) {
      component.setSomeParameter(value);
  }
}
----

. Создать класс, имплементирующий интерфейс `ComponentPalette`, и из его метода `getComponents()` вернуть мэп имен своих компонентов на их классы реализации:
+
[source, java]
----
package com.company.myproject.web;

import com.company.myproject.gui.components.MyComponent;
import com.company.myproject.web.components.WebMyComponent;
import com.haulmont.cuba.gui.ComponentPalette;
import com.haulmont.cuba.gui.components.Component;
import com.haulmont.cuba.gui.xml.layout.ComponentLoader;
import java.util.HashMap;
import java.util.Map;

public class AppComponentPalette implements ComponentPalette {

  @Override
  public Map<String, Class<? extends Component>> getComponents() {
      Map<String, Class<? extends Component>> components = new HashMap<>();
      components.put(MyComponent.NAME, WebMyComponent.class);
      return components;
  }

  @Override
  public Map<String, Class<? extends ComponentLoader>> getLoaders() {
      return Collections.emptyMap();
  }
}
----
+
Экземпляр палитры компонентов необходимо зарегистрировать в приложении. Это можно сделать в блоке инициализации класса <<gui_web,App>>:
+
[source, java]
----
package com.company.myproject.web;

import com.haulmont.cuba.web.DefaultApp;
import com.haulmont.cuba.web.gui.WebUIPaletteManager;

public class App extends DefaultApp {

  static {
      WebUIPaletteManager.registerPalettes(new AppComponentPalette());
  }
}
----

. На данном этапе новый GUI-компонент доступен для получения через `ComponentsFactory`:
+
[source, java]
----
@Inject
private BoxLayout box;
@Inject
private ComponentsFactory componentsFactory;

@Override
public void init(Map<String, Object> params) {
  MyComponent myComponent = componentsFactory.createComponent(MyComponent.NAME);
  box.addComponent(myComponent);
  ...
}
----

. Для поддержки объявления компонента в XML-дескрипторах экранов необходимо создать класс-загрузчик компонента, реализующий интерфейс `com.haulmont.cuba.gui.xml.layout.ComponentLoader`. Класс-загрузчик рекомендуется унаследовать от класса `com.haulmont.cuba.gui.xml.layout.loaders.ComponentLoader` или какого-либо его наследника. Загрузчик оперирует только с GUI-интерфейсом компонента, поэтому он является общим для всех типов клиентов и его можно разместить в модуле *gui*. В загрузчике достаточно вызвать унаследованный метод `loadComponent()`, который создает экземпляр компонента и устанавливает ему из XML общие свойства, такие как идентификатор, размеры и пр. После этого можно проинициализировать специфические свойства компонента:
+
[source, java]
----
package com.company.myproject.gui.loaders;

import com.company.myproject.gui.components.MyComponent;
import com.haulmont.cuba.gui.components.Component;
import com.haulmont.cuba.gui.xml.layout.*;
import org.dom4j.Element;

public class MyComponentLoader extends ComponentLoader {

  public MyComponentLoader(Context context, LayoutLoaderConfig config, ComponentsFactory factory) {
      super(context, config, factory);
  }

  @Override
  public Component loadComponent(ComponentsFactory factory, Element element, Component parent) {
      MyComponent component = (MyComponent) super.loadComponent(factory, element, parent);

      String someParameter = element.attributeValue("someParameter");
      if (someParameter != null) {
          component.setSomeParameter(Integer.valueOf(someParameter));
      }
      return component;
  }
}
----
+
Для того, чтобы система нашла загрузчик, необходимо зарегистрировать его с помощью метода `getLoaders()` созданной ранее палитры компонентов:
+
[source, java]
----
public class AppComponentPalette implements ComponentPalette {
  ...

  @Override
  public Map<String, Class<? extends ComponentLoader>> getLoaders() {
      Map<String, Class<? extends ComponentLoader>> loaders = new HashMap<>();
      loaders.put(MyComponent.NAME, MyComponentLoader.class);
      return loaders;
  }
}
----

. Теперь компонент можно использовать и в XML-дескрипторах экранов проекта:
+
[source, xml]
----
<layout>
  <myComponent id="someId" width="100%" someParameter="10"/>
</layout>
----
+
Для того, чтобы IDE подсказывала имя компонента и его атрибуты, можно определить собственную XSD и включать ее в экранах:
+
[source, xml]
----
<window xmlns="http://schemas.haulmont.com/cuba/window.xsd"
      xmlns:app="http://schemas.company.com/app/0.1/app-components.xsd"
      ...>

  <layout>
      <app:myComponent id="someId" width="100%" someParameter="10"/>
  </layout>
----

В <<own_gui_component_sample,Пример интеграции компонента Vaadin в Generic UI>> рассмотрен процесс интеграции в универсальный UI компонента *IntStepper*, предназначенного для пошагового изменения целого значения.

[[shortcuts]]
==== Горячие клавиши

В данном разделе приведена информация обо всех горячих клавишах (shortcuts), которые используются по умолчанию в универсальном пользовательском интерфейсе приложения. Все перечисленные ниже <<app_properties,свойства приложения>> принадлежат интерфейсу `ClientConfig` и используются в блоках *Web Client* и *Desktop Client*. 

* Главное окно приложения.

** *CTRL-SHIFT-PAGE_DOWN* - переход на следующую вкладку. Настраивается свойством приложения `cuba.gui.nextTabShortcut`.

** *CTRL-SHIFT-PAGE_UP* - переход на предыдущую вкладку. Настраивается свойством приложения `cuba.gui.previousTabShortcut`.

* Экраны.

** *ESCAPE* - закрыть текущий <<abstractWindow,экран>>. Настраивается свойством приложения `cuba.gui.closeShortcut`.

** *CTRL-ENTER* - закрыть текущий <<abstractEditor,экран редактирования>> с сохранением изменений. Настраивается свойством приложения `cuba.gui.commitShortcut`.

* Стандартные действия компонента-списка (<<gui_Table,Table>>, <<gui_GroupTable,GroupTable>>, <<gui_TreeTable,TreeTable>>, <<gui_Tree,Tree>>). Кроме указанных свойств приложения горячая клавиша для конкретного экземпляра действия может быть установлена его методом `setShortcut()`.

** *CTRL-INSERT* - вызов действия <<createAction,CreateAction>>. Настраивается свойством приложения `cuba.gui.tableInsertShortcut`. 

** *CTRL-ALT-INSERT* - вызов действия <<addAction,AddAction>>. Настраивается свойством приложения `cuba.gui.tableAddShortcut`.

** *ENTER* - вызов действия <<editAction,EditAction>>. Настраивается свойством приложения `cuba.gui.tableEditShortcut`.

** *CTRL-DELETE* - вызов действий <<removeAction,RemoveAction>> и <<excludeAction,ExcludeAction>>. Настраивается свойством приложения `cuba.gui.tableRemoveShortcut`.

* Выпадающие списки (<<gui_LookupField,LookupField>>, <<gui_LookupPickerField,LookupPickerField>>).

** *SHIFT-DELETE* – очистить значение.

* Стандартные действия поля выбора (<<gui_PickerField,PickerField>>, <<gui_LookupPickerField,LookupPickerField>>, <<gui_SearchPickerField,SearchPickerField>>). Кроме указанных свойств приложения горячая клавиша для конкретного экземпляра действия может быть установлена его методом `setShortcut()`.
** *CTRL-ALT-L* - вызов действия <<lookupAction,LookupAction>>. Настраивается свойством приложения `cuba.gui.pickerShortcut.lookup`.

** *CTRL-ALT-O* - вызов действия <<openAction,OpenAction>>. Настраивается свойством приложения `cuba.gui.pickerShortcut.open`.

** *CTRL-ALT-C* - вызов действия <<clearAction,ClearAction>>. Настраивается свойством приложения `cuba.gui.pickerShortcut.clear`.
+
В полях выбора кроме вышеперечисленных горячих клавиш поддерживается вызов действий сочетанием *CTRL-ALT-1*, *CTRL-ALT-2* и так далее по количеству действий. То есть при нажатии сочетания клавиш *CTRL-ALT-1* произойдет вызов действия, которое описано первым в списке действий, при нажатии сочетания клавиш *CTRL-ALT-2* − вызов второго действия и так далее. Сочетание *CTRL-ALT* можно заменить другим, указав его в свойстве приложения `cuba.gui.pickerShortcut.modifiers`.

* Компонент <<gui_Filter,Filter>>.

** *SHIFT-BACKSPACE* – открыть список выбора фильтров. Настраивается свойством приложения `cuba.gui.filterSelectShortcut`.

** *SHIFT-ENTER* - применить выбранный фильтр. Настраивается свойством приложения `cuba.gui.filterApplyShortcut`.

