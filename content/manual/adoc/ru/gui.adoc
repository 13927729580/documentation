[[gui_framework]]
=== Универсальный пользовательский интерфейс

Подсистема универсального пользовательского интерфейса (Generic UI, GUI) позволяет разрабатывать экраны пользовательского интерфейса, используя XML и Java. Созданные таким образом экраны одинаково работоспособны в двух стандартных клиентских <<app_tiers,блоках>>: *Web Client* и *Desktop Client*.

.Структура универсального пользовательского интерфейса 
image::ClientStructure.png[align="center"]

Здесь в центре изображены основные составляющие экранов универсального пользовательского интерфейса:

* <<screen_xml,XML-дескрипторы>> - файлы XML, содержащие информацию об источниках данных и компоновке экрана

* <<screen_controller,Контроллеры>> - классы Java, содержащие логику инициализации экрана и обработки событий от элементов пользовательского интерфейса.

Код экранов приложения, расположенный в <<app_modules,модуле>> *gui*, взаимодействует с интерфейсами визуальных компонентов (VCL Interfaces), реализованными по-отдельности в модулях *web* и *desktop* <<app_components,базового проекта>> *cuba*. Для *Web Client* реализация основана на фреймворке *Vaadin*, для *Desktop Client* – на фреймворке *Java Swing*.

<<gui_vcl,Библиотека визуальных компонентов>> (Visual Components Library, VCL) содержит большой набор готовых компонентов для отображения данных.

Механизм <<datasources,источников данных>> (Datasources) предоставляет унифицированный интерфейс, обеспечивающий функционирование связанных с данными визуальных компонентов.

Инфраструктура клиента (Infrastructure) включает в себя главное окно приложения, механизмы отображения и взаимодействия экранов UI, а также средства взаимодействия со средним слоем.

[[screens]]
==== Экраны

Экран универсального пользовательского интерфейса состоит из <<screen_xml,XML-дескриптора>> и класса <<screen_controller,контроллера>>. Дескриптор содержит ссылку на класс контроллера. 

Для того чтобы экран можно было вызывать из главного меню или из Java кода (например, из контроллера другого экрана), XML-дескриптор должен быть зарегистрирован в файле <<screens.xml,screens.xml>> проекта.

Главное меню приложения формируется отдельно для *Web Client* и *Desktop Client* на основе файлов <<menu.xml,menu.xml>>, расположенных соответственно в модулях *web* и *desktop* проекта.

[[screen_types]]
===== Типы экранов

В данном разделе рассматриваются основные типы экранов:

* <<frame,Фрейм>>

* <<screen_simple,Простой экран>>

* <<screen_lookup,Экран выбора>>

* <<screen_edit,Экран редактирования>>

[[frame]]
====== Фрейм

Фреймы представляют собой части экранов, которые применяются для декомпозиции и многократного использования.

Для подключения фрейма в XML экрана используется элемент <<gui_Frame,frame>> c указанием либо пути к файлу XML фрейма, либо идентификатора фрейма, если он зарегистрирован в <<screens.xml,screens.xml>>.

Контроллер фрейма должен быть унаследован от класса <<abstractFrame,AbstractFrame>>.

Правила взаимодействия экрана и вложенного в него фрейма:

* Из экрана обращаться к компонентам фрейма можно через точку: `++frame_id.component_id++`

* Из контроллера фрейма получить компонент экрана можно обычным вызовом `++getComponent(component_id)++`, но только в том случае, если компонент с таким именем не объявлен в самом фрейме. То есть компоненты фрейма маскируют компоненты экрана.

* Из фрейма получить <<datasources,источник данных>> экрана можно простым вызовом `++getDsContext().get(ds_id)++` или <<screen_controller_injection,инжекцией>>, либо в <<datasource_query,запросе>> `++ds$ds_id++`, но только в том случае, если источник данных с таким именем не объявлен в самом фрейме (аналогично компонентам).

* Из экрана получить источник данных фрейма можно только через итерацию по `getDsContext().getChildren()`

При коммите экрана вызывается также коммит измененных источников данных фрейма.

[[screen_simple]]
====== Простой экран

Простой экран предназначен для отображения и редактирования произвольной информации, в том числе отдельных экземпляров и списков сущностей. Данный тип экрана имеет только базовую функциональность, позволяющую отобразить его в главном окне системы, закрыть, а также работать с <<datasources,источниками данных>>.

Идентификатор экрана в файле <<screens.xml,screens.xml>> может быть произвольного вида.

Контроллер простого экрана должен быть унаследован от класса <<abstractWindow,AbstractWindow>>. 

[[screen_lookup]]
====== Экран выбора

Экран выбора (lookup) отличается от простого экрана тем, что при вызове методом `openLookup()` отображает внизу панель с кнопками, позволяющими передать вызывающему коду экземпляр выбранной в данный момент в списке сущности. При вызове методом `openWindow()` или, например, из главного меню, панель с кнопками выбора не отображается.

В метод `openLookup()` передается объект с интерфейсом `Window.Lookup.Handler`. Метод `handleLookup()` этого объекта вызывается экраном, и ему передается коллекция выбранных пользователем экземпляров сущности. Тем самым вызывающий код получает из экрана выбранные экземпляры. 

Экраны выбора рекомендуется использовать для отображения списков сущностей. Визуальные компоненты, предназначенные для отображения и редактирования ссылок между сущностями (такие как `<<gui_PickerField,PickerField>>`, `<<gui_LookupPickerField,LookupPickerField>>`, `<<gui_SearchPickerField,SearchPickerField>>`), вызывают экраны выбора для поиска связанных сущностей.

Для корректной работы <<standard_actions,стандартных действий>> идентификатор экрана выбора в файле <<screens.xml,screens.xml>> должен иметь вид `++{имя_сущности}.lookup++`, например, `sales$Customer.lookup`.

Контроллер экрана выбора должен быть унаследован от класса <<abstractLookup,AbstractLookup>>. В XML экрана в атрибуте `lookupComponent` должен быть указан компонент (например, `<<gui_Table,Table>>`), из которого будет взят экземпляр сущности при выборе.

[[screen_edit]]
====== Экран редактирования

Экран редактирования предназначен для отображения и редактирования экземпляра сущности. Поддерживает функциональность установки редактируемого экземпляра и <<gui_Action,действия>> по коммиту изменений в базу данных. Экран редактирования должен вызываться методом `openEditor()` с передачей экземпляра сущности.

Для корректной работы <<standard_actions,стандартных действий>> идентификатор экрана редактирования в файле <<screens.xml,screens.xml>> должен иметь вид `++{имя_сущности}.edit++`, например, `sales$Customer.edit`.

Контроллер экрана редактирования должен быть унаследован от класса <<abstractEditor,AbstractEditor>>. В XML экрана в атрибуте `datasource` указывается источник данных, в который проставляется редактируемый экземпляр сущности. Для отображения действий, выполняющих коммит или отмену изменений, в XML можно использовать следующие стандартные фреймы с кнопками:

* `editWindowActions` (файл `com/haulmont/cuba/gui/edit-window.actions.xml`) - содержит кнопки *OK* и *Cancel*

* `extendedEditWindowActions` (файл `com/haulmont/cuba/gui/extended-edit-window.actions.xml`) - содержит кнопки *OK & Close*, *OK* и *Cancel*

В экране редактирования неявно создаются следующие действия:

* `windowCommitAndClose` (соответствует константе `++Window.Editor.WINDOW_COMMIT_AND_CLOSE++`) - действие, выполняющее коммит изменений в базу данных и закрывающее экран. Создается при наличии в экране визуального компонента с идентификатором `windowCommitAndClose`, в частности, при использовании вышеописанного стандартного фрейма `extendedEditWindowActions` отображается кнопкой *OK & Close*.

* `windowCommit` (соответствует константе `++Window.Editor.WINDOW_COMMIT++`) - действие, выполняющее коммит изменений в базу данных. При отсутствии действия `windowCommitAndClose` после коммита закрывает экран. Создается всегда, и при наличии в экране вышеописанных стандартных фреймов отображается кнопкой *OK*.

* `windowClose` (соответствует константе `++Window.Editor.WINDOW_CLOSE++`) - действие, закрывающее экран без коммита изменений. Создается всегда, и при наличии в экране вышеописанных стандартных фреймов отображается кнопкой *Cancel*.

Таким образом, если в экран добавлен фрейм `editWindowActions`, то кнопка *OK* коммитит изменения и закрывает экран, а кнопка *Cancel* - закрывает без коммита. Если же добавлен фрейм `extendedEditWindowActions`, то кнопка *OK* только коммитит изменения, оставляя экран открытым, кнопка *OK & Close* коммитит и закрывает экран, кнопка *Cancel* - закрывает без коммита.

Вместо стандартных фреймов для отображения действий можно использовать произвольные компоненты, например, `<<gui_LinkButton,LinkButton>>`.

[[screen_xml]]
===== XML-дескриптор

XML-дескриптор - это файл формата XML, описывающий <<datasources,источники данных>> и расположение визуальных компонентов экрана.

Схема XML доступна по адресу {xsd_url}/window.xsd.

Рассмотрим структуру дескриптора.

`window` − корневой элемент.

Атрибуты `window`:

* `class` − имя класса <<screen_controller,контроллера>>

* `messagesPack` − <<message_packs,пакет сообщений>> данного экрана, который будет использован при получении локализованных строк без указания пакета из XML-дескриптора и из контроллера методом `getMessage()`

* `caption` − заголовок экрана, может содержать <<messageTools.loadString,ссылку на сообщение>> из вышеуказанного пакета, например, 
+
[source, properties]
----
caption="msg://caption"
----

* `focusComponent` − идентификатор компонента, который получит фокус ввода при отображении экрана

* `lookupComponent` - обязательный для <<screen_lookup,экрана выбора>> атрибут, задающий идентификатор визуального компонента, из которого будет выбран экземпляр сущности. Поддерживаются компоненты следующих типов (и их наследников):

** `Table`

** `Tree`

** `LookupField`

** `PickerField`

** `OptionsGroup`

* `datasource` - обязательный для <<screen_edit,экрана редактирования>> атрибут, задающий идентификатор <<datasources,источника данных>>, в который будет проставлен экземпляр редактируемой сущности.

Элементы `window`:

* `metadataContext` − элемент для инициализации <<views,представлений>> (views), необходимых данному экрану. Предпочтительным является определение всех представлений в одном общем файле `<<views.xml,views.xml>>`, так как все описатели представлений разворачиваются в один общий репозиторий, и при рассредоточении описателей по разным файлам трудно обеспечить уникальность имен.

* `dsContext` − определяет <<datasources,источники данных>> данного экрана.

* `actions` - определяет список <<gui_Action,действий>> данного экрана.

* `timers` - определяет список таймеров данного экрана.

* `companions` - определяет список классов-<<companions,компаньонов>> данного контроллера
+
Элементы `companions`:

** `web` - задает компаньон, реализованный в модуле *web*

** `desktop` - задает компаньон, реализованный в модуле *desktop*
+
Каждый из этих элементов содержит атрибут `class`, задающий класс компаньона.

* `layout` − корневой элемент компоновки экрана. Является сам по себе контейнером с вертикальным расположением компонентов, аналогичным <<gui_BoxLayout,vbox>>.
+
Атрибуты `layout`:

** <<gui_attr_spacing,spacing>>

** <<gui_attr_margin,margin>>

** <<gui_attr_expand,expand>>

** <<gui_attr_stylename,stylename>>

** <<gui_attr_height,height>>

** <<gui_attr_width,width>>

[[screen_controller]]
===== Контроллер экрана

Контроллер экрана - это `Java` или `Groovy` класс, связанный с <<screen_xml,XML-дескриптором>>, и содержащий логику инициализации и обработки событий экрана.

Контроллер должен быть унаследован от одного из следующих базовых классов:

* <<abstractFrame,AbstractFrame>> − предназначен для реализации <<frame,фреймов>>.

* <<abstractWindow,AbstractWindow>> − предназначен для реализации <<screen_simple,простых экранов>>.

* <<abstractLookup,AbstractLookup>> − предназначен для реализации <<screen_lookup,экранов выбора>>.

* <<abstractEditor,AbstractEditor>> − предназначен для реализации <<screen_edit,экранов редактирования>>.

[TIP]
====
Если экрану не нужна никакая дополнительная логика, то в качестве контроллера можно использовать сам базовый класс `AbstractWindow`, `AbstractLookup` или `AbstractEditor`, указав его в XML-дескрипторе (эти классы на самом деле не являются абстрактными в смысле невозможности создания экземпляров). Для фрейма класс контроллера можно не указывать вообще.
====

Класс контроллера должен быть зарегистрирован в XML-дескрипторе экрана в атрибуте `class` корневого элемента `window`.

.Базовые классы контроллеров
image::Controllers.png[align="center"]

[[abstractFrame]]
====== AbstractFrame

`AbstractFrame` является корнем иерархии классов контроллеров. Рассмотрим его основные методы:

* `init()` - вызывается фреймворком после создания всего дерева компонентов, описанного XML-дескриптором, но до отображения экрана.
+
В метод `init()` из вызывающего кода передается мэп параметров, которые могут быть использованы внутри контроллера. Эти параметры могут быть переданы как из кода контроллера вызывающего экрана (в методе `openWindow()`, `openLookup()` или `openEditor()`), так и установлены в файле регистрации экранов `<<screens.xml,screens.xml>>`.
+
Метод `init()` следует имплементировать при необходимости инициализации компонентов экрана, например:
+
[source, java]
----
include::{sourcesdir}/gui/abstractframe_1.java[]
----

* `getMessage()`, `formatMessage()` - методы получения локализованных сообщений из <<message_packs,пакета>>, заданного для экрана в XML-дескрипторе. Представляют собой просто короткие варианты вызова одноименных методов интерфейса `<<messages,Messages>>`.

* `openFrame()` - загрузить фрейм по идентификатору, зарегистрированному в `<<screens.xml,screens.xml>>`, и, если в метод передан компонент-контейнер, отобразить его внутри контейнера. Возвращается контроллер фрейма. Например:
+
[source, java]
----
include::{sourcesdir}/gui/abstractframe_3.java[]
----
+
Контейнер не обязательно сразу передавать в метод `openFrame()`, вместо этого можно загрузить фрейм, а затем добавить его в нужный контейнер:
+
[source, java]
----
include::{sourcesdir}/gui/abstractframe_4.java[]
----

* `openWindow()`, `openLookup()`, `openEditor()` - открыть соответственно простой экран, экран выбора или редактирования. Методы возвращают контроллер созданного экрана.
+
Для выполнения действий после закрытия вызываемого экрана необходимо добавить слушатель типа `CloseListener`, например:
+
[source, java]
----
include::{sourcesdir}/gui/abstractframe_5.java[]
----
+
`CloseWithCommitListener` можно использовать в случае, если необходимо реагировать только при закрытии экрана действием с именем `Window.COMMIT_ACTION_ID` (то есть кнопкой *OK*), например:
+
[source, java]
----
include::{sourcesdir}/gui/abstractframe_5_1.java[]
----

* `showMessageDialog()` - отобразить диалоговое окно с сообщением.

* `showOptionDialog()` - отобразить диалоговое окно с сообщением и возможностью выбора пользователем некоторых действий. Действия задаются массивом объектов типа `<<gui_Action,Action>>`, которые в диалоге отображаются посредством соответствующих кнопок.
+
Для отображения стандартных кнопок типа *OK*, *Cancel* и других рекомендуется использовать объекты типа `DialogAction`, например:
+
[source, java]
----
include::{sourcesdir}/gui/abstractframe_6.java[]
----

* `showNotification()` - отобразить всплывающее окно с сообщением.

* `showWebPage()` - открыть указанную веб-страницу в браузере.

[[abstractWindow]]
====== AbstractWindow

`AbstractWindow` является наследником `<<abstractFrame,AbstractFrame>>`, и определяет следующие собственные методы:

* `getDialogOptions()` - получить объект `DialogOptions` для управления геометрией и поведением экрана когда он открывается в режиме диалога (`WindowManager.OpenType.DIALOG`).
+
Установка ширины и высоты:
+
[source, java]
----
include::{sourcesdir}/gui/abstractwindow_2.java[]
----
+
Указание того, что диалог должен быть немодальным и с изменяемыми размерами:
+
[source, java]
----
include::{sourcesdir}/gui/abstractwindow_3.java[]
----
+
Указание того, что экран должен всегда открываться в режиме диалога, независимо от того, какой `WindowManager.OpenType` был выбран в вызывающем коде:
+
[source, java]
----
include::{sourcesdir}/gui/abstractwindow_4.java[]
----

* `ready()` - шаблонный метод, который можно имплементировать в контроллере для перехвата момента открытия экрана. Метод `ready()` вызывается фреймворком после метода `init()` непосредственно перед показом экрана в главном окне приложения.

* `validateAll()` - валидация экрана. Реализация по умолчанию вызывает метод `validate()` у всех компонентов экрана, реализующих интерфейс `Component.Validatable`, накапливает информацию об исключениях, и если таковые имеются, выводит соответствующее сообщение и возвращает `false`, иначе возвращает `true`.
+
Данный метод следует переопределять только в том случае, если необходимо полностью заменить стандартную процедуру валидации экрана. Если же нужно только дополнить ее, достаточно определить специальный шаблонный метод `postValidate()`.

* `postValidate()` - шаблонный метод, который можно имплементировать в контроллере для дополнительной валидации экрана. Получаемый методом объект `ValidationErrors` используется для добавления информации об ошибках валидации, которая будет отображена совместно с ошибками стандартной валидации. Например:
+
[source, java]
----
include::{sourcesdir}/gui/abstractwindow_1.java[]
----

* `close()` - закрыть данный экран. 
+
Метод принимает строковое значение, передаваемое далее в шаблонный метод `preClose()` и слушателям `CloseListener`. Таким образом, заинтересованный код может получить информацию о причине закрытия экрана от кода, инициирующего закрытие. В частности, в экранах редактирования сущностей при закрытии экрана после коммита изменений рекомендуется использовать константу `++Window.COMMIT_ACTION_ID++`, без коммита изменений - константу `++Window.CLOSE_ACTION_ID++`.
+
Если какой-либо из источников данных содержит несохраненные изменения, перед закрытием экрана будет выдано диалоговое окно с соответствующим предупреждением. Тип предупреждения можно выбрать с помощью свойства приложения `<<cuba.gui.useSaveConfirmation,cuba.gui.useSaveConfirmation>>`.
+
Вариант метода `close()` с параметром `force = true` закрывает экран без вызова `preClose()` и без предупреждения, независимо от наличия несохраненных изменений.
+
Метод `close()` возвращает `true`, если экран был успешно закрыт, и `false` - если закрытие было прервано.

* `preClose()` - шаблонный метод, который можно имплементировать в контроллере для перехвата момента закрытия экрана. Метод получает строковое значение, указанное инициатором закрытия при вызове метода `close()`.
+
Если метод `preClose()` возвращает `false`, то процесс закрытия экрана прерывается.

[[abstractLookup]]
====== AbstractLookup

`AbstractLookup` базовый класс контроллеров <<screen_lookup,экранов выбора>>, является наследником `<<abstractWindow,AbstractWindow>>`, и определяет следующие собственные методы:

* `setLookupComponent()` - установить компонент, из которого будет производиться выбор экземпляров сущности.
+
Как правило, компонент выбора устанавливается в XML-дескрипторе экрана, и вызывать данный метод в прикладном коде нет необходимости.

* `setLookupValidator()` - установить для экрана объект типа `Window.Lookup.Validator`, метод `validate()` которого вызывается фреймворком перед тем как вернуть выбранные экземпляры сущностей. Если `validate()` возвращает `false`, процесс выбора и закрытия экрана прерывается.
+
По умолчанию валидатор не установлен.

[[abstractEditor]]
====== AbstractEditor

`AbstractEditor` − базовый класс контроллеров <<screen_edit,экранов редактирования>>, является наследником `<<abstractWindow,AbstractWindow>>`.

При создании конкретного класса контроллера рекомендуется параметризовать `AbstractEditor` типом редактируемой сущности. При этом методы `getItem()` и `initNewItem()` будут работать с конкретным типом сущности и прикладному коду не потребуется дополнительных приведений типов. Например:

[source, java]
----
include::{sourcesdir}/gui/abstracteditor_1.java[]
----

`AbstractEditor` определяет следующие собственные методы:

* `getItem()` - возвращает экземпляр редактируемой сущности, установленный в главном источнике данных экрана (т.е. указанном в атрибуте `datasource` корневого элемента XML-дескриптора).
+
Если редактируется не новый экземпляр, то в момент открытия экрана он перезагружается из базы данных с необходимым <<views,представлением>>, указанным для главного источника данных. 
+
Изменения, вносимые в экземпляр, возвращаемый `getItem()`, отражаются на состоянии источника данных, и будут отправлены на *Middleware* при коммите экрана.
+
[WARNING]
====
Следует иметь в виду, что `getItem()` возвращает значение только после инициализации экрана методом `setItem()`. До этого момента, например, в методах `init()` и `initNewItem()`, данный метод возвращает `null`.

Однако в методе `init()` экземпляр сущности, переданный в `openEditor()`, можно получить из параметров следующим образом:

[source, java]
----
include::{sourcesdir}/gui/abstracteditor_2.java[]
----

В метод `initNewItem()` экземпляр передается явно и нужного типа.

В обоих случаях полученный экземпляр сущности, если он не новый, будет впоследствии перезагружен, и вносить в него изменения или сохранять в поле для последующего использования не имеет смысла.
====

* `setItem()` - вызывается фреймворком при открытии экрана методом `openEditor()` для установки редактируемого экземпляра сущности в главном источнике данных. В момент вызова созданы все компоненты и источники данных экрана, и отработал метод `init()` контроллера.
+
Для инициализации экрана редактирования вместо переопределения `setItem()` рекомендуется имплементировать специальные шаблонные методы `initNewItem()` и `postInit()`.

[[initNewItem]]
* `initNewItem()` - шаблонный метод, вызываемый фреймворком перед установкой редактируемого экземпляра сущности в главном источнике данных.
+
[TIP]
====
Метод `initNewItem()` вызывается только для нового, только что созданного экземпляра сущности. Если редактируется <<entity_states,detached>> экземпляр, метод не вызывается.
====
+
Данный метод можно имплементировать в контроллере при необходимости инициализации нового экземпляра сущности перед его установкой в источник данных, например:
+
[source, java]
----
include::{sourcesdir}/gui/abstracteditor_3.java[]
----
+
Более сложный пример использования `initNewItem()` приведен в разделе <<init_values_in_initNewItem,рецептов разработки>>.

* `postInit()` - шаблонный метод, вызываемый фреймворком сразу после установки редактируемого экземпляра сущности в главном источнике данных. Во время выполнения данного метода можно вызывать `getItem()`, который будет возвращать новый или перезагруженный при инициализации экрана экземпляр сущности.
+
Данный метод можно имплементировать в контроллере для окончательной инициализации экрана, например:
+
[source, java]
----
include::{sourcesdir}/gui/abstracteditor_4.java[]
----

* `commit()` - валидировать экран и отправить изменения через `<<dataSupplier,DataSupplier>>` на *Middleware*.
+
Если используется вариант метода с параметром `validate = false`, то валидация перед коммитом не производится.
+
Данный метод не рекомендуется переопределять, лучше использовать специальные шаблонные методы `postValidate()`, `preCommit()` и `postCommit()`.

* `commitAndClose()` - валидировать экран, отправить изменения на *Middleware* и закрыть экран. В метод `preClose()` и зарегистрированным слушателям `CloseListener` будет передано значение константы `++Window.COMMIT_ACTION_ID++`.
+
Данный метод не рекомендуется переопределять, лучше использовать специальные шаблонные методы `postValidate()`, `preCommit()` и `postCommit()`.

* `preCommit()` - шаблонный метод, вызываемый фреймворком в процессе коммита изменений, после того как валидация завершена успешно и перед отправкой данных на *Middleware*.
+
Данный метод можно имплементировать в контроллере. Если метод возвращает `false`, процесс коммита (и закрытия экрана, если был вызван `commitAndClose()`), прерывается. Например:
+
[source, java]
----
include::{sourcesdir}/gui/abstracteditor_5.java[]
----

* `postCommit()` - шаблонный метод, вызываемый фреймворком на финальной стадии коммита изменений. Параметры метода:

** `committed` - установлен в `true`, если в экране действительно были изменения, и они отправлены на *Middleware*;

** `close` - установлен в `true`, если экран после коммита будет закрыт.
+
Реализация метода по умолчанию, если экран не закрывается, отображает сообщение об успешном коммите изменений и вызывает метод `postInit()`.
+
Данный метод можно переопределить в контроллере для выполнения некоторых действий после успешного коммита, например:
+
[source, java]
----
include::{sourcesdir}/gui/abstracteditor_6.java[]
----

Далее приведены диаграммы последовательностей инициализации и различных вариантов коммита экрана редактирования.

.Инициализация экрана редактирования
image::EditorInit.png[align="center"]

.Коммит и закрытие экрана с фреймом editWindowActions
image::EditorCommit.png[align="center"]

.Коммит экрана с фреймом extendedEditWindowActions
image::ExtendedEditorCommit.png[align="center"]

.Коммит и закрытие экрана с фреймом extendedEditWindowActions
image::ExtendedEditorCommitAndClose.png[align="center"]

[[screen_controller_injection]]
====== Инжекция зависимостей контроллеров

В контроллерах можно использовать Dependency Injection для получения ссылок на используемые объекты. Для этого нужно объявить либо поле соответствующего типа, либо метод доступа на запись (setter) с соответствующим типом результата, и добавить ему одну из следующих аннотаций:

* `@Inject` - простейший вариант, поиск объекта для инжекции будет произведен по типу поля/метода и по имени, эквивалентному имени поля либо имени атрибута (по правилам JavaBeans) для метода

* `@Named("someName")` - вариант с явным указанием имени искомого объекта

Инжектировать в контроллеры можно следующие объекты: 

* Визуальные компоненты данного экрана, определенные в XML-дескрипторе. Если тип атрибута унаследован от `Component`, в текущем экране будет произведен поиск компонента с соответствующим именем. 

* Действия, определенные в XML-дескрипторе - см. <<gui_Action,Действия. Интерфейс Action>>

* <<datasources,Источники данных>>, определенные в XML-дескрипторе. Если тип атрибута унаследован от `Datasource`, в текущем экране будет произведен поиск источника данных с соответствующим именем. 

* `UserSession`. Если тип атрибута - `<<userSession,UserSession>>`, будет инжектирован объект текущей пользовательской сессии.

* `DsContext`. Если тип атрибута - `DsContext`, будет инжектирован `DsContext` текущего экрана. 

* `WindowContext`. Если тип атрибута - `WindowContext`, будет инжектирован `WindowContext` текущего экрана. 

* `DataSupplier`. Если тип атрибута - `<<dataSupplier,DataSupplier>>`, будет инжектирован соответствующий экземпляр.

* Любой бин, определенный в контексте данного клиентского блока приложения, в том числе:

** импортируемые клиентом <<services,сервисы>> *Middleware*

** <<config_interfaces,конфигурационные интерфейсы>>

** `ComponentsFactory`

** `WindowConfig`

** `ExportDisplay`

** `<<background_tasks,BackgroundWorker>>`

* Если ничего из вышеперечисленного не подошло и контроллер имеет <<companions,компаньонов>>, в случае совпадения типов будет инжектирован компаньон для текущего типа клиента.

С помощью специальной аннотации `@WindowParam` можно инжектировать в контроллер параметры, передаваемые в мэп метода `init()`. Аннотация имеет атрибут `name`, в котором указывается имя параметра (ключ в мэп), и опциональный атрибут `required`. Если `required = true`, то при отсутствии в мэп соответствующего параметра в лог выводится сообщение с уровнем `WARNING`. 

Пример инжекции объекта типа `Job`, передаваемого в метод `init()` контроллера:

[source, java]
----
include::{sourcesdir}/gui/cdi_1.java[]
----

[[companions]]
====== Компаньоны контроллеров

Базовые классы контроллеров расположены в <<app_modules,модуле>> *gui* <<app_components,базового проекта>> *cuba* и не содержат ссылок на классы реализации визуальных компонентов (*Swing* или *Vaadin*), что дает возможность использовать их в клиентах обоих типов.

В то же время конкретные классы контроллеров могут быть расположены как в модуле *gui*, так и в *web* или *desktop*, в зависимости от применяемых в проекте клиентских <<app_tiers,блоков>> и специфики экрана. Если контроллер является универсальным, но для разных типов клиента требуется дополнительная функциональность, ее можно определить в так называемых _классах-компаньонах_. 

Класс-компаньон располагается в модуле клиента соответствующего типа (*web* или *desktop*) и реализует интерфейс, задаваемый в использующем его контроллере. Класс компаньона задается в элементе `companions` XML-дескриптора экрана. Контроллер может получить ссылку на экземпляр компаньона с помощью инжекции или вызовом `getCompanion()`, и в нужный момент передать ему управление, например, для дополнительной инициализации визуальных компонентов специфичным для данного типа клиента способом. 

Например, необходимо раздельно для веб и десктоп клиентов проинициализировать таблицу некоторого экрана. Тогда в контроллере экрана, расположенном в модуле *gui*, определяем интерфейс компаньона и делегируем ему инициализацию таблицы:

[source, java]
----
include::{sourcesdir}/gui/companion_1.java[]
----

В модулях *web* и *desktop* создаем соответствующие классы реализации компаньона:

[source, java]
----
include::{sourcesdir}/gui/companion_2.java[]
----

[source, java]
----
include::{sourcesdir}/gui/companion_3.java[]
----

И регистрируем классы реализации компаньона в XML-дескрипторе экрана:

[source, xml]
----
include::{sourcesdir}/gui/companion_4.xml[]
----

Так как классы-компаньоны расположены в *web* и *desktop* модулях, в них можно использовать метод `unwrap()` классов <<webComponentsHelper,WebComponentsHelper>> и <<desktopComponentsHelper,DesktopComponentsHelper>> для извлечения из интерфейса <<gui_Table,Table>> ссылок на реализующие таблицу Vaadin и Swing компоненты, и работать с ними непосредственно.

[[screen_agent]]
===== Screen Agent

Указание агента позволяет выбрать экран в зависимости от текущего устройства и параметров его дисплея. Например, можно создать два экрана с различной компоновкой (и, возможно, различной функциональностью), и зарегистрировать их в файле <<screens.xml,screens.xml>> с одним идентификатором. Тогда во время выполнения платформа выберет экран, который лучше подходит для дисплея, с которого пользователь работает с приложением.

В платформе предопределены три агента: `DESKTOP`, `TABLET`, `PHONE`. Они заданы следующими классами: `DesktopScreenAgent`, `TabletScreenAgent`, `PhoneScreenAgent`. В проекте приложения можно определить собственные агенты путем создания <<managed_beans,бинов>>, реализующих интерфейс `ScreenAgent`.

Агент указывается для экрана в файле <<screens.xml,screens.xml>>. Значением атрибута `agent` должна быть либо одна из вышеперечисленных констант, либо имя бина, реализующего `ScreenAgent`.

В Studio агент задается на вкладке *Properties* дизайнера экранов.


include::gui_vcl.adoc[]

[[datasources]]
==== Источники данных

Источники данных обеспечивают работу связанных с данными (data-aware) компонентов.

Визуальные компоненты сами не обращаются к *Middleware*, а получают экземпляры сущностей из связанных источников данных. При этом один источник данных может обслуживать несколько визуальных компонентов, если им нужен один и тот же экземпляр или набор экземпляров.

Связь визуального компонента и источника данных проявляется в следующем:

* При изменении пользователем значения в компоненте новое значение проставляется в атрибуте сущности, находящейся в источнике.

* При изменении атрибута сущности из кода новое значение проставляется и отображается в визуальном компоненте. 

* Для слежения за вводом пользователя можно использовать как <<datasource_listeners,слушатель источника данных>>, так и слушатель значения визуального компонента - они срабатывают друг за другом. 

* При необходимости прочитать или записать значение атрибута сущности в коде предпочтительнее использовать источник данных, а не компонент. Рассмотрим пример чтения атрибута: 
+
[source, java]
----
include::{sourcesdir}/gui/datasources_1.java[]
---- 
+
Как видно из примера, работа со значениями атрибутов сущностей через компонент требует приведения типа и, в случае <<gui_FieldGroup,FieldGroup>>, указания имени атрибута в виде строки. В то же время, получив методом `getItem()` из источника данных хранящийся в нем экземпляр, можно напрямую читать и изменять значения его атрибутов.

[WARNING]
====
Как правило, визуальный компонент привязывается к атрибуту, непосредственно принадлежащему сущности, находящейся в источнике данных. В приведенном выше примере компонент привязан к атрибуту `customer` сущности `Order`. 

Можно также привязать компонент к атрибуту связанной сущности, например к `customer.name`. В этом случае компонент будет корректно отображать значение атрибута `name`, но при его изменении пользователем слушатели источника данных вызваны не будут, и изменения не будут сохранены. Поэтому привязывать компонент к атрибутам второго и более порядка имеет смысл только для отображения, например в <<gui_Label,Label>>, колонке <<gui_Table,Table>> или установив для <<gui_TextField,TextField>> свойство `editable = false`.
====

Источники данных также отслеживают изменения содержащихся в них сущностей, и могут отправлять измененные экземпляры обратно на *Middleware* для сохранения в базе данных.

Рассмотрим основные интерфейсы источников.

.Интерфейсы источников данных
image::Datasources.png[align="center"]

* `Datasource` − простейший источник данных, предназначенный для работы с одним экземпляром сущности. Экземпляр устанавливается методом `setItem()` и доступен через `getItem()`.
+
Стандартной реализацией такого источника является класс `DatasourceImpl`, который используется, например, как главный источник данных в <<screen_edit,экранах редактирования>> сущностей.

* `CollectionDatasource` − источник данных, предназначенный для работы с коллекцией экземпляров сущности. Коллекция загружается при вызове метода `refresh()`, ключи экземпляров доступны через метод `getItemIds()`. Метод `setItem()` устанавливает, а `getItem()` возвращает "текущий" экземпляр коллекции, т.е., например, соответствующий выбранной в данный момент строке таблицы.
+
Способ загрузки коллекции сущностей определяется реализацией. Наиболее типичный - загрузка с Middleware через <<dataManager,DataManager>>, при этом для формирования JPQL запроса используются методы `setQuery()`, `setQueryFilter()`.
+
Стандартной реализацией такого источника является класс `CollectionDatasourceImpl`, который используется в экранах, отображающих списки сущностей.

** `GroupDatasource` − подвид `CollectionDatasource`, предназначенный для работы с компонентом `<<gui_GroupTable,GroupTable>>`.
+
Стандартной реализацией является класс `GroupDatasourceImpl`.

** `HierarchicalDatasource` − подвид `CollectionDatasource`, предназначенный для работы с компонентами `<<gui_Tree,Tree>>` и `<<gui_TreeTable,TreeTable>>`.
+
Стандартной реализацией является класс `HierarchicalDatasourceImpl`.

* `NestedDatasource` - источник данных, предназначенный для работы с экземплярами, загруженными в атрибуте другой сущности. При этом источник, содержащий сущность-хозяина, доступен методом `getMaster()`, а <<metaProperty,мета-свойство>>, соответствующее атрибуту хозяина, содержащему экземпляры данного источника, доступно через метод `getProperty()`.
+
Например, в источнике `dsOrder` установлен экземпляр сущности `Order`, содержащий ссылку на экземпляр `Customer`. Тогда для связи экземпляра `Customer` с визуальными компонентами достаточно создать `NestedDatasource`, у которого хозяином является `dsOrder`, а мета-свойство указывает на атрибут `Order.customer`.

** `PropertyDatasource` - подвид `NestedDatasource`, предназначенный для работы с одним экземпляром или коллекцией связанных сущностей, не являющихся встроенными (embedded).
+
Стандартные реализации: для работы с одним экземпляром - `PropertyDatasourceImpl`, для работы с коллекцией - `CollectionPropertyDatasourceImpl`, `GroupPropertyDatasourceImpl`, `HierarchicalPropertyDatasourceImpl`. Последние реализуют также интерфейс `CollectionDatasource`, однако некоторые его нерелевантные методы, связанные с загрузкой, например, `setQuery()`, выбрасывают `UnsupportedOperationException`.

** `EmbeddedDatasource` - подвид `NestedDatasource`, содержащий экземпляр встроенной сущности.
+
Стандартной реализацией является класс `EmbeddedDatasourceImpl`.

* `RuntimePropsDatasource` − специфический источник, предназначенный для работы с <<dynamic_attributes,динамическими атрибутами>> сущностей.

Как правило, источники данных объявляются декларативно в секции `dsContext` <<screen_xml,дескриптора экрана>>.

[[datasource_creation]]
===== Создание источников данных

Объекты источников данных могут быть созданы как декларативно - путем объявления в XML-дескрипторе экрана, так и программно в контроллере. Обычно используются стандартные реализации интерфейсов источников, однако при необходимости можно создать собственный класс, унаследовав его от стандартного.

[[datasource_decl_creation]]
====== Декларативное создание

Как правило, источники данных объявляются декларативно в элементе `dsContext` дескриптора экрана. В зависимости от взаимного расположения элементов объявлений создаются источники двух разновидностей:

* если элемент расположен непосредственно в `dsContext`, создается обычный `Datasource` или `CollectionDatasource`, который содержит независимо загруженную сущность или коллекцию;

* если элемент расположен внутри элемента другого источника, создается `NestedDatasource`, при этом внешний источник становится его хозяином. 

Пример объявления источников данных:

[source, xml]
----
include::{sourcesdir}/gui/datasources_2.xml[]
----

Здесь источник `carDs` содержит один экземпляр сущности `Car`, а вложенные в него `allocationsDs` и `repairsDs` содержат коллекции связанных сущностей из атрибутов `Car.driverAllocations` и `Car.repairs` соответственно. Экземпляр `Car` вместе со связанными сущностями проставляется в источник данных извне. Если данный экран является <<screen_edit,экраном редактирования>>, то это происходит автоматически при открытии экрана. Источник данных `colorsDs` содержит коллекцию экземпляров сущности `Color`, загружаемую самим источником по указанному JPQL-<<datasource_query,запросу>> с <<views,представлением>> `++_local++`.

Рассмотрим схему XML. 

`dsContext` - корневой элемент.

Элементы `dsContext`:

* `datasource` - определяет источник данных, содержащий единственный экземпляр сущности. 
+
Атрибуты:

** `id` - идентификатор источника, должен быть уникальным для данного `DsContext`.

** `class` - Java класс сущности, которая будет содержаться в данном источнике

** `view` - имя <<views,представления>> сущности. Если источник сам загружает экземпляры, то это представление будет использовано при загрузке. В противном случае это представление сигнализирует внешним механизмам о том, как нужно загрузить сущность для данного источника.

** `allowCommit` - при установке значения `false` метод `isModified()` данного источника всегда возвращает `false`, а метод `commit()` ничего не делает. Таким образом, изменения содержащихся в источнике сущностей игнорируются. По умолчанию `true`, т.е. изменения отслеживаются и могут быть сохранены.

** `datasourceClass` - <<datasource_custom_class, собственный класс реализации>> источника данных, если необходим.

* `collectionDatasource` - определяет источник данных, содержащий коллекцию экземпляров.
+
Атрибуты `collectionDatasource`:

** `refreshMode` - режим обновления источника, по умолчанию `ALWAYS`. В режиме `NEVER` при вызове `refresh()` источник не производит загрузку данных, а только переходит в состояние `Datasource.State.VALID`, оповещает слушателей и сортирует имеющиеся в нем экземпляры. Режим `NEVER` удобен, если необходимо программно заполнить `CollectionDatasource` предварительно загруженными или созданными сущностями. Например:
+
[source, java]
----
include::{sourcesdir}/gui/datasources_3.java[]
----

** `softDeletion` - значение `false` отключает режим <<soft_deletion,мягкого удаления>> при загрузке сущностей, т.е. будут загружены также и удаленные экземпляры. По умолчанию `true`.
+
Элементы `collectionDatasource`:

** `query` - <<datasource_query,запрос>> для загрузки сущностей

* `groupDatasource` - полностью аналогичен `collectionDatasource`, но создает реализацию источника данных, пригодную для использования совместно с компонентом `<<gui_GroupTable,GroupTable>>`.

* `hierarchicalDatasource` - аналогичен `collectionDatasource`, и создает реализацию источника данных, пригодную для использования совместно с компонентами `<<gui_Tree,Tree>>` и `<<gui_TreeTable,TreeTable>>`.
+
Специфическим атрибутом является `hierarchyProperty`, задающий имя атрибута сущности, по которому строится иерархия.

Класс реализации источника выбирается неявно на основе имени элемента XML и, как было сказано выше, взаимного расположения элементов. Однако если необходимо применить нестандартный источник данных, его класс может быть явно указан в атрибуте `datasourceClass`. 

[[datasource_prog_creation]]
====== Программное создание

При необходимости создать источник данных в Java коде рекомендуется воспользоваться специальным классом `DsBuilder`. 

Экземпляр `DsBuilder` параметризуется цепочкой вызовов его методов в стиле текучего (fluent) интерфейса. Если установлены параметры `master` и `property`, то в результате будет создан `NestedDatasource`, в противном случае - `Datasource` или `CollectionDatasource`.

Пример:

[source, java]
----
include::{sourcesdir}/gui/datasources_4.java[]
----

[[datasource_custom_class]]
====== Собственные классы реализации

Как правило, нестандартная реализация источника данных требуется для изменения процесса загрузки коллекции сущностей. При создании класса такого источника рекомендуется унаследовать его от `CustomCollectionDatasource`, либо от `CustomGroupDatasource` или `CustomHierarchicalDatasource`, и определить метод `getEntities()`.

Пример:

[source, java]
----
include::{sourcesdir}/gui/datasources_5.java[]
----

Для создания экземпляра нестандартного источника данных декларативным способом необходимо указать класс в атрибуте `datasourceClass` элемента XML. При программном создании через `DsBuilder` класс источника указывается вызовом `setDsClass()` или в параметре одного из методов `build*()`.

[[datasource_query]]
===== Запросы в CollectionDatasourceImpl

Класс `CollectionDatasourceImpl` и его наследники `GroupDatasourceImpl`, `HierarchicalDatasourceImpl` являются стандартной реализацией источников данных, работающих с коллекциями независимых экземпляров сущностей. Эти источники загружают данные через `DataManager`, отправляя на *Middleware* запрос на языке JPQL. Далее рассматриваются особенности формирования таких запросов.

[[datasource_query_results]]
====== Возвращаемые значения

Запрос должен возвращать сущности того типа, который указан при создании источника данных. Тип сущности при декларативном создании указывается в атрибуте `class` элемента XML, при создании через `DsBuilder` - в методе `setJavaClass()` или `setMetaClass()`.

Например, запрос источника данных типа `Customer` может выглядеть следующим образом:

[source, sql]
----
select c from sales$Customer c
----

или

[source, sql]
----
select o.customer from sales$Order o
----

Запрос не может возвращать агрегированные значения или отдельные атрибуты, например:

[source, sql]
----
select c.id, c.name from sales$Customer c /* неверно - возвращает отдельные поля, а не весь объект Customer */
----

[[datasource_query_params]]
====== Параметры запроса

JPQL-запрос в источнике данных может содержать параметры нескольких видов. Вид параметра определяется по префиксу имени параметра. Префиксом является часть имени до знака "$". Интерпретация имени после "$" рассматривается ниже.

[[datasource_query_params_ds]]
* Префикс `ds`.
+
Значением параметра являются данные другого источника данных, зарегистрированного в этом же `DsContext`. Например:
+
[source, xml]
----
<collectionDatasource id="customersDs" class="com.sample.sales.entity.Customer" view="_local">
  <query>
      select c from sales$Customer c
  </query>
</collectionDatasource>

<collectionDatasource id="ordersDs" class="com.sample.sales.entity.Order" view="_local">
  <query>
      select o from sales$Order o where o.customer.id = :ds$customersDs
  </query>
</collectionDatasource>
----
+
В данном случае параметром запроса источника данных `ordersDs` будет текущий экземпляр сущности, находящийся в источнике данных `customersDs`. 
+
При использовании параметров с префиксом `ds` между источниками данных автоматически создаются зависимости, приводящие к обновлению источника если меняется значение его параметра. В приведенном примере если изменяется выбранный Покупатель, автоматически обновляется список его Заказов. 
+
Обратите внимание, что в примере запроса с параметром левой частью оператора сравнения является значение идентификатора `o.customer.id`, а правой - экземпляр `Customer`, содержащийся в источнике `customersDs`. Такое сравнение допустимо, так как при выполнении запроса на *Middleware* реализация интерфейса <<query,Query>>, присваивая значения параметрам запроса, автоматически подставляет ID сущности вместо переданного экземпляра сущности.
+
В имени параметра после префикса и имени источника может быть также указан путь по графу сущностей к атрибуту, из которого нужно взять значение, например: 
+
[source, xml]
----
<query>
  select o from sales$Order o where o.customer.id = :ds$customersDs.id
</query>
----
+
или
+
[source, xml]
----
<query>
  select o from sales$Order o where o.tagName = :ds$customersDs.group.tagName
</query>
----

[[datasource_query_params_custom]]
* Префикс `custom`.
+
Значение параметра будет взято из объекта `Map<String, Object>`, переданного в метод `refresh()` источника данных. Например:
+
[source, xml]
----
<collectionDatasource id="ordersDs" class="com.sample.sales.entity.Order" view="_local">
  <query>
      select o from sales$Order o where o.number = :custom$number
  </query>
</collectionDatasource>
----
+
[source, java]
----
Map<String, Object> params = new HashMap<>();
params.put("number", "1");
ordersDs.refresh(params);
----
+
Приведение экземпляра при необходимости к его идентификатору осуществляется аналогично параметрам с префиксом `ds`. Путь по графу сущностей в имени параметра в данном случае не поддерживается. 

[[datasource_query_params_param]]
* Префикс `param`.
+
Значение параметра будет взято из объекта `Map<String, Object>`, переданного при открытии экрана в метод `init()` <<screen_controller,контроллера>>.
+
Приведение экземпляра при необходимости к его идентификатору осуществляется аналогично параметрам с префиксом `ds`. Поддерживается путь к атрибуту по графу сущностей в имени параметра. 

[[datasource_query_params_component]]
* Префикс `component`.
+
Значением параметра будет текущее значение визуального компонента, путь к которому указан в имени параметра. Например:
+
[source, xml]
----
<query>
  select o from sales$Order o where o.number = :component$filter.orderNumberField
</query>
----
+
Путь к компоненту должен включать все вложенные <<frame,фреймы>>.
+
Приведение экземпляра при необходимости к его идентификатору аналогично параметрам `ds`. Поддерживается путь к атрибуту по графу сущностей в имени параметра как продолжение пути к компоненту.

[[datasource_query_params_session]]
* Префикс `session`.
+
Значением параметра будет значение атрибута <<userSession,пользовательской сессии>>, указанного в имени параметра.
+
Значение извлекается методом `UserSession.getAttribute()`, поэтому поддерживаются также предопределенные имена атрибутов сессии: 

** `userId` - ID текущего зарегистрированного или замещенного пользователя;

** `userLogin` - логин текущего зарегистрированного или замещенного пользователя в нижнем регистре.
+
Пример:
+
[source, xml]
----
<query>
  select o from sales$Order o where o.createdBy = :session$userLogin
</query>
----
+
Приведение экземпляра при необходимости к его идентификатору аналогично параметрам `ds`. Путь по графу сущностей в имени параметра в данном случае не поддерживается.

[WARNING]
====
Если значение параметра не найдено по правилам, задаваемым префиксом, для данного параметра устанавливается значение `null`. То есть если, например, в запросе указан параметр с именем `++param$some_name++`, а в мэп параметров экрана нет ключа `++some_name++`, то для параметра `++param$some_name++` устанавливается значение `null`.
====

[[datasource_query_filter]]
====== Фильтр запроса

Запрос источника данных может быть модифицирован во время работы приложения, в зависимости от вводимых пользователем условий, что позволяет эффективно фильтровать данные на уровне выборки из БД.

Простейший способ обеспечения такой возможности - подключение к источнику данных специального визуального компонента <<gui_Filter,Filter>>.

Если по какой-то причине применение универсального фильтра нежелательно, можно встроить в текст запроса специальную разметку на XML, позволяющую сформировать итоговый запрос в зависимости от значений, введенных пользователем в произвольные визуальные компоненты экрана.

В таком фильтре могут быть использованы следующие элементы:

* `filter` - корневой элемент фильтра. Может непосредственно содержать только одно условие.

** `and`, `or` - логические условия, могут содержать любое количество других условий и предложений. 

** `c` - предложение на JPQL, которое добавляется в секцию `where`. Содержит только текст и опционально атрибут `join`, значение которого будет добавлено в соответствующее место запроса, если добавляется данное предложение `where`. 

Условия и предложения добавляются в итоговый запрос, только если присутствующие внутри них параметры получили значения, т.е. не равны `null`. 

[WARNING]
====
В фильтрах запросов можно использовать только <<datasource_query_params_custom,custom>>, <<datasource_query_params_param,param>> и <<datasource_query_params_component,component>> параметры. Параметры <<datasource_query_params_ds,ds>> и <<datasource_query_params_session,session>> не будут работать.
====

Пример:

[source, xml]
----
<query>
  select distinct d from app$GeneralDoc d
  <filter>
      <or>
          <and>
              <c join=", app$DocRole dr">dr.doc.id = d.id and d.processState = :custom$state</c>
              <c>d.barCode like :component$barCodeFilterField</c>
          </and>
          <c join=", app$DocRole dr">dr.doc.id = d.id and dr.user.id = :custom$initiator</c>
      </or>
  </filter>
</query>
----

В данном случае если в метод `refresh()` источника данных переданы параметры `state` и `initiator`, а в визуальном компоненте `barCodeFilterField` установлено некоторое значение, то итоговый запрос примет вид:

[source, jpql]
----
select distinct d from app$GeneralDoc d, app$DocRole dr
where
(
  (dr.doc.id = d.id and d.processState = :custom$state)
  and
  (d.barCode like :component$barCodeFilterField)
)
or
(dr.doc.id = d.id and dr.user.id = :custom$initiator)
----

Если же, к примеру, компонент `barCodeFilterField` пуст, а в `refresh()` передан только параметр `initiator`, то запрос получится следующим:

[source, jpql]
----
select distinct d from app$GeneralDoc d, app$DocRole dr
where
(dr.doc.id = d.id and dr.user.id = :custom$initiator)
----

[[datasource_query_case_insensitive]]
====== Поиск подстроки без учета регистра

В источниках данных можно использовать особенность выполнения JPQL-запросов, описанную для интерфейса `<<query,Query>>` уровня *Middleware*: для удобного формирования условия поиска без учета регистра символов и по любой части строки можно использовать префикс `(?i)`. Однако, в связи с тем, что значение параметра обычно передается неявно, имеются следующие отличия:

* Префикс `(?i)` нужно указывать не в значении, а перед именем параметра.

* Значение параметра будет автоматически переведено в нижний регистр.

* Если в значении параметра отсутствуют символы `%`, то они будут добавлены в начало и конец.

Для примера рассмотрим обработку следующего запроса:

[source, jpql]
----
select c from sales$Customer c where c.name like :(?i)component$customerNameField
----

В данном случае значение параметра, взятое из компонента `customerNameField`, будет переведено в нижний регистр и обрамлено символами `%`, а затем в базе данных будет выполнен SQL запрос с условием вида `lower(C.NAME) like ?`

Следует иметь в виду, что при таком поиске индекс, созданный в БД по полю `NAME`, не используется. 

[[datasource_listeners]]
===== Слушатели источников данных

Слушатели <<datasources,источников данных>> (datasource listeners) позволяют получать оповещения об изменении состояния источников данных и экземпляров сущностей, в них находящихся.

Существует четыре типа слушателей. Три из них: `ItemPropertyChangeListener`, `ItemChangeListener` и `StateChangeListener` определены в интерфейсе `Datasource` и могут быть использованы в любых источниках данных. `CollectionChangeListener` определен в интерфейсе `CollectionDatasource` и может быть использован только в источниках данных, работающих с коллекциями сущностей.

Пример использования слушателей источников данных:

[source, java]
----
include::{sourcesdir}/gui/datasources_14.java[]
----

Интерфейсы слушателей описаны ниже.

* `ItemPropertyChangeListener` добавляется с помощью метода `Datasource.addItemPropertyChangeListener()`. Слушатель вызывается, если изменилось значение какого-либо атрибута сущности, находящейся в данный момент в источнике. Через объект события можно получить сам измененный экземпляр, имя измененного атрибута, старое и новое значение.
+
Слушатель `ItemPropertyChangeListener` можно использовать для действий в ответ на изменение пользователем сущности из UI, то есть редактирования полей ввода.

* `ItemChangeListener` добавляется с помощью метода `Datasource.addItemChangeListener()`. Он вызывается при смене выбранного экземпляра, возвращаемого методом `getItem()`.
+
Для `Datasource` это происходит при установке другого экземпляра (или `null`) методом `setItem()`.
+
Для `CollectionDatasource` данный слушатель вызывается, когда в связанном визуальном компоненте меняется выделенный элемент. Например, это может быть выделенная строка таблицы, элемент дерева, или выделенный элемент выпадающего списка.

* `StateChangeListener` добавляется с помощью метода `Datasource.addStateChangeListener()`. Он вызывается при изменении состояния источника данных. Источник данных может находиться в одном из трех состояний, соответствующих перечислению `Datasource.State`:
+
--
** `++NOT_INITIALIZED++` - источник только что создан.

** `INVALID` - создан весь `<<dsContext,DsContext>>`, к которому относится данный источник.

** `VALID` - источник данных в рабочем состоянии: `Datasource` содержит экземпляр сущности или `null`, `CollectionDatasource` - коллекцию экземпляров или пустую коллекцию.
+
Получение оповещения об изменении состояния источника может быть актуально для сложных <<screen_edit,редакторов>>, состоящих из нескольких <<frame,фреймов>>, где сложно отследить момент проставления редактируемой сущности в источник. В этом случае можно использовать слушатель `StateChangeListener` для отложенной инициализации некоторых элементов экрана:
+
[source, java]
----
include::{sourcesdir}/gui/datasources_17.java[]
----
--

* `CollectionChangeListener` добавляется с помощью метода `CollectionDatasource.addCollectionChangeListener()`. Слушатель вызывается при изменении коллекции сущностей, хранящейся в источнике данных. Объект события имеет метод `getOperation()`, возвращающий значение типа `CollectionDatasource.Operation`: `REFRESH`, `CLEAR`, `ADD`, `REMOVE`, `UPDATE`. Этот тип указывает операцию, которая привела к изменению коллекции.

[[dsContext]]
===== DsContext

Все созданные декларативно источники данных регистрируются в объекте `DsContext` экрана. Ссылку на `DsContext` можно получить методом `getDsContext()` контроллера экрана, либо инжекцией в поле класса.

`DsContext` решает следующие задачи:

. Позволяет организовать зависимости между источниками данных, когда при навигации по одному источнику (т.е. при изменении "текущего" экземпляра методом `setItem()`) обновляется связанный источник. Такие зависимости дают возможность в экранах легко организовывать master-detail связи между визуальными компонентами.
+
Зависимости между источниками организуются с помощью <<datasource_query,параметров запросов>> с префиксом `ds$`.

. Позволяет собрать все измененные экземпляры сущностей и отправить их на *Middleware* в одном вызове `DataManager.commit()`, т.е. сохранить в базе данных в одной транзакции. 
+
В качестве примера предположим, что некоторый экран позволяет редактировать экземпляр сущности `Order` и коллекцию принадлежащих ему экземпляров `OrderLine`. Экземпляр `Order` находится в `Datasource`, коллекция `OrderLine` - во вложенном `CollectionDatasource`, созданном по атрибуту `Order.lines`. Допустим, пользователь изменил какой-то атрибут `Order` и создал новый экземпляр `OrderLine`. Тогда при коммите экрана в <<dataManager,DataManager>> будут одновременно отправлены два экземпляра - измененный `Order` и новый `OrderLine`. Далее, они вместе попадут в один <<entityManager,персистентный контекст>> и при коммите транзакции сохранятся в БД. Разумеется, экземпляр `OrderLine` содержится также в коллекции `Order.lines`, но если не передавать его в персистентный контекст независимо, то потребуется установка каскадности сохранения между `Order` и `OrderLines` на уровне ORM. Жесткие отношения каскадности на уровне ORM иногда вызывают нежелательные последствия в неожиданных местах, поэтому лучше их избегать, что и обеспечивает описываемый механизм `DsContext`.
+
В результате коммита `DsContext` получает от *Middleware* набор сохраненных экземпляров (в случае оптимистической блокировки у них, как минимум, увеличено значение атрибута `version`), и устанавливает эти экземпляры в источниках данных взамен устаревших. Это позволяет сразу после коммита работать со свежими экземплярами без необходимости лишнего обновления источников данных, связанного с запросами к *Middleware* и базе данных.

. Объявляет два слушателя: `BeforeCommitListener` и `AfterCommitListener`, позволяющие получать оповещения перед коммитом измененных экземпляров и после него. Перед коммитом можно дополнить коллекцию отправляемых в <<dataManager,DataManager>> на Middleware экземпляров, тем самым обеспечив сохранение в той же транзакции произвольных сущностей. После коммита можно получить коллекцию вернувшихся из `DataManager` сохраненных экземпляров.
+
Данный механизм необходим, если некоторые сущности, с которыми работает экран, находятся не под управлением источников данных, а создаются и изменяются непосредственно в коде контроллера. Например, визуальный компонент `<<gui_FileUploadField,FileUploadField>>` после загрузки файла создает новый экземпляр сущности `FileDescriptor`, который можно сохранить вместе с другими сущностями экрана именно таким способом - добавив в `CommitContext` в слушателе `BeforeCommitListener`.
+
В следующем примере новый экземпляр `Customer` будет отправлен на *Middleware* и сохранен в БД вместе с остальными измененными сущностями экрана при его коммите:
+
[source, java]
----
include::{sourcesdir}/gui/dscontext_1.java[]
----

[[dataSupplier]]
===== DataSupplier

`DataSupplier` - интерфейс, через который источники данных обращаются к Middleware для загрузки и сохранения сущностей. Его стандартная реализация просто делегирует выполнение <<dataManager,DataManager>>. Экран может задать свою реализацию интерфейса `DataSupplier` в атрибуте `dataSupplier` элемента `window`. Собственная реализация может, например, вызывать дополнительный блок Middleware для загрузки данных экрана из другой базы данных.

Ссылку на `DataSupplier` можно получить либо <<screen_controller_injection,инжекцией>> в контроллер экрана, либо через экземпляры `DsContext` или `Datasource`. В обоих случаях возвращается или стандартная, или собственная реализация интерфейса (если таковая определена).

[[gui_Action]]
==== Действия. Интерфейс Action

`Action` − интерфейс, абстрагирующий действие (другими словами, некоторую функцию) от визуального компонента. Он особенно полезен в случаях, когда одно и то же действие может быть вызвано из разных визуальных компонентов. Кроме того, данный интерфейс позволяет снабдить действие дополнительными свойствами, такими как название, признаки доступности и видимости, и другими.

Рассмотрим методы интерфейса `Action`:

* `actionPerform()` - вызывается визуальным компонентом, связанным с данным действием. В метод передается экземпляр вызвавшего компонента.

* `getId()` - возвращает идентификатор данного действия. Идентификатор обычно устанавливается конструктором класса, реализующего `Action`, и не меняется на протяжении жизни созданного объекта действия.

* методы получения и установки свойств `caption`, `description`, `shortcut`, `icon`, `enabled`, `visible`. Все эти свойства обычно используется связанными визуальными компонентами для установки собственных одноименных свойств.

* `addPropertyChangeListener()`, `removePropertyChangeListener()` - подключение слушателей, реагирующих на изменение вышеупомянутых свойств. Слушатель получает уведомление типа `java.beans.PropertyChangeEvent`, в котором содержится имя измененного свойства, его старое и новое значение.

* `refreshState()` - метод, который может быть реализован в конкретном классе действия для инициализации вышеупомянутых свойств в соответствии с какими-либо внешними факторами, например правами пользователя. Вызывается обычно в конструкторах имплементирующих классов или из связанных визуальных компонентов.

* `addOwner()`, `removeOwner()`, `getOwner()`, `getOwners()` - методы для управления связью действия с визуальными компонентами.

Для реализации действий рекомендуется использовать <<declarative_actions,декларативное создание>> действий, либо наследоваться от класса <<baseAction,AbstractAction>>. Кроме того, существует набор <<standard_actions,стандартных действий>>, применимых для работы с таблицами и компонентами выбора. От стандартных действий также можно наследоваться для модификации их поведения или перехвата событий.

Визуальные компоненты, связанные с действием, могут быть двух типов:

* Визуальный компонент, содержащий одно действие, реализует интерфейс `Component.ActionOwner`. Это <<gui_Button,Button>> и <<gui_LinkButton,LinkButton>>.
+
Связь компонента с действием осуществляется путем вызова метода `ActionOwner.setAction()` компонента. В этот момент компонент заменяет свои свойства на соответствующие свойства действия (подробнее см. описание компонентов). 

* Визуальный компонент, содержащий несколько действий, реализует интерфейс `Component.ActionsHolder`. Это `Window`, `Frame`, <<gui_Table,Table>> и ее наследники, <<gui_Tree,Tree>>, <<gui_PopupButton,PopupButton>>, <<gui_PickerField,PickerField>>, <<gui_LookupPickerField,LookupPickerField>>.
+
Действия добавляются компоненту вызовом метода `ActionsHolder.addAction()`. Реализация этого метода в компоненте проверяет, нет ли уже в нем действия с таким же идентификатором. Если есть, то имеющееся действие будет заменено на новое переданное. Поэтому можно, например, декларировать стандартное действие в дескрипторе экрана, а затем в контроллере создать новое с переопределенными методами и добавить компоненту.

[[declarative_actions]]
===== Декларативное создание действий

В XML-дескрипторе экрана для любого компонента, реализующего интерфейс `Component.ActionsHolder`, в том числе для всего экрана или фрейма, может быть задан набор <<gui_Action,действий>>. Делается это в элементе `actions`, который содержит вложенные элементы `action`.

Элемент `action` может иметь следующие атрибуты:

* `id` − идентификатор, должен быть уникален в рамках данного компонента `ActionsHolder`.

* `caption` - название действия.

* `description` - описание действия.

* `enable` - признак доступности действия (`true` / `false`).

* `icon` - значок действия.

* `invoke` - имя вызываемого метода контроллера. Метод должен быть `public`, не возвращать результата и либо не иметь аргументов, либо иметь один аргумент типа `Component`. Если метод имеет аргумент `Component`, то при вызове в него будет передан экземпляр визуального компонента, запустившего данное действие.

* `shortcut` - комбинация клавиш для вызова. Возможные модификаторы - `ALT`, `CTRL`, `SHIFT` - отделяются символом "-". Например: *ALT-CTRL-C*.

* `visible` - признак видимости действия (`true` / `false`).

Рассмотрим примеры декларативного объявления действий.

* Объявление действий на уровне экрана:
+
[source, xml]
----
<window ...>
  <dsContext/>

  <actions>
      <action id="sayHelloAction" caption="msg://sayHello" shortcut="ALT-T" invoke="sayHello"/>
  </actions>

  <layout>
      <button action="sayHelloAction"/>
  </layout>
</window>
----
+
[source, java]
----
// controller

public void sayHello(Component component) {
  showNotification("Hello!", NotificationType.TRAY);
}
----

Здесь объявляется действие с идентификатором `sayHelloAction` и названием из <<message_packs,пакета сообщений>>. С этим действием связывается кнопка, заголовок которой будет установлен в название действия. Действие вызовет метод `sayHello()` контроллера при нажатии на кнопку, а также при нажатии комбинации клавиш *ALT-T*, если в данный момент экран принимает фокус ввода.

* Объявление действий для <<gui_PopupButton,PopupButton>>:
+
[source, xml]
----
<popupButton caption="Say something">
 <actions>
    <action id="helloAction" caption="Say hello" invoke="sayHello"/>
    <action id="goodbyeAction" caption="Say goodbye" invoke="sayGoodbye"/>
 </actions>
</popupButton>
----

* Объявление действий для <<gui_Table,Table>>:
+
[source, xml]
----
<table id="usersTable" width="100%">
  <actions>
      <action id="create"/>
      <action id="edit"/>
      <action id="copy" caption="msg://copy" icon="icons/copy.png"
              invoke="copy" trackSelection="true"/>
      <action id="changePassw" caption="msg://changePassw" icon="icons/change-pass.png"
              invoke="changePassword" trackSelection="true"/>
  </actions>
  <buttonsPanel>
      <button action="usersTable.create"/>
      <button action="usersTable.edit"/>
      <button action="usersTable.copy"/>
      <button action="usersTable.changePassw"/>
  </buttonsPanel>
  <rowsCount/>
  <columns>
      <column id="login"/>
      ...
  </columns>
  <rows datasource="usersDs"/>
</table>
----

Здесь помимо <<standard_actions,стандартных действий>> таблицы `create` и `edit` объявлены действия `copy` и `changePassw`, вызывающие соответствующие методы контроллера. Для этих действий указан также атрибут `trackSelection="true"`, в результате чего действие и связанная с ним кнопка становятся недоступными, если в таблице не выбрана ни одна строка. Это удобно, если действие предназначено для выполнения над текущей выбранной строкой таблицы. 

Для действий `create` и `edit` можно указать дополнительный атрибут `openType` для указания режима открытия экрана редактирования, как описано для метода `setOpenType()` класса <<createAction,CreateAction>>.

* Объявление действий для <<gui_PickerField,PickerField>>:
+
[source, xml]
----
<pickerField id="colourField" datasource="carDs" property="colour"/>
  <actions>
      <action id="lookup"/>
      <action id="show" icon="icons/show.png"
              invoke="showColour" caption="" description="Show colour"/>
  </actions>
</pickerField>
----

В данном примере для компонента `PickerField` объявлено <<standard_actions,стандартное действие>> `lookup` и действие `show`, вызывающее метод `showColour()` контроллера. Так как в кнопках `PickerField`, отображающих действия, используются значки, а не надписи, атрибут `caption` явно установлен в пустую строку, иначе названием действия и заголовком кнопки стал бы идентификатор действия. Атрибут `description` позволяет отображать всплывающую подсказку при наведении мыши на кнопку действия.

Ссылки на любые декларативно объявленные действия можно получить в контроллере экрана либо непосредственно путем <<screen_controller_injection,инжекции>>, либо из компонентов, реализующих интерфейс `Component.ActionsHolder`. Это может понадобиться для программной установки свойств действия. Например:

[source, java]
----
@Named("carsTable.create")
private CreateAction createAction;

@Named("carsTable.copy")
private Action copyAction;

@Inject
private PickerField colourField;

@Override
public void init(Map<String, Object> params) {
  Map<String, Object> values = new HashMap<>();
  values.put("type", CarType.PASSENGER);
  createAction.setInitialValues(values);

  copyAction.setEnabled(false);

  Action showAction = colourField.getAction("show");
  showAction.setEnabled(false);
}
----

[[standard_actions]]
===== Стандартные действия

Стандартные <<gui_Action,действия>> - это классы, имплементирующие интерфейс `Action`, и предназначенные для решения типовых задач, таких как вызов экрана редактирования для сущности, выбранной в таблице. Стандартные действия имеют строго определенные идентификаторы, поэтому для декларативного объявления некоторого стандартного действия достаточно указать его идентификатор. 

Существует два вида стандартных действий:

* <<list_actions,Действия с коллекцией>> сущностей, отображаемой в таблице или дереве.

* <<picker_actions,Действия поля выбора>> экземпляра сущности.

[[list_actions]]
====== Стандартные действия с коллекцией

Для наследников `ListComponent` (это <<gui_Table,Table>>, <<gui_GroupTable,GroupTable>>, <<gui_TreeTable,TreeTable>> и <<gui_Tree,Tree>>) набор стандартных действий определен в перечислении `ListActionType`, классы их реализации находятся в пакете `com.haulmont.cuba.gui.components.actions`. 

Пример использования стандартных действий в таблице: 

[source, xml]
----
include::{sourcesdir}/gui/listActions_1.xml[]
----

Рассмотрим их подробнее.

[[createAction]]
*CreateAction*

`CreateAction` - действие с идентификатором *create*. Предназначено для создания нового экземпляра сущности и открытия экрана редактирования для этого экземпляра. Если экран редактирования успешно закоммитил новый экземпляр в базу данных, то `CreateAction` добавляет этот новый экземпляр в источник данных таблицы и делает его выбранным.

В классе `CreateAction` определены следующие специфические методы: 

* `setOpenType()` - позволяет задать режим открытия экрана редактирования новой сущности. По умолчанию экран открывается в режиме `++THIS_TAB++`. 
+
Так как довольно часто требуется открывать экраны редактирования в другом режиме (как правило, `DIALOG`), при декларативном создании действия `create` в элементе `action` можно указать атрибут `openType` с нужным значением. Это избавляет от необходимости получать ссылку на действие в контроллере и программно устанавливать данное свойство. Например: 
+
[source, xml]
----
include::{sourcesdir}/gui/createAction_1.xml[]
---- 

* `setWindowId()` - позволяет задать идентификатор экрана редактирования сущности. По умолчанию используется экран `++{имя_сущности}.edit++`, например `sales$Customer.edit`.

* `setWindowParams()` - позволяет задать параметры экрана редактирования, передаваемые в его метод `init()`.

* `setInitialValues()` - позволяет задать начальные значения атрибутов создаваемой сущности. Принимает объект `Map`, в котором ключами являются имена атрибутов, а значениями - значения атрибутов. Например: 
+
[source, java]
----
include::{sourcesdir}/gui/createAction_2.java[]
---- 
+
Пример использования `setInitialValues()` приведен также в разделе <<init_values_in_CreateAction,рецептов разработки>>.

* `afterCommit()` - вызывается действием после того, как экран редактирования успешно закоммитил новую сущность и был закрыт. Данный метод не имеет реализации и может быть переопределен в наследниках для реакции на это событие. 

* `setAfterCommitHandler()` - позволяет задать обработчик, который будет вызван после того, как экран редактирования успешно закоммитил новую сущность и был закрыт. Данный обработчик можно использовать вместо переопределения метода `afterCommit()`, тем самым избавившись от необходимости создания наследника действия. Например: 
+
[source, java]
----
include::{sourcesdir}/gui/createAction_3.java[]
---- 

* `afterWindowClosed()` - вызывается действием в последнюю очередь после закрытия экрана редактирования, независимо от того, была ли закоммичена новая сущность или нет. Данный метод не имеет реализации и может быть переопределен в наследниках для реакции на это событие. 

* `setAfterWindowClosedHandler()` - позволяет задать обработчик, который будет вызван после закрытия экрана редактирования, независимо от того, была ли закоммичена новая сущность или нет. Данный обработчик можно использовать вместо переопределения метода `afterWindowClosed()`, тем самым избавившись от необходимости создания наследника действия.  

[[editAction]]
*EditAction*

`EditAction` - действие с идентификатором *edit*. Открывает экран редактирования для выбранного экземпляра сущности. Если экран редактирования успешно закоммитил экземпляр в базу данных, то `EditAction` обновляет этот экземпляр в источнике данных таблицы.

В классе `EditAction` определены следующие специфические методы:

* `setOpenType()` - позволяет задать режим открытия экрана редактирования сущности. По умолчанию экран открывается в режиме `++THIS_TAB++`. 
+
Так как довольно часто требуется открывать экраны редактирования в другом режиме (как правило, `DIALOG`), при декларативном создании действия `edit` в элементе `action` можно указать атрибут `openType` с нужным значением. Это избавляет от необходимости получать ссылку на действие в контроллере и программно устанавливать данное свойство. Например: 
+
[source, xml]
----
include::{sourcesdir}/gui/editAction_1.xml[]
---- 

* `setWindowId()` - позволяет задать идентификатор экрана редактирования сущности. По умолчанию используется экран `++{имя_сущности}.edit++`, например `sales$Customer.edit`.

* `setWindowParams()` - позволяет задать параметры экрана редактирования, передаваемые в его метод `init()`.

* `afterCommit()` - вызывается действием после того, как экран редактирования успешно закоммитил сущность и был закрыт. Данный метод не имеет реализации и может быть переопределен в наследниках для реакции на это событие. 

* `setAfterCommitHandler()` - позволяет задать обработчик, который будет вызван после того, как экран редактирования успешно закоммитил новую сущность и был закрыт. Данный обработчик можно использовать вместо переопределения метода `afterCommit()`, тем самым избавившись от необходимости создания наследника действия. Например: 
+
[source, java]
----
include::{sourcesdir}/gui/editAction_2.java[]
---- 

* `afterWindowClosed()` - вызывается действием в последнюю очередь после закрытия экрана редактирования, независимо от того, была ли закоммичена редактируемая сущность. Данный метод не имеет реализации и может быть переопределен в наследниках для реакции на это событие. 

* `setAfterWindowClosedHandler()` - позволяет задать обработчик, который будет вызван после закрытия экрана редактирования, независимо от того, была ли закоммичена новая сущность или нет. Данный обработчик можно использовать вместо переопределения метода `afterWindowClosed()`, тем самым избавившись от необходимости создания наследника действия.  

[[removeAction]]
*RemoveAction*

`RemoveAction` - действие с идентификатором *remove*. Предназначено для удаления выбранного экземпляра сущности.

В классе `RemoveAction` определены следующие специфические методы:

* `setAutocommit()` - позволяет управлять моментом удаления сущности из базы данных. По умолчанию после срабатывания действия и удаления сущности из источника данных у источника вызывается метод `commit()`, в результате чего сущность удаляется из базы данных. Cвойство `autocommit` можно установить в `false` либо методом `setAutocommit()`, либо соответствующим параметром конструктора. В результате после удаления сущности из источника данных для подтверждения удаления потребуется явно вызвать метод `commit()` источника данных.
+
Значение `autocommit` не влияет на работу источников данных в режиме `Datasource.CommitMode.PARENT`, то есть тех, которые обеспечивают редактирование <<composition_annotation,композиционных>> сущностей.

* `setConfirmationMessage()` - позволяет задать текст сообщения в диалоге подтверждения удаления. 

* `setConfirmationTitle()` - позволяет задать заголовок диалога подтверждения удаления.

*  `afterRemove()` - вызывается действием после успешного удаления сущности. Данный метод не имеет реализации и может быть переопределен в наследниках для реакции на это событие. 

* `setAfterRemoveHandler()` позволяет задать обработчик, который будет вызван после успешного удаления сущности. Данный обработчик можно использовать вместо переопределения метода `afterWindowClosed()`, тем самым избавившись от необходимости создания наследника действия. Например: 
+
[source, java]
----
include::{sourcesdir}/gui/removeAction_1.java[]
----  

[[refreshAction]]
*RefreshAction*

`RefreshAction` - действие с идентификатором *refresh*. Предназначено для обновления (перезагрузки) коллекции сущностей. При срабатывании вызывает метод `refresh()` <<datasources,источника данных>>, с которым связан компонент.

В классе `RefreshAction` определены следующие специфические методы:

* `setRefreshParams()` - позволяет задать параметры, передаваемые в метод `CollectionDatasource.refresh()`, для использования внутри <<datasource_query,запроса>>. По умолчанию никакие параметры не передаются. 

[[addAction]]
*AddAction*

`AddAction` - действие с идентификатором *add*. Предназначено для выбора существующего экземпляра сущности и добавления его в коллекцию. При срабатывании открывает <<screen_lookup,экран выбора>> сущностей.

В классе `AddAction` определены следующие специфические методы:

* `setOpenType()` - позволяет задать режим открытия экрана выбора сущности. По умолчанию экран открывается в режиме `++THIS_TAB++`. 
+
Так как довольно часто требуется открывать экраны выбора в другом режиме (как правило, `DIALOG`), при декларативном создании действия `add` в элементе `action` можно указать атрибут `openType` с нужным значением. Это избавляет от необходимости получать ссылку на действие в контроллере и программно устанавливать данное свойство. Например:
+
[source, xml]
----
<table id="usersTable">
<actions>
  <action id="add" openType="DIALOG"/>
----

* `setWindowId()` - позволяет задать идентификатор экрана выбора сущности. По умолчанию используется экран `++{имя_сущности}.lookup++`, например `sales$Customer.lookup`. Если такого экрана не существует, то делается попытка открыть экран `++{имя_сущности}.browse++`, например `sales$Customer.browse`.

* `setWindowParams()` - позволяет задать параметры экрана выбора, передаваемые в его метод `init()`.

* `setHandler()` - позволяет задать объект, реализующий интерфейс `Window.Lookup.Handler`, передаваемый в экран выбора. По умолчанию используется объект класса `AddAction.DefaultHandler`.

[[excludeAction]]
*ExcludeAction*

`ExcludeAction` - действие с идентификатором *exclude*. Позволяет исключать экземпляры сущности из коллекции, не удаляя их из базы данных. Класс данного действия является наследником `RemoveAction`, однако при срабатывании вызывает у `CollectionDatasource` не `removeItem()`, а `excludeItem()`. Кроме того, для вложенных источников данных `ExcludeAction` разрывает связь с родительской сущностью, поэтому с помощью данного действия можно организовать редактирование ассоциации one-to-many. 

В классе `ExcludeAction` в дополнение к `RemoveAction` определены следующие специфические методы:

* `setConfirm()` - показывать ли диалог подтверждения удаления. Это свойство можно также установить через конструктор действия. По умолчанию установлено в `false`.

[[excelAction]]
*ExcelAction*

`ExcelAction` - действие с идентификатором *excel*. Предназначено для экспорта данных таблицы в формат XLS и выгрузки соответствующего файла. Данное действие можно связать только с компонентами <<gui_Table,Table>>, <<gui_GroupTable,GroupTable>> и <<gui_TreeTable,TreeTable>>.

При программном создании действия можно задать следующие параметры конструктора:

* `display` - реализация интерфейса `ExportDisplay` для выгрузки файла. По умолчанию используется стандартная реализация.

* `parameterized` - при установке в `true` действие отображает специальное окно с идентификатором `excelExport`, позволяющее пользователю выбрать колонки таблицы для экспорта. 

[[picker_actions]]
====== Стандартные действия поля выбора

Для компонентов <<gui_PickerField,PickerField>>, <<gui_LookupPickerField,LookupPickerField>> и <<gui_SearchPickerField,SearchPickerField>> набор стандартных действий определен в перечислении `PickerField.ActionType`. Реализации являются внутренними классами интерфейса `PickerField`.

Пример использования стандартных действий в компоненте выбора: 

[source, xml]
----
include::{sourcesdir}/gui/pickerActions_1.xml[]
---- 

[[lookupAction]]
*LookupAction*

`LookupAction` - действие с идентификатором *lookup*. Предназначено для выбора экземпляра сущности и установки его в качестве значения компонента. При срабатывании открывает <<screen_lookup,экран выбора>> сущностей.

В классе `LookupAction` определены следующие специфические методы:

* `setLookupScreenOpenType()` - позволяет задать режим открытия экрана выбора сущности. По умолчанию экран открывается в режиме `++THIS_TAB++`. 

* `setLookupScreen()` - позволяет задать идентификатор экрана выбора сущности. По умолчанию используется экран `++{имя_сущности}.lookup++`, например `sales$Customer.lookup`. Если такого экрана не существует, то делается попытка открыть экран `++{имя_сущности}.browse++`, например `sales$Customer.browse`.

* `setLookupScreenParams()` - позволяет задать параметры экрана выбора, передаваемые в его метод `init()`.

* `afterSelect()` - вызывается действием после того, как выбранный экземпляр установлен в качестве значения компонента. Данный метод не имеет реализации и может быть переопределен в наследниках для реакции на это событие. 

* `afterCloseLookup()` - вызывается действием в последнюю очередь после закрытия экрана выбора, независимо от того, был сделан выбор или нет. Данный метод не имеет реализации и может быть переопределен в наследниках для реакции на это событие.  

[[clearAction]]
*ClearAction*

`ClearAction` - действие с идентификатором *clear*. Предназначено для очистки (то есть установки в `null`) текущего значения компонента. 

[[openAction]]
*OpenAction*

`OpenAction` - действие с идентификатором *open*. Предназначено для открытия экрана редактирования экземпляра сущности, являющегося текущим значением компонента. 

В классе `OpenAction` определены следующие специфические методы:

* `setEditScreenOpenType()` - позволяет задать режим открытия экрана редактирования сущности. По умолчанию экран открывается в режиме `++THIS_TAB++`. 

* `setEditScreen()` - позволяет задать идентификатор экрана редактирования сущности. По умолчанию используется экран `++{имя_сущности}.edit++`, например `sales$Customer.edit`.

* `setEditScreenParams()` - позволяет задать параметры экрана редактирования, передаваемые в его метод `init()`.

* `afterWindowClosed()` - вызывается действием после закрытия экрана редактирования. Данный метод не имеет реализации и может быть переопределен в наследниках для реакции на это событие. 

[[baseAction]]
===== BaseAction

`BaseAction` - базовый класс реализации <<gui_Action,действий>>. От него рекомендуется наследовать собственные нестандартные действия, если возможностей <<declarative_actions,декларативного создания действий>> не хватает. 

При создании конкретного класса действия необходимо определить метод `actionPerform()` и передать в конструктор `BaseAction` идентификатор действия. Можно также переопределить любые методы получения свойств действия: `getCaption()`, `getDescription()`, `getIcon()`, `getShortcut()`, `isEnabled()`, `isVisible()`. Стандартные реализации этих методов возвращают значения, установленные соответствующими set-методами. Исключение составляет метод `getCaption()`: если название действия явно не установлено методом `setCaption()`, то он обращается в <<message_packs,пакет локализованных сообщений>> с именем, соответствующим пакету класса действия, и возвращает сообщение с ключом, равным идентификатору действия. Если сообщения с таким ключом нет, то возвращается сам ключ, то есть идентификатор действия. 

`BaseAction` может изменять свои свойства `enabled` и `visible` в соответствии с <<permissions,разрешениями>> пользователя и текущим контекстом.

`BaseAction` видим (visible), если: 

* метод `setVisible(false)` не вызывался;

* для действия не установлено UI разрешение `hide`.

Действие разрешено (enabled), если: 

* метод `setEnabled(false)` не вызывался;

* для действия не установлено UI разрешений `hide` или `read-only`;

* метод `isPermitted()` возвращает true;

* метод `isApplicable()` возвращает true. 

Примеры использования:

* Действие кнопки: 
+
[source, java]
----
include::{sourcesdir}/gui/baseAction_1.java[]
----
+
В данном случае кнопка `helloBtn` получит в качестве заголовка строку, находящуюся в пакете сообщений с ключом `hello`. Для того, чтобы получить название кнопки каким-либо иным способом, можно переопределить метод `getCaption()` действия.

* Действие кнопки программно создаваемого <<gui_PickerField,PickerField>>:
+
[source, java]
----
include::{sourcesdir}/gui/baseAction_2.java[]
----
+
Здесь анонимный класс-наследник `BaseAction` используется для задания действия кнопки поля выбора. Заголовок кнопки не отображается, вместо него используется значок и описание, всплывающее при наведении курсора мыши.

* Действие таблицы:
+
[source, java]
----
include::{sourcesdir}/gui/baseAction_3.java[]
----
+
Здесь объявлен класс `HelloAction`, экземпляр которого добавляется в список действий таблицы. Действие разрешено пользователям, имеющим специфическое разрешение `*myapp.allow-greeting*`, и только когда выбрана одна строка таблицы. Последнее условие реализуется с помощью свойства `target` действия, которое автоматически устанавливается когда действие добавляется в `ListComponent` (`Table` или `Tree`).

* Если необходимо действие, которое доступно, когда выделены одна или более строк таблицы, удобно воспользоваться наследником `BaseAction` - классом `ItemTrackingAction`, который добавляет стандартную реализацию метода `isApplicable()`: 
+
[source, java]
----
include::{sourcesdir}/gui/baseAction_4.java[]
----

[[dialogs_and_notifications]]
==== Диалоговые окна и уведомления

Для вывода сообщений пользователю можно использовать диалоговые окна и уведомления. 

Диалоговые окна имеют заголовок с кнопкой закрытия и отображаются всегда в центре главного окна приложения. Уведомления могут отображаться как в центре, так и в углу приложения, и автоматически исчезать.

[[dialogs]]
===== Диалоговые окна

Диалоговые окна вызываются методами `showMessageDialog()` и `showOptionDialog()` интерфейса `Frame`. Этот интерфейс реализуется <<screen_controller,контроллером экрана>>, поэтому данные методы можно вызывать напрямую в коде контроллера.

* `showMessageDialog()` предназначен для отображения сообщения. Метод принимает следующие параметры:

** `title` - заголовок диалогового окна.

** `message` - сообщение. В случае HTML-типа (см. ниже) в сообщении можно использовать теги HTML для форматирования. При использовании HTML обязательно экранируйте данных из БД во избежание code injection в веб-клиенте. В не-HTML сообщениях можно использовать символы `\n` для переноса строки. 

** `messageType` - тип сообщения. Возможные типы:

*** `CONFIRMATION`, `++CONFIRMATION_HTML++` - диалог подтверждения. 

*** `WARNING`, `++WARNING_HTML++` - диалог преупреждения.
+
Различие типов сообщений отражается только в пользовательском интерфейсе десктоп-приложений.

Пример вызова диалога:

[source, java]
----
include::{sourcesdir}/gui/dialogs_1.java[]
----
--

* `showOptionDialog()` предназначен для отображения сообщения и кнопок для выбора пользователем. Метод в дополнение к параметрам, описанным для `showMessageDialog()`, принимает массив или список <<gui_Action,действий>>. Для каждого действия в диалоге создается кнопка, при нажатии на которую пользователем диалог закрывается и вызывается метод `actionPerform()` данного действия.
+
В качестве кнопок со стандартными названиями и значками удобно использовать анонимные классы, унаследованные от `DialogAction`. Поддерживаются пять видов действий, определяемых перечислением `DialogAction.Type`: `OK`, `CANCEL`, `YES`, `NO`, `CLOSE`. Названия соответствующих кнопок извлекаются из <<main_message_pack,главного пакета>> локализованных сообщений.
+
Пример вызова диалога с кнопками *Да* и *Нет* и с заголовком и сообщением, взятыми из пакета локализованных сообщений текущего экрана:
+
[source, java]
----
include::{sourcesdir}/gui/dialogs_2.java[]
----
+
Параметр `Status` конструктора `DialogAction` используется для определения визуального стиля кнопки, к которой привязано данное действие. Статус `Status.PRIMARY` подсвечивает кнопку и задаёт ей выделение по умолчанию. Параметр `Status` можно не использовать, в этом случае используется подсветка кнопок по умолчанию.
--

[[notifications]]
===== Уведомления

Уведомления вызываются методом `showNotification()` интерфейса `Frame`. Этот интерфейс реализуется <<screen_controller,контроллером экрана>>, поэтому данный метод можно вызывать напрямую в коде контроллера.

Метод `showNotification()` принимает следующие параметры:

* `caption` - текст уведомления. В случае HTML-типа (см. ниже) в сообщении можно использовать теги HTML для форматирования. При использовании HTML обязательно экранируйте данных из БД во избежание code injection в веб-клиенте. В не-HTML сообщениях можно использовать символы `\n` для переноса строки.

* `description` - опциональное описание, которое будет отображено ниже `caption`. Также можно использовать символы `\n` или HTML-форматирование.

* `type` - тип уведомления. Возможные типы:

** `TRAY`, `++TRAY_HTML++` - уведомление показывается в правом нижнем углу приложения и исчезает автоматически. 

** `HUMANIZED`, `++HUMANIZED_HTML++` - стадартное уведомление в центре экрана, исчезает автоматически.

** `WARNING`, `++WARNING_HTML++` - предупреждение. Исчезает при клике пользователя.

** `ERROR`, `++ERROR_HTML++` - уведомление об ошибке. Исчезает при клике пользователя.

Примеры вызова уведомлений:

[source, java]
----
showNotification(getMessage("selectBook.text"), NotificationType.HUMANIZED);

showNotification("Validation error", "<b>Date</b> is incorrect", NotificationType.TRAY_HTML);
----

[[background_tasks]]
==== Фоновые задачи

++++
<div class="manual-live-demo-container">
    <a href="https://demo.cuba-platform.com/sampler/open?screen=normal-progressbar" class="live-demo-btn" target="_blank">LIVE DEMO</a>
</div>
++++

Механизм фоновых задач предназначен для асинхронного выполнения длительных операций на клиентском уровне без заморозки пользовательского интерфейса.

Использование фоновых задач:

. Задача описывается как наследник абстрактного класса `BackgroundTask`. В конструктор задачи необходимо передать ссылку на контроллер экрана, с которым будет связана задача, и значение таймаута ее выполнения.
+
Если экран указан, то при его закрытии пользователем активная задача будет прервана. Кроме того, задача будет автоматически прервана по истечении указанного таймаута.
+
Собственно действия, выполняемые задачей, реализуются в методе `run()`.

. Создается объект управления задачей − `BackgroundTaskHandler`. Для этого экземпляр задачи необходимо передать методу `handle()` бина `BackgroundWorker`. Ссылку на `BackgroundWorker` можно получить инжекцией в <<screen_controller,контроллер экрана>>, либо статическим методом класса `AppBeans`.

. Выполняется запуск задачи.

Пример:

[source, java]
----
include::{sourcesdir}/gui/backgroundtasks_1.java[]
----

Подробная информация о назначении методов приведена в JavaDocs классов `BackgroundTask`, `TaskLifeCycle`, `BackgroundTaskHandler`. 

Ниже приведены моменты, на которые следует обратить внимание:

* `BackgroundTask<T, V>` − параметризованный класс:

** `T` − тип объектов, показывающих прогресс задачи. Объекты этого типа передаются в метод `progress()` задачи при вызове `TaskLifeCycle.publish()` в рабочем потоке.

** `V` − тип результата задачи, он передается в метод `done()`. Его также можно получить вызовом метода `BackgroundTaskHandler.getResult()`, что приведет к ожиданию завершения задачи.

* Метод `canceled()` вызывается только в случае управляемой отмены задачи, то есть при вызове `cancel()` у `TaskHandler`.

* Метод `handleTimeoutException()` вызывается при истечении таймаута задачи. Если окно, в котором выполняется задача, закрывается, то задача останавливается без оповещения.

* Метод `run()` задачи должен поддерживать возможность прерывания извне. Для этого в долгих процессах желательно периодически проверять флаг `TaskLifeCycle.isInterrupted()`, и соответственно завершать выполнение. Кроме того, нельзя тихо проглатывать исключение `InterruptedException` (или вообще все исключения). Вместо этого нужно либо вообще не перехватывать его, либо выполнять корректный выход из метода.

* Объекты `BackgroundTask` не имеют состояния. Если при реализации конкретного класса задачи не заводить полей для хранения промежуточных данных, то можно запускать несколько параллельно работающих процессов, используя единственный экземпляр задачи.

* Объект `BackgroundHandler` можно запускать (т.е. вызывать его метод `execute()`) всего один раз. Если требуется частый перезапуск задачи, то используйте класс `BackgroundTaskWrapper`.

* Для показа пользователю модального окна с прогрессом и кнопкой *Отмена* используйте классы `BackgroundWorkWindow` или `BackgroundWorkProgressWindow` с набором статических методов.Для окна можно задать режим отображения прогресса и разрешить или запретить отмену фоновой задачи.

* Если внутри потока задачи необходимо использовать некоторые значения визуальных компонентов, то нужно реализовать их получение в методе `getParams()`, который выполняется в потоке UI один раз при запуске задачи. В методе run() эти параметры будут доступны через метод `getParams()` объекта `TaskLifeCycle`.

* При возникновении исключительных ситуаций в потоке UI вызывается метод `BackgroundTask.handleException()`, в котором можно отобразить ошибку.

* На выполнение фоновых задач влияют свойства приложения <<cuba.backgroundWorker.maxActiveTasksCount,cuba.backgroundWorker.maxActiveTasksCount>> и <<cuba.backgroundWorker.timeoutCheckInterval,cuba.backgroundWorker.timeoutCheckInterval>>.

[WARNING]
====
В блоке Web Client фоновые задачи используют технологию HTTP push, предоставляемую фреймворком Vaadin. См. https://vaadin.com/wiki/-/wiki/Main/Working+around+push+issues для получения информации о настройке веб-серверов для использования данной технологии.
====

[TIP]
====
Если вы не используете фоновую задачу, но хотите изменять состояние UI-компонентов из не-UI потока, воспользуйтесь методами интерфейса `UIAccessor`. Получите ссылку на интерфейс `UIAccessor` методом `BackgroundWorker.getUIAccessor()` в UI-потоке, и после этого вы сможете вызывать его методы `access()` и `accessSynchronously()` из фонового потока для безопасного чтения и изменения состояния UI-компонентов.
====

[[gui_themes]]
==== Темы приложения

Тема служит для управления визуальным представлением приложения. 

[[web_theme]]
===== Тема в веб-приложениях

Тема веб-приложения состоит из файлов link:http://sass-lang.com[SCSS] и других ресурсов, в том числе файлов изображений.

[[web_theme_usage]]
====== Использование существующих тем

Платформа включает в себя две готовые темы: Halo и Havana. Приложение будет по умолчанию использовать ту из них, которая указана в свойстве приложения <<cuba.web.theme,cuba.web.theme>>. Пользователь может выбрать другую доступную тему в стандартном экране *Help* → *Settings*. Если вы не хотите, чтобы пользователи имели возможность сами выбирать тему, зарегистрируйте экран `settings` в файле <<screens.xml,web-screens.xml>> проекта с параметром `changeThemeEnabled = false`:

[source, xml]
----
include::{sourcesdir}/gui/themes_1.xml[]
----

[[web_theme_extension]]
====== Расширение существующей темы

Существующая в платформе тема может быть изменена в проекте приложения. В измененной теме можно сделать следующее:

* Изменить изображения для фирменного стиля.

* Добавить изображения для использования в визуальных компонентах.

* Создать новые стили и использовать их в атрибутах <<gui_attr_stylename,stylename>> визуальных компонентов. Для этого требуется знание CSS.

* Изменить существующие в платформе стили компонентов.

* Изменить общие параметры, такие как цвет фона, отступы, промежутки и т.д.

Тема описывается в файлах link:$$http://sass-lang.com$$[SCSS]. Для изменения (расширения) темы в проекте необходимо создать специальную файловую структуру в модуле *web*. Это удобно сделать с помощью *CUBA Studio*: откройте секцию *Project properties* и нажмите ссылку *Create theme extension*. В диалоговом окне выберите тему, которую вы хотите расширить. В результате в проекте будет создана следующая структура каталогов (для расширения темы Halo):

[source, plain]
----
themes/
  halo/
    branding/
      app-icon-login.png
      app-icon-menu.png
    favicon.ico
    halo-ext-defaults.scss
    halo-ext.scss
    styles.scss
----

Кроме того, скрипт сборки <<build.gradle,build.gradle>> будет дополнен задачей `buildScssThemes`, автоматически запускаемой при сборке модуля *web*. Опциональная задача <<build.gradle_deployThemes,deployThemes>> может быть использована для быстрого применения изменений в темах на работающем приложении.

Изменение фирменного стиля::
+
--
Можно настроить некоторые параметры фирменного стиля (branding): пиктограммы и заголовки окна логина и главного окна, пиктограмму вебсайта `favicon.ico`.

Для использования собственных изображений, замените соответствующие файлы в каталоге `modules/web/themes/halo/branding`.

Чтобы задать заголовки главного окна, окна логина и текст приглашения окна логина, в CUBA Studio откройте *Project properties* → *Edit* и нажмите кнопку *Branding* внизу страницы. Используйте соответствующие ссылки для задания заголовков окон и текста приглашения окна логина.

Данные параметры сохраняются в <<main_message_pack,главном пакете сообщений>> модуля *gui* (то есть в файле `modules/gui/<root_package>/gui/messages.properties` и его вариантах для разных локалей). Использование пакетов сообщений дает возможность использовать разные файлы изображений для разных локалей пользователей. Пример содержимого файла `messages.properties`:

[source, properties]
----
application.caption = MyApp
application.logoImage = branding/myapp-menu.png

loginWindow.caption = MyApp Login
loginWindow.welcomeLabel = Welcome to MyApp!
loginWindow.logoImage = branding/myapp-login.png
----

Путь к `favicon.ico` указывать не нужно, он должен обязательно находится в корне каталога с именем темы.
--

Добавление изображений::
+
--
В расширенную тему можно также добавить файлы изображений для использования в свойствах <<gui_attr_icon,icon>> <<gui_Action,действий>> и визуальных компонентов, например <<gui_Button,Button>>.

Например, чтобы добавить расширение темы Halo пиктограмму, достаточно в описанный выше каталог `modules/web/themes/halo` добавить файл изображения (желательно в некоторый подкаталог):

[source, plain]
----
themes/
  halo/
    images/
      address-book.png
----

После этого можно использовать эту пиктограмму, указывая в свойстве <<gui_attr_icon,icon>> путь к ней относительно каталога темы:

[source, xml]
----
include::{sourcesdir}/gui/themes_2.xml[]
----

Вместо файлов изображений для пиктограмм можно использовать элементы шрифта link:$$http://fortawesome.github.io/Font-Awesome$$[Font Awesome]. Для этого достаточно указать в свойстве `icon` имя нужной константы перечисления `com.vaadin.server.FontAwesome` с префиксом `font-icon:`, например:

[source, xml]
----
include::{sourcesdir}/gui/themes_3.xml[]
----
--

Создание новых стилей::
+
--
Рассмотрим пример установки желтого цвета фона для поля, отображающего название заказчика.

В XML-дескрипторе экрана определен компонент <<gui_FieldGroup,FieldGroup>>:

[source, xml]
----
include::{sourcesdir}/gui/themes_20.xml[]
----

Элементы `field` компонента `FieldGroup` не имеют атрибута <<gui_attr_stylename,stylename>>, поэтому необходимо задать имя стиля в контроллере:

[source, java]
----
include::{sourcesdir}/gui/themes_21.java[]
----

В файле `halo-ext.scss` добавьте определение нового стиля в mixin `halo-ext`:

[source, css]
----
include::{sourcesdir}/gui/themes_22.scss[]
----

После пересборки проекта поля будут выглядеть следующим образом:

image::gui_themes_fieldgroup_1.png[align="center"]
--

Изменение существующих стилей компонентов::
+
--
Для изменения параметров стиля существующих компонентов необходимо добавить соответствующий код CSS в mixin `halo-ext` файла `halo-ext.scss`. Например, для того, чтобы пункты главного меню отображались жирным шрифтом, содержимое файла `halo-ext.scss` должно быть следующим:

[source, css]
----
include::{sourcesdir}/gui/themes_6.scss[]
----
--

Изменение общих параметров::
+
--
Темы содержат переменные SCSS, которые управляют цветом фона, размерами компонентов, отступами и пр.

Рассмотрим пример расширения темы Halo, так как она основана на теме link:https://vaadin.com/valo[Valo] фреймворка *Vaadin*, и предоставляет максимальные возможности адаптации.

Файл `themes/halo/halo-ext-defaults.scss` предназначен для размещения в нем переменных темы. Большинство переменных Halo соответствует описанным в link:https://vaadin.com/api/valo[документации по Valo], ниже приведены основные:

[source, css]
----
include::{sourcesdir}/gui/themes_4.scss[]
----

Пример содержимого файла `halo-ext-defaults.scss` для темы с темным фоном и немного уменьшенными отступами:

[source, css]
----
include::{sourcesdir}/gui/themes_5.scss[]
----
--

Изменение заголовка приложения::
+
--
Тема Halo поддерживает свойство приложения <<cuba.web.useInverseHeader,cuba.web.useInverseHeader>>, управляющее цветом заголовка приложения. По умолчанию это свойство установлено в `true`, что задает темный (инверсный) заголовок. В проекте можно не изменяя темы сделать заголовок светлым, установив данное свойство в `false`.
--

[[web_theme_creation]]
====== Создание новой темы

В проекте можно создать одну или несколько новых тем и дать возможность пользователям выбирать среди них подходящую. Создание новой темы позволяет также переопределять переменные файла `*-theme.properties`, задающие некоторые параметры, требуемые на стороне сервера:

--
* Размеры диалоговых окон по умолчанию.

* Ширина полей ввода по умолчанию.

* Размеры некоторых компонентов (<<gui_Filter,Filter>>, <<gui_FileMultiUploadField,FileMultiUploadField>>).

* Соответствие между именами пиктограмм и именами констант перечисления `com.vaadin.server.FontAwesome` для использования элементов шрифта *Font Awesome* в стандартных действиях и экранах платформы при включенном свойстве <<cuba.web.useFontIcons,cuba.web.useFontIcons>>.
--

Создание новой темы::
+
--
Рассмотрим пример создания на основе Halo новой темы Facebook, напоминающей интерфейс сайта известной социальной сети.

. В *CUBA Studio* откройте секцию *Project properties* и нажмите ссылку *Create theme extension*. В диалоговом окне выберите `halo` и нажмите *Create*. В проекте будет создано расширение темы Halo, как описано в предыдущем разделе.

. Переименуйте созданный в модуле *web* каталог `themes/halo` в `themes/facebook`, внутри него файл `halo-ext.scss` переименуйте в `facebook.scss`, `halo-ext-defaults.scss` в `facebook-defaults.scss`:
+
[source, plain]
----
themes/
  facebook/
    branding/
    facebook.scss
    facebook-defaults.scss
    favicon.ico
    styles.scss
----

. Отредактируйте файл `styles.scss`:
+
[source, css]
----
include::{sourcesdir}/gui/themes_7.scss[]
----

. Отредактируйте файл `facebook.scss`:
+
[source, css]
----
include::{sourcesdir}/gui/themes_8.scss[]
----

. Поместите в файл `facebook-defaults.scss` следующие переменные:
+
[source, css]
----
include::{sourcesdir}/gui/themes_9.scss[]
----

. Создайте в подкаталоге `src` модуля *web* файл `facebook-theme.properties` со следующим содержимым:
+
[source, properties]
----
@include=halo-theme.properties
----
+
При необходимости в этом файле можно переопределять server-side переменные темы, заданные в файле `halo-theme.properties` платформы.

. В файл `web-app.properties` добавьте следующие свойства:
+
[source, properties]
----
cuba.web.theme = facebook
cuba.themeConfig = havana-theme.properties halo-theme.properties facebook-theme.properties
----

. Пересоберите приложение и запустите сервер. Теперь при первом входе пользователь увидит приложение в теме Facebook, и в окне *Help* → *Settings* сможет выбирать между темами *Facebook*, *Halo*, *Havana*.
--

Изменение server-side параметров темы::
+
--
В теме Halo по умолчанию (при включенном свойстве приложения <<cuba.web.useFontIcons,cuba.web.useFontIcons>>) пиктограммы стандартных действий и экранов платформы загружаются из шрифта *Font Awesome*. В этом случае можно заменить стандартную пиктограмму, задав в файле `<your_theme>-theme.properties` нужное соответствие между именем пиктограммы и именем элемента шрифта. Например, чтобы использовать занчок "плюс" для действия `create` в новой теме Facebook, содержимое файла `web/src/facebook-theme.properties` должно быть следующим:

[source, properties]
----
@include=halo-theme.properties

cuba.web.icons.create.png = PLUS
----

Фрагмент стандартного экрана списка пользователей в теме Facebook и с измененным значком действия `create`:

image::gui_theme_facebook_1.png[align="center"]
--

[[desktop_theme]]
===== Темы в десктоп-приложениях

В десктоп-приложениях базовой темой является тема `Nimbus`.

Для внесения изменения в стандартную тему нужно создать пакет `res.nimbus` в пакете `com.sample.sales.desktop` модуля *desktop*. В пакете `res.nimbus` будут храниться файлы темы.

image::gui_themes_desktop_structure.png[align="center"]

В папке `icons` хранятся файлы пиктограмм, в файле `nimbus.xml` − описание стиля темы.

В <<app_properties,файле свойств>> для десктоп-приложения нужно установить свойство `cuba.desktop.resourceLocations` (задает набор директорий, в которых расположены файлы стилей):

[source, properties]
----
cuba.desktop.resourceLocations = \
com/haulmont/cuba/desktop/res \
com/sample/sales/desktop/res
----

Ниже приведены примеры решения типовых задач.

Добавление пиктограмм::
+
--
Если в десктоп-приложении требуется добавить новую пиктограмму, например, для кнопки, нужно создать пакет `res.nimbus.icons` в пакете `com.sample.sales.desktop` модуля *desktop* и поместить в него требуемое изображение.

image::gui_themes_example4.png[align="center"]

Описываем <<gui_Button,кнопку>> в <<screen_xml_glossentry,дескрипторе>>, указывая в атрибуте <<gui_attr_icon,icon>> путь до пиктограммы:

[source, xml]
----
include::{sourcesdir}/gui/themes_10.xml[]
----

Ниже представлена кнопка с пиктограммой `attention.png`

image::gui_themes_example5.png[align="center"]
--

Переопределение значений свойств темы, установленных по умолчанию::
+
--
Рассмотрим на примере изменения цвета фона текстовых полей, обязательных для ввода.

В пакете `res.nimbus` нужно создать файл `nimbus.xml` следующего содержания:

[source, xml]
----
include::{sourcesdir}/gui/themes_11.xml[]
----

Элемент `ui-defaults` служит для переопределения значений свойств темы платформы, установленных по умолчанию.

В элементе `ui-defaults` присутствуют как свойства, содержащиеся в стандартной теме `Nimbus` (link:$$http://docs.oracle.com/javase/tutorial/uiswing/lookandfeel/_nimbusDefaults.html$$[http://docs.oracle.com/javase/tutorial/uiswing/lookandfeel/_nimbusDefaults.html]), так и свойства, созданные в платформе.

В данном примере переопределено значение свойства платформы `cubaRequiredBackground`, хранящего цвет фона поля, обязательного для заполнения. Данное изменение коснется всех полей, обязательных для ввода.Переопределение значений свойств темы, установленных по умолчанию.
--

Создание стиля для элемента с помощью стандартных средств::
+
--
Рассмотрим пример выделения надписи жирным цветом.

Для того чтобы создать такой стиль, необходимо определить элемент `style` в файле темы `nimbus.xml` следующим образом:

[source, xml]
----
include::{sourcesdir}/gui/themes_12.xml[]
----

Элемент `style` может содержать другие элементы, в которых можно определять те или иные свойства: `background`, `foreground`, `icon`.

В описании компонента надписи в <<screen_xml_glossentry,xml-дескрипторе>>, к которой нужно применить созданный стиль, нужно указать атрибут <<gui_attr_stylename,stylename>> с именем стиля:

[source, xml]
----
include::{sourcesdir}/gui/themes_13.xml[]
----

Таким образом, данный стиль будет применен только к тем надписям, для которых определен атрибут <<gui_attr_stylename,stylename>> со значением `boldlabel`.
--

Создание пользовательского стиля::
+
--
Если не хватает стандартных средств изменения стиля компонента, есть возможность создать пользовательский стиль. 

Создадим пользовательский стиль, который будет применяться для компонента <<gui_Button,Button>>. С помощью стиля надпись на кнопке будет отображаться подчеркнутой.

В первую очередь создадим класс-декоратор `UnderlinedLabelDecorator`:

[source, java]
----
include::{sourcesdir}/gui/themes_14.java[]
----

Определим пользовательский стиль в файле `nimbus.xml`:

[source, xml]
----
include::{sourcesdir}/gui/themes_15.xml[]
----

В атрибуте `component` элемента `style` содержится название компонента, к которому может быть применен стиль с названием `button-underlined`.

В элементе `custom` указывается путь до класса-декоратора, определенного ранее.

При создании XML-элемента кнопки, к которой нужно применить пользовательский стиль, нужно в атрибуте `stylename` указать название стиля:

[source, xml]
----
include::{sourcesdir}/gui/themes_16.xml[]
----

Кнопка с пользовательским стилем:

image::gui_themes_example6.png[align="center"]
--

[[gui_web]]
==== Специфика Web Client

Реализация универсального пользовательского интерфейса в <<app_tiers,блоке>> *Web Client* основана на фреймворке *Vaadin*. Рассмотрим основные классы, входящие в состав инфраструктуры веб клиента.

.Классы инфраструктуры Web Client
image::WebClientInfrastructure.png[align="center"]

* `App` - центральный класс инфраструктуры приложения. Позволяет получить ссылки на `Connection` и другие объекты инфраструктуры. Экземпляр `App` существует в единственном экземпляре для данной HTTP-сессии пользователя. Ссылку на `App` можно получить вызовом статического метода `App.getInstance()`.

* `Connection` - интерфейс, обеспечивающий функциональность подключения к среднему слою и хранящий пользовательскую сессию <<userSession,UserSession>>. Стандартной реализацией этого интерфейса является класс `DefaultConnection`.

* `ExceptionHandlers` - содержит коллекцию <<exceptionHandlers,обработчиков исключений клиентского уровня>>.

* `AppUI` - класс платформы, унаследованный от класса `com.vaadin.ui.UI`. Экземпляр данного класса соответствует одной открытой вкладке веб браузера. Содержит ссылку на реализацию интерфейса `TopLevelWindow` - это может быть либо окно логина, либо главное окно приложения, в зависимости от состояния подключения. Ссылку на `AppUI` можно получить вызовом статического метода `AppUI.getCurrent()`.

* `AppLoginWindow` - окно, отображаемое до логина пользователя. В конкретном приложении окно можно кастомизировать или создать новое с нуля, унаследовав класс от <<abstractWindow,AbstractWindow>> и реализовав маркерный интерфейс `TopLevelWindow`. В Studio это можно сделать, нажав *Create login window* в секции *Screens*.

* `AppMainWindow` - главное окно приложения, отображаемое после логина пользователя. В конкретном приложении окно можно кастомизировать или создать новое с нуля, унаследовав класс от `AbstractMainWindow` и определив нужную компоновку в XML-дескрипторе.
+
Без переопределения главного окна можно управлять некоторыми параметрами с помощью следующих свойств приложения:
+
--
** <<cuba.web.foldersPaneEnabled,cuba.web.foldersPaneEnabled>> - включает формирование <<folders_pane,панели папок>>.

** <<cuba.web.appWindowMode,cuba.web.appWindowMode>> - задает начальный режим главного окна: с вкладками или одноэкранный (`TABBED` или `SINGLE`). Пользователь впоследствии может задать желаемый режим через экран *Help* → *Settings*.

** <<cuba.web.maxTabCount,cuba.web.maxTabCount>> - в режиме представления главного окна с вкладками задает максимальное количество вкладок, которое может открыть пользователь. По умолчанию 7.
--

* `WindowManager` - центральный класс, реализующий логику работы экранов системы. Ему делегируются вызовы `openWindow()`, `openEditor()`, `showMessageDialog()` и другие методы интерфейса `Frame`, реализуемого <<screen_controller,контроллерами>> экранов. Класс `WindowManager` расположен в общем модуле *gui* платформы и является абстрактным. В модуле *web* имеется конкретный класс `WebWindowManager`, реализующий специфику веб клиента. Ссылку на `WindowManager` можно получить в любой реализации интерфейса `Window` (например в контроллере экрана), или с помощью бина `WindowManagerProvider`.

Для того, чтобы обрабатывать нажатия на кнопку *Back* браузера, реализуйте интерфейс `CubaHistoryControl.HistoryBackHandler` в ваших `TopLevelWindow` (окно логина и главное окно). Метод `onHistoryBackPerformed()` этого интерфейса вызывается вместо стандартного поведения браузера, если свойство приложения <<cuba.web.allowHandleBrowserHistoryBack,cuba.web.allowHandleBrowserHistoryBack>> установлено в true.

[[webComponentsHelper]]
===== Работа с компонентами Vaadin

Для работы непосредственно с компонентами Vaadin, реализующими интерфейсы <<gui_vcl,библиотеки визуальных компонентов>> в блоке Web Client, воспользуйтесь следующими методами интерфейса `Component`:

* `unwrap()` - получить Vaadin-компонент для данного CUBA-компонента.

* `unwrapComposition()` - получить Vaadin-компонент, который является наиболее внешним контейнером в реализации данного CUBA-компонента. Для простых компонентов, например <<gui_Button,Button>>, этот метод возвращает тот же объект, что и `unwrap()` - `com.vaadin.ui.Button`. Для сложных компонентов, например <<gui_Table,Table>>, `unwrap()` вернет соответсвующий объект `com.vaadin.ui.Table`, а `unwrapComposition()` - объект `com.vaadin.ui.VerticalLayout`, который содержит таблицу вместе с описанными вместе с ней <<gui_ButtonsPanel,ButtonsPanel>> и `RowsCount`.

Методы принимают класс компонента, который нужно вернуть, например:

[source, java]
----
com.vaadin.ui.TextField vTextField = textField.unwrap(com.vaadin.ui.TextField.class);
----

Можно также использовать статические методы `unwrap()` и `getComposition()` класса `WebComponentsHelper`, передавая в них CUBA-компонент.

Следует иметь в виду, что если экран расположен в модуле *gui* проекта, то в его контроллере можно работать только с обобщенными интерфейсами CUBA-компонентов. Чтобы использовать `unwrap()`, нужно либо расположить весь экран в модуле *web*, либо воспользоваться механизмом <<companions,компаньонов контроллеров>>.

[[main_window_layout]]
===== Компоновка главного окна приложения

Механизм предоставляет возможность задавать компоновку главного экрана веб-приложения с использованием технологии универсального пользовательского интерфейса CUBA - XML-дескриптора и Java-контроллера с применением <<gui_vcl,визуальных компонентов>> и <<datasources,источников данных>>. 

Главное окно - особый экран системы, имеющий идентификатор `mainWindow`. Контроллер главного экрана должен быть наследником класса `AbstractMainWindow`.

Помимо стандартных компонентов GUI в главном экране приложения можно использовать дополнительные компоненты:

* `AppMenu` - главное меню.

* `FoldersPane` - панель <<folders_pane,папок поиска и папок приложения>>.

* `AppWorkArea` - рабочая область, обязательный компонент для работы с экранами в режимах `++THIS_TAB++`, `++NEW_TAB++` и `++NEW_WINDOW++`.

* `UserIndicator` - поле, отображающее имя текущего пользователя, а при наличии замещаемых пользователей позволяет переключаться между ними.

* `NewWindowButton` - кнопка открытия нового окна приложения.

* `LogoutButton` - кнопка выхода из приложения.

* `TimeZoneIndicator` - надпись, которая отображает <<timeZone,часовой пояс>> пользователя.

* `FtsField` - поле полнотекстового поиска.

Для работы с дополнительными компонентами в XML-дескриптор экрана нужно добавить элемент `xmlns:main`:

[source, xml]
----
include::{sourcesdir}/gui/main_window_1.xml[]
----

Специальный компонент `AppWorkArea` представляет собой рабочую область, в которой открываются экраны приложения. Если свойство приложения <<cuba.web.appWindowMode,cuba.web.appWindowMode>> имеет значение `TABBED` (по умолчанию), то на месте рабочей области будет расположен компонент `TabSheet` с экранами приложения. В противном случае рабочая область будет содержать единственный открытый экран. Когда не открыт ни один экран, рабочая область содержит компоненты, определенные во вложенном элементе `initialLayout`: 

[source, xml]
----
include::{sourcesdir}/gui/main_window_2.xml[]
---- 

При открытии экранов компоновка начального экрана (`initialLayout`) удаляется из `AppWorkArea`, при закрытии всех экранов - добавляется обратно. Для реакции на события смены рабочей области на стартовый экран и на отображение экранов приложения можно добавить обработчик `AppWorkArea.StateChangeListener`. Например, в таком слушателе можно разместить код обновления данных стартового экрана. 

В платформе существует стандартная реализация главного окна приложения. Ее XML-дескриптор - `/com/haulmont/cuba/web/app/mainwindow/mainwindow.xml`, соответствующий контроллер - `AppMainWindow`. Стандартная реализация главного окна может быть расширена в проекте, так же как обычный экран системы. Пример расширяющего экрана: 

[source, xml]
----
include::{sourcesdir}/gui/main_window_3.xml[]
----
--
Этот экран должен быть зарегистрирован в <<screens.xml,screens.xml>> с идентификатором `mainWindow`.

Реализация главного окна может быть полностью заменена. Например: 

[source, xml]
----
include::{sourcesdir}/gui/main_window_4.xml[]
---- 
--
В результате главное окно приложения выглядит следующим образом: 

image::main_window_1.png[align="center"]


Оно же с открытым экраном: 

image::main_window_2.png[align="center"]


Свойство приложения <<cuba.web.showBreadCrumbs,cuba.web.showBreadCrumbs>> позволяет скрыть панель навигации (breadcrumbs) над открытым экраном.


[[gui_desktop]]
==== Специфика Desktop Client

Реализация универсального пользовательского интерфейса в <<app_tiers,блоке>> *Desktop Client* основана на *Java Swing*. Рассмотрим основные классы, входящие в состав инфраструктуры десктоп клиента.

.Классы инфраструктуры Desktop Client
image::DesktopClientInfrastructure.png[align="center"]

* `App` - центральный класс инфраструктуры десктоп приложения. Содержит ссылки на `Connection` и главный `TopLevelFrame`, а также методы инициализации и получения параметров приложения (см. ниже).
+
В конкретном приложении необходимо создать собственный класс-наследник `App` и переопределить в нем следующие методы:

** `getDefaultAppPropertiesConfig` - должен возвращать строку, в которой через пробел перечислены <<app_properties_files,файлы свойств приложения>>, например:
+
[source, java]
----
include::{sourcesdir}/gui/desktopclient_1.java[]
----

** `getDefaultHomeDir` - должен вовращать путь к каталогу, в котором приложение будет хранить временные и рабочие файлы, например:
+
[source, java]
----
include::{sourcesdir}/gui/desktopclient_2.java[]
----

** `getDefaultLogConfig` - должен возвращать имя файла настройки Logback, если таковой определен в проекте. Например:
+
[source, java]
----
include::{sourcesdir}/gui/desktopclient_3.java[]
----
+
Кроме того, в собственном классе-наследнике `App` необходимо определить метод `main()` следующим образом:
+
[source, java]
----
include::{sourcesdir}/gui/desktopclient_4.java[]
----

* `Connection` - класс, обеспечивающий функциональность подключения к среднему слою и хранящий пользовательскую сессию <<userSession,UserSession>>. 

* `LoginDialog` - диалог логина пользователя. В конкретном приложении можно создать наследника `LoginDialog` и переопределить метод `createLoginDialog()` класса `App` для его использования.

* `TopLevelFrame` - наследник `JFrame`, являющийся окном самого верхнего уровня. В приложении существует как минимум один экземпляр данного класса, создаваемый при старте приложения и содержащий главное меню. Этот экземпляр возвращается методом `getMainFrame()` класса `App`.
+
При отделении пользователем вкладок главного окна или компонента <<gui_TabSheet,TabSheet>> (см. атрибут `detachable`) создаются дополнительные экземпляры `TopLevelFrame`, не содержащие главного меню.

* `WindowManager` - центральный класс, реализующий логику работы экранов системы. Ему делегируются вызовы `openWindow()`, `openEditor()`, `showMessageDialog()` и другие методы интерфейса `Frame`, реализуемого <<screen_controller,контроллерами>> экранов. Класс `WindowManager` расположен в общем модуле *gui* платформы и является абстрактным. В модуле *desktop* имеется конкретный класс `DesktopWindowManager`, реализующий специфику десктоп клиента.
+
Как правило, `WindowManager` не используется в прикладном коде напрямую.

* `ExceptionHandlers` - содержит коллекцию <<exceptionHandlers,обработчиков исключений клиентского уровня>>.

[[desktopComponentsHelper]]
===== Работа с компонентами Swing

Для работы непосредственно с компонентами Swing, реализующими интерфейсы <<gui_vcl,библиотеки визуальных компонентов>> в блоке Desktop Client, воспользуйтесь следующими методами интерфейса `Component`:

* `unwrap()` - получить Swing-компонент для данного CUBA-компонента.

* `unwrapComposition()` - получить Swing-компонент, который является наиболее внешним контейнером в реализации данного CUBA-компонента. Для простых компонентов, например <<gui_Button,Button>>, этот метод возвращает тот же объект, что и `unwrap()` - `javax.swing.JButton`. Для сложных компонентов, например <<gui_Table,Table>>, `unwrap()` вернет соответсвующий объект `org.jdesktop.swingx.JXTable`, а `unwrapComposition()` - объект `javax.swing.JPanel`, который содержит таблицу вместе с описанными вместе с ней <<gui_ButtonsPanel,ButtonsPanel>> и `RowsCount`.

Методы принимают класс компонента, который нужно вернуть, например:

[source, java]
----
javax.swing.JButton jButton = button.unwrap(javax.swing.JButton.class);
----

Можно также использовать статические методы `unwrap()` и `getComposition()` класса `DesktopComponentsHelper`, передавая в них CUBA-компонент.

Следует иметь в виду, что если экран расположен в модуле *gui* проекта, то в его контроллере можно работать только с обобщенными интерфейсами CUBA-компонентов. Чтобы использовать `unwrap()`, нужно либо расположить весь экран в модуле *desktop*, либо воспользоваться механизмом <<companions,компаньонов контроллеров>>.

[[own_components]]
==== Собственные визуальные компоненты

В данном разделе содержится обзор различных способов создания создания собственных визуальных компонентов в CUBA-приложениях. Практическое руководство по использованию этих подходов содержится в разделе <<own_component_samples>>.

Новый визуальный компонент может быть создан с помощью следующих технологий:

* На основе Vaadin add-on.
+
--
Это простейший способ, требующий следующих шагов:

** Добавить в <<build.gradle,build.gradle>> зависимость от артефакта аддона.

** Создать в проекте модуль *web-toolkit*. Данный модуль содержит файл виджетсета GWT и позволяет создавать клиентские части визуальных компонентов.

** Подключить виджетсет аддона в виджетсет проекта.

** Если требуется адаптировать внешний вид компонента к теме приложения, создать расширение темы и задать для компонента нужный CSS.

См. пример в разделе <<vaadin_addon_sample>>.
--

* Как обертка библиотеки на JavaScript.
+
--
Данный метод рекомендуется, если у вас уже есть подходящий компонент, написанный на JavaSript. Чтобы использовать его в приложении, требуется следующее:

** Создать в модуле *web* серверный компонент Vaadin. Серверный компонент определяет API для серверного кода, методы доступа, слушатели событий и т.д. Серверный компонент должен быть унаследован от класса `AbstractJavaScriptComponent`. Модуль *web-toolkit* для интеграции JavaScript-компонента не требуется.

** Создать JavaScript-коннектор. Коннектор - это функция, которая инициализирует JavaScript-компонент и ответственна за взаимодействие между JavaScript и server-side кодом.

** Создать класс состояния. Публичные поля данного класса определяют, какие данные посылаются сервером клиенту. Класс состояния должен быть унаследован от `JavaScriptComponentState`.

См. пример в разделе <<js_library_sample>>.
--

* В виде нового компонента link:http://www.gwtproject.org[GWT].
+
--
Данный метод рекомендуется для создания полностью новых визуальных компонентов. Он требует следующих шагов:

** Создать в проекте модуль *web-toolkit*.

** Создать класс клиентского виджета GWT.

** Создать серверный компонент Vaadin.

** Создать класс состояния, определяющий данные, посылаемые сервером клиенту.

** Создать класс коннектора, который соединяет клиентский код с серверным компонентом.

** Создать интерфейс RPC, который определяет серверный API, вызываемый клиентом.

См. пример в разделе <<gwt_component_sample>>.
--

Степень интегрированности визуального компонента в платформу можно разделить на три уровня:

* На первом уровне новый компонент становится доступным как нативный компонент Vaadin. Прикладной разработчик может использовать его в контроллерах экранов приложения напрямую: создать экземпляр и добавить его в <<webComponentsHelper,нативный>> контейнер. Методы создания компонентов, описанные выше, предоставляют именно этот уровень интеграции.

* На втором уровне новый компонент интегрируется в <<gui_framework,универсальный пользовательский интерфейс>> платформы. В этом случае, с точки зрения прикладного разработчика, компонент выглядит так же как и стандартный компонент из <<gui_vcl,библиотеки визуальных компонентов>>. Разработчик может определить компонент в XML-дескрипторе экрана или создать его с помощью `ComponentsFactory` в контроллере. См. пример в разделе <<vaadin_addon_sample_gui>>.

* На третьем уровне новый компонент доступен в палитре компонентов WYSIWYG-дизайнера экранов Studio. См. пример в разделе <<own_component_in_studio>>.

[[shortcuts]]
==== Горячие клавиши

В данном разделе приведена информация обо всех горячих клавишах (shortcuts), которые используются по умолчанию в универсальном пользовательском интерфейсе приложения. Все перечисленные ниже <<app_properties,свойства приложения>> принадлежат интерфейсу `ClientConfig` и используются в блоках *Web Client* и *Desktop Client*. 

* Главное окно приложения.

** *CTRL-SHIFT-PAGE_DOWN* - переход на следующую вкладку. Настраивается свойством приложения `cuba.gui.nextTabShortcut`.

** *CTRL-SHIFT-PAGE_UP* - переход на предыдущую вкладку. Настраивается свойством приложения `cuba.gui.previousTabShortcut`.

* Экраны.

** *ESCAPE* - закрыть текущий <<abstractWindow,экран>>. Настраивается свойством приложения `cuba.gui.closeShortcut`.

** *CTRL-ENTER* - закрыть текущий <<abstractEditor,экран редактирования>> с сохранением изменений. Настраивается свойством приложения `cuba.gui.commitShortcut`.

* Стандартные действия компонента-списка (<<gui_Table,Table>>, <<gui_GroupTable,GroupTable>>, <<gui_TreeTable,TreeTable>>, <<gui_Tree,Tree>>). Кроме указанных свойств приложения горячая клавиша для конкретного экземпляра действия может быть установлена его методом `setShortcut()`.

** *CTRL-\* - вызов действия <<createAction,CreateAction>>. Настраивается свойством приложения `cuba.gui.tableShortcut.insert`.

** *CTRL-ALT-\* - вызов действия <<addAction,AddAction>>. Настраивается свойством приложения `cuba.gui.tableShortcut.add`.

** *ENTER* - вызов действия <<editAction,EditAction>>. Настраивается свойством приложения `cuba.gui.tableShortcut.edit`.

** *CTRL-DELETE* - вызов действий <<removeAction,RemoveAction>> и <<excludeAction,ExcludeAction>>. Настраивается свойством приложения `cuba.gui.tableShortcut.remove`.

* Выпадающие списки (<<gui_LookupField,LookupField>>, <<gui_LookupPickerField,LookupPickerField>>).

** *SHIFT-DELETE* – очистить значение.

* Стандартные действия поля выбора (<<gui_PickerField,PickerField>>, <<gui_LookupPickerField,LookupPickerField>>, <<gui_SearchPickerField,SearchPickerField>>). Кроме указанных свойств приложения горячая клавиша для конкретного экземпляра действия может быть установлена его методом `setShortcut()`.
** *CTRL-ALT-L* - вызов действия <<lookupAction,LookupAction>>. Настраивается свойством приложения `cuba.gui.pickerShortcut.lookup`.

** *CTRL-ALT-O* - вызов действия <<openAction,OpenAction>>. Настраивается свойством приложения `cuba.gui.pickerShortcut.open`.

** *CTRL-ALT-C* - вызов действия <<clearAction,ClearAction>>. Настраивается свойством приложения `cuba.gui.pickerShortcut.clear`.
+
В полях выбора кроме вышеперечисленных горячих клавиш поддерживается вызов действий сочетанием *CTRL-ALT-1*, *CTRL-ALT-2* и так далее по количеству действий. То есть при нажатии сочетания клавиш *CTRL-ALT-1* произойдет вызов действия, которое описано первым в списке действий, при нажатии сочетания клавиш *CTRL-ALT-2* − вызов второго действия и так далее. Сочетание *CTRL-ALT* можно заменить другим, указав его в свойстве приложения `cuba.gui.pickerShortcut.modifiers`.

* Компонент <<gui_Filter,Filter>>.

** *SHIFT-BACKSPACE* – открыть список выбора фильтров. Настраивается свойством приложения `cuba.gui.filterSelectShortcut`.

** *SHIFT-ENTER* - применить выбранный фильтр. Настраивается свойством приложения `cuba.gui.filterApplyShortcut`.

