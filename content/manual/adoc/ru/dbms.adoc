[[dbms]]
=== Компоненты работы с базой данных

В данном разделе приведена информация о возможных типах СУБД приложений на платформе CUBA. Кроме того, описан механизм на основе скриптов, с помощью которого можно создать новую базу данных, и в дальнейшем поддерживать ее в актуальном состоянии на протяжении всего цикла разработки и эксплуатации приложения. 

Компоненты работы с базой данных принадлежат <<app_tiers,блоку>> *Middleware*, другие блоки приложения не имеют прямого доступа к БД. 

Дополнительная практическая информация по работе с базой данных приведена в <<db_dev,>> и <<db_update_in_prod,>>.

[[dbms_types]]
==== Типы СУБД

Тип используемой СУБД определяется свойствами приложения `
        <<cuba.dbmsType,cuba.dbmsType>>
      ` и (опционально) <<cuba.dbmsVersion,cuba.dbmsVersion>>, а также настройкой источника данных `javax.sql.DataSource`, через который производится обращение к базе данных. Экземпляр источника данных извлекается из JNDI по имени, заданному в свойстве приложения `
        <<cuba.dataSourceJndiName,cuba.dataSourceJndiName>>
      `. Конфигурационный файл для *Tomcat*, определяющий источник данных, описан в <<context.xml,>>

Платформа "из коробки" поддерживает следующие СУБД:

[cols="3", frame="all"]
|===

| | cuba.dbmsType| cuba.dbmsVersion

| HSQLDB| hsql| 

| PostgreSQL 8.4+| postgres| 

| Microsoft SQL Server 2005, 2008| mssql| 

| Microsoft SQL Server 2012+| mssql| 2012

| Oracle Database 11g| oracle| 

|===

Таблица ниже описывает рекомендованное соответствие типов данных между атрибутами сущностей в Java и колонками таблиц различных СУБД. Эти типы автоматически выбираются Studio при генерации скриптов создания и обновления БД, и для них гарантируется работоспособность всех механизмов платформы.

[cols="5", frame="all"]
|===

| Java| HSQL| PostgreSQL| MS SQL Server| Oracle

| UUID| varchar(36)| uuid| uniqueidentifier| varchar2(32)

| Date| timestamp| timestamp| datetime| timestamp

| java.sql.Date| timestamp| date| datetime| date

| java.sql.Time| timestamp| time| datetime| timestamp

| BigDecimal| decimal(p, s)| decimal(p, s)| decimal(p, s)| number(p, s)

| Double| double precision| double precision| double precision| float

| Long| bigint| bigint| bigint| number(19)

| Integer| integer| integer| integer| integer

| Boolean| boolean| boolean| tinyint| char(1)

| String (limited)| varchar(n)| varchar(n)| varchar(n)| varchar2(n)

| String (unlimited)| longvarchar| text| varchar(max)| clob

| byte[]| longvarbinary| bytea| image| blob

|===

Как правило, всю работу по преобразованию данных между БД и кодом Java выполняет <<orm,слой ORM>> совместно с соответствующим JDBC драйвером. Это означает, что при работе с данными через методы <<entityManager,EntityManager>> и <<query,запросы на JPQL>> никакой ручной конвертации выполнять не нужно - вы просто используете типы Java, перечисленные в левой колонке таблицы.

При использовании native SQL через `EntityManager.<<nativeQuery,createNativeQuery>>()` или через `
        <<queryRunner,QueryRunner>>
      ` для разных типов СУБД некоторые типы данных в Java коде будут отличаться от приведенных. В первую очередь это касается атрибутов типа `UUID` - только драйвер PostgreSQL возвращает значения соответствующих колонок в этом типе, для других серверов это будет `String`. Для обеспечения независимости кода от используемой СУБД рекомендуется конвертировать типы параметров и результатов запросов с помощью интерфейса `
        <<dbTypeConverter,DbTypeConverter>>
      `.

[[arbitrary_dbms]]
===== Поддержка произвольных СУБД

На уровне прикладного проекта можно реализовать работу с любой СУБД, поддерживаемой фреймворком <<orm,ORM>> (OpenJPA). Для этого достаточно выполнить следующее:

* Указать тип СУБД в виде произвольного кода в свойстве <<cuba.dbmsType,cuba.dbmsType>>. Код должен отличаться от используемых в платформе кодов `hsql`, `postgres`, `mssql`, `oracle`.

* Реализовать интерфейсы `DbmsFeatures`, `SequenceSupport`, `DbTypeConverter` классами с именами соответственно `TypeDbmsFeatures`, `TypeSequenceSupport`, `TypeDbTypeConverter`, где `Type` - код типа СУБД. Пакет класса имплементации должен быть таким же, как у интерфейса.

* Если проект включает базовый проект *Workflow*, необходимо переопределить бин `CubaJbpmSpringHelper` и его метод `getHibernateDialectName()` для выбора диалекта Hibernate, используемого в jBPM.

* Создать скрипты инициализации и обновления БД в каталогах с кодом СУБД. Скрипты инициализации должны включать создание всех объектов БД, необходимых для сущностей платформы (их можно скопировать из имеющихся в каталоге `10-cuba` и др. скриптов и исправить для данной СУБД).

* Для создания и обновления БД задачами Gradle в build.gradle необходимо для этих задач указать дополнительные параметры:
+
[source, java]
----
task createDb(dependsOn: assemble, type: CubaDbCreation) {
  dbms = 'my'                                            // DBMS code
  driver = 'net.my.jdbc.Driver'                          // JDBC driver class
  dbUrl = 'jdbc:my:myserver://192.168.47.45/mydb'        // Database URL
  masterUrl = 'jdbc:my:myserver://192.168.47.45/master'  // URL of a master DB to connect to for creating the application DB
  dropDbSql = 'drop database mydb;'                      // Drop database statement
  createDbSql = 'create database mydb;'                  // Create database statement
  timeStampType = 'datetime'                             // Date and time datatype - needed for SYS_DB_CHANGELOG table creation
  dbUser = 'sa'
  dbPassword = 'saPass1'
}

task updateDb(dependsOn: assemble, type: CubaDbUpdate) {
  dbms = 'my'                                            // DBMS code
  driver = 'net.my.jdbc.Driver'                          // JDBC driver class
  dbUrl = 'jdbc:my:myserver://192.168.47.45/mydb'        // Database URL
  dbUser = 'sa'
  dbPassword = 'saPass1'
}
----

[[dbms_version]]
===== Версия СУБД

В дополнение к свойству приложения <<cuba.dbmsType,cuba.dbmsType>> существует опциональное свойство <<cuba.dbmsVersion,cuba.dbmsVersion>>. Оно влияет на выбор имплементаций интерфейсов `DbmsFeatures`, `SequenceSupport`, `DbTypeConverter`, и на поиск скриптов создания и обновления БД.

Имя класса имплементации интеграционного интерфейса формируется следующим образом: `TypeVersionName`. Здесь `Type` - значение `cuba.dbmsType` с заглавной буквы, `Version` - значение `cuba.dbmsVersion`, `Name` - имя интерфейса. Пакет класса должен быть таким же, как у интерфейса. Если класс с таким именем отсутствует, предпринимается попытка найти класс с именем без версии: `TypeName`. Если и такого класса нет, выдается исключение.

Например, в платформе определен класс `com.haulmont.cuba.core.sys.persistence.Mssql2012SequenceSupport`, который вступит в силу, если в проекте указаны следующие свойства:

[source]
----
cuba.dbmsType = mssql
cuba.dbmsVersion = 2012
----

При поиске <<db_scripts,скриптов создания и обновления БД>> каталог с именем `type-version` имеет приоритет над каталогом с именем `type`. Это значит, что скрипты каталога `type-version` заменяют одноименные скрипты каталога `type`. В каталоге `type-version` могут быть и скрипты с собственными именами, они будут также добавлены в общий набор скриптов для выполнения. Сортировка скриптов производится по пути начиная с каталога, вложенного в `type` или `type-version`, то есть без учета того, в каком каталоге (с версией или без) находится скрипт.

Например, следующим образом можно определить скрипты создания БД для Microsoft SQL Server для версий ниже и выше 2012:

[source]
----
modules/core/db/init/
   mssql/
       10.create-db.sql
       20.create-db.sql
       30.create-db.sql
   mssql-2012/
       10.create-db.sql 
----

[[db_scripts]]
==== Скрипты создания и обновления БД

Проект CUBA-приложения всегда содержит два набора скриптов:

* Скрипты _создания_ БД, предназначенные для создания базы данных с нуля. Они содержат набор DDL и DML операторов, после выполнении которых на пустой БД схема базы данных полностью соответствует текущему состоянию <<data_model,модели данных>> приложения. Скрипты создания могут также наполнять БД необходимыми первичными данными.

* Скрипты _обновления_ БД - предназначены для поэтапного приведения структуры БД к текущему состоянию модели данных.

При изменении модели данных необходимо отразить соответствующее изменение схемы БД и в скриптах содания, и в скриптах обновления. Например, при добавлении атрибута `address` в сущность `Customer`, нужно:

. Изменить оператор создания таблицы в скрипте создания:
+
[source]
----
create table SALES_CUSTOMER (
  ID varchar(36) not null ,
  CREATE_TS timestamp,
  CREATED_BY varchar(50),
  --
  NAME varchar(100),
  ADDRESS varchar(200), -- added column
  --
  primary key (ID)
)
----Изменить оператор создания таблицы в скрипте создания:
+
[source]
----
create table SALES_CUSTOMER (
  ID varchar(36) not null ,
  CREATE_TS timestamp,
  CREATED_BY varchar(50),
  --
  NAME varchar(100),
  ADDRESS varchar(200), -- added column
  --
  primary key (ID)
)
----

. Добавить скрипт обновления, содержащий оператор модификации таблицы:
+
[source]
----
alter table SALES_CUSTOMER add ADDRESS varchar(200)
----Добавить скрипт обновления, содержащий оператор модификации таблицы:
+
[source]
----
alter table SALES_CUSTOMER add ADDRESS varchar(200)
----

Скрипты создания располагаются в каталоге `/db/init` модуля *core*. Для каждого типа СУБД, поддерживаемой приложением, создается свой набор скриптов и располагается в подкаталоге с именем, соответствующим свойству приложения `
        <<cuba.dbmsType,cuba.dbmsType>>
      `, например, `/db/init/postgres`. Имена скриптов создания должны иметь вид `{optional_prefix}create-db.sql`.

Скрипты обновления располагаются в каталоге `/db/update` модуля *core*. Для каждого типа СУБД, поддерживаемой приложением, создается свой набор скриптов и располагается в подкаталоге с именем, соответствующим свойству приложения `
        <<cuba.dbmsType,cuba.dbmsType>>
      `, например, `/db/update/postgres`. 

Скрипты обновления могут быть двух типов: с расширением `*.sql` или с расширением `*.groovy`. SQL-скрипты являются основным средством обновления базы данных. Groovy-скрипты выполняются только <<db_update_server,механизмом запуска скриптов БД сервером>>, поэтому применяются в основном на этапе эксплуатации приложения - как правило, это процессы миграции или импорта данных, которые невозможно реализовать на SQL. 

Скрипты обновления должны иметь имена, которые при сортировке в алфавитном порядке образуют правильную последовательность их выполнения (обычно это хронологическая последовательность их создания). Поэтому при ручном создании рекомендуется задавать имя скрипта обновления в виде `{yymmdd}-{description}.sql`, где `yy` - год, `mm` - месяц, `dd` - день, `description` - краткое описание скрипта. Например, `121003-addCodeToCategoryAttribute.sql`. Studio при автоматической генерации скриптов также придерживается этого формата.

Скрипты обновления можно группировать в подкаталоги, главное, чтобы путь к скрипту с учетом подкаталога не нарушал хронологической последовательности. Например, можно создавать подкаталоги по номеру года или по году и месяцу.

В развернутом приложении скрипты создания и обновления БД располагаются в специальном <<db_dir,каталоге скриптов базы данных>>, задаваемым свойством приложения `
        <<cuba.dbDir,cuba.dbDir>>
      `.

===== Структура SQL-скриптов

SQL-скрипты создания и обновления представляют собой текстовые файлы с набором DDL и DML команд, разделенных символом "`^`". Символ "`^`" применяется для того, чтобы можно было применять разделитель "`;`" в составе сложных команд, например, при создании функций или триггеров. Механизм исполнения скриптов разделяет входной файл на команды по разделителю "`^`" и выполняет каждую команду в отдельной транзакции. Это означает, что при необходимости можно сгруппировать несколько простых операторов (например, `insert`), разделенных точкой с запятой, и обеспечить их выполнение в одной транзакции.

Пример SQL-скрипта обновления:

[source]
----
create table LIBRARY_COUNTRY (
  ID varchar(36) not null,
  CREATE_TS time,
  CREATED_BY varchar(50),
  --
  NAME varchar(100) not null,
  --
  primary key (ID)
)^

alter table LIBRARY_TOWN add column COUNTRY_ID varchar(36) ^
alter table LIBRARY_TOWN add constraint FK_LIBRARY_TOWN_COUNTRY_ID foreign key (COUNTRY_ID) references LIBRARY_COUNTRY(ID)^
create index IDX_LIBRARY_TOWN_COUNTRY on LIBRARY_TOWN (COUNTRY_ID)^
----

===== Структура Groovy-скриптов

Groovy-скрипты обновления имеют следующую структуру:

* _Основная_ часть, содержащая код, выполняемый до старта <<appContext,контекста приложения>>. В этой части можно использовать любые классы Java, Groovy и блока *Middleware* приложения, но при этом необходимо иметь в виду, что никакие бины, интерфейсы инфраструктуры и прочие объекты приложения еще не инстанциированы, и с ними работать нельзя.
+
Основная часть предназначена в первую очередь, как и обычные SQL-скрипты, для обновления схемы данных.

* _PostUpdate_ часть - набор замыканий, которые будут выполнены после завершения процесса обновления и после старта контекста приложения. Внутри этих замыканий можно оперировать любыми объектами *Middleware* приложения.
+
В этой части скрипта удобно, напимер, выполнять импорт данных, так как в ней можно использовать интерфейс <<persistence,Persistence>> и объекты модели данных.

На вход Groovy-скриптов механизм выполнения передает следующие переменные:

* `ds` - экземпляр `javax.sql.DataSource` для базы данных приложения.

* `log` - экземпляр `org.apache.commons.logging.Log` для вывода сообщений в журнал сервера

* `postUpdate` - объект, содержащий метод `add(Closure closure)` для добавления замыканий, выполняющихся после старта контекста сервера.

[WARNING]
====
Groovy-скрипты выполняются только <<db_update_server,механизмом запуска скриптов БД сервером>>.
====

Пример Groovy-скрипта обновления:

[source, java]
----
import com.haulmont.cuba.core.Persistence
import com.haulmont.cuba.core.global.AppBeans
import com.haulmont.refapp.core.entity.Colour
import groovy.sql.Sql

log.info('Executing actions in update phase')

Sql sql = new Sql(ds)
sql.execute """
alter table MY_COLOR add DESCRIPTION varchar(100);
"""

// Add post update action
postUpdate.add({
  log.info('Executing post update action using fully functioning server')

  def p = AppBeans.get(Persistence.class)
  def tr = p.createTransaction()
  try {
      def em = p.getEntityManager()

      Colour c = new Color()
      c.name = 'yellow'
      c.description = 'a description'

      em.persist(c)
      tr.commit()
  } finally {
      tr.end()
  }
})
----

[[db_update_gradle]]
==== Выполнение скриптов БД задачами Gradle

Данный механизм применяется обычно разработчиками приложения для собственного экземпляра базы данных. Выполнение скриптов в этом случае сводится к запуску специальных задач Gradle, описанных в скрипте сборки `
        <<build.gradle,build.gradle>>
      `. Это можно сделать как из командной строки, так и с помощью интерфейса Studio.

Для запуска скриптов _создания_ БД служит задача `createDb`. В Studio ей соответствует команда главного меню *Run* -> *Create database*. При запуске задачи происходит следующее:

. В каталоге `modules/core/build/db` собираются скрипты <<base_projects,базовых проектов>> платформы и скрипты `db/**/*.sql` модуля *core* текущего проекта. Наборы скриптов базовых проектов располагаются в подкаталогах с числовыми префиксами начиная с 10, скрипты текущего проекта - в подкаталоге с префиксом 50. Числовые префиксы необходимы для соблюдения алфавитного порядка выполнения скриптов - сначала выполняются скрипты *cuba*, затем других базовых проектов, затем текущего проекта.В каталоге `modules/core/build/db` собираются скрипты <<base_projects,базовых проектов>> платформы и скрипты `db/**/*.sql` модуля *core* текущего проекта. Наборы скриптов базовых проектов располагаются в подкаталогах с числовыми префиксами начиная с 10, скрипты текущего проекта - в подкаталоге с префиксом 50. Числовые префиксы необходимы для соблюдения алфавитного порядка выполнения скриптов - сначала выполняются скрипты *cuba*, затем других базовых проектов, затем текущего проекта.

. Если БД существует, она полностью очищается. Если не существует, то создается новая пустая БД.Если БД существует, она полностью очищается. Если не существует, то создается новая пустая БД.

. Последовательно в алфавитном порядке выполняются все скрипты создания `modules/core/build/db/init/**/*create-db.sql`, и их имена вместе с путем относительно каталога `db` регистрируются в таблице *SYS_DB_CHANGELOG*.Последовательно в алфавитном порядке выполняются все скрипты создания `modules/core/build/db/init/**/*create-db.sql`, и их имена вместе с путем относительно каталога `db` регистрируются в таблице *SYS_DB_CHANGELOG*.

. В таблице *SYS_DB_CHANGELOG* аналогично регистрируются все имеющиеся на данный момент скрипты обновления `modules/core/build/db/update/**/*.sql`. Это необходимо для будущего инкрементального обновления БД новыми скриптами. В таблице *SYS_DB_CHANGELOG* аналогично регистрируются все имеющиеся на данный момент скрипты обновления `modules/core/build/db/update/**/*.sql`. Это необходимо для будущего инкрементального обновления БД новыми скриптами. 

Для запуска скриптов _обновления_ БД служит задача `updateDb`. В Studio ей соответствует команда главного меню *Run* -> *Update database*. При запуске задачи происходит следующее:

. Производится сборка скриптов аналогично описанному выше.Производится сборка скриптов аналогично описанному выше.

. Производится проверка, все ли базовые проекты имеют необходимые таблицы в базе данных. Если обнаруживается, что БД не инициализирована для работы некоторого базового проекта, выполняются его скрипты создания. Производится проверка, все ли базовые проекты имеют необходимые таблицы в базе данных. Если обнаруживается, что БД не инициализирована для работы некоторого базового проекта, выполняются его скрипты создания. 

. В каталогах `modules/core/build/db/update/**` производится поиск скриптов обновления, не зарегистрированных в таблице *SYS_DB_CHANGELOG*, то есть не выполненных ранее и содержимое которых не отражено в БД при ее инициализации.В каталогах `modules/core/build/db/update/**` производится поиск скриптов обновления, не зарегистрированных в таблице *SYS_DB_CHANGELOG*, то есть не выполненных ранее и содержимое которых не отражено в БД при ее инициализации.

. Последовательно в алфавитном порядке выполняются все найденные на предыдущем шаге скрипты, и их имена вместе с путем относительно каталога `db` регистрируются в таблице *SYS_DB_CHANGELOG*. Последовательно в алфавитном порядке выполняются все найденные на предыдущем шаге скрипты, и их имена вместе с путем относительно каталога `db` регистрируются в таблице *SYS_DB_CHANGELOG*. 

[[db_update_server]]
==== Выполнение скриптов БД сервером

Механизм выполнения скриптов сервером предназначен для приведения БД в актуальное состояние на старте сервера приложения, и активируется во время инициализации блока *Middleware*. Понятно, что при этом приложение должно быть собрано и развернуто на сервере, будь то собственный Tomcat разработчика или сервер в режиме эксплуатации.

Данный механизм в зависимости от описанных ниже условий выполняет либо скрипты создания, либо скрипты обновления, то есть он может и инициализировать БД с нуля, и обновлять ее. Однако, в отличие от описанной в предыдущем разделе задачи Gradle `createDb`, для выполнения инициализации базы она должна существовать - сервер не создает БД автоматически, а только прогоняет на ней скрипты.

Механизм выполнения скриптов сервером действует следующим образом:

* Скрипты извлекаются из <<db_dir,каталога скриптов базы данных>>, определяемого свойством приложения <<cuba.dbDir,
              cuba.dbDir
            >>. В стандартном варианте развертывания в Tomcat это `tomcat/webapps/app-core/WEB-INF/db`.

* Если в БД отсутствует таблица *SEC_USER*, то считается, что база данных пуста, и запускается полная инициализация с помощью скриптов создания БД. После выполнения инициализирующих скриптов их имена запоминаются в таблице *SYS_DB_CHANGELOG*. Кроме того, там же сохраняются имена всех доступных скриптов обновления, _без их выполнения_.

* Если в БД имеется таблица *SEC_USER*, но отсутствует таблица *SYS_DB_CHANGELOG* (это случай, когда в первый раз запускается описываемый механизм на имеющейся рабочей БД), никакие скрипты _не запускаются_. Вместо этого создается таблица *SYS_DB_CHANGELOG* и в ней сохраняются имена всех доступных на данный момент скриптов создания и обновления. 

* Если в БД имеются и таблица *SEC_USER* и таблица *SYS_DB_CHANGELOG*, то производится запуск скриптов обновления, и их имена запоминаются в таблице *SYS_DB_CHANGELOG*. Причем запускаются только те скрипты, имен которых до этого не было в таблице *SYS_DB_CHANGELOG*, т.е. не запускавшиеся ранее. Последовательность запуска скриптов определяется 2-мя факторами: приоритетом базового проекта (см. содержимое <<db_dir,каталога скриптов базы данных>>: `10-cuba`, `20-workflow`, ...) и именем файла скрипта (с учетом подкаталогов внутри каталога `update`) в алфавитном порядке.
+
Перед выполнением скриптов обновления производится проверка, все ли базовые проекты имеют необходимые таблицы в базе данных. Если обнаруживается, что БД не инициализирована для работы некоторого базового проекта, выполняются его скрипты создания.

Механизм выполнения скриптов на старте сервера включается свойством приложения `
        <<cuba.automaticDatabaseUpdate,cuba.automaticDatabaseUpdate>>
      `.

В запущенном приложении механизм выполнения скриптов можно стартовать с помощью JMX-бина `app-core.cuba:type=PersistenceManager`, вызвав его метод `updateDatabase()` с параметром `*update*`. Понятно, что таким способом можно только обновить БД, а не проинициализировать новую, так как войти в систему для запуска метода JMX-бина при пустой БД невозможно. При этом следует иметь в виду, что если на старте *Middleware* или при входе пользователя в систему начнется инициализация той части модели данных, которая уже не соответствует устаревшей схеме БД, то произойдет ошибка, и продолжение работы станет невозможным. Именно поэтому универсальным является только автоматическое обновление БД на старте сервера перед инициализацией модели данных.

JMX-бин `app-core.cuba:type=PersistenceManager` имеет еще один метод, относящийся к механизму обновления БД: `findUpdateDatabaseScripts()`. Он возвращает список новых скриптов обновления, имеющихся в каталоге и не зарегистрированных в БД.

Практические рекомендации по использованию механизма обновления БД сервером приведены в <<db_update_in_prod,>>.

