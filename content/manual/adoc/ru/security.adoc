[[chapter_security]]
== Подсистема безопасности

Платформа CUBA включает в себя следующие средства разграничения прав доступа пользователей к информации: 

* Система назначения пользователям <<permissions,разрешений>>, основанная на <<roles,ролях>>; при этом набор ролей и разрешений настраивается администратором системы на этапе внедрения.

* Иерархическая структура <<groups,групп доступа>> с наследованием <<constraints,ограничений>>.

* Контроль доступа на следующих уровнях: 

** Операции над сущностями предметной области (чтение, создание, изменение, удаление): например, пользователь `*Иванов*` может просматривать документы, но не может создавать, изменять и удалять их.

** Атрибуты сущностей (изменение, чтение, запрет): пользователь `*Иванов*` видит все атрибуты документов, кроме суммы.

** Доступ к определенным экземплярам сущностей (контроль доступа на уровне строк): пользователь `*Иванов*` видит только те документы, которые были созданы в его отделе.

* Интеграция с <<ldap,LDAP>> с возможностью реализации технологии единого входа (Single Sign-On) для пользователей *Windows*. 

[[security_components]]
=== Компоненты подсистемы безопасности

Основные компоненты подсистемы безопасности CUBA приведены наследующей диаграмме. 

.Диаграмма компонентов подсистемы безопасности
image::Security.png[align="center"]

Рассмотрим их более подробно. 

_Security management screens_ - имеющиеся в платформе экраны, с помощью которых администратором системы осуществляется настройка прав доступа <<users,пользователей>>.

_Login screen_ − <<login_screen,окно входа>> в систему. В этом окне производится аутентификация пользователя по имени учетной записи и паролю. В базе данных вместо пароля, в целях его безопасности, хранится хэш.

После входа пользователя в систему создается объект <<userSession,UserSession>> − пользовательская сессия. Это центральный элемент обеспечения безопасности, объект, ассоциированный с аутентифицированным в данный момент в системе пользователем и содержащий информацию о правах доступа пользователя к данным.

Процесс входа пользователя в систему подробно описан в разделе <<login,>>.

_Roles_ − роли пользователей. <<roles,Роль>> - это объект системы, которому с одной стороны сопоставляется набор <<permissions,разрешений>>, необходимых для выполнения конкретных функций, а с другой стороны − подмножество пользователей, которые должны иметь эти разрешения. 

Разрешения бывают следующих типов:

* _Screen Permissions_ - возможность открытия некоторого экрана.

* _Entity Operation Permissions_ - возможность совершения операции с некоторой сущностью: чтение, создание,модификация, удаление. 

* _Entity Attribute Permissions_ - доступ к произвольному атрибуту некоторой сущности: модификация,только чтение, нет доступа.

* _Specific Permissions_ - разрешение на некоторую именованную функциональность.

* _UI Permissions_ - управление доступом к элементам некоторого экрана. 

_Access Groups_ - группы доступа пользователей. <<groups,Группы>> представляют собой иерархическую структуру, каждый элемент которой задает набор <<constraints,ограничений>> (_Constraints_), позволяющих контролироватьдоступ на уровне отдельных экземпляров (строк таблицы) некоторой сущности. Например, пользователь видит только те документы, которые были созданы в егоотделе.

[[login_screen]]
==== Окно входа в систему

Окно входа в систему (Login screen) предназначено для регистрации пользователя путем ввода логина и пароля. 

Логин не чувствителен к регистру вводимых символов.

Класс экрана в блоке Web Client - `LoginWindow`, в блоке Desktop Client - `LoginDialog`. Для расширения функциональности в приложении можно создать собственных наследников этих классов и возвращать соответствующие экземпляры, переопределив:

* для <<gui_web,веб клиента>> - метод `createLoginWindow()` класса `com.haulmont.cuba.web.App`

* для <<gui_desktop,десктоп клиента>> - метод `createLoginDialog()` класса `com.haulmont.cuba.desktop.App`.

Управлять отображением флажка *Remember Me* в веб клиенте можно с помощью свойства приложения <<cuba.web.rememberMeEnabled,cuba.web.rememberMeEnabled>>.

Стандартное окно входа содержит также выпадающий список поддерживаемых системой языков. Отображение списка и его содержимое определяются комбинацией свойств приложения <<cuba.localeSelectVisible,cuba.localeSelectVisible>> и <<cuba.availableLocales,cuba.availableLocales>>.

[[users]]
==== Пользователи

Для каждого пользователя системы создается соответствующий экземпляр сущности `sec$User`. Он содержит уникальный логин, хэш пароля, ссылку на группу доступа, список ролей и другие атрибуты. Управление пользователями осуществляется с помощью экрана *Administration* → *Users*:

image::security_user_browser.png[align="center"]

Помимо стандартных действий создания, изменения и удаления записей имеются следующие:

* *Copy* - быстрое создание нового пользователя на основе выбранного. Новый пользователь будет иметь такую же группу доступа и набор ролей. И то и другое можно изменить в появляющемся экране редактирования нового пользователя.

* *Copy settings* - позволяет скопировать выбранным пользователям настройки интерфейса, сделанные каким-либо другим пользователем. Настройки интерфейса включают в себя <<gui_Table_presentations,представления таблиц>>, положение разделителей контейнеров <<gui_SplitPanel,SplitPanel>>, наборы <<gui_Filter,фильтров>> и <<folders_pane,папок поиска>>.

* *Change password* - позволяет администратору системы задать новый пароль выбранному пользователю.

* *Reset passwords* - позволяет произвести следующие действия над выбранными пользователями:

** Если в появляющемся окне *Reset passwords for selected users* не включать флажок *Generate new passwords*, то пользователям будет установлен признак *Change password at next logon*. При следующем успешном логине пользователя ему будет предложено сменить свой пароль.

** Если в окне *Reset passwords for selected users* включить флажок *Generate new passwords*, то для выбранных пользователей будут сгенерированы и показаны новые случайные пароли. Список новых паролей можно выгрузить в формат XLS, и например, разослать пользователям. Кроме того, для каждого пользователя будет установлен признак *Change password at next logon*, что делает сгенерированный пароль одноразовым.

** Если в дополнение к *Generate new passwords* включить флажок *Send emails with generated passwords*, то новые одноразовые пароли не будут показаны администратору, а автоматически разосланы соответствующим пользователям на их адреса email.

Рассмотрим экран редактирования пользователя:

image::security_user_editor.png[align="center"]

* *Login* - обязательный к заполнению уникальный логин пользователя.

* *Group* - <<groups,группа доступа>>.

* *Last name*, *First name*, *Middle name* - части полного имени пользователя.

* *Name* - полное имя пользователя. Автоматически формируется на основе вводимых частей (Last, First, Middle) и правила, заданного свойством приложения <<cuba.user.fullNamePattern,cuba.user.fullNamePattern>>. Может быть произвольно изменено вручную.

* *Position* - должность.

* *Language* - язык интерфейса, устанавливаемый для пользователя, если возможность выбирать язык при входе в систему отключена при помощи свойства приложения <<cuba.localeSelectVisible,cuba.localeSelectVisible>>.

* *Time Zone* – <<timeZone,часовой пояс>>, в соответствии с которым будут отображаться и вводиться значения типа timestamp.

* *Email* - адрес email.

* *Active* - если данный флаг не установлен, то пользователь не может войти в систему.

* *Permitted IP Mask* - маска разрешенных IP-адресов, с которых возможен вход в систему.
+
Маска представляет собой список адресов через запятую. Поддерживаются как адреса формата IPv4, так и адреса формата IPv6. В первом случае адрес должен состоять из четырех чисел, разделенных точками, при этом любая часть вместо числа может содержать знак "++*++", что означает "любое число". Адрес в формате IPv6 представляет собой восемь групп по четыре шестнадцатеричные цифры, разделенных двоеточием. Любая группа также может быть заменена знаком "++*++".
+
Маска может содержать адреса только одного формата. Наличие адресов формата IPv4 и IPv6 одновременно недопустимо.
+
Пример: `++192.168.*.*++`

* *Roles* - список <<roles,ролей>> пользователя.

* *Substituted Users* - список <<user_substitution,замещаемых>> пользователей.

[[user_substitution]]
===== Замещение пользователей

Администратор системы может дать возможность пользователю _замещать_ другого пользователя. При этом у замещающего пользователя <<userSession,сессия>> не меняется, а подменяется набор <<roles,ролей>>, <<constraints,ограничений>> и <<session_attr,атрибутов>>. Все эти параметры текущий пользователь получает от замещаемого пользователя. 

[TIP]
====
В прикладном коде для получения текущего пользователя рекомендуется использовать метод `UserSession.getCurrentOrSubstitutedUser()` возвращающий либо замещаемого пользователя, либо пользователя, выполнившего логин (если замещения в данный момент нет).

В то же время механизмы аудита платформы (атрибуты `createdBy` и `updatedBy`, <<entity_log,журнал изменений>> и <<entity_snapshots,снимки>> сущностей) всегда регистрируют пользователя, который произвел логин, а не замещаемого пользователя.
====

Если пользователь имеет замещаемых пользователей, то в правом верхнем углу главного окна приложения вместо простой надписи с именем текущего пользователя отображается выпадающий список:

image::user_subst_select.png[align="center"]

При выборе другого пользователя в этом списке все открытые экраны будут закрыты, и произойдет замещение. После этого метод `UserSession.getUser()` по прежнему будет возвращать пользователя, выполнившего логин в систему, а метод `UserSession.getSubstitutedUser()` - замещенного пользователя. Если замещения нет, метод `UserSession.getSubstitutedUser()` возвращает `null`.

Управление замещаемыми пользователями производится с помощью таблицы *Substituted Users* экрана редактирования пользователя. Рассмотрим экран добавления замещаемого пользователя:

image::user_subst_edit.png[align="center"]

* *User* - текущий редактируемый пользователь. Он будет замещать другого пользователя.

* *Substituted user* - замещаемый пользователь.

* *Start date*, *End date* - необязательный период замещения. Вне периода замещение будет недоступным. Если период не указан, замещение доступно, пока не удалена данная запись таблицы.

[[timeZone]]
==== Часовой пояс

Все значения даты и времени по умолчанию отображаются в соответствии с часовым поясом сервера. Часовой пояс сервера возвращается методом `TimeZone.getDefault()` <<app_tiers,блока>> приложения. По умолчанию, платформа получает часовой пояс из операционной системы, однако его можно явно задать системным свойством Java `user.timezone`. Например, чтобы задать часовой пояс по Гринвичу для веб-клиента и Middleware, работающих на сервере Tomcat под Unix, нужно добавить в файл `tomcat/bin/setenv.sh` следующее свойство: 

[source, bash]
----
CATALINA_OPTS="$CATALINA_OPTS -Duser.timezone=GMT"
---- 

Пользователь может просматривать и редактировать значения типа timestamp в часовых поясах, отличных от часового пояса сервера. Существует два способа управления часовыми поясами пользователя: 

* Администратор может задать часовой пояс в экране редактирования пользователя.

* Пользователь может задать свой часовой пояс в окне *Help → Settings*.

В обоих случаях, часовой пояс настраивается при помощи двух полей: 

* Выпадающий список с названиями часовых поясов позволяет явно выбрать часовой пояс.

* Флажок *Auto* указывает, что часовой пояс будет получен из текущего окружения (для веб-клиента - из веб-браузера, для для десктоп-клиента - из операционной системы). 

Если оба поля пусты, часовые пояса для пользователя не конвертируются. В противном случае, платформа сохраняет часовой пояс в объекте <<userSession,UserSession>> при логине и использует его для ввода и отображения значений типа timestamp. Значение, возвращаемое методом `UserSession.getTimeZone()` может также использоваться и в прикладном коде.

Если часовой пояс используется для текущей сессии, его краткое имя и отклонение от времени по Гринвичу отображаются в главном окне приложения рядом с именем текущего пользователя.

[TIP]
====
Преобразование часовых поясов выполняется только для атрибутов типа <<datatype,DateTimeDatatype>>, то есть, содержащих timestamp. Атрибуты, хранящие только дату (`DateDatatype`) или время (`TimeDatatype`) по отдельности, не конвертируются. Вы можете запретить преобразование отдельных timestamp-атрибутов, установив для них аннотацию <<ignoreUserTimeZone,@IgnoreUserTimeZone>>.
====

[[permissions]]
==== Разрешения

_Разрешение_ определяет право пользователя на какой-либо объект или функциональность системы: экран, операцию над сущностью и так далее. Разрешение в зависимости от своего значения может как дать пользователю право на объект, так и отобрать его (то есть по сути являться _запрещением_).

[TIP]
====
Если явного разрешения на объект не установлено, пользователь имеет право на этот объект.
====

Разрешения представляются экземплярами сущности `sec$Permission` и содержат следующие атрибуты:

* `type` - тип разрешения: определяет, на какой тип объектов накладывается разрешение.

* `target` - конкретный объект разрешения. Формат представления объекта зависит от типа разрешения.

* `value` - значение разрешения. Диапазон значений зависит от типа разрешения.

Рассмотрим типы разрешений:

* `PermissionType.SCREEN` - разрешение на экран системы.
+
В атрибуте `target` указывается идентификатор экрана, атрибут `value` может иметь значения 0 или 1 (экран запрещен или разрешен соответственно).
+
Права на экраны проверяются при построении главного меню системы и при каждом вызове методов `openWindow()`, `openEditor()`, `openLookup()` интерфейса <<abstractFrame,Frame>>.
+
Для проверки права на экран в прикладном коде используйте метод `isScreenPermitted()` интерфейса <<security,Security>>.

* `++PermissionType.ENTITY_OP++` - разрешение на операцию c сущностью.
+
В атрибуте `target` указывается имя сущности и через символ ":" имя операции: `create`, `read`, `update`, `delete`. Например: `library$Book:delete`. Атрибут `value` может иметь значения 0 или 1 (операция запрещена или разрешена соответственно).
+
Права на операции с сущностью проверяются при работе с данными через <<dataManager,DataManager>>, а также в связанных с данными <<gui_components,визуальных компонентах>> и <<standard_actions,стандартных действиях>> со списками сущностей. В результате права на операции оказывают влияние на поведение клиентских блоков и <<rest_api,REST API>>. При работе с данными непосредственно на Middleware через <<entityManager,EntityManager>> права не проверяются.
+
Для проверки права на операцию c сущностью в прикладном коде используйте метод `isEntityOpPermitted()` интерфейса <<security,Security>>.

* `++PermissionType.ENTITY_ATTR++` - разрешение на атрибут сущности.
+
В атрибуте `target` указывается имя сущности и через символ ":" имя арибута, например: `library$Book:name`. Атрибут `value` может иметь значения 0, 1 или 2 (атрибут скрыт, только для чтения, или полностью разрешен соответственно).
+
Права на атрибуты сущностей проверяются только в связанных с данными <<gui_components,визуальных компонентах>> и <<rest_api,REST API>>.
+
Для проверки права на атрибут сущности в прикладном коде используйте метод `isEntityAttrPermitted()` интерфейса <<security,Security>>.

* `PermissionType.SPECIFIC` - разрешение на произвольную именованную функциональность.
+
В атрибуте `target` указывается код функциональности, атрибут `value` может иметь значения 0 или 1 (запрещено или разрешено соответственно).
+
Набор специфических разрешений для данного проекта задается в конфигурационном файле <<permissions.xml,permissions.xml>>.
+
Пример использования:
+
[source, java]
----
@Inject
private Security security;

private void calculateBalance() {
    if (!security.isSpecificPermitted("myapp.calculateBalance"))
        return;
    ...
}
----

* `PermissionType.UI` - разрешение на произвольный компонент экрана.
+
В атрибуте `target` указывается идентификатор экрана и через символ ":" путь к компоненту. Описание формата пути см. в следующем разделе.

[TIP]
====
Для проверки разрешений вместо непосредственного использования методов класса `UserSession` рекомендуется использовать аналогичные методы интерфейса <<security,Security>>, принимающие во внимание возможное <<entity_extension,расширение>> сущностей.
====

[[roles]]
==== Роли

Роль объединяет набор <<permissions,разрешений>>, которые могут быть предоставлены пользователю.

Пользователь может иметь несколько ролей. При этом он получает логическую сумму (ИЛИ) прав на некоторый объект от всех ролей, которые у него есть. Например, если пользователю назначены роли A, B и C, роль A запрещает X, роль B разрешает X, роль C не устанавливает явных разрешений на X, то в итоге X будет разрешен.

Если ни одна роль пользователя не определяет явно разрешения на объект, то пользователь имеет право на данный объект. Таким образом, пользователь имеет права на все объекты, на которые либо ни одна роль явно не определяет разрешения, либо хотя бы одна роль определяет, что право есть.

[WARNING]
====
Если пользователю дать единственную роль без явно установленных разрешений, или не давать никаких ролей вообще, то у него будут все права на все объекты. 
====

Список ролей отображается экраном *Administration* → *Roles*. Здесь помимо стандартных действий создания, изменения и удаления записей имеется кнопка *Assign to users*, позволяющая назначить выбранную роль сразу нескольким пользователям.

Рассмотрим экран редактирования роли. В верхней его части отображаются атрибуты роли: 

image::role_attributes.png[align="center"]

* *Name* - обязательное уникальное имя (или код) роли. Не может быть изменено после создания.

* *Localized name* - понятное пользователю название роли.

* *Description* - произвольное описание роли.

* *Type* - тип роли, может быть следующим:

** *Standard* - в роли данного типа действуют только явно назначенные разрешения.

** *Super* - роль данного типа автоматически дает все разрешения. Это удобно для назначения администраторов системы, так как она отменяет все запрещения, установленные другими ролями. 

** *Read-only* - роль данного типа автоматически отнимает разрешения на следующие операции с сущностями: CREATE, UPDATE, DELETE. Таким образом, пользователь с такой ролью может только читать данные, и не может их изменять (если какая-либо другая роль этого пользователя не разрешает явно эти операции).

**  *Denying* - запрещающая роль. Роль данного типа автоматически отнимает разрешения на все объекты, кроме атрибутов сущностей. Чтобы пользователь с данной ролью мог что-то увидеть или изменить в системе, ему нужно назначить дополнительно другую роль, явно дающую нужные права. 
+
Роли всех типов могут иметь явно установленные разрешения, например в *Read-only* роль можно добавить разрешения на модификацию некоторых сущностей. Однако для роли *Super* явная установка каких-либо запрещений не имеет смысла, так как наличие роли данного типа в любом случае отменяет все запрещения. 
+
[WARNING]
====
Пользователь с запрещающей ролью не сможет войти в десктоп или веб клиент, так как роль данного типа отнимает также специфическое разрешение `cuba.gui.loginToClient` (отображаемое в списке специфических разрешений как "Login to client"). Поэтому необходимо дать это разрешение пользователям явно - в какой-либо другой роли, либо прямо в запрещающей.
====

* *Default role* - признак роли по умолчанию. Все роли с данным признаком автоматически назначаются вновь создаваемым пользователям.

Ниже отображаются вкладки управления разрешениями.

* Вкладка *Screens* - разрешения на экраны системы:
+
image::role_screen_permissions.png[align="center"]
+
Дерево в левой части вкладки отражает структуру главного меню системы. Последним элементом дерева является *Other screens*, внутри которого сосредоточены экраны, не включенные в главное меню (например, экраны редактирования сущностей).

* Вкладка *Entities* - разрешения на операции с сущностями:
+
image::role_entity_permissions.png[align="center"]
+
При переходе на данную вкладку изначально включен флажок *Assigned only*, поэтому в таблице отображаются только сущности, для которых в данной роли уже есть явные разрешения. Поэтому для новой роли таблица пуста. Для установки разрешений снимите флажок *Assigned only* и нажмите *Apply*. Список сущностей можно фильтровать, вводя в поле *Entity* любую часть имени сущности и нажимая *Apply*.
+
Установив флажок *System level*, можно выбрать системную сущность, помеченную аннотацией `@SystemLevel`. По умолчанию такие сущности не показываются в таблице.

* Вкладка *Attributes* - разрешения на атрибуты сущностей:
+
image::role_attr_permissions.png[align="center"]
+
В таблице сущностей в колонке *Permissions* отображается список атрибутов, для которых явно указаны разрешения. Зеленым цветом обозначено разрешение *modify* (полный доступ), синим цветом - *read-only* (только чтение), красным - *hide* (атрибут скрыт).
+
Управление списком сущностей аналогично описанному для вкладки *Entities*.

* Вкладка *Specific* - разрешения на именованную функциональность:
+
image::role_specific_permissions.png[align="center"]
+
Имена объектов, на которые могут быть назначены специфические разрешения, определяются в конфигурационном файле <<permissions.xml,permissions.xml>> проекта.

* Вкладка *UI* - разрешения на UI-компоненты экранов:
+
image::role_ui_permissions.png[align="center"]
+
Разрешения данного типа дают возможность ограничить доступ к любому компоненту экрана, в том числе не связанному с данными (например, к контейнеру). Для создания таких разрешений необходимо знать идентификаторы компонентов, а значит, иметь доступ к исходному коду экранов.
+
Для создания ограничения выберите нужный экран в выпадающем списке *Screen*, задайте путь к компоненту в поле *Component*, и нажмите *Add*. После этого установите режим доступа к выбранному компоненту в панели *Permissions*.
+
Правила формирования пути к компоненту:

** Если компонент принадлежит экрану, указывается просто идентификатор компонента `id`.

** Если компонент принадлежит фрейму, вложенному в экран, то сначала указывается идентификатор фрейма, а затем через точку идентификатор компонента внутри фрейма.

** Если необходимо установить разрешение для вкладки <<gui_TabSheet,TabSheet>> или поля <<gui_FieldGroup,FieldGroup>>, то сначала указывается идентификатор компонента, а затем в квадратных скобках идентификатор соответственно вкладки или поля.

** Чтобы установить разрешение на <<gui_Action,действие>>, необходимо указать идентификатор компонента, содержащего действие, а затем идентификатор действия в угловых скобках. Например: `customersTable<changeGrade>`.

[[groups]]
==== Группы доступа

Группы доступа позволяют организовывать пользователей в иерархическую структуру для установки <<constraints,ограничений>> и для присвоения произвольных <<session_attr,атрибутов сессии>>.

Пользователь может быть причислен только к одной группе, однако он получит список ограничений и атрибутов сессии от всех групп вверх по иерархии.

Управление группами доступа осуществляется в экране *Administration* → *Access Groups*:

image::group_users.png[align="center"]

[[constraints]]
===== Ограничения

Ограничения (Constraints) дают возможность ограничить доступ к определенным экземплярам сущностей (записям таблиц).

Ограничения задаются для класса сущности с помощью фрагментов выражений на языке <<jpql,JPQL>>. Эти фрагменты затем подставляются в запросы каждый раз при выборке списка экземпляров данной сущности, тем самым фильтруя их.

Пользователь получает список ограничений от всех групп начиная со своей и вверх по иерархии. Тем самым реализуется принцип: чем ниже пользователь в иерархии групп, тем больше у него ограничений.

Для создания ограничения в экране *Access Groups* выберите группу, на которую нужно наложить ограничение, перейдите на вкладку *Constraints* и нажмите *Create*:

image::constraint_edit.png[align="center"]

Далее выберите сущность в выпадающем списке *Entity Name* и задайте ограничение в полях *Join Clause* и *Where Clause*.
[TIP]
====
Редактор JPQL в полях *Join Clause* и *Where Clause* поддерживает автодополнение имен сущностей и их атрибутов. Для вызова автодополнения нажмите *Ctrl+Space*. Если вызов произведен после точки, будет выведен список атрибутов сущности, соответствующей контексту, иначе - список всех сущностей модели данных.
====

Правила формирования ограничения:

* В качестве алиаса извлекаемой сущности необходимо использовать строку `{E}`. При выполнении запросов она будет заменена на реальный алиас, заданный в запросе.

* В параметрах JPQL можно использовать следующие предопределенные константы:

** `session$userLogin` − имя учетной записи текущего пользователя (в случае <<user_substitution,замещения>> − имя учетной записи замещаемого пользователя).

** `session$userId` − ID текущего пользователя (в случае замещения − ID замещаемого пользователя).

** `session$userGroupId` − ID группы текущего пользователя (в случае замещения − ID группы замещаемого пользователя).

** `session$XYZ` − произвольный атрибут текущей <<userSession,пользовательской сессии>>, где XYZ − имя атрибута.

* Содержимое поля *Where Clause* добавляется в выражение `where` запроса по условию `and` (И). Само слово `where` писать не нужно, оно будет добавлено автоматически, даже если исходный запрос его не содержал.

* Содержимое поля *Join Clause* добавляется в выражение `from` запроса. Оно должно начинаться с запятой или слов `join` или `left join`.

Простейший пример ограничения приведен на рисунке выше: пользователи с данным ограничением будут видеть только те экземпляры сущности `library$BookPublication`, которые они создали сами. 

[[session_attr]]
===== Атрибуты сессии

Группа доступа может определять список атрибутов <<userSession,сессии>> для пользователей, входящих в данную группу. Эти атрибуты можно использовать при настройке <<constraints,ограничений>>. Кроме того, на этапе разработки в прикладной код системы можно заложить анализ наличия некоторых атрибутов сессии, и тем самым управлять поведением готовой системы для конкретных групп пользователей на этапе эксплуатации. 

В пользовательскую сессию при входе в систему будут помещены все атрибуты, заданные для группы, в которой находится пользователь, и для всех родительских групп вверх по иерархии. При этом если атрибут встречается в иерархии групп несколько раз, значение он получит от самой верхней группы, то есть переопределение значений атрибутов на нижнем уровне невозможно. При попытке переопределения в <<logging_setup_tomcat,журнал>> сервера будет выведено сообщение с уровнем `WARN`. 

Для создания атрибута в экране *Access Groups* выберите группу, перейдите на вкладку *Session Attributes* и нажмите *Create*:

image::session_attr_edit.png[align="center"]

В данном экране необходимо задать уникальное имя атрибута, тип данных и значение.

Получить атрибут <<userSession,сессии>> в коде приложения можно следующим способом:

[source, java]
----
@Inject
private UserSessionSource userSessionSource;
...
Integer accessLevel = userSessionSource.getUserSession().getAttribute("accessLevel");
----

Использовать атрибут в <<constraints,ограничениях>> можно, указав его в параметре JPQL с префиксом `session$`:

[source, java]
----
{E}.accessLevel = :session$accessLevel
----

[[ldap]]
==== Интеграция с LDAP

Интеграция CUBA-приложения c LDAP позволяет решить две задачи:

. Хранить пароли пользователей и управлять ими централизованно в базе данных LDAP.

. Для пользователей компьютеров, входящих в домен Windows, выполнять логин в приложение без ввода имени и пароля (то есть организовывать Single Sign-On).

Для входа в систему пользователь должен быть заведен в приложении с нужными свойствами и правами. Пароль рекомендуется не указывать, тогда пользователь сможет войти в систему только с паролем из LDAP. Сначала производится попытка аутентифицировать пользователя через LDAP, а если она не удалась, то обычным способом через хранимый в базе данных приложения хэш пароля. Поэтому если для некоторого пользователя пароль в приложении задан, он сможет войти в систему с этим паролем, даже если в LDAP такого пользователя нет или у него там другой пароль.

Взаимодействие CUBA-приложения с LDAP осуществляется через интерфейс `CubaAuthProvider`. Платформа содержит единственную реализацию данного интерфейса - `LdapAuthProvider`, предназначенную для решения первой задачи. Для расширенной интеграции с Active Directory и обеспечения Single Sign-On можно использовать библиотеку *Jespa* и соответствующую имплементацию `CubaAuthProvider`, которая описана в <<jespa,Настройка аутентификации с использованием Jespa>>. При необходимости можно также создать собственный класс имплементации `CubaAuthProvider` и использовать его, установив следующие свойства приложения:

[source, properties]
----
cuba.web.ExternalAuthentication = true
cuba.web.externalAuthenticationProviderClass = com.company.sample.web.MyAuthProvider
----

[[ldap_basic]]
===== Базовая интеграция с Active Directory

Класс `LdapAuthProvider` используется по умолчанию при включенном свойстве приложения `cuba.web.ExternalAuthentication`. В этом случае для аутентификации пользователей используется библиотека *Spring LDAP*.

Для настройки интеграции используются следующие свойства приложения блока Web Client:

* `cuba.web.ldap.urls` - URL сервера Active Directory

* `cuba.web.ldap.base` - база поиска имен пользователей

* `cuba.web.ldap.user` - значение атрибута `sAMAccountName` пользователя, имеющего право на чтение информации из Active Directory

* `cuba.web.ldap.password` - пароль пользователя, заданного свойством `cuba.web.ldap.user`.

Пример содержимого файла <<app_properties_files,local.app.properties>> блока Web Client:

[source, properties]
----
cuba.web.ExternalAuthentication = true
cuba.web.ldap.urls = ldap://192.168.1.1:389
cuba.web.ldap.base = ou=Employees,dc=mycompany,dc=com
cuba.web.ldap.user = myuser
cuba.web.ldap.password = mypassword
----

[[jespa]]
===== Настройка аутентификации с использованием Jespa

*Jespa* − библиотека для *Java*, обеспечивающая расширенную интеграцию между службой каталогов *Active Directory* и Java-приложениями по протоколу link:$$http://en.wikipedia.org/wiki/NTLMv2#NTLMv2$$[NTLMv2]. Подробно о библиотеке см. link:$$http://www.ioplex.com$$[http://www.ioplex.com]. 

====== Подключение библиотеки

Загрузите библиотеку с сайта link:$$http://www.ioplex.com$$[http://www.ioplex.com] и разместите JAR в каком-либо <<artifact_repository,репозитории>>, зарегистрированном в вашем скрипте сборки <<build.gradle,build.gradle>>. Это может быть `mavenLocal()` или репозиторий вашей организации.

В файле `build.gradle` в секции конфигурации модуля *web* добавьте зависимость:

[source, java]
----
configure(webModule) {
    ...
    dependencies {
        compile('com.company.thirdparty:jespa:1.1.17')
    ...    
----

Создайте в модуле *web* класс реализации интерфейса `CubaAuthProvider`:

[source, java]
----
package com.company.sample.web;

import com.haulmont.cuba.core.global.AppBeans;
import com.haulmont.cuba.core.global.Configuration;
import com.haulmont.cuba.core.global.GlobalConfig;
import com.haulmont.cuba.core.global.Messages;
import com.haulmont.cuba.core.sys.AppContext;
import com.haulmont.cuba.security.global.LoginException;
import com.haulmont.cuba.web.auth.ActiveDirectoryHelper;
import com.haulmont.cuba.web.auth.CubaAuthProvider;
import com.haulmont.cuba.web.auth.DomainAliasesResolver;
import jespa.http.HttpSecurityService;
import jespa.ntlm.NtlmSecurityProvider;
import jespa.security.PasswordCredential;
import jespa.security.SecurityProviderException;
import org.apache.commons.lang.StringUtils;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

import javax.inject.Inject;
import javax.servlet.*;
import javax.servlet.http.HttpServletRequest;
import java.io.IOException;
import java.util.HashMap;
import java.util.Locale;
import java.util.Map;

public class JespaAuthProvider extends HttpSecurityService implements CubaAuthProvider {

    private static class DomainInfo {
        private String bindStr;
        private String acctName;
        private String acctPassword;

        private DomainInfo(String bindStr, String acctName, String acctPassword) {
            this.acctName = acctName;
            this.acctPassword = acctPassword;
            this.bindStr = bindStr;
        }
    }

    private static Map<String, DomainInfo> domains = new HashMap<>();

    private static String defaultDomain;

    private Log log = LogFactory.getLog(getClass());

    @Inject
    private Configuration configuration;

    @Inject
    private Messages messages;

    @SuppressWarnings("deprecation")
    @Override
    public void init(FilterConfig filterConfig) throws ServletException {

        initDomains();

        Map<String, String> properties = new HashMap<>();

        properties.put("jespa.bindstr", getBindStr());
        properties.put("jespa.service.acctname", getAcctName());
        properties.put("jespa.service.password", getAcctPassword());
        properties.put("jespa.account.canonicalForm", "3");
        properties.put("jespa.log.path", configuration.getConfig(GlobalConfig.class).getLogDir() + "/jespa.log");
        properties.put("http.parameter.anonymous.name", "anon");

        fillFromSystemProperties(properties);

        try {
            super.init(properties);
        } catch (SecurityProviderException e) {
            throw new ServletException(e);
        }
    }

    @Override
    public void destroy() {
    }

    @Override
    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)
            throws IOException, ServletException {
        HttpServletRequest httpServletRequest = (HttpServletRequest) request;
        if (httpServletRequest.getHeader("User-Agent") != null) {
            String ua = httpServletRequest.getHeader("User-Agent").toLowerCase();
            boolean windows = ua.contains("windows");
            boolean gecko = ua.contains("gecko") && !ua.contains("webkit");
            if (!windows && gecko) {
                chain.doFilter(request, response);
                return;
            }
        }
        super.doFilter(request, response, chain);
    }

    @Override
    public void authenticate(String login, String password, Locale loc) throws LoginException {
        DomainAliasesResolver aliasesResolver = AppBeans.get(DomainAliasesResolver.NAME);

        String domain;
        String userName;

        int atSignPos = login.indexOf("@");
        if (atSignPos >= 0) {
            String domainAlias = login.substring(atSignPos + 1);
            domain = aliasesResolver.getDomainName(domainAlias).toUpperCase();
        } else {
            int slashPos = login.indexOf('\\');
            if (slashPos <= 0) {
                throw new LoginException(
                        messages.getMessage(ActiveDirectoryHelper.class, "activeDirectory.invalidName", loc),
                        login
                );
            }
            String domainAlias = login.substring(0, slashPos);
            domain = aliasesResolver.getDomainName(domainAlias).toUpperCase();
        }

        userName = login;

        DomainInfo domainInfo = domains.get(domain);
        if (domainInfo == null) {
            throw new LoginException(
                    messages.getMessage(ActiveDirectoryHelper.class, "activeDirectory.unknownDomain", loc),
                    domain
            );
        }

        Map<String, String> params = new HashMap<>();
        params.put("bindstr", domainInfo.bindStr);
        params.put("service.acctname", domainInfo.acctName);
        params.put("service.password", domainInfo.acctPassword);
        params.put("account.canonicalForm", "3");
        fillFromSystemProperties(params);

        NtlmSecurityProvider provider = new NtlmSecurityProvider(params);
        try {
            PasswordCredential credential = new PasswordCredential(userName, password.toCharArray());
            provider.authenticate(credential);
        } catch (SecurityProviderException e) {
            throw new LoginException(
                    messages.getMessage(ActiveDirectoryHelper.class, "activeDirectory.authenticationError", loc),
                    e.getMessage()
            );
        }
    }

    private void initDomains() {
        String domainsStr = AppContext.getProperty("cuba.web.activeDirectoryDomains");
        if (!StringUtils.isBlank(domainsStr)) {
            String[] strings = domainsStr.split(";");
            for (int i = 0; i < strings.length; i++) {
                String domain = strings[i];
                domain = domain.trim();
                if (!StringUtils.isBlank(domain)) {
                    String[] parts = domain.split("\\|");
                    if (parts.length != 4) {
                        log.error("Invalid ActiveDirectory domain definition: " + domain);
                        break;
                    } else {
                        domains.put(parts[0], new DomainInfo(parts[1], parts[2], parts[3]));
                        if (i == 0)
                            defaultDomain = parts[0];
                    }
                }
            }
        }
    }

    public String getDefaultDomain() {
        return defaultDomain != null ? defaultDomain : "";
    }

    public String getBindStr() {
        return getBindStr(getDefaultDomain());
    }

    public String getBindStr(String domain) {
        initDomains();
        DomainInfo domainInfo = domains.get(domain);
        return domainInfo != null ? domainInfo.bindStr : "";
    }

    public String getAcctName() {
        return getAcctName(getDefaultDomain());
    }

    public String getAcctName(String domain) {
        initDomains();
        DomainInfo domainInfo = domains.get(domain);
        return domainInfo != null ? domainInfo.acctName : "";
    }

    public String getAcctPassword() {
        return getAcctPassword(getDefaultDomain());
    }

    public String getAcctPassword(String domain) {
        initDomains();
        DomainInfo domainInfo = domains.get(domain);
        return domainInfo != null ? domainInfo.acctPassword : "";
    }

    public void fillFromSystemProperties(Map<String, String> params) {
        for (String name : AppContext.getPropertyNames()) {
            if (name.startsWith("jespa.")) {
                params.put(name, AppContext.getProperty(name));
            }
        }
    }
}
----

====== Настройка конфигурации

* Выполнить настройки, описанные в разделе *Installation* → *Step 1: Create the Computer Account for NETLOGON Communication* руководства *Jespa Operator's Manual*, которое можно загрузить по адресу link:$$http://www.ioplex.com/support.html$$[http://www.ioplex.com/support.html].

* Задать параметры доменов в <<app_properties_files,local.app.properties>> в свойстве приложения `cuba.web.activeDirectoryDomains`. Каждый описатель домена имеет формат `++domain_name|full_domain_name|service_account_name|service_account_password++`. Описатели доменов отделяются друг от друга точкой с запятой. 
+
Например:
+
[source, properties]
----
cuba.web.activeDirectoryDomains = MYCOMPANY|mycompany.com|JESPA$@MYCOMPANY.COM|password1;TEST|test.com|JESPA$@TEST.COM|password2
----

* Разрешить интеграцию с Active Directory, установив в `local.app.properties` свойство приложения `cuba.web.ExternalAuthentication`:
+
[source, properties]
----
cuba.web.ExternalAuthentication = true
----

* Задать в `local.app.properties` дополнительные свойства для библиотеки (см. *Jespa Operator's Manual*). Например:
+
[source, properties]
----
jespa.log.level=3
----

* Добавить адрес сервера в местную интрасеть в настройках браузера:

** Для *Internet Explorer* и *Chrome*: `Свойства обозревателя` → `Безопасность` → `Местная интрасеть` → `Узлы` → `Дополнительно`.

** Для Firefox: `about:config` → `network.automatic-ntlm-auth.trusted-uris=http://myapp.mycompany.com`.

[[security_examples]]
=== Примеры управления доступом

В данном разделе приведены практические рекомендации по настройке доступа пользователей к данным.

[[roles_example]]
==== Настройка ролей

Рекомендованный способ настройки <<roles,ролей>> и <<permissions,разрешений>>:

. Создать роль `*Default*`, отбирающую все права в системе. Проще всего это сделать, установив тип роли *Denying*. Включить флажок *Default role*, чтобы эта роль автоматически назначалась всем новым пользователям.

. Создать набор ролей, дающих нужные права различным категориям пользователей. Можно предложить две стратегии создания таких ролей:

* Крупнозернистые (coarse-grained) роли - каждая роль содержит набор разрешений для всего круга обязанностей пользователя в системе. Например `*Sales Manager*`, `*Accountant*`. В этом случае пользователям в дополнение к запрещающей `*Default*` роли необходимо назначить как правило только одну разрешающую роль.

* Мелкозернистые (fine-grained) роли - каждая роль содержит небольшой набор разрешений для выполнения пользователем некоторой функции в системе. Например `*Task Creator*`, `*References Editor*`. В этом случае пользователям в дополнение к запрещающей `*Default*` роли необходимо назначить несколько разрешающих ролей в соответствии с кругом их обязанностей.
+
Разумеется, ничто не мешает совмещать обе стратегии.

. Администратору системы можно просто не назначать никаких ролей вообще, тогда у него будут все права на все объекты системы. Пользователя с запрещающими ролями можно сделать администратором, добавив ему роль типа *Super*.

[[local_admins_example]]
==== Создание локальных администраторов

Иерархическая структура <<groups,групп доступа>> с наследованием <<constraints,ограничений>> позволяет создавать _локальных администраторов_ и делегировать им создание пользователей и настройку их прав в рамках подразделений организации. 

Локальному администратору доступны экраны подсистемы безопасности, однако он видит только пользователей и группы в своей группе доступа и ниже. Он может создавать подгруппы и пользователей и назначать им имеющиеся в системе <<roles,роли>>. При этом все создаваемые им пользователи будут иметь как минимум те же ограничения, что и он сам.

Глобальный администратор, находящийся в корневой группе доступа, лишенной ограничений, должен создать роли, которые будут доступны локальным администраторам для назначения пользователям. Сами локальные администраторы не должны иметь прав на создание и изменение ролей.

Рассмотрим следующую структуру групп доступа:

image::local_admins_groups.png[align="center"]

Задача:

* Пользователи внутри группы `*Departments*` должны видеть только пользователей своей группы и ниже.

* В каждой из групп `*Dept 1*`, `*Dept 2*`, и т.д. должен быть свой локальный администратор, который может создавать пользователей и назначать им имеющиеся роли.

Способ решения задачи:

* Задать для группы `*Departments*` следующие ограничения:
+
image::local_admins_constraints.png[align="center"]

** Для сущности `sec$Group`:
+
[source, jpql]
----
{E}.id in (
  select h.group.id from sec$GroupHierarchy h
  where h.group.id = :session$userGroupId or h.parent.id = :session$userGroupId
)
----
+
Это ограничение не позволяет пользователям видеть группы выше своей собственной.

** Для сущности `sec$User`:
+
[source, jpql]
----
{E}.group.id in (
  select h.group.id from sec$GroupHierarchy h
  where h.group.id = :session$userGroupId or h.parent.id = :session$userGroupId
)
----
+
Это ограничение не позволяет пользователям видеть других пользователей, входящих в группы выше своей собственной.

** Для сущности `sec$Role`:
+
[source, jpql]
----
({E}.description is null or {E}.description not like '[hide]')
----
+
Данное ограничение не позволяет пользователям видеть роли, в атрибуте `description` которых записана строка `*[hide]*`.

* Создать роль, которая запретит редактирование ролей и разрешений:
+
image::local_admins_role.png[align="center"]

** Установите флажок *Default role*.

** В поле *Description* добавьте строку `*[hide]*`.

** На вкладке *Entities* запретите операции *create*, *update*, *delete* для сущностей `sec$Role` и `sec$Permission` (для добавления разрешений на объект `sec$Permission` установите флажок *System level*).
+
Все создаваемые пользователи, включая локальных администраторов, будут получать роль `*local_user*`. Эта роль невидима для пользователей группы `*Departments*`, поэтому даже локальные администраторы не смогут ее с себя снять. В результате они смогут оперировать только существующими ролями, созданными для них глобальным администратором. Разумеется, эти роли не должны отменять запрещений, введенных ролью `*local_user*`.
