[[common_components]]
=== Общие компоненты

В данной главе рассмотрены компоненты платформы, общие для всех <<app_tiers,уровней>> приложения.

[[data_model]]
==== Модель данных

Предметная область моделируется в приложении с помощью взаимосвязанных классов Java, называемых классами сущностей или просто сущностями. 

Сущности подразделяются на две категории:

* персистентные – экземпляры таких сущностей хранятся в таблицах базы данных

* неперсистентные – экземпляры существуют только в оперативной памяти

Сущности характеризуются своими атрибутами. Атрибут соответствует полю класса и паре методов доступа (get / set) к полю. Чтобы атрибут был неизменяемым (read only), достаточно не создавать метод set. 

Персистентные сущности могут включать в себя атрибуты, не хранящиеся в БД. В случае неперсистентного атрибута можно не создавать поле класса, ограничившись методами доступа.

Класс сущности должен удовлетворять следующим требованиям: 

* наследоваться от одного из базовых классов, предоставляемых платформой (см. ниже)

* иметь набор полей и методов доступа, соответствующих атрибутам сущностей

* класс и его поля (или методы доступа при отсутствии для атрибута соответствующего поля) должны быть определенным образом <<entity_annotations,аннотированы>> для работы <<jpa,JPA>> (в случае персистентной сущности) и <<metadata_framework,фреймворка метаданных>> 

* для поддержки возможного <<extension,расширения>> сущностей поля класса необходимо объявлять с модификатором `protected`, а не `private`

Поддерживаются следующие типы атрибутов сущностей:

* `java.lang.String`

* `java.lang.Boolean`

* `java.lang.Integer`

* `java.lang.Long`

* `java.lang.Double`

* `java.math.BigDecimal`

* `java.util.Date`

* `java.sql.Date`

* `java.sql.Time`

* `java.util.UUID`

* `byte[]`

* `enum`

* сущность

Базовые классы сущностей (см. ниже) переопределяют `equals()` и `hashCode()` таким образом, что экземпляры сущностей сравниваются по их глобальным уникальным идентификаторам (UUID). То есть экземпляры считаются равными, если равны их идентификаторы. Глобальный уникальный идентификатор присваивается сразу после создания экземпляра в памяти, поэтому новые экземпляры также можно сравнивать и помещать в коллекции.

[[base_entity_classes]]
===== Базовые классы сущностей

Рассмотрим базовые классы и интерфейсы сущностей более подробно.

.Базовые классы сущностей
image::EntityClasses.png[align="center"]

* `Instance` – декларирует базовые методы работы с объектами предметной области:

** Получение глобального уникального идентификатора (UUID) сущности.

** Получение ссылки на мета-класс объекта.

** Генерация имени экземпляра.

** Чтение/установка значений атрибутов по имени.

** Добавление слушателей, получающих уведомления об изменениях атрибутов.

* `Entity` – дополняет `Instance` понятием идентификатора сущности (который не обязательно равен UUID), причем `Entity` не определяет тип идентификатора, оставляя эту возможность наследникам.

* `AbstractInstance` – реализует логику работы со слушателями изменения атрибутов.
+
[WARNING]
====
`AbstractInstance` хранит слушателей в коллекции `WeakReference`, т.е. при отсутствии внешних ссылок на добавленного слушателя, он будет немедленно уничтожен сборщиком мусора. Как правило, слушателями изменения атрибутов являются <<gui_vcl,визуальные компоненты>> и <<datasources,источники данных>> UI, на которые всегда имеются ссылки из других объектов, поэтому проблема исчезновения слушателей не возникает. Однако если слушатель создается прикладным кодом и на него никто не ссылается естественным образом, необходимо кроме добавления в `Instance` сохранить его в некотором поле объекта.
====

* `AbstractNotPersistentEntity` – базовый класс неперсистентных сущностей с идентификаторами типа `UUID`.

* `BaseEntity` – базовый интерфейс всех персистентных сущностей, декларирует методы получения информации о том, кто и когда создал экземпляр сущности в базе данных.

* `BaseGenericIdEntity` - реализует `BaseEntity` и добавляет аннотации для поддержки <<jpa,JPA>>, не специфицируя при этом тип идентификатора (то есть первичного ключа) сущности.

* `BaseUuidEntity` - расширяет `BaseGenericIdEntity`, задавая атрибут-идентификатор с именем `id` типа `UUID`.

* `BaseLongIdEntity` - расширяет `BaseGenericIdEntity`, задавая атрибут-идентификатор с именем `id` типа `Long`.

* `BaseIntegerIdEntity` - расширяет `BaseGenericIdEntity`, задавая атрибут-идентификатор с именем `id` типа `Integer`.

* `BaseStringIdEntity` - расширяет `BaseGenericIdEntity`, задавая только тип идентификатора - `String`. В конкретном классе сущности, унаследованной от `BaseStringIdEntity`, необходимо задать атрибут-идентификатор типа `String` и добавить ему <<jpa,JPA>>-аннотацию `@Id`.

* `Versioned` – интерфейс сущностей, поддерживающих <<optimistic_locking,оптимистичную блокировку>>

* `Updatable` – интерфейс сущностей, для которых требуется сохранять информацию о том, кто и когда изменял экземпляр в последний раз

* `SoftDelete` – интерфейс сущностей, поддерживающих <<soft_deletion,мягкое удаление>>

* `StandardEntity` – наиболее часто используемый базовый класс персистентных сущностей, имеющий идентификатор типа `UUID` и реализующий интерфейсы `Versioned`, `Updatable`, `SoftDelete`.

При создании классов сущностей рекомендуется выбирать базовый класс по следующим правилам:

* Если сущность не хранится в БД, наследуйте ее от `AbstractNotPersistentEntity`.

* Если сущность встраиваемая - наследуйте ее от `EmbeddableEntity`.

* Если сущность только создается в БД, никогда не изменяется, и мягкое удаление не требуется - наследуйте ее от `BaseUuidEntity`.

* Если сущность ведет себя стандартным образом: изменяется в БД, требует оптимистичной блокировки и мягкого удаления − наследуйте ее от `StandardEntity`.

* В противном случае наследуйте сущность от `BaseUuidEntity` и реализуйте в классе тот набор интерфейсов `Versioned`, `Updatable`, `SoftDelete`, который требуется.

* Иногда для некоторых сущностей желательно использовать целочисленные или строковые первичные ключи. В этом случае вместо `BaseUuidEntity` унаследуйте класс сущности от `BaseLongIdEntity`, `BaseIntegerIdEntity`, или `BaseStringIdEntity`.

[[entity_annotations]]
===== Аннотации сущностей

В данном разделе описаны все поддерживаемые платформой аннотации классов и атрибутов сущностей. 

Аннотации пакета `javax.persistence` обеспечивают работу <<jpa,JPA>>, аннотации пакетов `++com.haulmont.*++` предназначены для управления <<metadata_framework,метаданными>> и другими механизмами платформы. 

Если для аннотации указано только простое имя класса, подразумевается что это класс платформы, расположенный в одном из пакетов `++com.haulmont.*++`

[[entity_class_annotations]]
*Аннотации класса*

[[entity_annotation]]
`link:$$http://docs.oracle.com/javaee/5/api/javax/persistence/Entity.html$$[@javax.persistence.Entity]`
--
Объявляет класс сущностью модели данных. 

Параметры:

* `name` - имя сущности, обязательно должно начинаться с префикса, отделенного знаком `$`. Желательно использовать в качестве префикса короткое имя проекта для формирования отдельного пространства имен. 

Пример:

[source, java]
----
@Entity(name = "sales$Customer")
----
--

`link:$$http://docs.oracle.com/javaee/5/api/javax/persistence/MappedSuperclass.html$$[@javax.persistence.MappedSuperclass]`::
+
--
Определяет, что данный класс является предком некоторых сущностей, и его атрибуты должны быть использованы в составе сущностей-наследников. Такой класс не сопоставляется никакой отдельной таблице БД.

--
[[table_annotation]]
`@link:$$http://docs.oracle.com/javaee/5/api/javax/persistence/Table.html$$[javax.persistence.Table]`:: 
+
--
Определяет таблицу базы данных для данной сущности. 

Параметры:

* `name` - имя таблицы

Пример:

[source, java]
----
@Table(name = "SALES_CUSTOMER")
----
--

[[embeddable_annotation]]
`link:$$http://docs.oracle.com/javaee/5/api/javax/persistence/Embeddable.html$$[@javax.persistence.Embeddable]`::
+
--
Определяет встраиваемую сущность, экземпляры которой хранятся вместе с владеющей сущностью в той же таблице. 

Для задания имени сущности требуется применение аннотации <<metaclass_annotation,@MetaClass>>.
--

[[inheritance_annotation]]
`link:$$http://docs.oracle.com/javaee/5/api/javax/persistence/Inheritance.html$$[@javax.persistence.Inheritance]`::
+
--
Определяет стратегию наследования для иерархии классов сущностей. Данная аннотация должна быть помещена на корневом классе иерархии. 

Параметры:

* `strategy` - стратегия, по умолчанию `++SINGLE_TABLE++`
--

`@link:$$http://docs.oracle.com/javaee/5/api/javax/persistence/DiscriminatorColumn.html$$[javax.persistence.DiscriminatorColumn]`:: 
+
--
Используется для определения колонки БД, отвечающей за различение типов сущностей в случае стратегий наследования `++SINGLE_TABLE++` и `JOINED`. 

Параметры:

* `name` - имя колонки-дискриминатора

* `discriminatorType` - тип данных колонки-дискриминатора

Пример:

[source, java]
----
@DiscriminatorColumn(name = "TYPE", discriminatorType = DiscriminatorType.INTEGER)
----
--
`link:$$http://docs.oracle.com/javaee/5/api/javax/persistence/DiscriminatorValue.html$$[@javax.persistence.DiscriminatorValue]`::
+
--
Определяет значение колонки-дискриминатора для данной сущности. Эта аннотация должна быть помещена на конкретном классе сущности. 

Пример:

[source, java]
----
@DiscriminatorValue("0")
----
--

`link:$$http://docs.oracle.com/javaee/5/api/javax/persistence/PrimaryKeyJoinColumn.html$$[@javax.persistence.PrimaryKeyJoinColumn]`::
+
--
Используется в случае стратегии наследования `JOINED` для указания колонки внешнего ключа данной сущности, ссылающегося на первичный ключ сущности-предка. 

Параметры:

* `name` - имя колонки внешнего ключа данной сущности

* `referencedColumnName` - имя колонки первичного ключа сущности предка

Пример:

[source, java]
----
@PrimaryKeyJoinColumn(name = "CARD_ID", referencedColumnName = "ID")
----
--

[[namePattern]]
`@NamePattern`:: 
+
--
Определяет способ получения имени экземпляра, возвращаемого методом `Instance.getInstanceName()`.

Значением аннотации должна быть строка вида `{0}|{1}`, где 

* `{0}` - строка форматирования по правилам `String.format()`, или имя метода данного объекта с префиксом `#`. Метод должен возвращать `String` и не иметь параметров.

* `{1}` - разделенный запятыми список имен полей класса, соответствующий формату `{0}`. В случае использования в `{0}` метода список полей все равно необходим, так как по нему формируется <<views,представление>> `++_minimal++`.

Примеры:

[source, java]
----
@NamePattern("%s|name")
----

[source, java]
----
@NamePattern("#getCaption|login,name")
----
--

[[listeners_annotation]]
`@Listeners`:: 
+
--
Определяет список слушателей, предназначенных для реакции на события жизненного цикла экземпляров сущности на <<app_tiers,уровне>> *Middleware*.

Значением аннотации должна быть строка или массив строк с именами классов слушателей - см. <<entity_listeners,Entity Listeners>>.

Строки используются здесь вместо ссылок на классы потому, что классы слушателей находятся только на уровне *Middleware* и не доступны клиентскому коду, в то время как классы самих сущностей используются на всех уровнях.

Примеры:

[source, java]
----
@Listeners("com.haulmont.cuba.security.listener.UserEntityListener")
----

[source, java]
----
@Listeners({"com.abc.sales.entity.FooListener","com.abc.sales.entity.BarListener"})
----
--

[[metaclass_annotation]]
`@MetaClass`:: 
+
--
Используется для объявления неперсистентной или <<embeddable_annotation,встраиваемой>> сущности (т.е. когда аннотация `@javax.persistence.Entity` не применима) 

Параметры:

* `name` - имя сущности, обязательно должно начинаться с префикса, отделенного знаком `$`. Желательно использовать в качестве префикса короткое имя проекта для формирования отдельного пространства имен.

Пример:

[source, java]
----
@MetaClass(name = "sys$LockInfo")
----
--

`@SystemLevel`:: 
Указывает, что данная сущность является системной и не должна быть доступна для выбора пользователем в различных списках сущностей, например, как тип параметра универсального фильтра или тип <<dynamic_attributes,динамического атрибута>>. 

`@EnableRestore`:: 
Указывает, что экземпляры данной сущности доступны для восстановления после <<soft_deletion,мягкого удаления>> в специальном экране `core$Entity.restore`. 

`@TrackEditScreenHistory`:: 
Указывает, что для данной сущности будет запоминаться история открытия экранов редактирования (`++{имя_сущности}.edit++`) с возможностью отображения в специальном экране `sec$ScreenHistory.browse`. 

`@Extends`:: 
Указывает, что данная сущность является расширением и должна повсеместно использоваться вместо базовой. См. <<extension,Расширение функциональности>>.

[[postConstruct_entity_annotation]]
`@PostConstruct`:: 
Данная аннотация может быть указана для метода класса. Такой метод будет вызван сразу после создания экземпляра сущности через <<metadata,Metadata.create()>>. Это удобно, если для инициализации экземпляра сущности требуется вызов каких-либо <<managed_beans,бинов>>. Пример см. в <<init_values_in_class,Инициализация полей сущности>>.

[[entity_attr_annotations]]

*Аннотации атрибутов*

Аннотации атрибутов устанавливаются на соответствующие поля класса, за одним исключением: если требуется объявить неизменяемый (read only) неперсистентный атрибут `foo`, то достаточно создать метод доступа `getFoo()` и поместить на этот метод аннотацию `@MetaProperty`.

`link:$$http://docs.oracle.com/javaee/5/api/javax/persistence/Transient.html$$[@javax.persistence.Transient]`::
+
--
Указывает, что данное поле не хранится в БД, т.е. является неперсистентным. 

Поля поддерживаемых <<jpa,JPA>> типов (см. link:$$http://docs.oracle.com/javaee/5/api/javax/persistence/Basic.html$$[http://docs.oracle.com/javaee/5/api/javax/persistence/Basic.html]) _по умолчанию являются персистентными_, поэтому аннотация `@Transient` обязательна для объявления неперсистентного атрибута такого типа. 

Для включения `@Transient` атрибута в метаданные, необходимо также указать аннотацию `<<metaProperty_annotation,@MetaProperty>>`.
--

`@org.apache.openJPA.persistence.Persistent`::
+
--
Указывает, что данное поле хранится в БД, т.е. является персистентным.

Данная аннотация требуется только для нестандартного для <<jpa,JPA>> типа поля, платформа на данный момент поддерживает один такой тип - `java.util.UUID`. Таким образом, `@Persistent` требуется только в одном случае - при объявлении персистентного поля типа `UUID`.
--

`link:$$http://docs.oracle.com/javaee/5/api/javax/persistence/Column.html$$[@javax.persistence.Column]`::
+
--
Определяет колонку БД, в которой будут храниться значения данного атрибута. 

Параметры:

* `name` - имя колонки

* `length` - (необязательный параметр, по умолчанию `255`) - длина колонки. Используется также при формировании <<metadata_framework,метаданных>> и, в конечном счете, может ограничивать максимальную длину вводимого текста в визуальных компонентах, работающих с данным атрибутом. Для отмены ограничения по длине атрибуту необходимо добавить аннотацию <<lob_annotation,@Lob>>.

* `nullable` - (необязательный параметр, по умолчанию `true`) - может ли атрибут содержать `null`. При указании `nullable = false` <<jpa,JPA>> контролирует наличие значения поля при сохранении, кроме того, визуальные компоненты, работающие с данным атрибутом, могут сигнализировать пользователю о необходимости ввода значения.
--

`link:$$http://docs.oracle.com/javaee/5/api/javax/persistence/Id.html$$[@javax.persistence.Id]`::
+
--
Указывает, что данный атрибут является первичным ключом сущности. Обычно эта аннотация присутствует на поле базового класса, такого как <<base_entity_classes,BaseUuidEntity>>. Использовать эту аннотацию в конкретном классе сущности необходимо только при наследовании от базового класса `BaseStringIdEntity` (то есть при создании сущности со строковым первичным ключом).
--

[[manyToOne]]
`link:$$http://docs.oracle.com/javaee/5/api/javax/persistence/ManyToOne.html$$[@javax.persistence.ManyToOne]`::
+
--
Определяет атрибут-ссылку на сущность с типом ассоциации много-к-одному. 

Параметры:

* `fetch` - (по умолчанию `EAGER`) параметр, определяющий, будет ли <<jpa,JPA>> <<eager_fetching,жадно>> загружать ассоциированную сущность. Данный параметр всегда должен быть установлен в значение `LAZY`, так как в CUBA-приложении политика загрузки связей определяется динамически на основе механизма <<views,представлений>>.

* `optional` - (необязательный параметр, по умолчанию `true`) - может ли атрибут содержать `null`. При указании `optional = false` <<jpa,JPA>> контролирует наличие ссылки при сохранении, кроме того, визуальные компоненты, работающие с данным атрибутом, могут сигнализировать пользователю о необходимости ввода значения.

Например, несколько экземпляров `Order` (заказов) ссылаются на один экземпляр `Customer` (покупателя), в этом случае класс `Order` должен содержать следующее объявление:

[source, java]
----
@ManyToOne(fetch = FetchType.LAZY)
@JoinColumn(name = "CUSTOMER_ID")
protected Customer customer;
----
--

`link:$$http://docs.oracle.com/javaee/5/api/javax/persistence/OneToMany.html$$[@javax.persistence.OneToMany]`::
+
--
Определяет атрибут-коллекцию ссылок на сущность с типом ассоциации один-ко-многим. 

Параметры:

* `mappedBy` - поле связанной сущности, определяющее ассоциацию 

* `targetEntity` - тип связанной сущности. Необязательный параметр, если коллекция объявлена с использованием *Java generics*. 

* `fetch` - (необязательный параметр, по умолчанию `LAZY`) - определяет, будет ли <<jpa,JPA>> <<eager_fetching,жадно>> загружать коллекцию связанных сущностей. Необходимо всегда оставлять значение по умолчанию `LAZY`, так как в CUBA-приложении политика загрузки связей определяется динамически на основе механизма <<views,представлений>>.

* `cascade` - (необязательный параметр, по умолчанию `{}`) - каскадирование операций определяет, какие операции над сущностью должны быть применены к ассоциированным сущностям. Каскадирование на данном уровне не рекомендуется использовать.

Например, несколько экземпляров `Item` (пунктов заказа) ссылаются на один экземпляр `Order` (заказ) с помощью `@ManyToOne` поля `Item.order`, в этом случае класс `Order` может содержать коллекцию экземпляров `Item`:

[source, java]
----
@OneToMany(mappedBy = "order")
protected Set<Item> items;
----
--

`link:$$http://docs.oracle.com/javaee/5/api/javax/persistence/OneToOne.html$$[@javax.persistence.OneToOne]`::
+
--
Определяет атрибут-ссылку на сущность с типом ассоциации один-к-одному. 

Параметры:

* `fetch` - (по умолчанию `EAGER`) параметр, определяющий, будет ли <<jpa,JPA>> <<eager_fetching,жадно>> загружать ассоциированную сущность. Данный параметр всегда должен быть установлен в значение `LAZY`, так как в CUBA-приложении политика загрузки связей определяется динамически на основе механизма <<views,представлений>>.

* `mappedBy` - поле связанной сущности, определяющее ассоциацию. Требуется устанавливать только на ведомой стороне ассоциации. 

* `optional` - (необязательный параметр, по умолчанию `true`) - может ли атрибут содержать `null`. При указании `optional = false` <<jpa,JPA>> контролирует наличие ссылки при сохранении, кроме того, визуальные компоненты, работающих с данным атрибутом, могут сигнализировать пользователю о необходимости ввода значения.

Пример ведущей стороны ассоциации, класс `Driver`:

[source, java]
----
@OneToOne(fetch = FetchType.LAZY)
@JoinColumn(name = "CALLSIGN_ID")
protected DriverCallsign callsign;
----

Пример ведомой стороны ассоциации, класс `DriverCallsign`:

[source, java]
----
@OneToOne(fetch = FetchType.LAZY, mappedBy = "callsign")
protected Driver driver;
----
--

`link:$$http://docs.oracle.com/javaee/5/api/javax/persistence/ManyToMany.html$$[@javax.persistence.ManyToMany]`::
+
--
Определяет атрибут-коллекцию ссылок на сущность с типом ассоциации много-ко-многим.

Ассоциация много-ко-многим всегда имеет ведущую сторону и может иметь обратную сторону - ведомую. На ведущей стороне указывается дополнительная аннотация `@JoinTable`, на ведомой стороне - параметр `mappedBy`.

Параметры:

* `mappedBy` - поле связанной сущности, определяющее ассоциацию с ведущей стороны. Необходимо указывать только на ведомой стороне.

* `targetEntity` - тип связанной сущности. Необязательный параметр, если коллекция объявлена с использованием *Java generics*. 

* `fetch` - (необязательный параметр, по умолчанию `LAZY`) - определяет, будет ли <<jpa,JPA>> <<eager_fetching,жадно>> загружать коллекцию связанных сущностей. Необходимо всегда оставлять значение по умолчанию `LAZY`, так как в CUBA-приложении политика загрузки связей определяется динамически на основе механизма <<views,представлений>>.
--

`link:$$http://docs.oracle.com/javaee/5/api/javax/persistence/JoinColumn.html$$[@javax.persistence.JoinColumn]`::
+
--
Используется для указания колонки БД, определяющей ассоциацию между сущностями. 

Параметры:

* `name` - имя колонки

Пример:

[source, java]
----
@ManyToOne(fetch = FetchType.LAZY)
@JoinColumn(name = "CUSTOMER_ID")
protected Customer customer;
----
--

`link:$$http://docs.oracle.com/javaee/5/api/javax/persistence/JoinTable.html$$[@javax.persistence.JoinTable]`::
+
--
Используется для указания таблицы связи на ведущей стороне `@ManyToMany` ассоциации. 

Параметры:

* `name` - имя таблицы связи

* `joinColumns` - элемент `@JoinColumn`, определяющий колонку таблицы связей, соответствующую первичному ключу ведущей стороны ассоциации (т.е. содержащей аннотацию `@JoinTable`)

* `inverseJoinColumns` - элемент `@JoinColumn`, определяющий колонку таблицы связей, соответствующую первичному ключу ведомой стороны ассоциации

Пример атрибута `customers` класса `Group`, являющегося ведущей стороной ассоциации:

[source, java]
----
@ManyToMany
@JoinTable(name = "SALES_CUSTOMER_GROUP_LINK",
  joinColumns = @JoinColumn(name = "GROUP_ID"),
  inverseJoinColumns = @JoinColumn(name = "CUSTOMER_ID"))
protected Set<Customer> customers;
----

Пример атрибута `groups` класса `Customer`, являющегося ведомой стороной этой же ассоциации:

[source, java]
----
@ManyToMany(mappedBy = "customers")
protected Set<Group> groups;
----
--

`link:$$http://docs.oracle.com/javaee/5/api/javax/persistence/OrderBy.html$$[@javax.persistence.OrderBy]`::
+
--
Определяет порядок элементов в атрибуте-коллекции на момент извлечения из базы данных. Данную аннотацию необходимо задавать для упорядоченных коллекций, таких как `List` или `LinkedHashSet` для получения предсказуемого порядка следования элементов.

Параметры:

* `value` - строка, определяющая порядок, в формате:
+
[source, java]
----
orderby_list::= orderby_item [,orderby_item]*
orderby_item::= property_or_field_name [ASC | DESC]
----

Пример:

[source, java]
----
@OneToMany(mappedBy = "user")
@OrderBy("createTs")
protected List<UserRole> userRoles;
----
--

`link:$$http://docs.oracle.com/javaee/5/api/javax/persistence/Embedded.html$$[@javax.persistence.Embedded]`::
+
--
Определяет атрибут типа встраиваемой сущности, в свою очередь аннотированной `@Embeddable`. 

Пример:

[source, java]
----
@Embedded
protected Address address;
----
--

`link:$$http://docs.oracle.com/javaee/5/api/javax/persistence/Temporal.html$$[@javax.persistence.Temporal]`::
+
--
Для атрибута типа `java.util.Date` уточняет тип хранимого значения: дата, время или дата+время. 

Параметры:

* `value` - тип хранимого значения: `DATE`, `TIME`, ` TIMESTAMP`

Пример:

[source, java]
----
@Column(name = "START_DATE")
@Temporal(TemporalType.DATE)
protected Date startDate;
----
--

`link:$$http://docs.oracle.com/javaee/5/api/javax/persistence/Version.html$$[@javax.persistence.Version]`::
+
--
Указывает, что данное поле хранит версию для поддержки <<optimistic_locking,оптимистичной блокировки>> сущностей.

Применение такого поля необходимо при реализации классом сущности интерфейса `Versioned` (базовый класс `StandardEntity` уже содержит такое поле).

Пример:

[source, java]
----
@Version
@Column(name = "VERSION")
private Integer version;
----
--

[[lob_annotation]]
`link:$$http://docs.oracle.com/javaee/5/api/javax/persistence/Lob.html$$[@javax.persistence.Lob]`::
+
--
Указывает, что данный атрибут не имеет ограничений длины. Применяется совместно с аннотацией `@Column`. Если `@Lob` указан, то длина, заданная в `@Column` явно или по умолчанию, игнорируется. 

Пример:

[source, java]
----
@Column(name = "DESCRIPTION")
@Lob
private String description;
----
--

[[metaProperty_annotation]]
`@MetaProperty`:: 
+
--
Указывает, что данный атрибут должен быть включен в <<metadata_framework,метаданные>>. Данная аннотация может быть установлена как на поле класса, так и на метод доступа, в случае отсутствия соответствующего атрибуту поля.

Данная аннотация не обязательна для полей, снабженных следующими аннотациями пакета `javax.persistence`: `@Column`, `@OneToOne`, `@OneToMany`, `@ManyToOne`, `@ManyToMany`, `@Embedded`. Такие поля отражаются в метаданных автоматически. Поэтому `@MetaProperty` в основном применяется для определения неперсистентных атрибутов сущностей. 

Параметры:

* `mandatory` - (необязательный параметр, по умолчанию `false`) - может ли атрибут содержать `null`. При указании `mandatory = true` визуальные компоненты, работающие с данным атрибутом, могут сигнализировать пользователю о необходимости ввода значения.

Пример использования для поля:

[source, java]
----
@Transient
@MetaProperty
protected String token;
----

Пример использования для метода:

[source, java]
----
@MetaProperty
public String getLocValue() {
  if (!StringUtils.isBlank(messagesPack)) {
      return AppBeans.get(Messsages.class).getMessage(messagesPack, value);
  } else {
      return value;
  }
}
----
--

[[onDelete_annotation]]
`@OnDelete`:: 
+
--
Определяет политику обработки связи в случае мягкого удаления сущности, содержащей данный атрибут. См. <<soft_deletion,Мягкое удаление>>.

Пример:

[source, java]
----
@OneToMany(mappedBy = "group")
@OnDelete(DeletePolicy.CASCADE)
private Set<Constraint> constraints;
----
--

[[onDeleteInverse_annotation]]
`@OnDeleteInverse`:: 
+
--
Определяет политику обработки связи в случае мягкого удаления сущности с обратной стороны ассоциации. См. <<soft_deletion,Мягкое удаление>>.

Пример:

[source, java]
----
@ManyToOne
@JoinColumn(name = "DRIVER_ID")
@OnDeleteInverse(DeletePolicy.DENY)
private Driver driver;
----
--

[[composition_annotation]]
`@Composition`:: 
+
--
Указывает на то, что связь является композицией - более тесным вариантом ассоциации. Это означает, что связанная сущность имеет смысл только как часть владеющей сущности, т.е. создается и удаляется вместе с ней. 

Например, список пунктов в заказе (класс `Order` содержит коллекцию экземпляров `Item`):

[source, java]
----
@OneToMany(mappedBy = "order")
@Composition
protected List<Item> items;
----

Указание для связи аннотации `@Composition` позволяет организовать в <<screen_edit,экранах редактирования>> специальный режим коммита источников данных, при котором изменения экземпляров детализирующей сущности сохраняются в базе данных только при коммите основной сущности. Подробнее см. <<composition_recipe,>>.
--

[[localizedValue_annotation]]
`@LocalizedValue`:: 
+
--
Служит для описания способа получения локализованного значения некоторого изменяющегося атрибута, которое возвращает метод `<<messageTools,MessageTools>>.getLocValue()`. 

Параметры:

* `messagePack` - явное указание пакета, из которого будет взято локализованное сообщение, например, `com.haulmont.cuba.core.entity`

* `messagePackExpr` - выражение в терминах пути к атрибуту, хранящему имя пакета, из которого будет взято локализованное сообщение, например `proc.messagesPack`. Путь начинается с атрибута текущей сущности. 

Пример аннотации, означающей, что локализованное значение атрибута `state` будет взято из пакета, имя которого хранится в атрибуте `messagesPack` связанной сущности `proc`:

[source, java]
----
@Column(name = "STATE")
@LocalizedValue(messagePackExpr = "proc.messagesPack")
protected String state;

@ManyToOne(fetch = FetchType.LAZY)
@JoinColumn(name = "PROC_ID")
protected Proc proc;
----
--

[[ignoreUserTimeZone]]
`@IgnoreUserTimeZone`:: 
Для атрибутов типа timestamp с аннотацией `@javax.persistence.Temporal.TIMESTAMP` заставляет платформу игнорировать <<timeZone,часовой пояс>> пользователя, если он задан для текущей сессии.

[[enum_attributes]]
===== Атрибуты типа enum

В стандартном варианте использования <<jpa,JPA>> для атрибутов типа `enum` в базе данных хранится целое число, получаемое методом `ordinal()` этого перечисления. Такой подход может привести к следующим проблемам при эксплуатации и развитии системы:

* при появлении в БД значения, не равного ни одному `ordinal` значению перечисления, экземпляр сущности нельзя загрузить вообще;

* невозможно ввести новое значение между имеющимися, что актуально при использовании сортировки по значению перечисления (order by).

Чтобы решить эти проблемы, в подходе CUBA предлагается отвязать значение, хранимое в БД, от `ordinal` перечисления. Для этого необходимо поле класса сущности объявлять с типом, хранимым в БД (`Integer` или `String`), а методы доступа (getter / setter) создавать для типа самого перечисления.

Например:

[source, java]
----
@Entity(name = "sales$Customer")
@Table(name = "SALES_CUSTOMER")
public class Customer extends StandardEntity {

  @Column(name = "GRADE")
  protected Integer grade;

  public CustomerGrade getGrade() {
      return grade == null ? null : CustomerGrade.fromId(grade);
  }

  public void setGrade(CustomerGrade grade) {
      this.grade = grade == null ? null : grade.getId();
  }
...
}  
----

При этом сам класс перечисления может выглядеть следующим образом:

[source, java]
----
public enum CustomerGrade implements EnumClass<Integer> {

  PREMIUM(10),
  HIGH(20),
  MEDIUM(30);

  private Integer id;

  CustomerGrade(Integer id) {
      this.id = id;
  }

  @Override
  public Integer getId() {
      return id;
  }

  public static CustomerGrade fromId(Integer id) {
      for (CustomerGrade grade : CustomerGrade.values()) {
          if (grade.getId().equals(id))
              return grade;
      }
      return null;
  }
}
----

Для правильного отражения в <<metadata_framework,метаданных>> класс перечисления, используемый в качестве типа атрибута сущности, должен реализовывать интерфейс `EnumClass`.

Как видно из примеров, для атрибута `grade` в БД хранится значение типа `Integer`, задаваемое полем `id` перечисления `CustomerGrade`, а конкретно `10`, `20` или `30`. В то же время прикладной код и метаданные работают с самим типом `CustomerGrade` через методы доступа, которые и осуществляют конвертацию.

При наличии в поле БД значения, не соответствующего ни одному значению перечисления, метод `getGrade()` просто вернет `null`. Для ввода нового значения, например, `HIGHER`, между `HIGH` и `PREMIUM`, достаточно добавить это значение в перечисление с идентификатором `15`, при этом сортировка по полю `Customer.grade` останется верной.

Значениям перечисления могут быть сопоставлены <<enum_localization,локализованные названия>> для отображения в пользовательском интерфейсе приложения.

[[soft_deletion]]
===== Мягкое удаление

Платформа CUBA поддерживает режим "мягкого удаления" данных - когда вместо удаления записей из базы данных они только помечаются определенным образом и становятся недоступными для обычного использования. В дальнейшем такие записи можно либо совсем удалить из БД с помощью отдельной регламентной процедуры, либо восстановить.

Механизм мягкого удаления является "прозрачным" для прикладного программиста - достаточно убедиться, что класс сущности реализует интерфейс `SoftDelete`, и платформа сама нужным образом будет модифицировать запросы и операции с данными.

Режим мягкого удаления имеет следующие преимущества:

* значительно снижается риск потери данных вследствие неверных действий пользователей

* позволяет быстро сделать некоторые записи недоступными, даже если на них имеются ссылки. 
+
Возьмем для примера модель данных `Заказы` - `Покупатели`. Допустим, на некоторого покупателя оформлено несколько заказов, однако нам нужно сделать его недоступным для дальнейшей работы. Традиционным "жестким" удалением сделать это невозможно, так как для удаления покупателя нам нужно либо удалить все его заказы, либо обнулить в этих заказах ссылки на него (т.е. потерять информацию). При мягком удалении покупателя он становится недоступным для поиска и изменения, однако при просмотре заказов пользователь видит на экране название покупателя, так как при загрузке связей признак удаления намеренно игнорируется.
+
Описанное поведение является стандартным, но может быть модифицировано с помощью <<delete_policy,политики обработки связей>> при удалении.

Отрицательной стороной мягкого удаления является увеличение объема базы данных и потенциальная необходимость дополнительных процедур ее очистки.

*Использование*

Для того чтобы экземпляры сущности удалялись мягко, класс сущности должен реализовывать интерфейс `SoftDelete`, а соответствующая таблица БД должна содержать колонки: 

* *DELETE_TS* - когда удалена запись

* *DELETED_BY* - логин пользователя, который удалил запись

Поведение системы по умолчанию - сущности, реализующие `SoftDelete`, удаляются мягко, удаленные сущности не возвращаются запросами и поиском по идентификатору. При необходимости такое поведение можно динамически отключить следующими способами:

* для текущего экземпляра <<entityManager,EntityManager>> - вызовом `setSoftDeletion(false)`

* при запросе данных через <<dataManager,DataManager>> - вызовом у передаваемого объекта `LoadContext` метода `setSoftDeletion(false)`

* на уровне <<datasources,источников данных>> - используя метод `CollectionDatasource.setSoftDeletion(false)` или атрибут `softDeletion="false"` элемента `collectionDatasource` в <<screen_xml,XML-дескрипторе>> экрана.

В режиме мягкого удаления платформа автоматически отфильтровывает удаленные экземпляры при загрузке по идентификатору и по <<jpql,JPQL-запросу>>, а также удаленные элементы связанных сущностей в атрибутах-коллекциях. Однако связанные сущности в единичных атрибутах загружаются независимо от того, удален связанный экземпляр или нет.

[[delete_policy]]
*Политика обработки связей*

Платформа предоставляет средство обработки связей при удалении сущностей, во многом аналогичное правилам *ON DELETE* внешних ключей в базе данных. Это средство работает на <<app_tiers,уровне>> *Middleware* и использует аннотации <<onDelete_annotation,@OnDelete>>, <<onDeleteInverse_annotation,@OnDeleteInverse>> атрибутов сущности.

Аннотация `@OnDelete` обрабатывается при удалении той сущности, в которой она встретилась, а не той, на которую указывает аннотированный атрибут (в этом отличие от каскадных удалений на уровне БД).

Аннотация `@OnDeleteInverse` обрабатывается при удалении той сущности, на которую указывает аннотированный атрибут, (т.е. аналогично каскадному удалению на уровне внешних ключей в БД). Эта аннотация полезна при отсутствии в удаляемом объекте атрибута, который нужно проверять при удалении. При этом, как правило, в проверяемом объекте существует ссылка на удаляемый, на этот атрибут и устанавливается аннотация `@OnDeleteInverse`. 

Значением аннотации может быть: 

* `DeletePolicy.DENY` - запретить удаление сущности, если аннотированный атрибут не `null` или не пустая коллекция 

* `DeletePolicy.CASCADE` - каскадно удалить аннотированный атрибут 

* `DeletePolicy.UNLINK` - разорвать связь с аннотированным атрибутом. Разрыв связи имеет смысл указывать только на ведущей стороне ассоциации - той, которая в классе сущности аннотирована `@JoinColumn`. 

Примеры: 

. Запрет удаления при наличии ссылки: при попытке удаления экземпляра `Customer`, на который ссылается хотя бы один `Order`, будет выброшено исключение `DeletePolicyException`.
+
`Order.java`
+
[source, java]
----
@ManyToOne(fetch = FetchType.LAZY)
@JoinColumn(name = "CUSTOMER_ID")
@OnDeleteInverse(DeletePolicy.DENY)
protected Customer customer;
----
+
`Customer.java`
+
[source, java]
----
@OneToMany(mappedBy = "customer")
protected List<Order> orders;
----
. Каскадное удаление элементов коллекции: при удалении экземпляра `Role` все экземпляры `Permission` также будут удалены.
+
`Role.java`
+
[source, java]
----
@OneToMany(mappedBy = "role")
@OnDelete(DeletePolicy.CASCADE)
protected Set<Permission> permissions;
----
+
`Permission.java`
+
[source, java]
----
@ManyToOne(fetch = FetchType.LAZY)
@JoinColumn(name = "ROLE_ID")
protected Role role;
----
. Разрыв связи с элементами коллекции: удаление экземпляра `Role` приведет к установке в `null` ссылок со стороны всех входивших в коллекцию экземпляров `Permission`.
+
`Role.java`
+
[source, java]
----
@OneToMany(mappedBy = "role")
protected Set<Permission> permissions;
----
+
`Permission.java`
+
[source, java]
----
@ManyToOne(fetch = FetchType.LAZY)
@JoinColumn(name = "ROLE_ID")
@OnDeleteInverse(DeletePolicy.UNLINK)
protected Role role;
----
+
Особенности реализации:

. Нужно быть осторожным при использовании `@OnDeleteInverse` с политиками `CASCADE` и `UNLINK`, так как при этом происходит извлечение из БД на сервер приложения всех экземпляров ссылающихся объектов, изменение и затем сохранение. 
+
Например, в случае ассоциации `Customer` - `Job` и большого количества работ для одного заказчика, если поставить на атрибут `Job.customer` политику `@OnDeleteInverse(CASCADE)`, то при удалении экземпляра заказчика будет предпринята попытка извлечь и изменить все его работы. Это может привести к перегрузке сервера приложения и БД.
+
С другой стороны, использование `@OnDeleteInverse(DENY)` безопасно, так как при этом производится только подсчет количества ссылающихся объектов, и если оно больше `0`, выбрасывается исключение. Поэтому `@OnDeleteInverse(DENY)` для атрибута `Job.customer` вполне допустимо.

. Политика обработки связей реализуется с помощью <<entity_listeners,Entity Listeners>>, то есть при сохранении данных в БД на <<app_tiers,уровне>> *Middleware*.

*Ограничение уникальности на уровне БД*

В режиме мягкого удаления для ограничения уникальности некоторого значения необходимо обеспечить существование единственной неудаленной записи с этим значением, и произвольного количества удаленных записей с этим же значением.

Реализуется данная логика путем, специфичным для используемого сервера базы данных:

* Если сервер БД поддерживает частичные (partial) индексы (например, *PostgreSQL*), то ограничение уникальности можно создать следующим образом:
+
[source, sql]
----
create unique index IDX_SEC_USER_UNIQ_LOGIN on SEC_USER (LOGIN_LC) where DELETE_TS is null
----
+
* Если сервер БД не поддерживает частичные индексы (например, *Microsoft SQL Server 2005*), то в уникальный индекс можно включить поле *DELETE_TS*:

[source, sql]
----
create unique index IDX_SEC_USER_UNIQ_LOGIN on SEC_USER (LOGIN_LC, DELETE_TS)
----

[[metadata_framework]]
==== Metadata Framework

Для эффективной работы с <<data_model,моделью данных>> в CUBA-приложениях используется фреймворк метаданных, который:

* предоставляет удобный интерфейс для получения информации о <<entity,сущностях>>, их атрибутах и отношениях между сущностями; а также для навигации по ссылкам

* служит специализированной и более удобной в использовании альтернативой *Java Reflection API*

* регламентирует допустимые типы данных и отношений между сущностями

* позволяет создавать универсальные механизмы работы с данными

===== Интерфейсы метаданных

Рассмотрим основные интерфейсы метаданных.

.Интерфейсы фреймворка метаданных
image::MetadataFramework.png[align="center"]

`Session`:: 
+
--
Точка входа в фреймворк метаданных. Позволяет получать экземпляры `MetaClass` по имени и по соответствующему классу Java. Обратите внимание на различие методов `getClass()` и `getClassNN()` - первые могут возвращать `null`, вторые нет (NonNull).

Объект `Session` может быть получен через интерфейс инфраструктуры `<<metadata,Metadata>>`.

Пример:

[source, java]
----
@Inject
protected Metadata metadata;
...
Session session = metadata.getSession();
MetaClass metaClass1 = session.getClassNN("sec$User");
MetaClass metaClass2 = session.getClassNN(User.class);
assert metaClass1 == metaClass2;
----
--

`MetaModel`:: 
+
--
Редко используемый интерфейс, служит для группировки мета-классов. 

Группировка осуществляется по имени корневого Java пакета проекта, указываемого в файле `<<metadata.xml,metadata.xml>>`.
--

[[metaClass]]
`MetaClass`:: 
+
--
Интерфейс метаданных класса сущности. `MetaClass` всегда ассоциирован с классом Java, которого он представляет.

Основные методы:

* `getName()` – имя сущности, по соглашению первой частью имени до знака `$` является код пространства имен, например, `sales$Customer`

* `getProperties()` – список мета-свойств (`MetaProperty`)

* `getProperty()`, `getPropertyNN()` - получение мета-свойства по имени. Первый метод в случае отсутствия атрибута с указанным именем возвращает `null`, второй выбрасывает исключение.
+
Пример:
+
[source, java]
----
MetaClass userClass = session.getClassNN(User.class);
MetaProperty groupProperty = userClass.getPropertyNN("group");
----

* `getPropertyPath()` - позволяет перемещаться по ссылкам. Данный метод принимает строковый параметр - путь из имен атрибутов, разделенных точкой. Возвращаемый объект `MetaPropertyPath` позволяет обратиться к искомому (последнему в пути) атрибуту вызовом `getMetaProperty()`. 
+
Пример:
+
[source, java]
----
MetaClass userClass = session.getClassNN(User.class);
MetaProperty groupNameProp = userClass.getPropertyPath("group.name").getMetaProperty();
assert groupNameProp.getDomain().getName().equals("sec$Group");
----

* `getJavaClass()` – класс сущности, которому соответствует данный `MetaClass`

* `getAnnotations()` – коллекция <<meta_annotations,мета-аннотаций>> 

--

[[metaProperty]]
`MetaProperty`:: 
+
--
Интерфейс метаданных атрибута сущности. 

Основные методы:

* `getName()` – имя свойства, соответствует имени атрибута сущности

* `getDomain()` – мета-класс, которому принадлежит данное свойство

* `getType()` – тип свойства:

** простой тип: `DATATYPE`

** перечисление: `ENUM`

** ссылочный тип двух видов:
*** `ASSOCIATION` − простая ссылка на другую сущность. Например, отношение заказа и покупателя − ассоциация.

*** `COMPOSITION` − ссылка на сущность, которая не имеет самостоятельного значения без владеющей сущности. `COMPOSITION` можно считать "более тесным" отношением, чем `ASSOCIATION`. Например, отношение заказа и пункта этого заказа − `COMPOSITION`, т.к. пункт не может существовать без заказа, которому он принадлежит.
+
Вид ссылочного атрибута `ASSOCIATION` или `COMPOSITION` влияет на режим редактирования сущности: в первом случае сохранение связанной сущности в базу данных происходит независимо, а во втором − связанная сущность сохраняется в БД только вместе с владеющей сущностью.

* `getRange()` – интерфейс `Range`, детально описывающий тип данного атрибута

* `isMandatory()` – признак обязательности атрибута. Используется, например, визуальными компонентами для сигнализации пользователю о необходимости ввода значения.

* `isReadOnly()` – признак неизменности атрибута

* `getInverse()` – для ссылочного атрибута возвращает мета-свойство с обратной стороны ассоциации, если таковое имеется

* `getAnnotatedElement()` – поле (`java.lang.reflect.Field`) или метод (`java.lang.reflect.Method`), соответствующие данному атрибуту сущности

* `getJavaType()` – класс Java данного атрибута сущности. Это либо тип поля класса, либо тип возвращаемого значения метода.

* `getDeclaringClass()` – класс Java, содержащий данный атрибут

--

`Range`:: 
+
--
Интерфейс, детально описывающий тип атрибута сущности.

Основные методы:

* `isDatatype()` – возвращает `true` для атрибута простого <<metaProperty.getType,типа>>

* `asDatatype()` - возвращает <<datatype,Datatype>> для атрибута простого <<metaProperty.getType,типа>>

* `isEnum()` – возвращает `true` для атрибута <<metaProperty.getType,типа>> перечисления

* `asEnumeration()` - возвращает <<datatype,Enumeration>> для атрибута <<metaProperty.getType,типа>> перечисления

* `isClass()` – возвращает `true` для ссылочного атрибута <<metaProperty.getType, типа>> `ASSOCIATION` или `COMPOSITION`

* `asClass()` - возвращает <<metaClass,мета-класс>> ассоциированной сущности для ссылочного атрибута

* `isOrdered()` – возвращает `true` если атрибут представляет собой упорядоченную коллекцию (например, `List`)

* `getCardinality()` – вид отношения для ссылочного атрибута: `++ONE_TO_ONE++`, `++MANY_TO_ONE++`, `++ONE_TO_MANY++`, `++MANY_TO_MANY++`

--

[[metadata_building]]
===== Формирование метаданных

Основной источник формирования структуры метаданных - <<entity_annotations,аннотированные>> классы сущностей. 

Класс сущности отражается в метаданных в следующих случаях: 

* Класс персистентной сущности аннотирован `@Entity`, `@Embeddable`, `@MappedSuperclass` и расположен в пределах корневого пакета, указанного в `<<metadata.xml,metadata.xml>>`.

* Класс неперсистентной сущности аннотирован `@MetaClass` и расположен в пределах корневого пакета, указанного в `<<metadata.xml,metadata.xml>>`.

Все сущности внутри одного корневого пакета помещаются в один экземпляр `MetaModel`, которому присваивается имя этого пакета. Между сущностями внутри одной `MetaModel` можно устанавливать произвольные связи, между разными - в порядке объявления файлов `metadata.xml` в свойстве `<<cuba.metadataConfig,cuba.metadataConfig>>`.

Атрибут сущности отражается в метаданных, если: 

* поле класса аннотировано `@Column`, `@OneToOne`, `@OneToMany`, `@ManyToOne`, `@ManyToMany`, `@Embedded`

* поле класса или метод доступа на чтение (getter) аннотирован `@MetaProperty`

Параметры мета-класса и мета-свойств формируются на основе параметров перечисленных <<entity_annotations,аннотаций>>, а также типов полей и методов класса. Кроме того, если у атрибута отсутствует метод доступа на запись (setter), атрибут становится неизменяемым (read only). 

[[datatype]]
===== Datatype

Интерфейс `Datatype` описывает тип данных, допустимый для атрибута сущности, не являющегося ассоциацией. Каждый экземпляр реализации `Datatype` соответствует одному классу Java, для работы с которым он предназначен.

Все экземпляры зарегистрированы в репозитории - классе `Datatypes`, который выполняет загрузку и инициализацию классов реализации `Datatype` следующим образом:

* в корне `CLASSPATH` ищется файл `<<datatypes.xml,datatypes.xml>>`, и если он найден, репозиторий `Datatypes` инициализируется из него

* в противном случае инициализация `Datatypes` производится из файла `/com/haulmont/chile/core/datatypes/<<datatypes.xml,datatypes.xml>>`

Экземпляр `Datatype` может быть получен двумя способами:

* для атрибута сущности из соответствующего ему мета-свойства типа `<<metaProperty.getType,DATATYPE>>`, вызовом `getRange().asDatatype()`

* статическим методом `Datatypes.get()`, передавая в него имя реализации `Datatype` или класс Java, для которого он создан.

`Datatype` сопоставляется атрибуту сущности на старте системы по следующим правилам:

* Если для поля или метода задана аннотация `@MetaProperty` с непустым значением `datatype`, то атрибуту сопоставляется экземпляр `Datatype` с данным именем. 
+
Например, при следующем объявлении атрибута сущности он получит нестандартный тип `GeoCoordinateDatatype` (см. пример ниже):
+
[source, java]
----
@MetaProperty(datatype = GeoCoordinateDatatype.NAME)
@Column(name = "LATITUDE")
private Double latitude;
----

* как правило, явное указание отсутствует, и атрибуту сопоставляется экземпляр `Datatype`, возвращаемый репозиторием `Datatypes.get(Class)`, при передаче в него типа поля или метода.
+
Например, в данном случае атрибут `latitude` получит стандартный тип `DoubleDatatype`, зарегистрированный в базовом `/com/haulmont/chile/core/datatypes/datatypes.xml`:
+
[source, java]
----
@Column(name = "LATITUDE")
private Double latitude;
----

Основные методы интерфейса `Datatype`:

* `getName()` - возвращает уникальное имя данной реализации

* `format()` - преобразовывает переданное значение в строку

* `parse()` - преобразовывает строку в значение нужного типа 

`Datatype` определяет два набора методов для форматирования/парсинга: с учетом локали и без учета локали. Преобразование с учетом локали используется повсеместно в пользовательском интерфейсе, преобразование без учета локали используется в системных механизмах, например, для сериализации в <<rest_api,REST API>>. 

Форматы для преобразований без учета локали задаются в вышеупомянутом файле `<<datatypes.xml,datatypes.xml>>`.

Форматы для преобразований с учетом локали задаются в <<main_message_pack,главном пакете локализованных сообщений>>, в строках со следующими ключами:

* `numberDecimalSeparator` - задает символ разделителя целой и дробной части для числовых типов

* `numberGroupingSeparator` - задает символ разделителя групп разрядов для числовых типов

* `integerFormat` - формат для типов `Integer` и `Long`

* `doubleFormat` - формат для типа `Double`

* `decimalFormat` - формат для типа `BigDecimal`

* `dateTimeFormat` - формат для типа `java.util.Date`

* `dateFormat` - формат для типа `java.sql.Date`

* `timeFormat` - формат для типа `java.sql.Time`

* `trueString` - строка, соответствующая `Boolean.TRUE`

* `falseString` - строка, соответствующая `Boolean.FALSE`

Все перечисленные форматы по умолчанию заданы в главном пакете локализованных сообщений <<base_projects,базового проекта>> *cuba*, и могут быть переопределены в аналогичных файлах проекта приложения.

*Пример форматирования даты в UI*

Рассмотрим отображение атрибута `Order.date` в таблице браузера заказов.

`order-browse.xml`

[source, xml]
----
<table id="ordersTable">
  ...
  <columns>
      <column id="date"/>
      ...
----

Атрибут `date` в классе `Order` определен с типом "дата":

[source, java]
----
@Column(name = "DATE", nullable = false)
@Temporal(TemporalType.DATE)
private Date date;
----

Если текущий пользователь зарегистрирован c русской локалью, то из <<main_message_pack,главного пакета>> локализованных сообщений клиентского <<app_tiers,уровня>>, из файла `messages_ru.properties` извлекается строка:

[source, plain]
----
dateFormat=dd.MM.yyyy
----

Результат: дата "6 августа 2012 года" конвертируется в строку "06.08.2012" для отображения в ячейке таблицы.

*Примеры форматирования дат и чисел в коде приложения*

* Пример форматирования даты
+
[source, java]
----
@Inject
protected UserSessionSource userSessionSource;
...
Date date = ...;
String dateStr = Datatypes.get(Date.class).format(date, userSessionSource.getLocale());
----

* Пример форматирования числового значения с повышенной точностью (5 знаков после запятой) в <<app_tiers,блоке>> *Web Client*
+
`/com/sample/sales/web/messages_ru.properties`
+
[source, plain]
----
coordinateFormat = #,##0.00000
----
+
`SomeClass.java`
+
[source, java]
----
@Inject
protected Messages messages;
@Inject
protected UserSessionSource userSessionSource;
...
String coordinateFormat = messages.getMainMessage("coordinateFormat");
FormatStrings formatStrings = Datatypes.getFormatStrings(userSessionSource.getLocale());
NumberFormat format = new DecimalFormat(coordinateFormat, formatStrings.getFormatSymbols());

String formattedValue = format.format(value);
----

*Пример специализированного Datatype*

Рассмотрим реализацию нестандартного типа GeoCoordinateDatatype, предназначенного для атрибутов, хранящих географические координаты.

Создаем класс в модуле *global*:

[source, java]
----
public class GeoCoordinateDatatype extends DoubleDatatype {

  public static final String NAME = "geocoordinate";

  // формат общий для всех локалей, отличаться могут только символы десятичной точки
  public static final String FORMAT = "#0.000000";

  public GeoCoordinateDatatype(Element element) {
      super(element);
  }

  @Override
  public String getName() {
      return NAME;
  }

  @Override
  public String format(Double value, Locale locale) {
      if (value == null)
          return "";
      FormatStrings formatStrings = Datatypes.getFormatStrings(locale);
      if (formatStrings == null)
          return format(value); // FormatStrings для локали не определены, форматируем по данным datatypes.xml

      NumberFormat format = new DecimalFormat(FORMAT, formatStrings.getFormatSymbols());
      return format.format(value);
  }

  @Override
  public Double parse(String value, Locale locale) throws ParseException {
      if (StringUtils.isBlank(value))
          return null;
      FormatStrings formatStrings = Datatypes.getFormatStrings(locale);
      if (formatStrings == null)
          return parse(value); // FormatStrings для локали не определены, парсим по данным datatypes.xml

      NumberFormat format = new DecimalFormat(FORMAT, formatStrings.getFormatSymbols());
      return parse(value, format).doubleValue();
  }
}
----

Создаем файл `datatypes.xml` в корне каталога `src` модуля *global* проекта приложения и копируем в него все из файла `/com/haulmont/chile/core/datatypes/datatypes.xml`, расположенного в модуле *global* базового проекта *cuba*. Затем добавляем в него регистрацию нового типа:

[source, xml]
----
<datatypes>

  <datatype class="com.sample.sales.entity.GeoCoordinateDatatype"
            format="#0.000000" decimalSeparator="." groupingSeparator=""/>
...
----

Указываем новый тип данных для требуемых атрибутов:

[source, java]
----
@MetaProperty(datatype = GeoCoordinateDatatype.NAME)
@Column(name = "LATITUDE")
private Double latitude;
----

После выполнения перечисленных действий атрибут `latitude` везде в приложении будет отображаться в нужном формате.

[[meta_annotations]]
===== Мета-аннотации

Мета-аннотации сущностей - набор пар ключ/значение, содержащих дополнительную информацию о сущностях.

Обращение к мета-аннотациям производится с помощью метода <<metaClass,мета-класса>> `getAnnotations()`.

Источниками мета-аннотаций сущности являются:

* <<entity_annotations,Аннотации>> `@OnDelete`, `@OnDeleteInverse`, `@Extends`. При этом в мета-аннотациях создаются служебные объекты связей между сущностями. 

* <<entity_annotations,Аннотации>> `@NamePattern`, `@SystemLevel`, `@EnableRestore`, `@TrackEditScreenHistory`. При этом создаются мета-аннотации с ключами, соответствующими полному имени класса Java аннотации. 

* Опционально: в прикладном проекте могут быть определены свои аннотации для сущностей, и в <<extension,переопределенном>> методе `MetadataImpl.initMetaAnnotations()` отображены в соответствующие мета-аннотации. 

* Опционально: в файлах <<metadata.xml,metadata.xml также могут быть определены мета-аннотации сущностей. Если мета-аннотация в XML имеет то же имя, что и мета-аннотация, созданная по Java аннотации класса сущности, первая переопределит значение второй.
+
Пример определения мета-аннотаций в <<metadata.xml,metadata.xml>>:
+
[source, xml]
----
<annotations>
  <entity class="com.haulmont.cuba.security.entity.User">
      <annotation name="com.haulmont.cuba.core.entity.annotation.TrackEditScreenHistory" value="false"/>
      <annotation name="com.haulmont.cuba.core.entity.annotation.EnableRestore" value="true"/>
  </entity>
</annotations>
----

[[views]]
==== Представления

При извлечении сущностей из базы данных обычно встает вопрос - как обеспечить загрузку связанных сущностей на нужную глубину? 

Например, для браузера Заказов нужно отобразить дату и сумму заказа совместно с названием Покупателя, т.е. загрузить связанный экземпляр Покупателя. А для экрана редактирования Заказа необходимо загрузить еще и коллекцию Пунктов заказа, причем каждый Пункт заказа должен содержать связанный экземпляр Товара для отображения его наименования. 

<<lazy_loading,Загрузка по требованию>> в большинстве случаев не может помочь, так как обработка данных, как правило, происходит не в транзакции, в которой загружаются сущности, а, например, на клиентском <<app_tiers,уровне>> в пользовательском интерфейсе. В то же время задание <<eager_fetching,жадной загрузки>> в <<entity_annotations,аннотациях сущностей>> недопустимо, так как приводит к постоянному извлечению всего графа связанных сущностей, который может быть очень большим.

Другой похожей проблемой является ограничение набора <<local_attribute,локальных атрибутов>> сущностей загружаемого графа: например, некоторая сущность имеет 50 атрибутов, в том числе BLOB, а в экране отображается только 10 атрибутов. Зачем загружать из БД, затем сериализовать и передавать клиенту 40 атрибутов, которые ему в данный момент не нужны?

Механизм _представлений_ (views) решает эти проблемы, обеспечивая извлечение из базы данных и передачу клиенту графов сущностей, ограниченных в глубину и по атрибутам. _Представление_ является описателем графа объектов, который требуется в некотором экране UI или другом процессе обработки данных.

Обработка представлений производится следующим образом:

* Все связи в модели данных объявляются с признаком <<lazy_loading,загрузки по требованию>> (`fetch = FetchType.LAZY`, см. <<entity_annotations,>>).

* В процессе загрузки данных через <<dataManager,DataManager>> клиентский код помимо <<jpql,JPQL>>-запроса указывает нужное представление.

* На основе представления формируется так называемый _Fetch Plan_ - особенность лежащего в основе <<orm,слоя ORM>> фреймворка *Apache OpenJPA*. Fetch Plan влияет на формирование SQL-запроса к базе данных: как на список возвращаемых полей, так и на соединения с другими таблицами, содержащими связанные сущности.

* В представлении некоторые ссылочные атрибуты могут быть объявлены как `lazy` (см. ниже). Lazy-атрибуты не включаются в Fetch Plan, а загружаются отдельными SQL-запросами (иногда это полезно для упрощения основного SQL-запроса). Для этого механизм обработки представлений просто обращается к соответствующим методам чтения атрибутов.

* В результате на момент завершения <<transactions,транзакции>>, загружающей данные, в памяти *Middleware* содержится граф объектов, заданный JPQL-запросом и представлением.

.Классы представления
image::View.png[align="center"]

Представление определяется экземпляром класса `View`, в котором:

* `entityClass` - класс сущности, для которого определено представление. Другими словами, "корень" дерева загружаемых сущностей.

* `name` - имя представления. Должно быть либо `null`, либо уникальным в пределах данной сущности.

* `properties` - коллекция экземпляров класса ViewProperty, соответствующих загружаемым атрибутам сущности.

* `includeSystemProperties` - признак включения системных атрибутов (входящих в состав <<base_entity_classes,базовых интерфейсов>> персистентных сущностей `BaseEntity` и `Updatable`). Системные атрибуты не перечисляются в `properties` явно, а учитываются механизмом обработки представлений в зависимости от того, какие интерфейсы реализует данная сущность.

Класс `ViewProperty` имеет следующие свойства:

* `name` - имя атрибута сущности

* `view` - для ссылочных атрибутов задает представление, с которым необходимо загружать связанную сущность

* `lazy` - для ссылочных атрибутов признак того, что данный атрибут нужно не включать в Fetch Plan, а загружать отдельным SQL запросом, инициированным обращением к атрибуту. Следует иметь в виду, что при использовании <<dataManager,DataManager>> и <<datasources,источников данных>> атрибут в любом случае будет загружен, данный признак влияет только на способ загрузки. Если же представление с `lazy` атрибутами используется на уровне ORM, то после загрузки экземпляров их обязательно нужно передать в метод <<entityManager,EntityManager>>.fetch() до окончания транзакции, иначе `lazy` атрибуты загружены не будут.

[WARNING]
====
Независимо от набора атрибутов, определенного в представлении, всегда загружаются следующие атрибуты:

* `id` - идентификатор сущности

* `version` - для оптимистично блокируемых сущностей, реализующих `Versioned`

* `deleteTs`, `deletedBy` - для сущностей, реализующих <<soft_deletion,SoftDelete>>

====

Незагруженные атрибуты имеют значение `null`. По умолчанию попытка установки значения незагруженного атрибута (вызов setter) для <<entity_states,Detached>> сущности вызывает исключение. Это поведение можно изменить с помощью свойства приложения <<cuba.allowSetNotLoadedAttributes,cuba.allowSetNotLoadedAttributes>>. Если данное свойство установлено в `true`, то вызов setter не приведет к исключению, но значение все равно сохранено не будет.

Следует иметь в виду, что незагруженные ссылочные атрибуты Detached сущности, соответствующие внешним ключам (т.е. ManyToOne, OneToOne), можно установить в новое ненулевое значение в любом случае, и изменения будут сохранены при последующем `merge()`.

[[view_creation]]

===== Создание представлений

Представление может быть создано двумя путями:

* *программно* - созданием экземпляра `View`, например:
+
[source, java]
----
View view = new View(Order.class)
      .addProperty("date")
      .addProperty("amount")
      .addProperty("customer", new View(Customer.class)
          .addProperty("name")
      );
----
+
Как правило, таким способом создаются представления, используемые только в каком-то одном месте бизнес-логики.

* *декларативно* - путем создания описателя на XML и его развертывания в репозитории представлений `ViewRepository`. При развертывании на основе XML-описателя создаются и кэшируются экземпляры `View`. В дальнейшем в любом месте кода приложения требуемое представление можно получить вызовом репозитория с указанием класса сущности и имени представления.

Рассмотрим подробнее декларативный способ создания и работы с представлениями.

`ViewRepository` является бином *Spring*, доступным для всех блоков приложения. Ссылка на `ViewRepository` может быть также получена через интерфейс инфраструктуры <<metadata,Metadata>>. Для получения экземпляра `View`, содержащегося в репозитории, используются методы `getView()`. Для развертывания XML-описателей представлений в репозитории используются методы `deployViews()` базовой реализации `AbstractViewRepository`.

В репозитории для каждой сущности по умолчанию доступны два представления с именами `_local` и `_minimal`:

* `_local` включает в себя все <<local_attribute,локальные>> атрибуты сущности

* `_minimal` включает в себя атрибуты, входящие в имя экземпляра сущности, и задаваемые аннотацией <<namePattern,@NamePattern>>. Если аннотация `@NamePattern` для сущности не указана, данное представление не включает никаких атрибутов.

Подробная структура XML-описателей изложена в <<views.xml,views.xml>>.

Пример описателя представления для сущности Заказ, которое должно обеспечить загрузку всех локальных атрибутов, ассоциированного Покупателя и коллекции Пунктов заказа:

[source, xml]
----
<view class="com.sample.sales.entity.Order"
    name="orderWithCustomer"
    extends="_local">
  <property name="customer" view="_minimal"/>
  <property name="items" view="itemsInOrder"/>
</view>
----

Рекомендуемый способ группировки и развертывания описателей представлений:

* В <<app_modules,модуле>> *global* в корне `src` создать файл `views.xml` и поместить в него все описатели представлений, которые должны быть доступны глобально, т.е. на всех <<app_tiers,уровнях приложения>>.

* Зарегистрировать данный файл в свойстве <<cuba.viewsConfig,cuba.viewsConfig>> блока *Middleware* и используемых клиентских блоков, т.е. в файле `app.properties` модуля *core*, в файле `web-app.properties` модуля *web* и так далее. Это обеспечит автоматическое развертывание представлений на старте приложения в репозитории *Middleware* и клиентских блоков (см. метод `AbstractViewRepository.init()`).

* Если существуют представления, которые необходимы только какому-то одному клиентскому блоку приложения, то можно определить их в аналогичном файле данного блока, например, `web-views.xml`, и добавить этот файл в свойство `cuba.viewsConfig` этого блока, т.е. в данном случае в файл `web-app.properties`. 

Если на момент развертывания некоторого представления в репозитории уже есть представление для этого же класса сущности и с таким же именем, то новое будет проигнорировано. Для того чтобы представление заменило имеющееся в репозитории и гарантированно было развернуто, в XML-описателе должен быть явно указан атрибут `overwrite = "true"`.

[TIP]
====
Рекомендуется давать представлениям "описательные" имена. Например, не "browse", а "customerBrowse". Это упрощает поиск XML-описателей представлений по имени в процессе разработки приложения.
====

[[managed_beans]]
==== Управляемые бины

_Управляемые бины (Managed Beans)_ − это программные компоненты, предназначенные для реализации бизнес-логики приложения. Термин "управляемые" в данном случае означает, что созданием экземпляров и установкой связей между такими компонентами управляет <<container,контейнер>> который является основной частью фреймворка *Spring*.

[WARNING]
====
Managed Bean представляет собой _singleton_, то есть в некотором блоке приложения существует только один экземпляр данного класса. Поэтому, если бин содержит изменяемые данные в полях (другими словами, имеет состояние), то обращение к таким данным необходимо синхронизировать.
====

===== Создание бина

Для создания управляемого бина достаточно добавить классу Java аннотацию `@javax.annotation.ManagedBean`. Например:

[source, java]
----
package com.sample.sales.core;

import com.sample.sales.entity.Order;
import javax.annotation.ManagedBean;

@ManagedBean(OrderWorker.NAME)
public class OrderWorker {
  public static final String NAME = "sales_OrderWorker";

  public void calculateTotals(Order order) {
  }
}
----

Рекомендуется присваивать бину уникальное имя вида `++{имя_проекта}_{имя_класса}++`, и определять его в константе `NAME`. 

Класс управляемого бина должен находиться внутри дерева пакетов с корнем, заданным в элементе `context:component-scan` файла <<spring.xml,spring.xml>>. В нашем случае файл `spring.xml` содержит элемент:

[source, xml]
----
<context:component-scan base-package="com.sample.sales"/>
----

что означает, что поиск аннотированных бинов для данного блока приложения будет происходить начиная с пакета `com.sample.sales`.

Если нужно обеспечить возможность подмены реализации, рекомендуется выделять бизнес-интерфейс бина, например, следующим образом:

[source, java]
----
package com.sample.sales.core;

import com.sample.sales.entity.Order;

public interface OrderWorker {
  String NAME = "sales_OrderWorker";

  void calculateTotals(Order order);
}
----

[source, java]
----
package com.sample.sales.core;

import com.sample.sales.entity.Order;
import javax.annotation.ManagedBean;

@ManagedBean(OrderWorker.NAME)
public class OrderWorkerBean implements OrderWorker {
  @Override
  public void calculateTotals(Order order) {
  }
}
----

Управляемые бины можно создавать на любом <<app_tiers,уровне>>, так как контейнер *Spring Framework* используется во всех стандартных блоках приложения.

===== Использование бина

Ссылку на бин можно получить с помощью инжекции или класса `AppBeans`. В качестве примера использования бина рассмотрим реализацию <<services,сервиса>> `OrderService`, делегирующего выполнение бину `OrderWorker`:

[source, java]
----
package com.sample.sales.core;

import com.haulmont.cuba.core.Persistence;
import com.sample.sales.entity.Order;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import javax.inject.Inject;

@Service(OrderService.NAME)
public class OrderServiceBean implements OrderService {

  @Inject
  protected Persistence persistence;

  @Inject
  protected OrderWorker orderWorker;

  @Transactional
  @Override
  public BigDecimal calculateTotals(Order order) {
      Order entity = persistence.getEntityManager().merge(order);
      orderWorker.calculateTotals(entity);
  }
}
----

В данном примере сервис стартует <<transactions,транзакцию>>, вносит полученный с клиентского уровня экземпляр сущности в <<entityManager,персистентный контекст>>, и передает управление бину `OrderWorker`, который и содержит основную бизнес-логику. 

[[jmx_beans]]
==== JMX-бины

Иногда требуется предоставить администратору системы возможность просматривать и изменять состояние некоторого <<managed_beans,управляемого бина>> во время выполнения. В этом случае рекомендуется создать JMX-бин - программный компонент, имеющий <<jmx,JMX>>-интерфейс. Такой бин, как правило, делегирует вызовы управляемому бину, содержащему кэш, конфигурационные данные или статистику, к которым нужно обеспечить доступ через JMX.

image::JMXBeans.png[align="center"]

Как видно из диаграммы, JMX-бин состоит из интерфейса и класса реализации. Класс должен представлять собой <<managed_beans,управляемый бин>>, то есть иметь аннотацию `@ManagedBean` и уникальное имя. Интерфейс JMX-бина специальным образом регистрируется в <<spring.xml,spring.xml>> для создания в текущей JVM собственно JMX-интерфейса.

Вызовы всех методов интерфейса JMX-бина перехватываются с помощью *Spring AOP* классом−<<interceptor,интерцептором>> `MBeanInterceptor`, который обеспечивает установку правильного `ClassLoader` в контексте потока выполнения, и журналирование необработанных исключений.

[WARNING]
====
Интерфейс JMX-бина обязательно должен иметь имя вида `++{имя_класса}MBean++`.
====

С JMX-интерфейсом можно работать из внешних инструментов, таких как `jconsole` или `jvisualvm`. Кроме того, в состав блока Web Client платформы входит <<jmx_console,JMX-консоль>>, предоставляющая базовые средства просмотра состояния и вызова методов JMX-бинов.

===== Создание JMX-бина

Рассмотрим процесс создания JMX-бина на примере.

* Интерфейс JMX-бина:
+
[source, java]
----
package com.sample.sales.core;

import org.springframework.jmx.export.annotation.*;

@ManagedResource(description = "Performs operations on Orders")
public interface OrdersMBean {

  @ManagedOperation(description = "Recalculates an order amount")
  @ManagedOperationParameters({@ManagedOperationParameter(name = "orderId", description = "")})
  String calculateTotals(String orderId);
}
----
+
Интерфейс и его методы могут содержать аннотации для задания описания JMX-бина и его операций. Это описание будет отображаться во всех инструментах, работающих с данным JMX-интерфейсом, тем самым помогая администратору системы.
+
Так как инструменты JMX поддерживают ограниченный набор типов данных, параметры и результат метода желательно задавать типа `String`, и при необходимости выполнять конвертацию внутри метода.

* Класс JMX-бина:
+
[source, java]
----
package com.sample.sales.core;

import com.haulmont.cuba.core.*;
import com.haulmont.cuba.core.app.*;
import com.sample.sales.entity.Order;
import org.apache.commons.lang.exception.ExceptionUtils;
import javax.annotation.ManagedBean;
import javax.inject.Inject;
import java.util.UUID;

@ManagedBean("sales_OrdersMBean")
public class Orders implements OrdersMBean {

  @Inject
  protected OrderWorker orderWorker;

  @Inject
  protected Persistence persistence;

  @Authenticated
  @Override
  public String calculateTotals(final String orderId) {
      try {
          persistence.createTransaction().execute(new Transaction.Runnable() {
              @Override
              public void run(EntityManager em) {
                  Order entity = em.find(Order.class, UUID.fromString(orderId));
                  orderWorker.calculateTotals(entity);
              }
          });
          return "Done";
      } catch (Throwable e) {
          return ExceptionUtils.getStackTrace(e);
      }
  }
}
----
+
Аннотация `@ManagedBean` определяет, что данный класс является управляемым бином с именем `++sales_OrdersMBean++`. Имя указано напрямую в аннотации, а не в константе, так как доступ к JMX-бину из кода Java не требуется.
+
Рассмотрим реализацию метода `calculateTotals()`.

** Метод имеет аннотацию `@Authenticated`, т.е. при входе в метод и при отсутствии в потоке выполнения <<userSession,пользовательской сессии>> выполняется <<system_authentication,системная аутентификация>>.

** Тело метода обернуто в блок `try/catch`, так что метод в случае успешного выполнения возвращает строку "Done", а в случае ошибки - stacktrace исключения в виде строки. 
+
Следует иметь в виду, что в данном случае все исключения обрабатываются, а значит, не попадают в `MBeanInterceptor` и не выводятся в журнал автоматически. Поэтому при необходимости логгировать исключения здесь нужно добавить вызов логгера в секции `catch`.

** Логика метода заключается в том, что он стартует транзакцию, загружает экземпляр сущности `Order` по идентификатору и передает управление бину `OrderWorker` для обработки.

* Регистрация JMX-бина в `spring.xml`:
+
[source, xml]
----
<bean id="sales_MBeanExporter" lazy-init="false"
    class="com.haulmont.cuba.core.sys.jmx.MBeanExporter">
  <property name="beans">
      <map>
          <entry key="${cuba.webContextName}.sales:type=Orders"
                 value-ref="sales_OrdersMBean"/>
      </map>
  </property>
</bean>
----

Все JMX-бины проекта объявляются в одном экземпляре `MBeanExporter` в элементах `map/entry` свойства `beans`. Ключом элемента здесь является JMX ObjectName, значением - имя бина, заданноев аннотации `@ManagedBean`. ObjectName начинается с имени веб-приложения, так как в одном экземпляре *Tomcat* (т.е. в одной JVM) может быть развернуто несколько веб-приложений, экспортирующих одинаковые JMX-интерфейсы.

===== JMX-бины платформы

В данном разделе описаны некоторые имеющиеся в платформе JMX-бины.

[[cachingFacadeMBean]]
*CachingFacadeMBean*

`CachingFacadeMBean` предоставляет методы очистки различных кэшей в блоках *Middleware* и *Web Client*.

JMX ObjectName: `app-core.cuba:type=CachingFacade` и `app.cuba:type=CachingFacade`

[[configStorageMBean]]
*ConfigStorageMBean*

`ConfigStorageMBean` позволяет просматривать и задавать значения <<app_properties,свойствам приложения>> в блоках *Middleware*, *Web Client* и *Web Portal*.

Данный интерфейс имеет отдельные наборы методов для работы с параметрами конфигурации и развертывания (`++*AppProperties++`) и с параметрами времени выполнения (`++*DbProperties++`), что обусловлено различием механизмов хранения этих категорий свойств.

[WARNING]
====
Существуют следующие ограничения в использовании интерфейса `ConfigStorageMBean`:

* Отображаются только явно установленные в месте хранения свойства. Если значение свойства не задано, то в случае обращения к нему из кода программы через <<config_interfaces,конфигурационный интерфейс>>, возвращается значение по умолчанию. Однако через `ConfigStorageMBean` значение по умолчанию не может быть получено. 

* Измененные значения для свойств, хранящихся в файлах, не сохраняются, и действуют только до рестарта данного блока.
====

JMX ObjectName: `app-core.cuba:type=ConfigStorage`, `app.cuba:type=ConfigStorage`, `app-portal.cuba:type=ConfigStorage`

*EmailerMBean*

`EmailerMBean` позволяет просмотреть текущие значения параметров <<email_sending,отсылки email>>, а также отправить тестовое сообщение.

JMX ObjectName: `app-core.cuba:type=Emailer`

[[persistenceManagerMBean]]
*PersistenceManagerMBean*

`PersistenceManagerMBean` предоставляет следующие возможности:

* управление механизмом <<entity_statistics,статистики сущностей>>

* отображение новых скриптов обновления БД методом `findUpdateDatabaseScripts()` и запуск обновления методом `updateDatabase()`

* запуск произвольных JPQL запросов в контексте *Middleware* методами `jpqlLoadList()`, `jpqlExecuteUpdate()`

JMX ObjectName: `app-core.cuba:type=PersistenceManager`

[[scriptingManagerMBean]]
*ScriptingManagerMBean*

`ScriptingManagerMBean` является JMX-фасадом для интерфейса инфраструктуры <<scripting,Scripting>>.

JMX ObjectName: `app-core.cuba:type=ScriptingManager`

JMX-атрибуты:

* `RootPath` - абсолютный путь к <<conf_dir,конфигурационному каталогу>> <<app_tiers,блока приложения>>, в котором запущен данный бин.

JMX-операции:

* `runGroovyScript()` - выполнить скрипт Groovy в контексте *Middleware* и вернуть результат. В скрипт передаются следующие переменные:

** `persistence` типа <<persistence,Persistence>>

** `metadata` типа <<metadata,Metadata>>

** `configuration` типа <<configuration,Configuration>>
+
Для отображения в JMX-интерфейсе результат должен быть типа `String`. В остальном аналогичен методу `Scripting.<<scripting.runGroovyScript,runGroovyScript()>>`. 
+
Пример скрипта, создающего набор тестовых пользователей:
+
[source, java]
----
import com.haulmont.cuba.core.*
import com.haulmont.cuba.core.global.*
import com.haulmont.cuba.security.entity.*

PasswordEncryption passwordEncryption = AppBeans.get(PasswordEncryption.class)

Transaction tx = persistence.createTransaction()
try {
  EntityManager em = persistence.getEntityManager()
  Group group = em.getReference(Group.class, UUID.fromString('0fa2b1a5-1d68-4d69-9fbd-dff348347f93'))
  for (i in (1..250)) {
      User user = new User()
      user.setGroup(group)
      user.setLogin("user_${i.toString().padLeft(3, '0')}")
      user.setName(user.login)
      user.setPassword(passwordEncryption.getPasswordHash(user.id, '1'));
      em.persist(user)
  }
  tx.commit()
} finally {
  tx.end()
}
----

[[serverInfoMBean]]
*ServerInfoMBean*

`ServerInfoMBean` предоставляет общую информацию о данном блоке *Middleware*: номер и дату сборки, <<serverId,идентификатор сервера>>.

JMX ObjectName: `app-core.cuba:type=ServerInfo`

[[infrastructure_interfaces]]
==== Интерфейсы инфраструктуры

Интерфейсы инфраструктуры обеспечивают доступ к часто используемой функциональности платформы. Большинство из этих интерфейсов расположены в <<app_modules,модуле>> *global* и могут быть использованы как на среднем слое, так и в <<app_tiers,блоках>> клиентского уровня, но некоторые (например, <<persistence,Persistence>>) доступны только коду среднего слоя.

Интерфейсы инфраструктуры реализуются бинами *Spring Framework*, поэтому они могут быть инжектированы в любые другие управляемые компоненты (<<managed_beans,Managed Beans>>, <<services,сервисы среднего слоя>>, <<screen_controller,контроллеры>> экранов универсального пользовательского интерфейса).

Кроме того, как и любые другие бины, интерфейсы инфраструктуры могут быть получены с помощью статических методов класса `AppBeans` и использоваться в неуправляемых компонентах (<pojo,POJO>>, вспомогательных классах и пр.).

[[configuration]]
===== Configuration

Позволяет получать ссылки на <<config_interfaces,конфигурационные интерфейсы>> там, где невозможна их инжекция.

Пример:

[source, java]
----
String tempDir = AppBeans.get(Configuration.class).getConfig(GlobalConfig.class).getTempDir();
----

[[messages]]
===== Messages

Интерфейс `Messages` обеспечивает получение <<localization,локализованных строк сообщений>>.

Рассмотрим методы интерфейса подробнее.

* `getMessage()` - возвращает локализованное сообщение по ключу, имени пакета сообщений и требуемой локали. Существует несколько модификаций данного метода в зависимости от набора параметров. Если локаль не указана в параметре метода, используется локаль текущего пользователя.
+
Примеры:
+
[source, java]
----
@Inject
protected Messages messages;
...
String message1 = messages.getMessage(getClass(), "someMessage");
String message2 = messages.getMessage("com.abc.sales.web.customer", "someMessage");
String message3 = messages.getMessage(RoleType.STANDARD);
----

* `formatMessage()` - находит локализованное сообщение по ключу, имени пакета сообщений и требуемой локали, и использует его для форматирования переданных параметров. Формат задается по правилам метода `String.format()`. Существует несколько модификаций данного метода в зависимости от набора параметров. Если локаль не указана в параметре метода, используется локаль текущего пользователя.
+
Пример:
+
[source, java]
----
String formattedValue = messages.formatMessage(getClass(), "someFormat", someValue);
----

* `getMainMessage()` - возвращает локализованное сообщение из <<main_message_pack,главного пакета>> данного <<app_tiers,блока>> приложения.
+
Пример:
+
[source, java]
----
protected Messages messages = AppBeans.get(Messages.class);
...
messages.getMainMessage("actions.Ok");
----

* `getMainMessagePack()` - возвращает имя <<main_message_pack,главного пакета>> сообщений данного блока приложения.
+
Пример:
+
[source, java]
----
String formattedValue = messages.formatMessage(messages.getMainMessagePack(), "someFormat", someValue);
----

* `getTools()` - возвращает экземпляр интерфейса `MessageTools` (см. ниже).

[[messageTools]]
*MessageTools*

<<managed_beans,ManagedBean>>, содержащий вспомогательные методы работы с <<localization,локализованными сообщениями>>. Интерфейс `MessageTools` можно получить либо методом `Messages.getTools()`, либо как любой другой бин - инжекцией или через класс `AppBeans`. 

Методы `MessageTools`:

* `loadString()` - возвращает локализованное сообщение, заданное ссылкой вида `msg://{messagePack}/{key}`.
+
Составные части ссылки:

** `msg://` - обязательный префикс.

** `{messagePack}` - необязательное имя пакета сообщения. Если не указано, предполагается, что имя пакета передается в `loadString()` отдельным параметром.

** `{key}` - ключ сообщения в пакете.
+
Примеры ссылок на сообщения:
+
[source, plain]
----
msg://someMessage
msg://com.abc.sales.web.customer/someMessage
----

* `getEntityCaption()` - возвращает локализованное название сущности.

* `getPropertyCaption()` - возвращает локализованное название атрибута сущности.

* `hasPropertyCaption()` - определяет, задано ли для атрибута сущности локализованное название. 

* `getLocValue()` - возвращает локализованное значение атрибута сущности, основываясь на определении аннотации <<localizedValue_annotation,@LocalizedValue>>.

* `getMessageRef()` - формирует для <<metaProperty,мета-свойства>> <<messageTools.loadString,ссылку на сообщение>>, по которой можно получить локализованное название атрибута сущности.

* `getDefaultLocale()` - возвращает локаль приложения по умолчанию, то есть указанную первой в списке свойства <<cuba.availableLocales,cuba.availableLocales>>.

* `useLocaleLanguageOnly()` - возвращает `true`, если в списке поддерживаемых приложением локалей, заданном свойством <<cuba.availableLocales,cuba.availableLocales>>, для всех локалей определен только язык, а `country` и `variant` не указаны. Этим методом пользуются механизмы платформы, которым необходимо найти наиболее подходящую локаль из списка поддерживаемых на основе локали, полученной из внешних источников, таких как операционная система или HTTP запрос.

* `trimLocale()` - удаляет из переданной локали все кроме языка, если метод `useLocaleLanguageOnly()` возвращает `true`.

Для расширения набора вспомогательных методов в конкретном приложении бин `MessageTools` можно <<bean_extension,переопределить>>. Примеры работы с расширенным интерфейсом:

[source, java]
----
MyMessageTools tools = messages.getTools();
tools.foo();
----

[source, java]
----
((MyMessageTools) messages.getTools()).foo();
---- 

[[metadata]]
===== Metadata

Интерфейс `Metadata` обеспечивает доступ к сессии <<metadata_framework,метаданных>> и репозиторию <<views,представлений>>.

Методы интерфейса:

* `getSession()` - возвращает экземпляр сессии <<metadata_framework,метаданных>> 

* `getViewRepository()` - возвращает экземпляр репозитория <<views,представлений>>

* `getExtendedEntities()` - возвращает экземпляр `ExtendedEntities`, предназначенный для работы с расширенными сущностями. Подробнее см. <<entity_extension,>>

* `create()` - создать экземпляр сущности, учитывая возможность расширения. Подробнее см. <<entity_extension,>> 

* `getTools()` - возвращает экземпляр интерфейса `MetadataTools` (см. ниже).

*MetadataTools*

<<managed_beans,ManagedBean>>, содержащий вспомогательные методы работы с метаданными. Интерфейс `MetadataTools` можно получить либо методом `Metadata.getTools()`, либо как любой другой бин - инжекцией или через класс `AppBeans`.

Методы `MetadataTools`:

* `getAllPersistentMetaClasses()` - возвращает коллекцию <<metaClass,мета-классов>> персистентных сущностей

* `getAllEmbeddableMetaClasses()` - возвращает коллекцию <<metaClass,мета-классов>> встраиваемых сущностей

* `getAllEnums()` - возвращает коллекцию классов перечислений, используемых в качестве типов атрибутов сущностей

* `format()` - форматирует переданное значение в соответствии с типом данных заданного <<metaProperty,мета-свойства>>

* `isSystem()` - определяет, является ли переданное <<metaProperty,мета-свойство>> системным, т.е. заданным в одном из <<base_entity_classes,базовых интерфейсов сущностей>>

* `isPersistent()` - определяет, является ли переданное мета-свойство персистентным, т.е. хранимым в БД

* `isTransient()` - определяет, является ли переданное мета-свойство или произвольный атрибут неперсистентным

* `isEmbedded()` - определяет, является ли переданное мета-свойство встроенным объектом

* `isAnnotationPresent()` - определяет наличие указанной аннотации на классе или его предках

* `getNamePatternProperties()` - возвращает коллекцию мета-свойств атрибутов, входящих в имя экземпляра, возвращаемого методом `Instance.getInstanceName()`. См. <<namePattern,@NamePattern>>.

Для расширения набора вспомогательных методов в конкретном приложении бин `MetadataTools` можно <<bean_extension,переопределить>>. Примеры работы с расширенным интерфейсом:

[source, java]
----
MyMetadataTools tools = metadata.getTools();
tools.foo();
----

[source, java]
----
((MyMetadataTools) metadata.getTools()).foo();
----

[[resources]]
===== Resources

Обеспечивает загрузку ресурсов по следующим правилам:

. если указанное местонахождение представляет собой URL, ресурс загружается из этого URL;если указанное местонахождение представляет собой URL, ресурс загружается из этого URL;

. если указанное местонахождение начинается с префикса `classpath:`, ресурс загружается из classpath;

. если не URL и не начинается с `classpath:`, то:

.. в <<conf_dir,каталоге конфигурации>> приложения ищется файл, используя указанное местонахождение как относительный путь. Если файл найден, ресурс загружается из него;

.. если ресурс не найден на предыдущих этапах, он загружается из classpath.

На практике явное указание URL или префикса `classpath:` используется редко, т.е. обычно ресурсы загружаются либо из <<conf_dir,конфигурационного каталога>>, либо из classpath. Ресурс в конфигурационном каталоге замещает одноименный ресурс в classpath.

Методы `Resources`:

* `getResourceAsStream()` - возвращает `InputStream` для указанного ресурса, либо `null`, если ресурс не найден. Поток должен быть закрыт после использования, например:
+
[source, java]
----
@Inject
protected Resources resources;
...
InputStream stream = null;
try {
  stream = resources.getResourceAsStream(resourceLocation);
  ...
} finally {
  IOUtils.closeQuietly(stream);
}
----
+
Возможно использование "try with resources":
+
[source, java]
----
try (InputStream stream = resources.getResourceAsStream(resourceLocation)) {
  ...
}
----

* `getResourceAsString()` - возвращает указанный ресурс в виде строки, либо `null`, если ресурс не найден

[[scripting]]
===== Scripting

Интерфейс `Scripting` позволяет динамически (т.е. во время работы приложения) компилировать и загружать классы Java и Groovy, а также выполнять скрипты и выражения на Groovy.

Методы `Scripting`:

* `evaluateGroovy()` - выполняет выражение на Groovy и возвращает его результат. 
+
Свойство приложения <<cuba.groovyEvaluatorImport,cuba.groovyEvaluatorImport>> позволяет определить общий набор импортируемых классов, подставляемых в каждое выполняемое выражение. По умолчанию все стандартные блоки приложения импортируют класс <<persistenceHelper,PersistenceHelper>>.
+
Скомпилированные выражения кэшируются, что значительно ускоряет повторное выполнение.
+
Пример:
+
[source, java]
----
@Inject
protected Scripting scripting;
...
Integer intResult = scripting.evaluateGroovy("2 + 2", new Binding());

Binding binding = new Binding();
binding.setVariable("instance", new User());
Boolean boolResult = scripting.evaluateGroovy("return PersistenceHelper.isNew(instance)", binding);
----

* `runGroovyScript()` - выполняет скрипт Groovy и возвращает его результат.
+
Скрипт должен быть расположен либо в <<conf_dir,конфигурационном каталоге>> приложения, либо в classpath (текущая реализация `Scripting` поддерживает ресурсы classpath только внутри JAR-файлов). Скрипт в конфигурационном каталоге замещает одноименный скрипт в classpath.
+
Путь к скрипту указывается с разделителями `/`, в начале пути символ `/` не требуется.
+
Пример:
+
[source, java]
----
@Inject
protected Scripting scripting;
...
Binding binding = new Binding();
binding.setVariable("itemId", itemId);
BigDecimal amount = scripting.runGroovyScript("com/abc/sales/CalculatePrice.groovy", binding);
----

* `loadClass()` - загружает Java или Groovy класс, используя следующую последовательность действий:

. Если класс уже загружен, возвращает его.Если класс уже загружен, возвращает его.

. Ищет исходный текст Groovy (файл `++*.groovy++`) в каталоге конфигурации. Если найден, компилирует его, загружает и возвращает класс.

. Ищет исходный текст Java (файл `++*.java++`) в каталоге конфигурации. Если найден, компилирует его, загружает и возвращает класс.

. Ищет скомпилированный класс в classpath, если найден - загружает и возвращает его.

. Если ничего не найдено, возвращает `null`.
+
Файлы исходных текстов Java и Groovy в каталоге конфигурации можно изменять во время работы приложения. При следующем вызове `loadClass()` соответствующий класс будет перекомпилирован и возвращен новый, однако существуют следующие ограничения:

** нельзя изменять тип исходного текста с Groovy на Java

** если существовал исходный текст Groovy, и был однажды скомпилирован, то удаление файла исходного текста не приведет к загрузке другого класса из classpath - будет по-прежнему возвращаться класс, скомпилированный из удаленного исходника.
+
Пример:
+
[source, java]
----
@Inject
protected Scripting scripting;
...
Class calculatorClass = scripting.loadClass("com.abc.sales.PriceCalculator");
----

* `getClassLoader()` - возвращает `ClassLoader`, способный работать по правилам, описанным выше для метода `loadClass()`.

Кэш скомпилированных классов можно очистить во время выполнения с помощью JMX-бина <<cachingFacadeMBean,CachingFacadeMBean>>.

См. также <<scriptingManagerMBean,ScriptingManagerMBean>>

[[security]]
===== Security

Обеспечивает авторизацию - проверку прав пользователя на различные объекты системы. Перед вызовом соответствующих методов <<userSession,UserSession>> выполняется поиск исходного мета-класса сущности, что является важным при наличии <<entity_extension,расширений>>. Кроме методов, дублирующих методы `UserSession`, данный интерфейс имеет методы `isEntityAttrReadPermitted()` и `isEntityAttrUpdatePermitted()`, предназначенные для определения доступности пути к атрибуту с учетом доступности атрибутов и сущностей, входящих в этот путь.

Подробнее см. <<authentication,Аутентификация пользователей>>.

[[timeSource]]
===== TimeSource

Обеспечивает получение текущего времени. Применение `new Date()` и т.п. в прикладном коде не рекомендуется.

Примеры:

[source, java]
----
@Inject
protected TimeSource timeSource;
...
Date date = timeSource.currentTimestamp();
----

[source, java]
----
long startTime = AppBeans.get(TimeSource.class).currentTimeMillis();
----

[[userSessionSource]]
===== UserSessionSource

Обеспечивает получение объекта сессии текущего пользователя. Подробнее см. <<authentication,Аутентификация пользователей>>.

[[uuidSource]]
===== UuidSource

Обеспечивает получение значений `UUID`, в том числе для идентификаторов сущностей. Применение `UUID.randomUUID()` в прикладном коде не рекомендуется.

Для вызова из статического контекста можно использовать класс `UuidProvider`, который имеет также дополнительный метод `fromString()`, работающий быстрее, чем стандартный метод `UUID.fromString()`.

[[dataManager]]
===== DataManager

Интерфейс `DataManager` является универсальным средством для загрузки графов сущностей из базы данных, и для сохранения изменений, произведенных в detached экземплярах сущностей. 

`DataManager` всегда стартует новую транзакцию и по завершении работы выполняет коммит, таким образом возвращая сущности в <<entity_states,detached состоянии>>.

Методы `DataManager`:

* `load()`, `loadList()` - загружает граф сущностей в соответствии с параметрами переданного объекта `LoadContext`. 
+
В `LoadContext` обязательно должен быть передан либо JPQL-запрос, либо идентификатор сущности. Если передано и то и другое, используется запрос, а идентификатор игнорируется. 
+
Правила создания запросов аналогичны описанным в <<query,Выполнение JPQL-запросов>>. Отличием является то, что в запросе `LoadContext` могут быть использованы только именованные параметры, позиционные не поддерживаются.
+
Методы `load()` и `loadList()` проверяют наличие у пользователя <<permissions,права>> `EntityOp.READ` на загружаемую сущность. Кроме того, при извлечении сущностей из БД накладываются <<constraints,ограничения>> групп доступа. Для отмены действия ограничений в текущем запросе можно передать в `LoadContext` атрибут `useSecurityConstraints = false`.
+
Примеры загрузки сущностей в контроллере экрана: 
+
[source, java]
----
include::{sourcesdir}/common/dataManager_1.java[]
---- 

* `commit()` - сохраняет в базе данных набор сущностей, переданный в объекте `CommitContext`. Отдельно указываются коллекции сущностей, которые нужно сохранить, и которые нужно удалить.
+
Метод возвращает набор экземпляров сущностей, возвращенных из метода <<entityManager,EntityManager>>.merge(), то есть по сути свежие экземпляры, только что обновленные в БД. Дальнейшая работа должна производиться именно с этими возвращенными экземплярами, чтобы предотвратить потерю данных или исключения оптимистичной блокировки. Для того, чтобы обеспечить наличие нужных атрибутов у возвращенных сущностей, с помощью мэп `CommitContext.getViews()` можно указать <<views,представление>> для каждого сохраняемого экземпляра. 
+
Метод `commit()` проверяет наличие у пользователя <<permissions,права>> `EntityOp.UPDATE` на изменяемые сущности, и `EntityOp.DELETE` на удаляемые. 
+
Примеры сохранения коллекций сущностей: 
+
[source, java]
----
include::{sourcesdir}/common/dataManager_2.java[]
---- 

* `reload()` - удобные методы для перезагрузки экземпляра сущности с требуемым <<views,представлением>>. Делегируют выполнение методу `load()`.

* `remove()` - удаляет экземпляр сущности из базы данных. Делегируют выполнение методу `commit()`.

В процессе загрузки данных `DataManager` может реализовывать дополнительную функциональность, описанную ниже.

[[query_with_distinct]]
*Запросы с distinct*

В JPQL запросах для экранов со списками сущностей, в которых включено постраничное отображение и возможна непредсказуемая модификация запроса <<gui_Filter,универсальным фильтром>> или механизмом ограничений групп доступа, при отсутствии в запросе оператора `distinct` может возникать следующий эффект: 

* при объединении с коллекцией на уровне извлечения из базы данных возникает набор с дубликатами строк

* на клиентском уровне в источнике данных дубликаты исчезают, т.к. попадают в мэп (`java.util.Map`) 

* при постраничном отображении на одной странице оказывается меньшее количество строк, чем запрошено, общее количество строк наоборот завышено.

Таким образом, рекомендуется в JPQL запросы браузеров включать предложение `distinct`, которое гарантирует отсутствие дубликатов записей при выборке из базы данных. Однако в некоторых серверах БД (в частности *PostgreSQL*) при большом количестве извлекаемых записей (более 10000) SQL запрос с `distinct` выполняется недопустимо долго.

Для решения этой проблемы в платформе реализована возможность корректной работы без `distinct` на уровне SQL. Данный механизм включается свойством приложения <<cuba.inMemoryDistinct,cuba.inMemoryDistinct>>, при активации которого выполняется следующее: 

* В JPQL запросе должен по-прежнему присутствовать `select distinct`

* В `DataManager` из JPQL запроса перед отправкой в ORM `distinct` вырезается 

* После загрузки страницы данных на *Middleware* удаляются дубликаты и выполняются дополнительные запросы к БД для получения нужного количества строк, которые затем и возвращаются клиенту.

[[query_from_selected]]
*Последовательная выборка*

`DataManager` может выполнять последовательную выборку данных из результатов предыдущего запроса. Эта возможность используется в <<gui_Filter,универсальном фильтре>> при последовательном наложении фильтров. 

Данный механизм работает следующим образом:

* При получении `LoadContext` с установленными атрибутами `prevQueries` и `queryKey` `DataManager` выполняет выборку по предыдущему запросу и сохраняет идентификаторы полученных сущностей в таблице *SYS_QUERY_RESULT* (соответствующей сущности `sys$QueryResult`), разделяя наборы записей по идентификаторам пользовательских сессий и ключу сеанса выборки `queryKey`. 

* Текущий запрос модифицируется для объединения с результатами предыдущего, так что в итоге возвращает данные, соответствующие условиям обоих запросов, объединенных по "И".

* Далее процесс может повторяться, при этом уменьшающийся набор предыдущих результатов удаляется из таблицы *SYS_QUERY_RESULT* и заполняется заново.

Таблицу *SYS_QUERY_RESULT* необходимо периодически чистить от ненужных результатов запросов, оставленных завершенными пользовательскими сессиями. Для этого предназначен метод `deleteForInactiveSessions` бина `QueryResultsManagerAPI`. В прикладном проекте с включенным параметром <<cuba.allowQueryFromSelected,cuba.allowQueryFromSelected>> необходимо вызывать этот метод из <<scheduled_tasks,назначенных заданий>>, например:

[source, xml]
----
<task:scheduled-tasks scheduler="scheduler">
      <task:scheduled ref="cuba_QueryResultsManager" method="deleteForInactiveSessions" fixed-rate="600000"/>
  </task:scheduled-tasks>
----

[[appContext]]
==== AppContext

`AppContext` - системный класс, в статических полях которого хранятся ссылки на некоторые общие для любого <<app_tiers,блока>> приложения компоненты:

* `ApplicationContext` фреймворка *Spring*

* Набор <<app_properties,свойств приложения>>, загруженных из файлов `app.properties`

* `ThreadLocal` переменная, хранящая экземпляры `SecurityContext`

* Коллекция слушателей жизненного цикла приложения (`AppContext.Listener`)

`AppContext` инициализируется на запуске приложения классами-загрузчиками, специфичными для типа <<app_tiers,блока>> приложения:

* загрузчик *Middleware* - `AppContextLoader`

* загрузчик *Web Client* - `WebAppContextLoader`

* загрузчик *Web Portal* - `PortalAppContextLoader`

* загрузчик *Desktop Client* - `DesktopAppContextLoader`

`AppContext` может быть использован в прикладном коде для решения следующих задач:

* Регистрации слушателей, срабатывающих после полной инициализации и перед закрытием приложения, например:
+
[source, java]
----
AppContext.addListener(new AppContext.Listener() {
  @Override
  public void applicationStarted() {
      System.out.println("Application is ready");
  }

  @Override
  public void applicationStopped() {
      System.out.println("Application is closing");
  }
});
----
+
В момент вызова `applicationStarted()`:

** Полностью инициализированы все <<managed_beans,бины>>, в том числе выполнены их методы `@PostConstruct`.

** Можно использовать статические методы получения бинов `AppBeans.get()`.

** Метод `AppContext.isStarted()` возвращает `true`.

** Метод `AppContext.isReady()` возвращает `false`.

** В блоке Middleware: если свойство приложения <<cuba.automaticDatabaseUpdate,cuba.automaticDatabaseUpdate>> включено, все скрипты обновления БД успешно выполнены.
+
В момент вызова `applicationStopped()`:

** Все бины работоспособны и доступны через статические методы `AppBeans.get()`.

** Метод `AppContext.isStarted()` возвращает `false`.

** Метод `AppContext.isReady()` возвращает `false`.
+
Практический пример использования `AppContext.Listener` см. в <<app_start_recipe,Выполнение кода на старте приложения>>.

* Получения значений <<app_properties,свойств приложения>>, хранимых в файлах `app.properties`, если они недоступны через <<config_interfaces,конфигурационные интерфейсы>>.

* Передачи `SecurityContext` в новые потоки выполнения, см. <<authentication,Аутентификация пользователей>>.

[TIP]
====
Для получения ссылок на *Spring*-бины используйте инжекцию или статические методы класса `AppBeans`.

Использование `AppContext.getApplicationContext().getBean()` не рекомендуется.
====

[[app_properties]]
==== Свойства приложения

Свойства приложения − именованные данные различных типов, определяющие всевозможные аспекты конфигурации и функционирования приложения.

По назначению свойства приложения можно классифицировать следующим образом:

* _Конфигурационные параметры_ - задают наборы конфигурационных файлов и некоторые параметры пользовательского интерфейса, т.е. определяют функциональность приложения.
+
Например: `cuba.springContextConfig`, `cuba.web.useLightHeader`.

* _Параметры развертывания_ - различные URL для соединения <<app_tiers,блоков>> приложения, тип используемой БД, настройки подсистемы безопасности и т.д. 
+
Например: `cuba.connectionUrlList`, `cuba.dbmsType`, `<<cuba.userSessionExpirationTimeoutSec,cuba.userSessionExpirationTimeoutSec>>`.

* _Параметры времени выполнения_ - активность аудита, параметры отсылки email и т.д. 
+
Например: `cuba.security.EntityLog.enabled`, `cuba.email.smtpHost`.

Как правило, некоторое свойство принадлежит только одному или нескольким <<app_tiers,блокам>> приложения. Например, `<<cuba.persistenceConfig,cuba.persistenceConfig>>` имеет смысл только для *Middleware*, `cuba.web.useLightHeader` − только для *Web Client*, а `<<cuba.springContextConfig,cuba.springContextConfig>>` − для всех блоков.

Принадлежность к блоку означает, что если нужно задать значение некоторому свойству, это необходимо сделать _во всех блоках_, которым данное свойство принадлежит (и которые используются в приложении). 

Принадлежность можно выяснить следующими способами:

* Из документации: см. <<app_properties_reference,Свойства приложения>>

* Проследив использование свойства в коде приложения

* Если к свойству есть доступ через <<config_interfaces,конфигурационный интерфейс>>, то по принадлежности интерфейса <<app_modules,модулю>> проекта.

===== Доступ к свойствам

Основной способ доступа к свойствам приложения из прикладного кода − использование механизма <<config_interfaces,конфигурационных интерфейсов>>. Кроме того, все параметры конфигурации и развертывания доступны через методы класса `<<appContext,AppContext>>`.

Некоторые блоки приложения определяют JMX-интерфейсы для доступа к свойствам приложения. В частности, в блоках *Middleware*, *Web Client* и *Web Portal* имеется JMX-интерфейс `<<configStorageMBean,ConfigStorageMBean>>`, позволяющий получить и задать значение любого свойства во время работы приложения.

[[app_properties_files]]
===== Хранение свойств в файлах

Свойства, определяющие конфигурацию и параметры развертывания, задаются в специальных файлах свойств, имеющих имя вида `*-app.properties`. Каждый <<app_tiers,блок>> приложения имеет набор таких файлов, включающий в себя файлы из <<base_projects,базовых проектов>> платформы и файл текущего приложения. Набор файлов свойств определяется следующим образом:

* Для блоков, являющихся веб-приложениями (*Middleware*, *Web Client*, *Web Portal*) набор файлов свойств задается в `web.xml` в параметре `appPropertiesConfig`.

* Для блока *Desktop Client* основной способ задания набора файлов свойств − переопределение в приложении метода getDefaultAppPropertiesConfig() в классе-наследнике `com.haulmont.cuba.desktop.App`.

Например, набор файлов свойств блока *Middleware* проекта *sales* задается в файле `web/WEB-INF/web.xml` модуля *core*, и выглядит следующим образом:

[source, xml]
----
classpath:cuba-app.properties
classpath:app.properties
file:${catalina.home}/conf/app-core/local.app.properties
----

Здесь префикс `classpath:` означает, что данный файл нужно искать в Java classpath, префикс `file:` − в файловой системе. Возможно использование системных свойств Java, в данном случае это `catalina.home` − путь к корню *Tomcat*.

Порядок перечисления файлов важен, так как значения, указанные в каждом последующем файле заменяют значения одноименных свойств, заданные в предыдущих файлах. Этим достигается переопределение свойств платформы в конкретном приложении.

Последний файл в приведенном наборе − `local.app.properties`. Он может использоваться для переопределения свойств приложения при развертывании. Если этого файла нет, он игнорируется. Если же во время инсталляции системы требуется переопределение некоторых параметров (как правило, различных URL), достаточно создать этот файл и поместить в него переопределяемые свойства. При последующих обновлениях системы такой файл с локальными настройками легко сохранить.

Аналогом `local.app.properties` для *Desktop Client* служат аргументы командной строки запуска JVM. Загрузчик свойств данного блока воспринимает все аргументы, содержащие знак "`=`", как пары ключ-значение, и заменяет ими соответствующие свойства приложения, заданные в файлах `app.properties`.

[TIP]
====
Правила задания информации в файлах `*.properties`:

* Кодировка файла - `UTF-8`

* Ключ может состоять из латинских букв, цифр, точек и знаков подчеркивания

* Значение пишется после знака равно (`=`)

* Значение не нужно брать в кавычки " или '

* Файловые пути записываются либо в UNIX-виде (`/opt/haulmont/`), либо в Windows-виде (`c:\\haulmont\\`)

* Возможно использование кодов `\n \t \r`. Символ `\` является зарезервированным, для вставки в значение экранируется сам собой (`\\`). Подробнее см.: link:$$http://docs.oracle.com/javase/tutorial/java/data/characters.html$$[http://docs.oracle.com/javase/tutorial/java/data/characters.html]

* Для ввода значения в нескольких строках файла используйте символ `\` в конце строки, для того чтобы данное значение продолжалось на следующей строке.

====

[[app_properties_db]]
===== Хранение свойств в базе данных

Параметры времени выполнения хранятся в таблице *SYS_CONFIG* базы данных. 

Такие свойства имеют следующие особенности:

* так как значение свойства хранится в базе данных, оно задается в одном месте, независимо от того, в каких блоках приложения оно используется

* значение может быть изменено и сохранено во время работы приложения, как через <<config_interfaces,конфигурационный интерфейс>>, содержащий это свойство, так и через <<configStorageMBean,ConfigStorageMBean>>.

* значение свойства может быть переопределено для конкретного блока приложения в его файле `app.properties`. Поиск значения всегда происходит в два этапа - сначала в `app.properties`, если не найдено - то в базе данных. Поэтому изменять значение нужно в обоих местах хранения.

Хранящиеся в БД свойства кэшируются на уровне *Middleware*. Очистить кэш можно с помощью JMX-интерфейсов <<configStorageMBean,ConfigStorageMBean>> методом `clearCache()` или <<cachingFacadeMBean,CachingFacadeMBean>> методом `clearConfigStorageCache()`.

Следует иметь в виду, что на клиентском уровне чтение свойства, хранящегося в БД, приводит к запросу к *Middleware*, что менее эффективно, чем чтение локального свойства из `app.properties`. Для уменьшения количества таких запросов клиент кэширует все свойства, хранящиеся в БД, на время жизни экземпляра реализации конфигурационного интерфейса. Поэтому если, например, в некотором экране UI необходимо несколько раз обратиться к свойствам одного конфигурационного интерфейса, лучше получить ссылку на него при инициализации экрана, и сохранить в поле для последующих обращений к одному и тому же экземпляру. 

[[config_interfaces]]
===== Конфигурационные интерфейсы

Данный механизм позволяет работать со свойствами приложения через методы Java-интерфейсов, что дает следующие преимущества:

* типизированность - прикладной код работает с нужными типами (String, Boolean, Integer и пр.), а не только со строками

* в прикладном коде вместо строковых идентификаторов свойств используются методы интерфейсов, имена которых подсказываются средой разработки

Пример получения значения таймаута транзакции в блоке *Middleware*:

[source, java]
----
@Inject
private ServerConfig serverConfig;

public void doSomething() {
  int timeout = serverConfig.getDefaultQueryTimeoutSec();
  ...
}
----

При невозможности инжекции можно получить ссылку на конфигурационный интерфейс через <<configuration,Configuration>>:

[source, java]
----
int timeout = AppBeans.get(Configuration.class)
  .getConfig(ServerConfig.class)
  .getDefaultQueryTimeoutSec();
----

[WARNING]
====
Конфигурационные интерфейсы не являются нормальными бинами Spring, не пытайтесь получить их через `AppBeans.get()` - только непосредственной инжекцией самого интерфейса или через `Configuration.getConfig()`.
====

*Использование*

Для создания конфигурационного интерфейса необходимо:

* Создать интерфейс, унаследованный от `com.haulmont.cuba.core.config.Config` (не путать с классом сущности `com.haulmont.cuba.core.entity.Config`)

* Добавить интерфейсу аннотацию `@Source` для указания источника (способа хранения) параметров:

** `SourceType.SYSTEM` - значение свойства будет взято из системных свойств данной JVM, т.е. методом `System.getProperty()`

** `SourceType.APP` - значение свойства будет взято из файлов `app.properties`

** `SourceType.DATABASE` - значение свойства будет взято из таблицы *SYS_CONFIG*

* Создать методы доступа к свойству (getter / setter). Если значение свойства не предполагается изменять во время выполнения, метод доступа на запись не нужен. Возможный тип свойства рассмотрен ниже.

* Добавить методу доступа на чтение аннотацию `@Property`, определяющую имя свойства.

* Опционально аннотацию `@Source` можно задать для отдельного свойства в интерфейсе, если его источник отличается от заданного для всего интерфейса.

Например:

[source, java]
----
@Source(type = SourceType.DATABASE)
public interface SalesConfig extends Config {

  @Property("sales.companyName")
  String getCompanyName();
}
----

Создавать класс реализации конфигурационного интерфейса не нужно - при получении ссылки на интерфейс через <<configuration,Configuration>> будет автоматически создан необходимый прокси-объект.

[[config_interface_property_types]]
*Типы свойств*

Без дополнительных усилий поддерживаются следующие типы свойств: 

* `String`, простые типы либо их объектные обертки (`boolean`, `Boolean`, `int`, `Integer`, etc.).

* Перечисления (`enum`). Значение свойства сохраняется в файле или БД в виде имени значения перечисления.
+
Если перечисление реализует интерфейс `EnumClass` и имеет статический метод `fromId()` для получения значения по идентификатору, с помощью аннотации `@EnumStore` можно задать хранение значения в виде идентификатора. Например:
+
[source, java]
----
@Property("myapp.defaultCustomerGrade")
@DefaultInteger(10)
@EnumStore(EnumStoreMode.ID)
CustomerGrade getDefaultCustomerGrade();

@EnumStore(EnumStoreMode.ID)
void setDefaultCustomerGrade(CustomerGrade grade);
----

* Классы персистентных <<data_model,сущностей>>. При обращении к свойству типа сущности происходит загрузка из БД экземпляра, заданного значением свойства.

Для поддержки произвольного типа необходимо реализовать классы `TypeStringify` и `TypeFactory` для преобразования значения в строку и из нее, и указать эти классы для свойства с помощью аннотаций `@Stringify` и `@Factory`.

Рассмотрим этот процесс на примере типа `UUID`.

* Создаем класс `com.haulmont.cuba.core.config.type.UuidTypeFactory` унаследованный от `com.haulmont.cuba.core.config.type.TypeFactory` и реализуем в нем метод:
+
[source, java]
----
public Object build(String string) {
  if (string == null)
      return null;
  return UUID.fromString(string);
}
----

* `TypeStringify` создавать не нужно, т.к. по умолчанию будет использован метод `toString()` − в данном случае он нам подходит.

* Аннотируем свойство в конфигурационном интерфейсе:
+
[source, java]
----
@Factory(factory = UuidTypeFactory.class)
UUID getUuidProp();
void setUuidProp(UUID value);
----

В платформе определены реализации `TypeFactory` для следующих типов:

* `UUID` - `UuidTypeFactory`, описано выше.

* `java.util.Date` - `DateFactory`. Значение даты должно быть указано в формате `yyyy-MM-dd HH:mm:ss.SSS`, например:
+
[source, properties]
----
cuba.test.dateProp = 2013-12-12 00:00:00.000
----

* `List<Integer>` (список целых чисел) - `IntegerListTypeFactory`. Значение свойства должно быть указано в виде списка чисел, разделенных пробелами, например:
+
[source, properties]
----
cuba.test.integerListProp = 1 2 3
----

* `List<String>` (список строк) - `StringListTypeFactory`. Значение свойства должно быть указано в виде списка строк, разделенных символом "|", например:
+
[source, properties]
----
cuba.test.stringListProp = aaa|bbb|ccc
----

*Значения по умолчанию*

Для свойств конфигурационных интерфейсов могут быть заданы значения по умолчанию. Эти значения будут возвращаться вместо `null`, если данный параметр не задан в месте хранения - в БД или в `app.properties`.

Значение по умолчанию может быть задано в виде строки с помощью аннотации `@Default`, либо в виде конкретного типа с помощью других аннотаций пакета `com.haulmont.cuba.core.config.defaults`:

[source, java]
----
@Property("cuba.email.adminAddress")
@Default("address@company.com")
String getAdminAddress();

@Property("cuba.email.delayCallCount")
@Default("2")
int getDelayCallCount();

@Property("cuba.email.defaultSendingAttemptsCount")
@DefaultInt(10)
int getDefaultSendingAttemptsCount();

@Property("cuba.test.dateProp")
@Default("2013-12-12 00:00:00.000")
@Factory(factory = DateFactory.class)
Date getDateProp();

@Property("cuba.test.integerList")
@Default("1 2 3")
@Factory(factory = IntegerListTypeFactory.class)
List<Integer> getIntegerList();

@Property("cuba.test.stringList")
@Default("aaa|bbb|ccc")
@Factory(factory = StringListTypeFactory.class)
List<String> getStringList();
----

Для сущностей значение по умолчанию задается строкой вида `++{entity_name}-{id}-{optional_view_name}++`, например:

[source, java]
----
@Default("sec$User-98e5e66c-3ac9-11e2-94c1-3860770d7eaf-browse")
User getAdminUser();

@Default("sec$Role-a294aef0-3ac9-11e2-9433-3860770d7eaf")
Role getAdminRole();
----

[[localization]]
==== Локализация сообщений

Приложение на основе платформы CUBA поддерживает локализацию сообщений, то есть вывод всех элементов пользовательского интерфейса на языке, выбранном пользователем.

Возможности выбора языка пользователем определяются комбинацией свойств приложения <<cuba.localeSelectVisible,cuba.localeSelectVisible>> и <<cuba.availableLocales,cuba.availableLocales>>.

Для того, чтобы некоторое сообщение могло быть локализовано, т.е. представлено пользователю на нужном языке, его необходимо поместить в так называемый _пакет сообщений_. Ниже рассмотрены принципы работы механизма локализации и правила создания сообщений. 

<<getting_messages,>> содержит информацию о способах получения локализованных сообщений в различных компонентах системы.

[[message_packs]]
===== Пакеты сообщений

Пакет сообщений представляет собой набор файлов свойств с именами вида `messages{++_XX++}.properties`, расположенных в одном Java-пакете. Суффикс `XX` определяет язык, для которого в данном файле содержатся сообщения, и соответствует коду языка в `Locale.getLanguage()`. Возможно также использование остальных атрибутов `Locale`, например, `country`. В этом случая файл пакета будет иметь вид `messages{_XX_YY}.properties`. Один из файлов пакета может быть без суффикса языка - это _файл по умолчанию_. Именем пакета сообщений считается имя Java-пакета, в котором расположены файлы пакета.

Рассмотрим пример:

[source, properties]
----
/com/abc/sales/gui/customer/messages.properties
/com/abc/sales/gui/customer/messages_fr.properties
/com/abc/sales/gui/customer/messages_ru.properties
----

Данный пакет состоит из 3-х файлов - один для русского языка, один для французского, и один по умолчанию. Имя пакета - `com.abc.sales.gui.customer` 

Файлы сообщений содержат пары ключ-значение, где ключ - это идентификатор сообщения, на который ссылается код приложения, а значение - само сообщение на языке данного файла. Правила задания пар аналогичны правилам файлов свойств `java.util.Properties`, со следующими особенностями:

* Кодировка файла - обязательно `UTF-8`

* Поддерживается включение других пакетов сообщений с помощью ключа `@include`, в том числе нескольких сразу - перечислением через запятую. При этом если некоторый ключ сообщения встречается и во включаемом пакете, и в текущем, будет использовано сообщение из текущего. Пример включения пакетов:
+
[source, plain]
----
@include=com.haulmont.cuba.web, com.abc.sales.web

someMessage=Some Message
...
----

Получение сообщений из пакетов производится с помощью методов интерфейса <<messages,Messages>> по следующим правилам:

* Сначала производится поиск в <<conf_dir,конфигурационном каталоге>> приложения

** Ищется файл `messages++_XX++.properties` в каталоге, задаваемом именем пакета сообщений, где `XX` - код требуемого языка

** Если такого файла нет, в этом же каталоге ищется файл по умолчанию `messages.properties`

** Если найден или файл нужного языка, или файл по умолчанию, он загружается вместе со всеми `@include`, и в нем ищется ключ сообщения

** Если файл не найден, либо нужный ключ в нем отсутствует, производится смена каталога на родительский, и процедура поиска повторяется. И так до достижения корня конфигурационного каталога.

* Если в конфигурационном каталоге сообщение не найдено, производится поиск в classpath по такому же алгоритму.

* На клиентском <<app_tiers,уровне>>, если сообщение не найдено на предыдущих шагах, отправляется запрос на *Middleware*, и сообщение ищется там аналогичным способом.

* Если сообщение найдено, оно кэшируется и возвращается. Если не найдено - кэшируется факт отсутствия сообщения и возвращается ключ, который был передан для поиска. Таким образом, сложная процедура поиска выполняется только один раз, в дальнейшем результат загружается из локального для блока приложения кэша.

[TIP]
====
Рекомендуется организовывать пакеты сообщений следующим образом:

* Если приложение не предполагает интернационализации, то можно не использовать пакеты и включать строки сообщений прямо в код приложения, либо пользоваться файлами по умолчанию `messages.properties` для отделения ресурсов от кода.

* Если приложение интернациональное, логично файлы по умолчанию использовать для языка основной аудитории приложения, либо для английского языка. Именно сообщения из файлов по умолчанию будут показаны пользователю, если сообщений для нужного языка не найдено.
====

[[main_message_pack]]
===== Главный пакет сообщений

Каждый стандартный <<app_tiers,блок>> приложения определяет для себя один _главный_ пакет сообщений. Для блоков клиентского уровня этот пакет содержит названия пунктов главного меню и общих элементов UI (например, названия кнопок *OK* и *Cancel*). Для всех блоков приложения, включая *Middleware*, главный пакет определяет форматы преобразований <<datatype,Datatype>>.

Для указания главного пакета сообщений используется свойство приложения <<cuba.mainMessagePack,cuba.mainMessagePack>>. Значением свойства может быть либо один пакет, либо список пакетов, разделенный пробелами. Например:

[source, properties]
----
cuba.mainMessagePack=com.haulmont.cuba.web com.abc.sales.web
----

В данном случае сообщения, заданные во втором пакете списка будут перекрывать сообщений из первого пакета. Таким образом в проекте приложения можно переопределять сообщения, заданные в пакетах <<base_projects,базовых проектов>>.

[[entity_localization]]
===== Локализация названий сущностей и атрибутов

Для отображения в UI локализованных названий сущностей и их атрибутов необходимо создать специальные пакеты сообщений в тех же Java-пакетах, что и сами сущности. Формат файлов сообщений должен быть следующим:

* Ключ названия сущности - простое имя класса (без пакета)

* Ключ названия атрибута - простое имя класса, затем через точку имя атрибута

Пример русской локализации сущности `com.abc.sales.entity.Customer` - файл `/com/abc/sales/entity/messages_ru.properties`:

[source, plain]
----
Customer=Покупатель
Customer.name=Имя
Customer.email=Email

Order=Заказ
Order.customer=Покупатель
Order.date=Дата
Order.amount=Сумма
----

Такие пакеты сообщений, как правило, используются неявно для разработчика, например, визуальными компонентами <<gui_Table,Table>> и <<gui_FieldGroup,FieldGroup>>. Кроме того, названия сущностей и атрибутов могут быть также получены следующими методами:

* программно - методами <<messageTools,MessageTools>> `getEntityCaption()`, `getPropertyCaption()`

* в XML-дескрипторе экрана - указанием ссылки на сообщение по правилам `MessageTools.<<messageTools.loadString,loadString>>()`: `++msg://{entity_package}/{key}++`, например,
+
[source, xml]
----
caption="msg://com.abc.sales.entity/Customer.name"
----

[[enum_localization]]
===== Локализация enum

Для локализации названий и значений перечислений необходимо в пакет сообщений, находящийся в Java-пакете класса перечисления добавить сообщения со следующими ключами:

* Ключ названия перечисления - простое имя класса (без пакета)

* Ключ значения - простое имя класса, затем через точку имя значения

Например, для перечисления 

[source, java]
----
package com.abc.sales;

public enum CustomerGrade { PREMIUM, HIGH, STANDARD }
----

файл русской локализации `/com/abc/sales/messages_ru.properties` должен содержать строки:

[source, plain]
----
CustomerGrade=Уровень покупателя
CustomerGrade.PREMIUM=Премиум
CustomerGrade.HIGH=Высокий
CustomerGrade.STANDARD=Стандартный
----

Локализованные значения перечислений автоматически используются различными визуальными компонентами, например, <<gui_LookupField,LookupField>>. Для программного получения локализованного значения перечисления можно использовать метод `getMessage()` интерфейса <<messages,Messages>>, просто передавая в него экземпляр `enum`.

[[authentication]]
==== Аутентификация пользователей

В данном разделе рассмотрены некоторые аспекты управления доступом с точки зрения разработчика приложения. Для получения полной информации о возможностях и настройке ограничения доступа пользователей к данным см. <<chapter_security,>>. 

[[userSession]]
===== UserSession

Основной элемент подсистемы контроля доступа в CUBA-приложении - пользовательская сессия. Это объект класса `UserSession`, который ассоциирован с аутентифицированным в данный момент в системе пользователем, и содержит информацию о правах доступа пользователя к данным. Объект текущей сессии может быть получен в любом <<app_tiers,блоке>> приложения через интерфейс инфраструктуры <<userSessionSource,UserSessionSource>>.

Пользовательская сессия создается на *Middleware* при выполнении метода `LoginService.login()` после аутентификации пользователя по переданному имени и паролю. Объект `UserSession` затем кэшируется в данном блоке *Middleware*, и возвращается на клиентский уровень. При работе в кластере объект сессии реплицируется на соседние узлы кластера *Middleware*. Клиентский блок, получив объект сессии, также сохраняет его у себя, так или иначе ассоциируя с активным пользователем (например, в HTTP сессии). Далее все вызовы *Middleware* для данного пользователя сопровождаются передачей идентификатора сессии (типа `UUID`), причем прикладному коду не нужно об этом заботиться - идентификатор сессии передается автоматически, независимо от сигнатуры вызываемых методов среднего слоя. Обработка вызовов клиентов на *Middleware* начинается с извлечения из кэша сессии по полученному идентификатору и установки ее в потоке выполнения. Объект сессии удаляется из кэша при вызове метода `LoginService.logout()`, либо при истечении времени бездействия, определяемого свойством приложения <<cuba.userSessionExpirationTimeoutSec,cuba.userSessionExpirationTimeoutSec>>.

Таким образом, идентификатор сессии, создаваемой при входе пользователя в систему, служит для аутентификации пользователя при каждом вызове среднего слоя.

Объект `UserSession` содержит также методы для _авторизации_ текущего пользователя, т.е. проверки его прав на объекты системы: `isScreenPermitted()`, `isEntityOpPermitted()`, `isEntityAttrPermitted()`, `isSpecificPermitted()`.

С объектом `UserSession` могут быть ассоциированы именованные атрибуты произвольного сериализуемого типа. Атрибуты устанавливаются методом `setAttribute()` и возвращаются методом `getAttribute()`. Последний может также возвращать следующие параметры сессии, как если бы они были атрибутами:

* `userId` - ID текущего зарегистрированного или замещенного пользователя;

* `userLogin` - логин текущего зарегистрированного или <<user_substitution,замещенного>> пользователя в нижнем регистре.

Атрибуты реплицируются в кластере *Middleware* так же, как и все остальные данные сессии.

[[login]]
===== Вход в систему

Стандартный вариант входа пользователя: 

* пользователь вводит свой логин и пароль

* клиентский блок приложения хэширует пароль, вызывая метод `getPlainHash()` бина `PasswordEncryption` и вызывает на *Middleware* метод `LoginService.login()`, передавая ему логин пользователя и хэш пароля

* `LoginService` делегирует выполнение бину `LoginWorker`, который загружает объект `User` по полученному логину, хэширует полученный хэш пароля повторно, используя в качестве соли идентификатор пользователя, и сравнивает полученный хэш с сохраненным в БД хэшем пароля. В случае несовпадения выбрасывается исключение `LoginException`.

* После успешной аутентификации в созданный экземпляр <<userSession,UserSession>> загружаются все параметры доступа данного пользователя: список ролей, права, ограничения и атрибуты сессии.

Алгоритм хэширования паролей реализуется бином типа `EncryptionModule` и задается в свойстве приложения <<cuba.passwordEncryptionModule,cuba.passwordEncryptionModule>>. По умолчанию - SHA-1.

Возможен вариант, когда пароль пользователя (точнее, хэш пароля) не хранится в базе данных, а проверяется внешними средствами, например, путем интеграции с *ActiveDirectory*. В этом случае фактически аутентификацию выполняет клиентский блок, а *Middleware* "доверяет" клиенту, создавая сессию по одному только логину пользователя без пароля методом `LoginService.loginTrusted()`. Метод `loginTrusted()` требует выполнения следующих условия:

* клиентский блок должен передать так называемый доверенный пароль, задаваемый на *Middleware* и на клиентском блоке свойством приложения <<cuba.trustedClientPassword,cuba.trustedClientPassword>>

* IP-адрес клиентского блока должен соответствовать маске, задаваемой свойством приложения <<cuba.trustedClientPermittedIpMask,cuba.trustedClientPermittedIpMask>>

Вход в систему требуется также для автоматических процессов, запускаемых по расписанию, а также при подключении к бинам *Middleware* через JMX-интерфейс. Строго говоря, такие действия считаются административными и не требуют аутентификации до тех пор, пока не выполняется каких-либо изменений сущностей в базе данных. При записи сущностей в БД требуется проставить логин пользователя, который выполнил изменения, поэтому для работы таких процессов должен быть указан пользователь, от лица которого выполняются изменения. 

Дополнительным плюсом входа в систему для автоматического процесса и для JMX-вызова является то, что вывод в журнал сообщений от логгеров сопровождается указанием логина текущего пользователя, если пользовательская сессия установлена в потоке выполнения. Это упрощает поиск сообщений от конкретного процесса при разборе журнала.

Вход в систему для процессов внутри *Middleware* выполняется вызовом `LoginWorker.loginSystem()` с передачей логина пользователя (без пароля), от имени которого будет работать данный процесс. В результате создается объект <<userSession,UserSession>>, который будет закэширован в данном блоке *Middleware* и не будет реплицироваться в кластере.

Более подробно аутентификация процессов внутри *Middleware* рассмотрена в разделе <<system_authentication,Системная аутентификация>>.

[[securityContext]]
===== SecurityContext

Экземпляр класса `SecurityContext` хранит информацию о пользовательской сессии для текущего потока выполнения. Он создается и передается в метод `AppContext.setSecurityContext()` в следующие моменты:

* для блоков *Web Client* и *Web Portal* - в начале обработки каждого HTTP-запроса от пользовательского браузера

* для блока *Middleware* - в начале обработки каждого запроса от клиентского уровня

* для блока *Desktop Client* - один раз после входа пользователя, так как десктопное приложение является однопользовательским

По окончании выполнения запроса в первых двух случаях `SecurityContext` удаляется из потока выполнения.

При создании прикладным кодом нового потока выполнения в него необходимо передать текущий экземпляр `SecurityContext`, например:

[source, java]
----
final SecurityContext securityContext = AppContext.getSecurityContext();
executor.submit(new Runnable() {
  public void run() {
      AppContext.setSecurityContext(securityContext);
      // business logic here
  }
});
----

[[exception_handling]]
==== Обработка исключений

В данном разделе рассмотрены различные аспекты генерации и обработки исключений в CUBA-приложениях.

[[exception_classes]]
===== Классы исключений

При создании собственных классов исключений следует придерживаться следующих правил:

* Если исключение является нормальной частью бизнес-логики и при его возникновении требуется предпринимать некоторые нетривиальные действия, то класс исключения следует делать декларируемым (наследником `Exception`). Обработка таких исключений производится вызывающим кодом.

* Если исключение сигнализирует об ошибочной ситуации, и реакцией на него должно быть прерывание хода выполнения и простое действие типа отображения информации об ошибке пользователю, то класс исключения следует делать недекларируемым (наследником `RuntimeException`). Обработка таких исключений производится специальными классами-обработчиками, зарегистрированными в клиентских блоках приложения.

* Если исключение выбрасывается и обрабатывается в рамках одного <<app_tiers,блока>> приложения, то класс исключения следует объявлять в соответствующем <<app_modules,модуле>>. Если же исключение выбрасывается на *Middleware*, а обрабатывается на клиентском уровне, то класс исключения необходимо объявлять в модуле *global*.

Платформа содержит специальный класс недекларируемого исключения `SilentException`, который можно использовать для прерывания хода выполнения без выдачи каких-либо сообщений пользователю или в лог. `SilentException` объявлен в модуле *global*, поэтому доступен как на *Middleware*, так и в клиентских блоках.

[[remoteException]]
===== Передача исключений Middleware

Если при выполнении запроса от клиента на *Middleware* возникает исключение, выполнение прерывается и на клиента возвращается объект исключения, как правило, включающий цепочку порождающих друг друга исключений. Так как цепочка исключений может содержать классы, недоступные клиентскому блоку (например, исключения JDBC-драйвера), на клиента передается не сама эта цепочка, а ее представление внутри специального создаваемого исключения `RemoteException`. 

Информация об исключениях-причинах сохраняется в виде списка объектов `RemoteException.Cause`. Каждый объект `Cause` хранит обязательно имя класса исключения и его сообщение. Кроме того, если класс исключения "поддерживается клиентом", то `Cause` содержит также и сам объект исключения. Это дает возможность передать на клиента информацию в полях исключения. 

Класс исключения, объекты которого нужно передавать на клиентский уровень именно в виде Java-объектов, нужно аннотировать `@SupportedByClient`, например: 

[source, java]
----
@SupportedByClient
public class WorkflowException extends RuntimeException {
...
----

Таким образом, при возникновении на *Middleware* исключения, не аннотированного `@SupportedByClient`, вызывающий клиентский код получит `RemoteException`, внутри которого будет находиться исходное исключение в виде строки. Если же исходное исключение аннотировано `@SupportedByClient`, то вызывающий код получит именно его. Это дает возможность в прикладном коде организовывать обработку декларируемых <<services,сервисами>> *Middleware* исключений традиционным образом - с помощью блоков `try...catch`. 

Следует иметь в виду, что чтобы поддерживаемое клиентом исключение было действительно передано на клиента в виде объекта, оно не должно содержать внутри себя в цепочке `getCause()` неподдерживаемых исключений. Поэтому если вы создаете на *Middleware* экземпляр исключения и хотите передать его на клиента, указывайте для него параметр `cause` только если вы уверены, что он содержит только исключения, известные клиенту.

Упаковку объектов исключений в `RemoteException` перед передачей на клиентский уровень выполняет перехватчик вызовов <<services,сервисов>> - класс `ServiceInterceptor`. Кроме того, он же выполняет логгирование исключений. По умолчанию в журнал выводится вся информация об исключении, включая полный stack trace. Если это нежелательно, можно добавить классу исключения аннотацию `@Logging`, указав в ней тип логгирования:

* `FULL` - (по умолчанию) полная информация, включая stacktrace

* `BRIEF` - только имя класса исключения и сообщение

* `NONE` - не выводить ничего

Например:

[source, java]
----
@SupportedByClient
@Logging(Logging.Type.BRIEF)
public class FinancialTransactionException extends Exception {
...
----

[[exceptionHandlers]]
===== Обработчики исключений клиентского уровня

Необработанные исключения в <<app_tiers,блоках>> *Web Client* и *Desktop Client*, возникшие на клиентском уровне или переданные с *Middleware*, попадают в специальный механизм обработчиков. Этот механизм реализован в <<app_modules,модуле>> GUI и доступен обоим клиентам. 

Обработчик должен быть <<managed_beans,управляемым бином>>, реализовывать интерфейс `GenericExceptionHandler`, в методе `handle()` которого производить обработку и возвращать `true`, либо сразу возвращать `false`, если данный обработчик не может обработать переданное ему исключение. Такое поведение позволяет организовать "цепочку ответственности" обработчиков. 

Рекомендуется наследовать классы своих обработчиков от базового класса `AbstractGenericExceptionHandler`, который умеет разбирать цепочку исключений (с учетом упакованных внутри `RemoteException`) и реагировать на конкретные типы исключений. Типы исключений, для которых предназначен данный обработчик, указываются в массиве строк, передаваемом в конструкторе обработчика базовому конструктору. Каждая строка массива должна содержать одно полное имя класса обрабатываемого исключения, например: 

[source, java]
----
include::{sourcesdir}/common/exceptionHandlers_1.java[]
---- 

Если класс исключения недоступен на клиенте, следует указывать его имя строковым литералом: 

[source, java]
----
include::{sourcesdir}/common/exceptionHandlers_2.java[]
---- 

В случае использования в качестве базового класса `AbstractGenericExceptionHandler` логика обработки располагается в методе `doHandle()`, и может выглядеть следующим образом: 

[source, java]
----
include::{sourcesdir}/common/exceptionHandlers_3.java[]
---- 

Если имени класса исключения недостаточно для того, чтобы принять решение о применимости данного обработчика к исключению, следует определить метод `canHandle()`, получающий кроме прочего текст исключения. Метод должен вернуть `true`, если данный обработчик применим для исключения. Например: 

[source, java]
----
include::{sourcesdir}/common/exceptionHandlers_4.java[]
---- 

