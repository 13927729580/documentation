:sourcesdir: ../../../../source

[[entityChangedEvent]]
==== EntityChangedEvent

`EntityChangedEvent` - это `ApplicationEvent`, который посылается фреймворком на среднем слое, когда некоторый экземпляр сущности сохраняется в базу данных. Данное событие может быть обработано как внутри текущей транзакции, так и после ее завершения (при использовании https://docs.spring.io/spring/docs/current/spring-framework-reference/data-access.html#transaction-event[@TransactionalEventListener]). Событие посылается только если на сущности есть аннотация `@PublishEntityChangedEvents`.

Объект `EntityChangedEvent` содержит не сам измененный экземпляр сущности, а только его id. Кроме того, метод `getOldValue(attributeName)` возвращает идентификаторы ссылок вместо самих объектов. Поэтому при необходимости, разработчик должен загрузить требуемые сущности с указанием требуемого представления и других параметров.

Ниже приведен пример обработки `EntityChangedEvent` для сущности `Customer` в текущей транзакции и после ее завершения:

[source,java]
----
include::{sourcesdir}/middleware/entityChangedEvent_usage_1.java[]
----
<1> - данный обработчик вызывается внутри текущей транзакции. Для этого можно использовать либо аннотацию `@EventListener`, либо `@TransactionalEventListener(phase = TransactionPhase.BEFORE_COMMIT)`.
<2> - id измененной сущности.
<3> - тип изменения: `CREATED`, `UPDATED` or `DELETED`.
<4> - можно проверить, изменился ли определенный атрибут.
<5> - можно получить старое значение измененного атрибута.
<6> - данный обработчик вызывается после коммита транзакции.
<7> - после коммита событие содержит те же значения что и внутри транзакции.

Если обработчик вызывается внутри транзакции, ее можно откатить путем выбрасывания исключения. При этом в БД никакие изменения не сохранятся. Если вы не хотите, чтобы пользователь получил какое-либо оповещение, используйте `SilentException`.

При обработке `EntityChangedEvent` внутри транзакции, используйте <<transactionalDataManager,TransactionalDataManager>> для загрузки текущего состояния измененной сущности из базы данных. В обработчике, вызываемом после коммита транзакции, можно использовать `DataManager`, который создаст новую транзакцию для загрузки данных.

[TIP]
=====
Не забудьте добавить аннотацию `@PublishEntityChangedEvents` классам сущностей, для которых вы хотите обрабатывать `EntityChangedEvent`.
=====
