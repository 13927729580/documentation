:sourcesdir: ../../../../../source

[[entityManager]]
===== EntityManager

`EntityManager` - основной интерфейс ORM, служит для управления персистентными <<data_model,сущностями>>.

[TIP]
====
В разделе <<dm_vs_em>> приведена информация о различиях между EntityManager и <<dataManager,DataManager>>.
====

Ссылку на `EntityManager` можно получить через интерфейс `Persistence`, вызовом метода `getEntityManager()`. Полученный экземпляр `EntityManager` привязан к текущей <<transactions,транзакции>>, то есть все вызовы `getEntityManager()` в рамках одной транзакции возвращают один и тот же экземпляр `EntityManager`. После завершения транзакции обращения к данному экземпляру невозможны.

Экземпляр `EntityManager` содержит в себе _персистентный контекст_ – набор экземпляров сущностей, загруженных из БД или только что созданных. Персистентный контекст является своего рода кэшем данных в рамках транзакции.`EntityManager` автоматически сбрасывает в БД все изменения, сделанные в его персистентном контексте, в момент коммита транзакции, либо при явном вызове метода `flush()`.

Интерфейс `EntityManager`, используемый в CUBA-приложениях, в основном повторяет стандартный link:$$http://docs.oracle.com/javaee/7/api/javax/persistence/EntityManager.html$$[javax.persistence.EntityManager]. Рассмотрим его основные методы:

* `persist()` - вводит <<entity_states,новый экземпляр>> сущности в персистентный контекст. При коммите транзакции командой SQL `INSERT` в БД будет создана соответствующая запись.

* `merge()` - переносит состояние <<entity_states,отсоединенного экземпляра>> сущности в персистентный контекст следующим образом: из БД загружается экземпляр с тем же идентификатором, в него переносится состояние переданного Detached экземпляра и возвращается загруженный Managed экземпляр. Далее надо работать именно с возвращенным Managed экземпляром. При коммите транзакции командой SQL `UPDATE` в БД будет сохранено состояние данного экземпляра.

* `remove()` - удалить объект из базы данных, либо, если включен режим <<soft_deletion,мягкого удаления>>, установить атрибуты `deleteTs` и `deletedBy`.
+
Если переданный экземпляр находится в Detached состоянии, сначала выполняется `merge()`.

* `find()` - загружает экземпляр сущности по идентификатору.
+
--
При формировании запроса к БД учитывается <<views,представление>>, переданное в параметре данного метода. В результате в персистентном контексте окажется граф объектов, для которого загружены все атрибуты представления.

[TIP]
====
В отличие от <<dataManager,DataManager>>, все локальные атрибуты сущностей загружаются независимо от того, указаны ли они в представлении или нет. В `EntityManager` представление влияет только на загрузку атрибутов-ссылок.
====
--

* `createQuery()` - создать объект `Query` или `TypedQuery` для выполнения <<query,JPQL запроса>>.

* `createNativeQuery()` - создать объект `Query` для выполнения <<nativeQuery,SQL запроса>>. 

* `addView()` - аналогичен методу `setView()`, но в случае наличия уже установленного в `EntityManager` представления, не заменяет его, а добавляет атрибуты переданного представления.

* `reload()` - перезагрузить экземпляр сущности с указанным <<views,представлением>>.

* `isSoftDeletion()` - проверяет, находится ли данный `EntityManager` в режиме <<soft_deletion,мягкого удаления>>.

* `setSoftDeletion()` - устанавливает режим <<soft_deletion,мягкого удаления>> для данного экземпляра `EntityManager`.

* `getConnection()` - возвращает `java.sql.Connection`, через который выполняет запросы данный экземпляр `EntityManager`, и, соответственно, текущая транзакция. Закрывать такое соединение не нужно, оно будет закрыто при завершении транзакции.

* `getDelegate()` - возвращает `javax.persistence.EntityManager`, предоставляемый реализацией ORM. 

Пример использования `EntityManager` в <<services,сервисе>>:

[source, java]
----
include::{sourcesdir}/middleware/entityManager_1.java[]
----

[[em_partial_entities]]
Частичные сущности::
+
--
По умолчанию, представления в EntityManager влияют только на загрузку связей, т.е. все локальные атрибуты всегда загружаются.

Вы можете заставить EntityManager загружать _частичные_ сущности, если установите свойство <<view_loadPartialEntities,loadPartialEntities>> представления в true (например, так делает <<dataManager,DataManager>>). Однако, если загружаемая сущность <<entity_cache,кэшируется>>, то данный признак игнорируется, и сущность все равно будет загружена со всеми локальными атрибутами.
--

