:sourcesdir: ../../../../../source

[[gui_DataContext]]
===== DataContext

Интерфейс `DataContext` позволяет отслеживать изменения в сущностях, загружаемых на клиентский уровень. Отслеживаемые сущности помечаются как "грязные" при любом изменении их атрибутов, и `DataContext` сохраняет грязные экземпляры на Middleware при вызове его метода `commit()`.

Внутри `DataContext` сущность с некоторым идентификатором будет представлена как единственный объект экземпляра, вне зависимости от того, где и сколько раз она использована в графах других объектов.

Чтобы сущность отслеживалась, её необходимо поместить в `DataContext` с помощью метода `merge()`.

[WARNING]
====
Главный принцип использования метода `merge()` заключается в том, чтобы продолжать работать с возвращённым экземпляром, забывая про переданный. Это следствие того, что в контекст ранее уже мог быть помещён экземпляр с тем же идентификатором, и в таком случае именно этот экземпляр будет возвращён. Данный принцип позволяет всегда иметь в контексте не более одного экземпляра сущности с конкретным идентификатором.
====

Пример помещения сущности в `DataContext`:

[source, java]
----
include::{sourcesdir}/gui/data_context/dataContext_1.java[]
----

Для одного <<gui_screens,экрана>> и всех его вложенных фрагментов может существовать только один экземпляр `DataContext`. Он создаётся автоматически, если в XML-дескрипторе экрана существует элемент `<data>`.

Элемент `<data>` может содержать атрибут `readOnly="true"`, в этом случае будет использована специальная "no-op"-реализация, в которой не будут отслеживаться изменения в сущностях и, следовательно, улучшится быстродействие экрана. Экраны просмотра списков, автоматически создаваемые в Studio, по умолчанию имеют read-only data context, поэтому если вам нужно отслеживать изменения и сохранять грязные сущности в браузере, удалите XML-атрибут `readOnly="true"`.

[[parent_data_context]]
Родительский DataContext::
+
--
Сущности `DataContext` могут образовывать отношения предок-потомок. Если у экземпляра `DataContext` есть родительский контекст, он будет сохранять измененные сущности в своего предка вместо того. чтобы сразу отправлять их на Middleware. Эта особенности позволяет редактировать <<composition_recipe,композитные сущности>>, где дочерние сущности должны сохраняться только вместе с родительской. Если атрибут сущности снабжён аннотацией <<composition_annotation,@Composition>>, платформа автоматически установит родительский контекст для экрана редактирования этого атрибута, чтобы изменённая сущность атрибута могла быть сохранена только вместе с основной сущностью.

Подобное поведение можно легко настроить вручную для любой сущности или экрана.

Если вы программно открываете экран редактирования сущности, который должен сохранять изменения в data context текущего экрана, используйте метод `withParentDataContext()` builder'а:

[source, java]
----
include::{sourcesdir}/gui/data_context/dataContext_2.java[]
----

Если вы открываете простой экран с помощью бина `Screens`, определите в нём сеттер, принимающий data context родительского экрана:

[source, java]
----
include::{sourcesdir}/gui/data_context/dataContext_3.java[]
----

Этот метод вы сможете использовать при создании экрана:

[source, java]
----
include::{sourcesdir}/gui/data_context/dataContext_4.java[]
----

[WARNING]
====
Убедитесь, что для родительского data context не задан атрибут `readOnly="true"`. В противном случае при попытке использовать его как предка другого контекста будет выброшено исключение.
====
--
