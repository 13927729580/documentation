[[middleware]]
=== Компоненты среднего слоя

На следующем рисунке приведены основные компоненты среднего слоя CUBA-приложения.

.Компоненты среднего слоя
image::Middleware.png[align="center"]

<<services,Services>> – управляемые <<container,контейнером>> компоненты, формирующие границу приложения и предоставляющие интерфейс клиентскому <<app_tiers,уровню>> приложения. Сервисы могут содержать бизнес-логику сами, либо делегировать выполнение <<managed_beans,Managed Beans>>.

<<managed_beans,Managed Beans>> – управляемые <<container,контейнером>> компоненты, содержащие бизнес-логику приложения. Вызываются <<services,сервисами>>, другими бинами или через опциональный <<jmx,JMX>>-интерфейс.

<<persistence,Persistence>> − инфраструктурный интерфейс для доступа к функциональности хранения данных: управлению <<transactions,транзакциями>> и <<orm,ORM>>.

[[services]]
==== Сервисы

Сервисы образуют слой компонентов, определяющий множество операций Middleware, доступных клиентскому <<app_tiers,уровню>> приложения. Внутри сервисов инкапсулируется бизнес-логика и управление <<transactions,транзакциями>>.

Основные задачи сервисов:

* Предоставляют удаленный (remote) интерфейс для вызова с клиентского уровня

* Проверяют наличие активной <<userSession,пользовательской сессии>>, соответствующей идентификатору сессии, переданному с клиента

* Записывают в журнал необработанные исключения среднего слоя

Кроме того, именно в слое сервисов рекомендуется выполнять авторизацию текущего пользователя, т.е. проверять его права на ту или иную функциональность.

Общие для всех сервисов задачи решаются следующим образом:

* Проверка наличия пользовательской сессии и логгирование исключений производится классом-<<interceptor,интерцептором>> `ServiceInterceptor`, который перехватывает выполнение каждого метода сервиса с помощью Spring AOP

* Удаленный интерфейс для доступа к сервису через Spring HTTP Invoker создается бином `RemoteServicesBeanCreator`, который конфигурируется в файле <<remoting-spring.xml,remoting-spring.xml>> модуля *core*.

.Диаграмма классов сервиса
image::MiddlewareServices.png[align="center"]

===== Создание сервиса

Имена интерфейсов сервисов должны заканчиваться на `Service`, имена классов реализации на `ServiceBean`.

При создании сервиса необходимо выполнить следующее:

. Создать интерфейс в <<app_modules,модуле>> *global* (т.к. интерфейс сервиса должен быть доступен на всех <<app_tiers,уровнях>>) и задать в нем имя сервиса. Имя рекомендуется задавать в формате `++{имя_проекта}_{имя_интерфейса}++`. Например:
+
[source, java]
----
include::{sourcesdir}/middleware/service_1.java[]
----

. Создать класс сервиса в модуле *core* и добавить ему аннотацию `@org.springframework.stereotype.Service` с именем, заданным в интерфейсе
+
[source, java]
----
include::{sourcesdir}/middleware/service_2.java[]
----

Класс сервиса, как и класс любого другого <<managed_beans,управляемого бина>>, должен находиться внутри дерева пакетов с корнем, заданным в элементе `context:component-scan` файла <<spring.xml,spring.xml>>. В нашем случае файл `spring.xml` содержит элемент:

[source, xml]
----
include::{sourcesdir}/middleware/service_3.xml[]
----

что означает, что поиск аннотированных бинов для данного блока приложения будет происходить начиная с пакета `com.sample.sales`.

[WARNING]
====
Сервисы предназначены только для вызова "снаружи" Middleware. Не рекомендуется вызывать методы сервисов из других компонентов среднего слоя. При обнаружении факта вызова сервиса из другого сервиса в журнал выводится сообщение об ошибке.

Если некоторую бизнес-логику требуется вызывать из разных сервисов либо других компонентов Middleware, ее необходимо выделить и инкапсулировать внутри соответствующего <<managed_beans,Managed Bean>>.
====

[[service_import]]
===== Использование сервиса

Для того чтобы вызывать сервис, в клиентском блоке приложения для него должен быть создан соответствующий прокси-объект. Делается это путем объявления имени и интерфейса сервиса в параметрах фабрики прокси-объектов. Для блока Web Client это бин класса `WebRemoteProxyBeanCreator`, для Web Portal - `PortalRemoteProxyBeanCreator` , для Desktop Client - `RemoteProxyBeanCreator` .

Фабрика прокси-объектов конфигурируется в файле <<spring.xml,spring.xml>> соответствующего клиентского блока.

Например, чтобы в приложении *sales* вызвать с веб-клиента сервис `++sales_OrderService++`, необходимо добавить в файл `web-spring.xml` модуля *web* следующее:

[source, xml]
----
include::{sourcesdir}/middleware/service_4.xml[]
----

Все импортируемые сервисы объявляются в одном свойстве `remoteServices` в элементах `map/entry`.

С точки зрения прикладного кода прокси-объект сервиса на клиентском уровне является обычным бином Spring и может быть получен либо инжекцией, либо с помощью класса `AppBeans`, например:

[source, java]
----
include::{sourcesdir}/middleware/service_5.java[]
----

[[dataService]]
===== DataService

`DataService` является фасадом для вызова серверной релизации <<dataManager,DataManager>> с клиентского уровня. `DataService` не рекомендуется использовать в прикладном коде. Вместо него и на клиентском уровне, и на Middleware следует использовать `DataManager`.

[[system_authentication]]
==== Системная аутентификация

При выполнении пользовательских запросов программному коду Middleware через интерфейс <<userSessionSource,UserSessionSource>> всегда доступна информация о текущем пользователе. Это возможно потому, что при получении запроса с клиентского уровня в потоке выполнения автоматически устанавливается соответствующий объект `<<securityContext,SecurityContext>>`.

Однако существуют ситуации, когда текущий поток выполнения не связан ни с каким пользователем системы: например, при вызове метода бина из <<scheduled_tasks_spring,планировщика>>, либо через JMX-интерфейс. Если при этом бин выполняет изменение сущностей в базе данных, то ему потребуется информация о том, кто выполняет изменения, то есть аутентификация.

Такого рода аутентификация называется системной, так как не требует участия пользователя - средний слой приложения просто создает (или использует имеющуюся) пользовательскую сессию, и устанавливает в потоке выполнения соответствующий объект `SecurityContext`. 

Обеспечить системную аутентификацию некоторого участка кода можно следующими способами:

* явно используя бин `com.haulmont.cuba.security.app.Authentication`, например:
+
[source, java]
----
include::{sourcesdir}/middleware/auth_1.java[]
----

* добавив методу бина аннотацию `@Authenticated`, например:
+
[source, java]
----
include::{sourcesdir}/middleware/auth_2.java[]
----

Во втором случае также используется бин `Authentication`, но неявно, через интерцептор `AuthenticationInterceptor`, который перехватывает вызовы всех методов бинов с аннотацией `@Authenticated`.

В приведенных примерах пользовательская сессия будет создаваться от лица пользователя, логин которого указан в свойстве приложения <<cuba.jmxUserLogin,cuba.jmxUserLogin>>. Если требуется аутентификация от имени другого пользователя, нужно воспользоваться первым вариантом и передать в метод `begin()` логин нужного пользователя.

[WARNING]
====
Если в момент выполнения `Authentication.begin()` в текущем потоке выполнения присутствует активная пользовательская сессия, то она не заменяется - соответственно, код, требующий аутентификации, будет выполняться с имеющейся сессией, и последующий метод `end()` не будет очищать поток.

Например, вызов метода JMX-бина из встроенной в *Web Client* консоли JMX, если бин находится в той же JVM, что и блок WebClient, к которому в данный момент подключен пользователь, будет выполнен от имени текущего зарегистрированного в системе пользователя, независимо от наличия системной аутентификации.
====

[[persistence]]
==== Интерфейс Persistence

Интерфейс инфраструктуры, являющийся точкой входа в функциональность хранения данных в БД.

Методы интерфейса:

* `createTransaction()`, `getTransaction()` - получить интерфейс управления <<transactions,транзакциями>>

* `isInTransaction()` - определяет, существует ли в данный момент активная транзакция

* `getEntityManager()` - возвращает экземпляр <<entityManager,EntityManager>> для текущей транзакции

* `isSoftDeletion()` - позволяет определить, активен ли режим <<soft_deletion,мягкого удаления>>

* `setSoftDeletion()` - устанавливает или отключает режим мягкого удаления. Влияет на аналогичный признак всех создаваемых экземпляров `EntityManager`. По умолчанию мягкое удаление включено.

* `getDbTypeConverter()` - возвращает экземпляр <<dbTypeConverter,DbTypeConverter>> для используемой в данный момент базы данных.

* `getDataSource()` - получить `javax.sql.DataSource` для используемой в данный момент базы данных.
+
[WARNING]
====
Для всех объектов `javax.sql.Connection`, получаемых методом `getDataSource().getConnection()`, необходимо после использования соединения вызвать метод `close()` в секции `finally`. В противном случае соединение не вернется в пул, через какое-то время пул переполнится, и приложение не сможет выполнять запросы к базе данных. 
====

* `getTools()` - возвращает экземпляр интерфейса `PersistenceTools` (см. ниже).

[[persistenceTools]]
===== PersistenceTools

<<managed_beans,ManagedBean>>, содержащий вспомогательные методы работы с хранилищем данных. Интерфейс `PersistenceTools` можно получить либо методом `Persistence.getTools()`, либо как любой другой бин - инжекцией или через класс `AppBeans`.

Методы `PersistenceTools`:

* `getDirtyFields()` - возвращает коллекцию имен атрибутов сущности, измененных со времени последней загрузки экземпляра из БД. Для новых экземпляров возвращает пустую коллекцию.

* `isLoaded()` - определяет, загружен ли из БД указанный атрибут экземпляра. Атрибут может быть _не_ загружен, если он не указан в примененном при загрузке <<views,представлении>>. 
+
Данный метод работает только для экземпляров в состоянии <<entity_states,Managed>>.

* `getReferenceId()` - возвращает идентификатор связанной сущности без загрузки ее из БД. 
+
Предположим, в <<persistence_context,персистентный контекст>> загружен экземпляр `Order`, и нужно получить значение идентификатора экземпляра `Customer`, связанного с данным Заказом. Стандартное решение `order.getCustomer().getId()` приведет к выполнению SQL запроса к БД для загрузки экземпляра `Customer`, что в данном случае избыточно, так как значение идентификатора Покупателя физически находится также и в таблице Заказов. Выполнение же
+
[source, java]
----
include::{sourcesdir}/middleware/persistencetools_1.java[]
----

не вызовет никаких дополнительных запросов к базе данных. 

Данный метод работает только для экземпляров в состоянии <<entity_states,Managed>>.

Для расширения набора вспомогательных методов в конкретном приложении бин `PersistenceTools` можно <<bean_extension,переопределить>>. Примеры работы с расширенным интерфейсом:

[source, java]
----
include::{sourcesdir}/middleware/persistencetools_2.java[]
----

[source, java]
----
include::{sourcesdir}/middleware/persistencetools_3.java[]
----

[[dbTypeConverter]]
===== DbTypeConverter

Интерфейс, определяющий методы для конвертации данных между значениями атрибутов <<data_model,модели данных>> и параметрами и результатами запросов JDBC. Объект данного интерфейса можно получить методом `<<persistence,Persistence>>.getDbTypeConverter()`.

Методы `DbTypeConverter`:

* `getJavaObject()` - конвертирует результат JDBC запроса в тип, подходящий для присвоения атрибуту сущности. 

* `getSqlObject()` - конвертирует значение атрибута сущности в тип, подходящий для присвоения параметру JDBC запроса.

* `getSqlType()` - возвращает константу из `java.sql.Types`, соответствующую переданному типу атрибута сущности.

[[orm]]
==== Слой ORM

Object-Relational Mapping - объектно-реляционное отображение - технология связывания таблиц реляционной базы данных с объектами языка программирования. 

Преимущества использования ORM::: 

* Позволяет работать с данными реляционной СУБД, манипулируя объектами Java.

* Упрощает программирование, избавляя от рутины написания тривиальных SQL-запросов.

* Упрощает программирование, позволяя извлекать и сохранять целые графы объектов одной командой.

* Обеспечивает легкое портирование приложения на различные СУБД.

* Позволяет использовать лаконичный язык запросов <<jpql,JPQL>>.

Недостатки:::

* Требует понимания особенностей работы с ORM.

* Усложняет оптимизацию SQL и использование особенности применяемой СУБД.

В платформе CUBA используется реализация ORM основе фреймворка *EclipseLink*.

[[entityManager]]
===== EntityManager

`EntityManager` - основной интерфейс ORM, служит для управления персистентными <<data_model,сущностями>>.

Ссылку на `EntityManager` можно получить через интерфейс `Persistence`, вызовом метода `getEntityManager()`. Полученный экземпляр `EntityManager` привязан к текущей <<transactions,транзакции>>, то есть все вызовы `getEntityManager()` в рамках одной транзакции возвращают один и тот же экземпляр `EntityManager`. После завершения транзакции обращения к данному экземпляру невозможны.

Экземпляр `EntityManager` содержит в себе _персистентный контекст_ – набор экземпляров сущностей, загруженных из БД или только что созданных. Персистентный контекст является своего рода кэшем данных в рамках транзакции.`EntityManager` автоматически сбрасывает в БД все изменения, сделанные в его персистентном контексте, в момент коммита транзакции, либо при явном вызове метода `flush()`.

Интерфейс `EntityManager`, используемый в CUBA-приложениях, в основном повторяет стандартный link:$$http://docs.oracle.com/javaee/7/api/javax/persistence/EntityManager.html$$[javax.persistence.EntityManager]. Рассмотрим его основные методы:

* `persist()` - вводит <<entity_states,новый экземпляр>> сущности в персистентный контекст. При коммите транзакции командой SQL `INSERT` в БД будет создана соответствующая запись.

* `merge()` - переносит состояние <<entity_states,отсоединенного экземпляра>> сущности в персистентный контекст следующим образом: из БД загружается экземпляр с тем же идентификатором, в него переносится состояние переданного Detached экземпляра и возвращается загруженный Managed экземпляр. Далее надо работать именно с возвращенным Managed экземпляром. При коммите транзакции командой SQL `UPDATE` в БД будет сохранено состояние данного экземпляра.

* `remove()` - удалить объект из базы данных, либо, если включен режим <<soft_deletion,мягкого удаления>>, установить атрибуты `deleteTs` и `deletedBy`.
+
Если переданный экземпляр находится в Detached состоянии, сначала выполняется `merge()`.

* `find()` - загружает экземпляр сущности по идентификатору. 
+
При формировании запроса к БД учитывается <<views,представление>>, переданное в параметре данного метода. В результате в персистентном контексте окажется граф объектов, для которого загружены все атрибуты представления.

* `createQuery()` - создать объект `Query` или `TypedQuery` для выполнения <<query,JPQL запроса>>.

* `createNativeQuery()` - создать объект `Query` для выполнения <<nativeQuery,SQL запроса>>. 

* `addView()` - аналогичен методу `setView()`, но в случае наличия уже установленного в `EntityManager` представления, не заменяет его, а добавляет атрибуты переданного представления.

* `reload()` - перезагрузить экземпляр сущности с указанным <<views,представлением>>.

* `isSoftDeletion()` - проверяет, находится ли данный `EntityManager` в режиме <<soft_deletion,мягкого удаления>>.

* `setSoftDeletion()` - устанавливает режим <<soft_deletion,мягкого удаления>> для данного экземпляра `EntityManager`.

* `getConnection()` - возвращает `java.sql.Connection`, через который выполняет запросы данный экземпляр `EntityManager`, и, соответственно, текущая транзакция. Закрывать такое соединение не нужно, оно будет закрыто при завершении транзакции.

* `getDelegate()` - возвращает `javax.persistence.EntityManager`, предоставляемый реализацией ORM. 

Пример использования `EntityManager` в <<services,сервисе>>:

[source, java]
----
include::{sourcesdir}/middleware/entityManager_1.java[]
----

[[entity_states]]
===== Состояния сущности

New:: 
+
--
Только что созданный в памяти экземпляр, например: `Car car = new Car()`.
Новый экземпляр может быть передан в `EntityManager.persist()` для сохранения в БД, при этом он переходит в состояние Managed.
--

Managed:: 
+
--
Загруженный из БД или новый, переданный в EntityManager.persist(), экземпляр. Принадлежит некоторому экземпляру `EntityManager`, другими словами, находится в его персистентном контексте.

Любые изменения экземпляра в состоянии Managed будут сохранены в БД в случае коммита транзакции, к которой принадлежит данный `EntityManager`.

--

Detached:: 
+
--
Экземпляр, загруженный из БД и отсоединенный от своего персистентного контекста (вследствие завершения транзакции или сериализации).

Изменения, вносимые в Detached экземпляр, запоминаются в самом этом экземпляре (в полях, добавленных с помощью bytecode enhancement). Эти изменения будут сохранены в БД, только если данный экземпляр будет снова переведен в состояние Managed путем передачи в метод `EntityManager.merge()`.
--

[[lazy_loading]]
===== Загрузка по требованию

Загрузка по требованию (lazy loading) позволяет загружать связанные сущности отложенно, т.е. только в момент первого обращения к их свойствам.

Загрузка по требованию в сумме порождает больше запросов к БД, чем <<eager_fetching,жадная загрузка>> (eager fetching), однако нагрузка при этом растянута во времени.

* Например, при извлечении списка N экземпляров сущности A, содержащих ссылку на экземпляр сущности B, в случае загрузки по требованию будет выполнено N+1 запросов к базе данных.

* Как правило, для минимизации времени отклика и снижения нагрузки необходимо стремиться к меньшему количеству обращений к БД. Для этого в платформе используется механизм <<views,представлений>>, с помощью которого в вышеописанном случае ORM может сформировать один запрос к БД с объединением таблиц.

Загрузка по требованию работает только для экземпляра в состоянии <<entity_states,Managed>>, то есть внутри транзакции, загрузившей данный экземпляр.

[[query]]
===== Выполнение JPQL запросов

Для выполнения <<jpql,JPQL>> запросов предназначен интерфейс `Query`, ссылку на который можно получить у текущего экземпляра `EntityManager` вызовом метода `createQuery()`. Если запрос предполагается использовать для извлечения сущностей, рекомендуется вызывать `createQuery()` с передачей типа результата, что приведет к созданию `TypedQuery`. 

Методы `Query` в основном соответствуют методам стандартного интерфейса JPA link:$$http://docs.oracle.com/javaee/7/api/javax/persistence/Query.html$$[`javax.persistence.Query`]. Рассмотрим отличия.

* `setParameter()` - устанавливает значение параметра запроса. При передаче в данный метод экземпляра сущности выполняет неявное преобразование экземпляра в его идентификатор. Например:
+
[source, java]
----
include::{sourcesdir}/middleware/jpqlquery_1.java[]
----
+
Обратите внимание на сравнение в запросе по идентификатору, но передачу в качестве параметра самого экземпляра сущности. 
+
Вариант метода с передачей `implicitConversions = false` не выполняет такого преобразования.

* `setView()`, `addView()` - устанавливают <<views,представление>>, используемое при загрузке данных.

* `getDelegate()` - возвращает экземпляр `javax.persistence.Query`, предоставляемый реализацией ORM.

При выполнении запроса через `Query` изменения в текущем персистентном контексте не учитываются, т.е. запрос просто выполняется в БД. Если результатом выборки являются экземпляры, уже находящиеся в персистентном контексте, то в результате запроса окажутся именно они, а не прочитанные из БД. Ситуацию поясняет следующий фрагмент теста:

[source, java]
----
include::{sourcesdir}/middleware/jpqlquery_2.java[]
----

Запросы, модифицирующие данные (`update`, `delete`) приводят к сбросу (flush) в базу данных текущего персистентного контекста перед выполнением. Другими словами, ORM сначала синхронизирует состояние сущностей в персистентном контексте и в БД, а уже потом выполняет модифицирующий запрос. Рекомендуется выполнять такие запросы в неизмененном персистентном контексте, чтобы исключить неявные действия ORM, которые могут отрицательно сказаться на производительности.

[[query_case_insensitive]]
====== Поиск подстроки без учета регистра

Для удобного формирования условия поиска без учета регистра символов и по любой части строки можно использовать префикс `(?i)` в значении параметра запроса. Например, имеется запрос:

[source, jpql]
----
select c from sales$Customer c where c.name like :name
----

Если в значении параметра `name` передать строку `(?i)%doe%`, то при наличии в БД записи со значением `John Doe` она будет найдена, несмотря на раличие в регистре символа. Это произойдет потому, что ORM выполнит SQL с условием вида `lower(C.NAME) like ?`.

Следует иметь в виду, что при таком поиске индекс, созданный в БД по полю `NAME`, не используется.

[[jpql_macro]]
====== Макросы в JPQL

Текст JPQL запроса может включать макросы, которые обрабатываются перед выполнением и превращаются в исполняемый JPQL, дополнительно модифицируя набор параметров.

Макросы, определенные в платформе, решают следующие задачи:

* Позволяют обойти принципиальную невозможность средствами JPQL выразить условие зависимости значения поля от текущего момента времени (не работает арифметика типа current_date-1)

* Позволяют сравнивать с датой поля типа Timestamp (содержащие дату+время)

Рассмотрим их подробно:

@between:: 
+
--
Имеет вид `++@between(field_name, moment1, moment2, time_unit)++`, где 

* `++field_name++` - имя атрибута для сравнения 

* `moment1`, `moment2` - моменты времени, в которые должно попасть значение атрибута `++field_name++`. Каждый из моментов должен быть определен выражением с участием переменной `now`, к которой может быть прибавлено или отнято целое число 

* `++time_unit++` - определяет единицу измерения времени, которое прибавляется или вычитается из `now` в выражениях моментов, а также точность округления моментов. Может быть следующим: `year`, `month`, `day`, `hour`, `minute`, `second`. При включенном <<base_projects,базовом проекте>> *workflow* можно также использовать единицы рабочего времени: `workday`, `workhour`, `workminute`.

Макрос преобразуется в следующее выражение JPQL: `++field_name >= :moment1 and field_name < :moment2++`

Пример 1. Покупатель создан сегодня:

[source, jpql]
----
select c from sales$Customer where @between(c.createTs, now, now+1, day)
----

Пример 2. Покупатель создан в течение последних 10 минут:

[source, jpql]
----
select c from sales$Customer where @between(c.createTs, now-10, now, minute)
----

Пример 3. Документы, датированные последними 5 рабочими днями (для проектов, включающих *workflow*): 

[source, jpql]
----
select d from sales$Doc where @between(d.createTs, now-5, now, workday)
----
--

@today:: 
+
--
Имеет вид `++@today(field_name)++` и обеспечивает формирование условия попадания значения атрибута в текущий день. По сути это частный случай макроса `@between`.

Пример. Пользователь создан сегодня:

[source, jpql]
----
select d from sales$Doc where @today(d.createTs)
----
--

@dateEquals:: 
+
--
Имеет вид `++@dateEquals(field_name, parameter)++` и позволяет сформировать условие попадания значения поля `++field_name++` типа `Timestamp` в дату, задаваемую параметром `parameter`.

Пример:

[source, jpql]
----
select d from sales$Doc where @dateEquals(d.createTs, :param)
----
--

@dateBefore:: 
+
--
Имеет вид `++@dateBefore(field_name, parameter++`) и позволяет сформировать условие, что дата значения поля `++field_name++` типа `Timestamp` меньше даты, задаваемой параметром `parameter`.

Пример:

[source, jpql]
----
select d from sales$Doc where @dateBefore(d.createTs, :param)
----
--

@dateAfter:: 
+
--
Имеет вид `++@dateAfter(field_name, parameter++`) и позволяет сформировать условие, что дата значения поля `++field_name++` типа `Timestamp` больше или равна дате, задаваемой параметром `parameter`.

Пример:

[source, jpql]
----
select d from sales$Doc where @dateAfter(d.createTs, :param)
----
--

@enum:: 
+
--
Позволяет использовать полное имя константы enum вместо ее идентификатора в БД. Это упрощает поиск использований enum в коде приложения.

Пример: 

[source, jpql]
----
select r from sec$Role where r.type = @enum(com.haulmont.cuba.security.entity.RoleType.SUPER) order by r.name
---- 
--

Список макросов может быть расширен в прикладном проекте. Для создания нового макроса необходимо определить бин, реализующий интерфейс `QueryMacroHandler`, и задать ему `@Scope("prototype")`. Механизм выполнения JPQL запросов создает все доступные бины типа `QueryMacroHandler`, и по очереди передает им текст запроса с набором параметров. Очередность вызова обработчиков не определена.

[[nativeQuery]]
===== Выполнение SQL запросов

ORM позволяет выполнять SQL запросы к базе данных, возвращая как списки отдельных полей, так и экземпляры сущностей. Для этого необходимо создать объект `Query` или `TypedQuery` вызовом одного из методов `EntityManager.createNativeQuery()`. 

Если выполняется выборка отдельных колонок таблицы, то результирующий список будет содержать строки в виде `Object[]`. Например:

[source, java]
----
include::{sourcesdir}/middleware/sqlquery_1.java[]
----

Следует иметь в виду, при использовании SQL колонки, соответствующие атрибутам сущностей типа `UUID`, возвращаются в виде `UUID` или в виде `String`, в зависимости от используемой СУБД и JDBC драйвера:

* *HSQLDB* - `String`
* *PostgreSQL*, драйвер `postgresql-8.3-603.jdbc4.jar` - `String`
* *PostgreSQL*, драйвер `postgresql-9.1-901.jdbc4.jar` - `UUID`
* *Microsoft SQL Server*, драйвер `jtds-1.2.4.jar` - `String`
* *Oracle* - `String`

Параметры этого типа также должны задаваться либо как `UUID`, либо своим строковым представлением, в зависимости от используемой СУБД и JDBC драйвера. Для обеспечения независимости кода от используемой СУБД рекомендуется использовать <<dbTypeConverter,DbTypeConverter>>.

Если вместе с текстом запроса передан класс результирующей сущности, то возвращается `TypedQuery` и после выполнения производится попытка отображения результатов запроса на атрибуты сущности. Например:

[source, java]
----
include::{sourcesdir}/middleware/sqlquery_2.java[]
----

Поведение SQL запросов, возвращающих сущности, и модифицирующих запросов (`update`, `delete`), по отношению к текущему персистентному контексту аналогично описанному для <<query,JPQL запросов>>.

См. также <<queryRunner,>>.

[[entity_listeners]]
===== Entity Listeners

_Entity Listeners_ предназначены для реакции на события жизненного цикла экземпляров сущностей на уровне Middleware.

Слушатель представляет собой класс, реализующий один или несколько интерфейсов пакета `com.haulmont.cuba.core.listener`. Слушатель будет реагировать на события типов, соответствующих реализуемым интерфейсам.

`BeforeDetachEntityListener`:: 
+
--
Метод `onBeforeDetach()` вызывается перед отделением объекта от <<entityManager,EntityManager>> при коммите транзакции.

Данный слушатель можно использовать, например, для заполнения неперсистентных атрибутов сущности перед отправкой ее на клиентский уровень.
--

`BeforeAttachEntityListener`:: 
+
--
Метод `onBeforeAttach()` вызывается перед введением объекта в персистентный контекст при выполнении операции `EntityManager.merge()`.

Данный слушатель можно использовать, например, для заполнения персистентных атрибутов сущности перед сохранением ее в базе данных.
--

`BeforeInsertEntityListener`:: 
Метод `onBeforeInsert()` вызывается перед выполнением вставки записи в БД. В данном методе возможны любые операции с текущим `EntityManager`.

`AfterInsertEntityListener`:: 
Метод `onAfterInsert()` вызывается после выполнения вставки записи в БД, но до коммита транзакции. В данном методе нельзя модифицировать текущий персистентный контекст, однако можно производить изменения в БД с помощью <<queryRunner,QueryRunner>>.

`BeforeUpdateEntityListener`:: 
Метод `onBeforeUpdate()` вызывается перед изменением записи в БД. В данном методе возможны любые операции с текущим `EntityManager`.

`AfterUpdateEntityListener`:: 
Метод `onAfterUpdate()` вызывается после изменения записи в БД, но до коммита транзакции. В данном методе нельзя модифицировать текущий персистентный контекст, однако можно производить изменения в БД с помощью `QueryRunner`.

`BeforeDeleteEntityListener`:: 
Метод `onBeforeDelete()` вызывается перед удалением записи из БД (или в случае <<soft_deletion,мягкого удаления>> - перед изменением записи). В данном методе возможны любые операции с текущим `EntityManager`.

`AfterDeleteEntityListener`:: 
Метод `onAfterDelete()` вызывается после удаления записи из БД (или в случае мягкого удаления - после изменения записи), но до коммита транзакции. В данном методе нельзя модифицировать текущий персистентный контекст, однако можно производить изменения в БД с помощью `QueryRunner`.

Entity Listener может быть как обычным классом Java, так и управляемым бином. В последнем случае в нем можно использовать инжекцию: 

[source, java]
----
include::{sourcesdir}/middleware/entitylisteners_1.java[]
----

Entity Listener может быть задан двумя способами:

* Статически - имена классов слушателей, или, если слушатель является бином, имена бинов, указываются в аннотации <<listeners_annotation,@Listeners>> на классе сущности:
+
[source, java]
----
include::{sourcesdir}/middleware/entitylisteners_2.java[]
----

* Динамически - класс сущности и класс слушателя, или, если слушатель является бином, имя бина, передаются в метод `addListener()` бина `EntityListenerManager`. Пример динамического добавления слушателя рассматривается в разделе рецептов разработки: <<app_start_recipe,Выполнение кода на старте приложения>>.

Для всех экземпляров некоторого класса сущности извлекается из контекста Spring или создается и кэшируется _один_ экземпляр слушателя определенного типа, поэтому слушатель _не должен иметь состояния_.

Если для сущности объявлены несколько слушателей одного типа (например, аннотациями класса сущности и его предков, плюс динамически), то их вызов будет выполняться в следующем порядке:

. Для каждого предка, начиная с самого дальнего, вызываются его динамически добавленные слушатели, затем статически назначенные.

. После всех предков вызываются динамически добавленные слушатели данного класса, затем статически назначенные.

[[transactions]]
==== Управление транзакциями

В данном разделе рассмотрены различные аспекты управления транзакциями в CUBA-приложениях.

[[transactions_prog]]
===== Программное управление транзакциями

Программное управление транзакциями осуществляется с помощью интерфейса `com.haulmont.cuba.core.Transaction`, ссылку на который можно получить методами `createTransaction()` или `getTransaction()` интерфейса инфраструктуры <<persistence,Persistence>>.

Метод `createTransaction()` создает новую транзакцию и возвращает интерфейс `Transaction`. Последующие вызовы методов `commit()`, `commitRetaining()`, `end()` этого интерфейса управляют созданной транзакцией. Если в момент создания существовала другая транзакция, то она будет приостановлена, и возобновлена после завершения созданной. 

Метод `getTransaction()` вызывает либо создание новой, либо присоединение к текущей транзакции. Если в момент вызова существовала активная транзакция, то метод успешно завершается, и последующие вызовы `commit()`, `commitRetaining()`, `end()` не оказывают никакого влияния на существующую транзакцию. Однако если `end()` вызван без предварительного вызова `commit()`, то текущая транзакция помечается как `RollbackOnly`.

Примеры программного управления транзакцией:

[source, java]
----
include::{sourcesdir}/middleware/transactions_1.java[]
----

Интерфейс Transaction имеет также метод `execute()`, принимающий на вход класс-действие или lambda-выражение, которое нужно выполнить в данной транзакции. Это позволяет организовать управление транзакциями в функциональном стиле, например:

[source, java]
----
include::{sourcesdir}/middleware/transactions_2.java[]
----

Следует иметь в виду, что метод `execute()` у некоторого экземпляра `Transaction` можно вызвать только один раз, так как после выполнения кода действия транзакция завершается.

[[transactions_decl]]
===== Декларативное управление транзакциями

Любой метод <<managed_beans,управляемого бина>> Middleware можно пометить аннотацией `@org.springframework.transaction.annotation.Transactional`, что вызовет автоматическое создание транзакции при вызове этого метода. В таком методе не нужно вызывать `Persistence.createTransaction()`, а можно сразу получать `EntityManager` и работать с ним.

Для аннотации `@Transactional` можно указать параметры. Основным параметром является режим создания транзакции - `Propagation`. Значение `REQUIRED` соответствует `getTransaction()`, значение `++REQUIRES_NEW++` - `createTransaction()`. По умолчанию `REQUIRED`.

Декларативное управление транзакциями позволяет уменьшить количество link:$$http://en.wikipedia.org/wiki/Boilerplate_code$$[boilerplate кода], однако имеет следующий недостаток: коммит транзакции происходит вне прикладного кода, что часто затрудняет отладку, т.к. скрывается момент отправки изменений в БД и перехода сущностей в состояние <<entity_states,Detached>>. Кроме того, следует иметь в виду, что декларативная разметка сработает только в случае вызова метода контейнером, т.е. вызов транзакционного метода из другого метода того же самого объекта не приведет к старту транзакции.

В связи с этим рекомендуется применять декларативное управление транзакциями только для простых случаев типа метода <<services,сервиса>>, читающего некоторый объект и возвращающего его на клиента. 

[[transactions_interaction]]
===== Примеры взаимодействия транзакций

====== Откат вложенной транзакции

Если вложенная транзакция создана через `getTransaction()`, то ее откат приведет к невозможности коммита охватывающей транзакции. Например:

[source, java]
----
include::{sourcesdir}/middleware/transactions_3.java[]
----

Если же транзакция в `methodB()` будет создана через `createTransaction()`, то ее откат не окажет никакого влияния на коммит охватывающей транзакции в `methodA()`. 

====== Чтение и изменение данных во вложенной транзакции

Рассмотрим сначала зависимую вложенную транзакцию, создаваемую через `getTransaction()`:

[source, java]
----
include::{sourcesdir}/middleware/transactions_4.java[]
----

Теперь рассмотрим тот же самый пример с независимой вложенной транзакцией, создаваемой через `createTransaction()`: 

[source, java]
----
include::{sourcesdir}/middleware/transactions_5.java[]
----

В последнем случае исключение в точке (8) возникнет, только если сущность является оптимистично блокируемой, т.е. если она реализует интерфейс `Versioned`.

[[transaction_timeout]]
===== Таймаут транзакции

Для создаваемой транзакции может быть указан таймаут в секундах, при превышении которого транзакция будет прервана и откачена. Таймаут транзакции ограничивает максимальную длительность запросов к базе данных.

При программном управлении транзакциями таймаут включается путем передачи объекта `TransactionParams` в метод `Persistence.createTransaction()`. Например:

[source, java]
----
Transaction tx = persistence.createTransaction(new TransactionParams().setTimeout(2));
----

При декларативном управлении транзакциями используется параметр `timeout` аннотации `@Transactional`, например:

[source, java]
----
@Transactional(timeout = 2)
public void someServiceMethod() {
...
----

Таймаут по умолчанию может быть задан в свойстве приложения <<cuba.defaultQueryTimeoutSec,cuba.defaultQueryTimeoutSec>>.
