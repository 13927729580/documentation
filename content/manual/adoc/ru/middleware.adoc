[[middleware]]
=== Компоненты среднего слоя

На следующем рисунке приведены основные компоненты среднего слоя CUBA-приложения.

.Компоненты среднего слоя
image::Middleware.png[align="center"]

<<services,Services>> – управляемые контейнером компоненты, формирующие границу приложения и предоставляющие интерфейс клиентскому <<app_tiers,уровню>> приложения. Сервисы могут содержать бизнес-логику сами, либо делегировать выполнение <<managed_beans,Managed Beans>>.

<<managed_beans,Managed Beans>> – управляемые контейнером компоненты, содержащие бизнес-логику приложения. Вызываются <<services,сервисами>>, другими бинами или через опциональный JMX интерфейс.

`
        <<persistence,Persistence>>
      ` − инфраструктурный интерфейс для доступа к функциональности хранения данных: управлению <<transactions,транзакциями>> и <<orm,ORM>>. 

[[services]]
==== Сервисы

Сервисы образуют слой компонентов, определяющий множество операций *Middleware*, доступных клиентскому <<app_tiers,уровню>> приложения. Внутри сервисов инкапсулируется бизнес-логика и управление <<transactions,транзакциями>>.

Основные задачи сервисов:



* Предоставляют удаленный (remote) интерфейс для вызова с клиентского уровня

* Проверяют наличие активной <<userSession,пользовательской сессии>>, соответствующей идентификатору сессии, переданному с клиента

* Записывают в журнал необработанные исключения среднего слоя

Кроме того, именно в слое сервисов рекомендуется выполнять авторизацию текущего пользователя, т.е. проверять его права на ту или иную функциональность.

Общие для всех сервисов задачи решаются следующим образом:

* Проверка наличия пользовательской сессии и логгирование исключений производится классом-интерцептором `ServiceInterceptor`, который перехватывает выполнение каждого метода сервиса с помощью *Spring AOP*

* Удаленный интерфейс для доступа к сервису через *Spring HTTP Invoker* создается бином `RemoteServicesBeanCreator`, который конфигурируется в файле `
                <<remoting-spring.xml,remoting-spring.xml>>
              ` модуля *core*. 

.Диаграмма классов сервиса
image::MiddlewareServices.png[align="center"]

===== Создание сервиса

Имена интерфейсов сервисов должны заканчиваться на `Service`, имена классов реализации на `ServiceBean`.

При создании сервиса необходимо выполнить следующее:

. Создать интерфейс в <<app_modules,модуле>> *global* (т.к. интерфейс сервиса должен быть доступен на всех <<app_tiers,уровнях>>) и задать в нем имя сервиса. Имя рекомендуется задавать в формате `++{имя_проекта}_{имя_интерфейса}++`. Например:


+
[source, java]
----
package com.sample.sales.core;

import com.sample.sales.entity.Order;

public interface OrderService {
    String NAME = "sales_OrderService";

    void calculateTotals(Order order);
}
----



. Создать класс сервиса в модуле *core* и добавить ему аннотацию `@org.springframework.stereotype.Service` с именем, заданным в интерфейсе


+
[source, java]
----
package com.sample.sales.core;

import com.sample.sales.entity.Order;
import org.springframework.stereotype.Service;

@Service(OrderService.NAME)
public class OrderServiceBean implements OrderService {
    @Override
    public void calculateTotals(Order order) {
    }
}
----

Класс сервиса, как и класс любого другого <<managed_beans,управляемого бина>>, должен находиться внутри дерева пакетов с корнем, заданным в элементе `context:component-scan` файла `
                <<spring.xml,spring.xml>>
              `. В нашем случае файл `spring.xml` содержит элемент:
+
[source, xml]
----
<context:component-scan base-package="com.sample.sales"/>
----

что означает, что поиск аннотированных бинов для данного блока приложения будет происходить начиная с пакета `com.sample.sales`.




[WARNING]
====
Сервисы предназначены только для вызова "снаружи" *Middleware*. Не рекомендуется вызывать методы сервисов из других компонентов среднего слоя. При обнаружении факта вызова сервиса из другого сервиса в журнал выводится сообщение об ошибке.

Если некоторую бизнес-логику требуется вызывать из разных сервисов либо других компонентов *Middleware*, ее необходимо выделить и инкапсулировать внутри соответствующего <<managed_beans,Managed Bean>>.
====

[[service_import]]
===== Использование сервиса

Для того чтобы вызывать сервис, в клиентском блоке приложения для него должен быть создан соответствующий прокси-объект. Делается это путем объявления имени и интерфейса сервиса в параметрах фабрики прокси-объектов. Для блока *Web Client* это бин класса `WebRemoteProxyBeanCreator`, для *Web Portal* - `PortalRemoteProxyBeanCreator` , для *Desktop Client* - `RemoteProxyBeanCreator` .

Фабрика прокси-объектов конфигурируется в файле `
            <<spring.xml,spring.xml>>
          ` соответствующего клиентского блока.

Например, чтобы в приложении *sales* вызвать с веб-клиента сервис `++sales_OrderService++`, необходимо добавить в файл `web-spring.xml` модуля *web* следующее:

[source, xml]
----
<bean id="sales_proxyCreator" class="com.haulmont.cuba.web.sys.remoting.WebRemoteProxyBeanCreator">
    <property name="clusterInvocationSupport" ref="cuba_clusterInvocationSupport"/>
    <property name="remoteServices">
        <map>
            <entry key="sales_OrderService" value="com.sample.sales.core.OrderService"/>
        </map>
    </property>
</bean>
----

Все импортируемые сервисы объявляются в одном свойстве `remoteServices` в элементах `map/entry`.

С точки зрения прикладного кода прокси-объект сервиса на клиентском уровне является обычным бином *Spring* и может быть получен либо инжекцией, либо с помощью класса `AppBeans`, например:

[source, java]
----
@Inject
protected OrderService orderService;
...
orderService.calculateTotals(order);
----

[[dataService]]
===== DataService

`DataService` является фасадом для вызова серверной релизации <<dataManager,DataManager>> с клиентского уровня. `DataService` не рекомендуется использовать в прикладном коде. Вместо него и на клиентском уровне, и на Middleware следует использовать `DataManager`.

[[system_authentication]]
==== Системная аутентификация

При выполнении пользовательских запросов программному коду *Middleware* через интерфейс `
          <<userSessionSource,UserSessionSource>>
        ` всегда доступна информация о текущем пользователе. Это возможно потому, что при получении запроса с клиентского уровня в потоке выполнения автоматически устанавливается соответствующий объект `
          <<securityContext,SecurityContext>>
        `.

Однако существуют ситуации, когда текущий поток выполнения не связан ни с каким пользователем системы: например, при вызове метода бина из <<scheduled_tasks_spring,планировщика>>, либо через JMX-интерфейс. Если при этом бин выполняет изменение сущностей в базе данных, то ему потребуется информация о том, кто выполняет изменения, то есть аутентификация.

Такого рода аутентификация называется системной, так как не требует участия пользователя - средний слой приложения просто создает (или использует имеющуюся) пользовательскую сессию, и устанавливает в потоке выполнения соответствующий объект `SecurityContext`. 

Обеспечить системную аутентификацию некоторого участка кода можно следующими способами:

* явно используя бин `com.haulmont.cuba.security.app.Authentication`, например:
+
[source, java]
----
@Inject
protected Authentication authentication;
...
authentication.begin();
try {
    // authenticated code
} finally {
    authentication.end();
}
----

* добавив методу бина аннотацию `@Authenticated`, например:
+
[source, java]
----
@Authenticated
public String foo(String value) {
    // authenticated code
}
----

Во втором случае также используется бин `Authentication`, но неявно, через интерцептор `AuthenticationInterceptor`, который перехватывает вызовы всех методов бинов с аннотацией `@Authenticated`.

В приведенных примерах пользовательская сессия будет создаваться от лица пользователя, логин которого указан в свойстве приложения `
          <<cuba.jmxUserLogin,cuba.jmxUserLogin>>
        `. Если требуется аутентификация от имени другого пользователя, нужно воспользоваться первым вариантом и передать в метод `begin()` логин нужного пользователя.


[WARNING]
====
Если в момент выполнения `Authentication.begin()` в текущем потоке выполнения присутствует активная пользовательская сессия, то она не заменяется - соответственно, код, требующий аутентификации, будет выполняться с имеющейся сессией, и последующий метод `end()` не будет очищать поток.

Например, вызов метода JMX-бина из встроенной в *Web Client* консоли JMX, если бин находится в той же JVM, что и блок WebClient, к которому в данный момент подключен пользователь, будет выполнен от имени текущего зарегистрированного в системе пользователя, независимо от наличия системной аутентификации.
====

[[persistence]]
==== Интерфейс Persistence

Интерфейс инфраструктуры, являющийся точкой входа в функциональность хранения данных в БД.

Методы интерфейса:

* `createTransaction()`, `getTransaction()` - получить интерфейс управления <<transactions,транзакциями>>

* `isInTransaction()` - определяет, существует ли в данный момент активная транзакция

* `getEntityManager()` - возвращает экземпляр `
                <<entityManager,EntityManager>>
              ` для текущей транзакции

* `isSoftDeletion()` - позволяет определить, активен ли режим <<soft_deletion,мягкого удаления>>

* `setSoftDeletion()` - устанавливает или отключает режим мягкого удаления. Влияет на аналогичный признак всех создаваемых экземпляров `EntityManager`. По умолчанию мягкое удаление включено.

* `getDbTypeConverter()` - возвращает экземпляр `
                <<dbTypeConverter,DbTypeConverter>>
              ` для используемой в данный момент базы данных.

* `getDataSource()` - получить `javax.sql.DataSource` для используемой в данный момент базы данных.

+
[WARNING]
====
Для всех объектов `javax.sql.Connection`, получаемых методом `getDataSource().getConnection()`, необходимо после использования соединения вызвать метод `close()` в секции `finally`. В противном случае соединение не вернется в пул, через какое-то время пул переполнится, и приложение не сможет выполнять запросы к базе данных. 
====



* `getTools()` - возвращает экземпляр интерфейса `PersistenceTools` (см. ниже).

[[persistenceTools]]
===== PersistenceTools

<<managed_beans,ManagedBean>>, содержащий вспомогательные методы работы с хранилищем данных. Интерфейс `PersistenceTools` можно получить либо методом `Persistence.getTools()`, либо как любой другой бин - инжекцией или через класс `AppBeans`.

Методы `PersistenceTools`:

* `getDirtyFields()` - возвращает коллекцию имен атрибутов сущности, измененных со времени последней загрузки экземпляра из БД. Для новых экземпляров возвращает пустую коллекцию.

* `isLoaded()` - определяет, загружен ли из БД указанный атрибут экземпляра. Атрибут может быть _не_ загружен, если он не указан в примененном при загрузке <<views,представлении>>. 
+
Данный метод работает только для экземпляров в состоянии <<entity_states,Managed>>.

* `getReferenceId()` - возвращает идентификатор связанной сущности без загрузки ее из БД. 
+
Предположим, в персистентный контекст загружен экземпляр `Order`, и нужно получить значение идентификатора экземпляра `Customer`, связанного с данным Заказом. Стандартное решение `order.getCustomer().getId()` приведет к выполнению SQL запроса к БД для загрузки экземпляра `Customer`, что в данном случае избыточно, так как значение идентификатора Покупателя физически находится также и в таблице Заказов. Выполнение же 
+
[source, java]
----
persistence.getTools().getReferenceId(order, "customer")
----

не вызовет никаких дополнительных запросов к базе данных. 
+
Данный метод работает только для экземпляров в состоянии <<entity_states,Managed>>.

Для расширения набора вспомогательных методов в конкретном приложении бин `PersistenceTools` можно <<bean_extension,переопределить>>. Примеры работы с расширенным интерфейсом:

[source, java]
----
MyPersistenceTools tools = persistence.getTools();
tools.foo();
----



[source, java]
----
((MyPersistenceTools) persistence.getTools()).foo();
----

[[persistenceHelper]]
===== PersistenceHelper

Вспомогательный класс для получения информации о персистентных сущностях. В отличие от бинов `Persistence` и `PersistenceTools` доступен на всех <<app_tiers,уровнях>> приложения.

Методы `PersistenceHelper`:

* `isNew()` - определяет, является ли переданный экземпляр только что созданным, т.е. находящимся в состоянии <<entity_states,New>>. Возвращает `true`, также если экземпляр не является персистентной сущностью.

* `isDetached()` - определяет, находится ли переданный экземпляр в состоянии <<entity_states,Detached>>. Возвращает `true`, также если экземпляр не является персистентной сущностью.

* `isSoftDeleted()` - определяет, поддерживает ли переданный класс сущности <<soft_deletion,мягкое удаление>>

* `getEntityName()` - возвращает имя сущности, заданное в <<entity_annotations,аннотации>> `@Entity`

* `getTableName()` - возвращает имя таблицы БД, хранящей экземпляры сущности, заданное в <<entity_annotations,аннотации>> `@Table`

[[dbTypeConverter]]
===== DbTypeConverter

Интерфейс, определяющий методы для конвертации данных между значениями атрибутов <<data_model,модели данных>> и параметрами и результатами запросов JDBC. Объект данного интерфейса можно получить методом `<<persistence,Persistence>>.getDbTypeConverter()`.

Методы `DbTypeConverter`:

* `getJavaObject()` - конвертирует результат JDBC запроса в тип, подходящий для присвоения атрибуту сущности. 

* `getSqlObject()` - конвертирует значение атрибута сущности в тип, подходящий для присвоения параметру JDBC запроса.

* `getSqlType()` - возвращает константу из `java.sql.Types`, соответствующую переданному типу атрибута сущности.

[[orm]]
==== Слой ORM

Object-Relational Mapping - объектно-реляционное отображение - технология связывания таблиц реляционной базы данных с объектами языка программирования. 

Преимущества использования ORM::: 


* Позволяет работать с данными реляционной СУБД, манипулируя объектами Java

* Упрощает программирование, избавляя от рутины написания тривиальных SQL-запросов

* Упрощает программирование, позволяя извлекать и сохранять целые графы объектов одной командой

* Обеспечивает легкое портирование приложения на различные СУБД

* Использует лаконичный язык запросов JPQL

* Оптимизирует количество выполняемых SQL-запросов на команды insert и update



Недостатки::: 


* Требует понимания особенностей работы с ORM

* Не позволяет напрямую оптимизировать SQL или использовать особенности применяемой СУБД



В платформе CUBA используется реализация ORM по стандарту Java Persistence API на основе фреймворка *Apache OpenJPA*.

[[entityManager]]
===== EntityManager

`EntityManager` - основной интерфейс ORM, служит для управления персистентными <<data_model,сущностями>>.

Ссылку на `EntityManager` можно получить через интерфейс `Persistence`, вызовом метода `getEntityManager()`.Полученный экземпляр `EntityManager` привязан к текущей <<transactions,транзакции>>, то есть все вызовы `getEntityManager()` в рамках одной транзакции возвращают один и тот же экземпляр `EntityManager`. После завершения транзакции обращения к данному экземпляру невозможны.

Экземпляр `EntityManager` содержит в себе "персистентный контекст" – набор экземпляров сущностей, загруженных из БД или только что созданных. Персистентный контекст является своего рода кэшем данных в рамках транзакции.`EntityManager` автоматически сбрасывает в БД все изменения, сделанные в его персистентном контексте, в момент коммита транзакции, либо при явном вызове метода `flush()`.

Интерфейс `EntityManager`, используемый в CUBA-приложениях, в основном повторяет стандартный link:$$http://docs.oracle.com/javaee/5/api/javax/persistence/EntityManager.html$$[javax.persistence.EntityManager]. Рассмотрим его основные методы:

* `persist()` - вводит <<entity_states,новый экземпляр>> сущности в персистентный контекст. При коммите транзакции командой SQL `INSERT` в БД будет создана соответствующая запись.

* `merge()` - переносит состояние <<entity_states,отсоединенного экземпляра>> сущности в персистентный контекст следующим образом: из БД загружается экземпляр с тем же идентификатором, в него переносится состояние переданного Detached экземпляра и возвращается загруженный Managed экземпляр. Далее надо работать именно с возвращенным Managed экземпляром. При коммите транзакции командой SQL `UPDATE` в БД будет сохранено состояние данного экземпляра.

* `remove()` - удалить объект из базы данных, либо, если включен режим <<soft_deletion,мягкого удаления>>, установить атрибуты `deleteTs` и `deletedBy`.
+
Если переданный экземпляр находится в Detached состоянии, сначала выполняется `merge()`.

* `find()` - загружает экземпляр сущности по идентификатору. 
+
При формировании запроса к БД учитывается <<views,представление>>, переданное в параметре данного метода, либо установленное для всего `EntityManager` методом `setView()`. В результате в персистентном контексте окажется граф объектов, для которого загружены все не-lazy атрибуты представления. Остальные атрибуты можно дозагрузить обращением к соответствующим методам доступа объектов, либо вызовом метода `fetch()`.

* `createQuery()` - создать объект `Query` для выполнения <<query,JPQL запроса>>. 
+
Рекомендуется использовать вариант метода с передачей класса сущности для получения экземпляра `TypedQuery`.

* `createNativeQuery()` - создать объект `Query` для выполнения <<nativeQuery,SQL запроса>>. 

* `setView()` - устанавливает <<views,представление>> по умолчанию, с которым будет производиться последующая загрузка сущностей методом `find()` либо JPQL запросами. В результате жадно загружены будут все не-`lazy` атрибуты представления.
+
Если в данный метод передать `null`, либо не вызывать его вообще, загрузка будет производиться в соответствие с правилами <<entity_annotations,аннотаций сущностей>>.
+
Представления, явно переданные в метод `find()` или установленные в объекте `Query` имеют приоритет над установленным данным методом.

* `addView()` - аналогичен методу `setView()`, но в случае наличия уже установленного в `EntityManager` представления, не заменяет его, а добавляет атрибуты переданного представления.

* `fetch()` - обеспечивает для экземпляра сущности загрузку всех атрибутов указанного <<views,представления>>, включая `lazy` атрибуты. Экземпляр сущности должен быть в <<entity_states,Managed>> состоянии.
+
Данный метод рекомендуется вызывать перед коммитом транзакции, если представление содержит `lazy` атрибуты, а экземпляр сущности нужно отправить на клиентский уровень. В этом случае только после вызова `fetch()` можно быть уверенным, что все нужные клиентсткому коду атрибуты действительно загружены.

* `reload()` - перезагрузить экземпляр сущности с указанным <<views,представлением>>. Обеспечивает загрузку всех атрибутов представления, вызывая внутри себя метод `fetch()`. 

* `isSoftDeletion()` - проверяет, находится ли данный `EntityManager` в режиме <<soft_deletion,мягкого удаления>>.

* `setSoftDeletion()` - устанавливает режим <<soft_deletion,мягкого удаления>> для данного экземпляра `EntityManager`.

* `getConnection()` - возвращает `java.sql.Connection`, через который выполняет запросы данный экземпляр `EntityManager`, и, соответственно, текущая транзакция. Закрывать такое соединение не нужно, оно будет закрыто при завершении транзакции.

* `getDelegate()` - возвращает `javax.persistence.EntityManager`, предоставляемый реализацией ORM. 

[[entity_states]]
===== Состояния сущности

New:: 
+
--
Только что созданный в памяти экземпляр, например: `Car car = new Car()`

Новый экземпляр может быть передан в EntityManager.persist() для сохранения в БД, при этом он переходит в состояние Managed.
--

Managed:: 
+
--
Загруженный из БД или новый, переданный в EntityManager.persist(), экземпляр. Принадлежит некоторому экземпляру `EntityManager`, другими словами, находится в его персистентном контексте.

Любые изменения экземпляра в состоянии Managed будут сохранены в БД в случае коммита транзакции, к которой принадлежит данный `EntityManager`
--

Detached:: 
+
--
Экземпляр, загруженный из БД и отсоединенный от своего персистентного контекста (вследствие закрытия транзакции или сериализации).

Изменения, вносимые в Detached экземпляр, запоминаются в самом этом экземпляре (в полях, добавленных с помощью bytecode enhancement).Эти изменения будут сохранены в БД, только если данный экземпляр будет снова переведен в состояние Managed путем передачи в метод EntityManager.merge(). 
--



[[lazy_loading]]
===== Загрузка по требованию

Загрузка по требованию (lazy loading) позволяет загружать связанные сущности отложенно, т.е. только в момент первого обращения к их свойствам.

Загрузка по требованию в сумме порождает больше запросов к БД, чем жадная загрузка (eager fetching), однако нагрузка при этом растянута во времени.

* Например, при извлечении списка N экземпляров сущности A, содержащих ссылку на экземпляр сущности B, в случае загрузки по требованию будет выполнено N+1 запросов к базе данных.

* Для минимизации времени отклика и снижения нагрузки необходимо стремиться к меньшему количеству обращений к БД. Для этого в платформе используется механизм <<views,представлений>>, с помощью которого в вышеописанном случае ORM может сформировать один запрос к БД с объединением таблиц.

* Если A содержит коллекцию B, в случае жадной загрузки ORM сформирует SQL запрос, возвращающий произведение строк A и B. 

* Иногда загрузка по требованию с точки зрения производительности предпочтительнее, чем жадная загрузка. Например, когда работает асинхронный процесс, выполняющий некоторую бизнес-логику, общее время выполнения некритично и желательно распределить во времени нагрузку на БД.

Загрузка по требованию работает только для экземпляра в состоянии <<entity_states,Managed>>, то есть внутри транзакции, загрузившей данный экземпляр.

[[query]]
===== Выполнение JPQL запросов

Для выполнения <<jpql,JPQL>> запросов предназначен интерфейс `Query`, ссылку на который можно получить у текущего экземпляра `EntityManager` вызовом метода `createQuery()`. Если запрос предполагается использовать для извлечения сущностей, рекомендуется вызывать `createQuery()` с передачей типа результата, что приведет к созданию `TypedQuery`. 

Методы `Query` в основном соответствуют методам стандартного интерфейса link:$$http://docs.oracle.com/javaee/5/api/javax/persistence/Query.html$$[
            `javax.persistence.Query`
          ]. Рассмотрим отличия.

* `setParameter()` - устанавливает значение параметра запроса. При передаче в данный метод экземпляра сущности выполняет неявное преобразование экземпляра в его идентификатор. Например:
+
[source, java]
----
Customer customer = ...;
TypedQuery<Order> query = entityManager.createQuery(
    "select o from sales$Order o where o.customer.id = ?1", Order.class);
query.setParameter(1, customer);
----
+
Обратите внимание на сравнение в запросе по идентификатору, но передачу в качестве параметра самого экземпляра сущности. 
+
Вариант метода с передачей `implicitConversions = false` не выполняет такого преобразования.

* `setView()`, `addView()` - аналогичны одноименным методам интерфейса `EntityManager` - устанавливают <<views,представление>>, используемое при загрузке данных текущим запросом, не влияя на представление всего `EntityManager`.

* `getDelegate()` - возвращает экземпляр `javax.persistence.Query`, предоставляемый реализацией ORM.

При выполнении запроса через `Query` изменения в текущем персистентном контексте не учитываются, т.е. запрос просто выполняется в БД. Если результатом выборки являются экземпляры, уже находящиеся в персистентном контексте, то в результате запроса окажутся именно они, а не прочитанные из БД. Ситуацию поясняет следующий фрагмент теста:

[source, java]
----
TypedQuery<User> query;
List<User> list;

query = em.createQuery("select u from sec$User u where u.name = ?1", User.class);
query.setParameter(1, "testUser");
list = query.getResultList();
assertEquals(1, list.size());
User user = list.get(0);

user.setName("newName");

query = em.createQuery("select u from sec$User u where u.name = ?1", User.class);
query.setParameter(1, "testUser");
list = query.getResultList();
assertEquals(1, list.size());
User user1 = list.get(0);

assertTrue(user1 == user);
----

Такое поведение определяется параметром `openjpa.IgnoreChanges=true`, заданным в файле <<persistence.xml,
            persistence.xml
          >> базового проекта *cuba*. В прикладном проекте данный параметр можно изменить, указав его в собственном `persistence.xml`.

Запросы, модифицирующие данные (`update`, `delete`) приводят к сбросу (flush) в базу данных текущего персистентного контекста перед выполнением. Другими словами, ORM сначала синхронизирует состояние сущностей в персистентном контексте и в БД, а уже потом выполняет модифицирующий запрос. Рекомендуется выполнять такие запросы в неизмененном персистентном контексте, чтобы исключить неявные действия ORM, которые могут отрицательно сказаться на производительности.

[[query_case_insensitive]]
====== Поиск подстроки без учета регистра

Для удобного формирования условия поиска без учета регистра символов и по любой части строки можно использовать префикс `(?i)` в значении параметра запроса. Например, имеется запрос:

[source]
----
select c from sales$Customer c where c.name like :name
----

Если в значении параметра `name` передать строку `*(?i)%doe%*`, то при наличии в БД записи со значением `*John Doe*` она будет найдена, несмотря на раличие в регистре символа. Это произойдет потому, что ORM выполнит SQL с условием вида `lower(C.NAME) like ?`.

Следует иметь в виду, что при таком поиске индекс, созданный в БД по полю `NAME`, не используется.

[[jpql_macro]]
====== Макросы в JPQL

Текст JPQL запроса может включать макросы, которые обрабатываются перед выполнением и превращаются в исполняемый JPQL, дополнительно модифицируя набор параметров.

Макросы, определенные в платформе, решают следующие задачи:

* Позволяют обойти принципиальную невозможность средствами JPQL выразить условие зависимости значения поля от текущего момента времени (не работает арифметика типа current_date-1)

* Позволяют сравнивать с датой поля типа Timestamp (содержащие дату+время)

Рассмотрим их подробно:

@between:: 
+
--
Имеет вид `++@between(field_name, moment1, moment2, time_unit)++`, где 

* `++field_name++` - имя атрибута для сравнения 

* `moment1`, `moment2` - моменты времени, в которые должно попасть значение атрибута `++field_name++`. Каждый из моментов должен быть определен выражением с участием переменной `now`, к которой может быть прибавлено или отнято целое число 

* `++time_unit++` - определяет единицу измерения времени, которое прибавляется или вычитается из `now` в выражениях моментов, а также точность округления моментов. Может быть следующим: `year`, `month`, `day`, `hour`, `minute`, `second`. При включенном <<base_projects,базовом проекте>> *workflow* можно также использовать единицы рабочего времени: `workday`, `workhour`, workminute. 

Макрос преобразуется в следующее выражение JPQL: `++field_name &gt;= :moment1 and field_name &lt; :moment2++`

Пример 1. Покупатель создан сегодня:

[source]
----
select c from sales$Customer where @between(c.createTs, now, now+1, day)
----

Пример 2. Покупатель создан в течение последних 10 минут:

[source]
----
select c from sales$Customer where @between(c.createTs, now-10, now, minute)
----

Пример 3. Документы, датированные последними 5 рабочими днями (для проектов, включающих *workflow*): 

[source]
----
select d from sales$Doc where @between(d.createTs, now-5, now, workday)
----
--

@today:: 
+
--
Имеет вид `++@today(field_name)++` и обеспечивает формирование условия попадания значения атрибута в текущий день. По сути это частный случай макроса `@between`.

Пример.Пользователь создан сегодня: 

[source]
----
select d from sales$Doc where @today(d.createTs)
----
--

@dateEquals:: 
+
--
Имеет вид `++@dateEquals(field_name, parameter)++` и позволяет сформировать условие попадания значения поля `++field_name++` типа `Timestamp` в дату, задаваемую параметром `parameter`.

Пример:

[source]
----
select d from sales$Doc where @dateEquals(d.createTs, :param)
----
--

@dateBefore:: 
+
--
Имеет вид `++@dateBefore(field_name, parameter++`) и позволяет сформировать условие, что дата значения поля `++field_name++` типа `Timestamp` меньше даты, задаваемой параметром `parameter`.

Пример:

[source]
----
select d from sales$Doc where @dateBefore(d.createTs, :param)
----
--

@dateAfter:: 
+
--
Имеет вид `++@dateAfter(field_name, parameter++`) и позволяет сформировать условие, что дата значения поля `++field_name++` типа `Timestamp` больше или равна дате, задаваемой параметром `parameter`.

Пример:

[source]
----
select d from sales$Doc where @dateAfter(d.createTs, :param)
----
--

@enum:: 
+
--
Позволяет использовать полное имя константы enum вместо ее идентификатора в БД. Это упрощает поиск использований enum в коде приложения.

Пример: 

[source]
----
select r from sec$Role where r.type = @enum(com.haulmont.cuba.security.entity.RoleType.SUPER) order by r.name
---- 
--



Список макросов может быть расширен в прикладном проекте. Для создания нового макроса необходимо определить бин, реализующий интерфейс `QueryMacroHandler`, и задать ему `@Scope("prototype")`. Механизм выполнения JPQL запросов создает все доступные бины типа `QueryMacroHandler`, и по очереди передает им текст запроса с набором параметров. Очередность вызова обработчиков не определена.

[[nativeQuery]]
===== Выполнение SQL запросов

ORM позволяет выполнять SQL запросы к базе данных, возвращая как списки отдельных полей, так и экземпляры сущностей. Для этого необходимо создать объект `Query` или `TypedQuery` вызовом одного из методов `EntityManager.createNativeQuery()`. 

Если выполняется выборка отдельных колонок таблицы, то результирующий список будет содержать строки в виде `Object[]`. Например:

[source, java]
----
Query query = em.createNativeQuery("select ID, NAME from SALES_CUSTOMER where NAME like ?1");
query.setParameter(1, "%Company%");
List list = query.getResultList();
for (Iterator it = list.iterator(); it.hasNext(); ) {
    Object[] row = (Object[]) it.next();
    UUID id = (UUID) row[0];
    String name = (String) row[1];
}
----

Следует иметь в виду, при использовании SQL колонки, соответствующие атрибутам сущностей типа `UUID`, возвращаются в виде `UUID` или в виде `String`, в зависимости от используемой СУБД и JDBC драйвера:

* *HSQLDB* - `String`

* *PostgreSQL*, драйвер `postgresql-8.3-603.jdbc4.jar` - `String`

* *PostgreSQL*, драйвер `postgresql-9.1-901.jdbc4.jar` - `UUID`

* *Microsoft SQL Server*, драйвер `jtds-1.2.4.jar` - `String`

* *Oracle* - `String`

Параметры этого типа также должны задаваться либо как `UUID`, либо своим строковым представлением, в зависимости от используемой СУБД и JDBC драйвера. Для обеспечения независимости кода от используемой СУБД рекомендуется использовать `
            <<dbTypeConverter,DbTypeConverter>>
          `.

Если вместе с текстом запроса передан класс результирующей сущности, то возвращается `TypedQuery` и после выполнения производится попытка отображения результатов запроса на атрибуты сущности. Например:

[source, java]
----
TypedQuery<Customer> query = em.createNativeQuery(
    "select * from SALES_CUSTOMER where NAME like ?1",
    Customer.class);
query.setParameter(1, "%Company%");
List<Customer> list = query.getResultList();
----

Поведение SQL запросов, возвращающих сущности, и модифицирующих запросов (`update`, `delete`), по отношению к текущему персистентному контексту аналогично описанному для <<query,JPQL запросов>>.

См. также <<queryRunner,>>.

[[entity_listeners]]
===== Entity Listeners

_Entity Listeners_ предназначены для реакции на события жизненного цикла экземпляров сущностей на уровне* Middleware*.

Слушатель представляет собой класс, реализующий один или несколько интерфейсов пакета `com.haulmont.cuba.core.listener`. Слушатель будет реагировать на события типов, соответствующих реализуемым интерфейсам.

`BeforeDetachEntityListener`:: 
+
--
Метод `onBeforeDetach()` вызывается перед отделением объекта от <<entityManager,EntityManager>> при коммите транзакции.

Данный слушатель можно использовать, например, для заполнения неперсистентных атрибутов сущности перед отправкой ее на клиентский уровень.
--

`BeforeAttachEntityListener`:: 
+
--
Метод `onBeforeAttach()` вызывается перед введением объекта в персистентный контекст при выполнении операции `EntityManager.merge()`.

Данный слушатель можно использовать, например, для заполнения персистентных атрибутов сущности перед сохранением ее в базе данных.
--

`BeforeInsertEntityListener`:: 
Метод `onBeforeInsert()` вызывается перед выполнением вставки записи в БД. В данном методе возможны любые операции с текущим `EntityManager`.

`AfterInsertEntityListener`:: 
Метод `onAfterInsert()` вызывается после выполнения вставки записи в БД, но до коммита транзакции. В данном методе нельзя модифицировать текущий персистентный контекст, однако можно производить изменения в БД с помощью <<queryRunner,QueryRunner>>.

`BeforeUpdateEntityListener`:: 
Метод `onBeforeUpdate()` вызывается перед изменением записи в БД. В данном методе возможны любые операции с текущим `EntityManager`.

`AfterUpdateEntityListener`:: 
Метод `onAfterUpdate()` вызывается после изменения записи в БД, но до коммита транзакции. В данном методе нельзя модифицировать текущий персистентный контекст, однако можно производить изменения в БД с помощью `QueryRunner`.

`BeforeDeleteEntityListener`:: 
Метод `onBeforeDelete()` вызывается перед удалением записи из БД (или в случае <<soft_deletion,мягкого удаления>> - перед изменением записи). В данном методе возможны любые операции с текущим `EntityManager`.

`AfterDeleteEntityListener`:: 
Метод `onAfterDelete()` вызывается после удаления записи из БД (или в случае мягкого удаления - после изменения записи), но до коммита транзакции. В данном методе нельзя модифицировать текущий персистентный контекст, однако можно производить изменения в БД с помощью `QueryRunner`.

Entity Listener может быть как обычным классом Java, так и управляемым бином. В последнем случае в нем можно использовать инжекцию: 

[source, java]
----
@ManagedBean("cuba_MyEntityListener")
public class MyEntityListener implements
        BeforeInsertEntityListener<MyEntity>,
        BeforeUpdateEntityListener<MyEntity> {

    @Inject
    protected Persistence persistence;

    @Override
    public void onBeforeInsert(MyEntity entity) {
        EntityManager em = persistence.getEntityManager();
        ...
    }

    @Override
    public void onBeforeUpdate(MyEntity entity) {
        EntityManager em = persistence.getEntityManager();
        ...
    }
}
----

Entity Listener может быть задан 2-мя способами: 

* Статически - имена классов слушателей, или, если слушатель является бином, имена бинов, указываются в аннотации <<listeners_annotation,@Listeners>> на классе сущности:
+
[source, java]
----
@Entity(...)
@Table(...)
@Listeners("cuba_MyEntityListener")
public class MyEntity extends StandardEntity {
    ...
}
----

* Динамически - класс сущности и класс слушателя, или, если слушатель является бином, имя бина, передаются в метод `addListener()` бина `EntityListenerManager`. Пример динамического добавления слушателя рассматривается в разделе рецептов разработки: <<app_start_recipe,>>. 

Для всех экземпляров некоторого класса сущности извлекается из контекста Spring или создается и кэшируется _один_ экземпляр слушателя определенного типа, поэтому слушатель _не должен иметь состояния_.

Если для сущности объявлены несколько слушателей одного типа (например, аннотациями класса сущности и его предков, плюс динамически), то их вызов будет выполняться в следующем порядке:

. Для каждого предка, начиная с самого дальнего, вызываются его динамически добавленные слушатели, затем статически назначенные.Для каждого предка, начиная с самого дальнего, вызываются его динамически добавленные слушатели, затем статически назначенные.

. После всех предков вызываются динамически добавленные слушатели данного класса, затем статически назначенные.После всех предков вызываются динамически добавленные слушатели данного класса, затем статически назначенные.

[[transactions]]
==== Управление транзакциями

В данном разделе рассмотрены различные аспекты управления транзакциями в CUBA-приложениях.

===== Программное управление транзакциями

Программное управление транзакциями осуществляется с помощью интерфейса `com.haulmont.cuba.core.Transaction`, ссылку на который можно получить методами `createTransaction()` или `getTransaction()` интерфейса инфраструктуры `
            <<persistence,Persistence>>
          `.

Метод `createTransaction()` создает новую транзакцию и возвращает интерфейс `Transaction`. Последующие вызовы методов `commit()`, `commitRetaining()`, `end()` этого интерфейса управляют созданной транзакцией. Если в момент создания существовала другая транзакция, то она будет приостановлена, и возобновлена после завершения созданной. 

Метод `getTransaction()` вызывает либо создание новой, либо присоединение к текущей транзакции. Если в момент вызова существовала активная транзакция, то метод успешно завершается, и последующие вызовы `commit()`, `commitRetaining()`, `end()` не оказывают никакого влияния на существующую транзакцию. Однако если `end()` вызван без предварительного вызова `commit()`, то текущая транзакция помечается как `RollbackOnly`.

Пример ручного управления транзакцией:

[source, java]
----
@Inject
private Persistence persistence;
...
Transaction tx = persistence.createTransaction();
try {
    EntityManager em = persistence.getEntityManager();
    Customer customer = new Customer();
    customer.setName("John Smith");
    em.persist(customer);

    tx.commit();
} finally {
    tx.end();
}
----

Интерфейс Transaction имеет также метод execute(), принимающий на вход класс-действие, которое нужно выполнить в данной транзакции. Это позволяет организовать управление транзакциями в функциональном стиле, например:

[source, java]
----
persistence.createTransaction().execute(new Transaction.Runnable() {
    public void run(EntityManager em) {
        // transactional code here
    }
});
----

Если транзакционный блок должен вернуть результат, класс-действие должен реализовывать интерфейс `Transaction.Callable`. Если результат не требуется, как в приведенном примере, то класс-действие удобно наследовать от абстрактного класса `Transaction.Runnable`.

Следует иметь в виду, что метод `execute()` у некоторого экземпляра `Transaction` можно вызвать только один раз, так как после выполнения кода класса-действия транзакция завершается.

===== Декларативное управление транзакциями

Любой метод <<managed_beans,управляемого бина>> *Middleware* можно пометить аннотацией `@org.springframework.transaction.annotation.Transactional`, что вызовет автоматическое создание транзакции при вызове этого метода. В таком методе не нужно вызывать `Persistence.createTransaction()`, а можно сразу получать `EntityManager` и работать с ним.

Для аннотации `@Transactional` можно указать параметры. Основным параметром является режим создания транзакции - `Propagation`. Значение `REQUIRED` соответствует `getTransaction()`, значение `++REQUIRES_NEW++` - `createTransaction()`. По умолчанию `REQUIRED`.

Декларативное управление транзакциями позволяет уменьшить количество link:$$http://en.wikipedia.org/wiki/Boilerplate_code$$[boilerplate кода], однако имеет следующий недостаток: коммит транзакции происходит вне прикладного кода, что часто затрудняет отладку, т.к. скрывается момент отправки изменений в БД и перехода сущностей в состояние <<entity_states,Detached>>. Кроме того, следует иметь в виду, что декларативная разметка сработает только в случае вызова метода контейнером, т.е. вызов транзакционного метода из другого метода того же самого объекта не приведет к старту транзакции.

В связи с этим рекомендуется применять декларативное управление транзакциями только для простых случаев типа метода <<services,сервиса>>, читающего некоторый объект и возвращающего его на клиента. 

===== Примеры взаимодействия транзакций

====== Откат вложенной транзакции

Если вложенная транзакция создана через `getTransaction()`, то ее откат приведет к невозможности коммита охватывающей транзакции. Например:

[source, java]
----
void methodA() {
    Transaction tx = persistence.createTransaction();
    try {
        // (1) вызываем метод, создающий вложенную транзакцию
        methodB();

        // (4) в этот момент будет выброшено исключение, т.к. транзакция
        //     помечена как rollback only
        tx.commit();
    } finally {
        tx.end();
    }
}

void methodB() {
    Transaction tx = persistence.getTransaction();
    try {
        // (2) допустим здесь возникло исключение
        tx.commit();
    } catch (Exception e) {
        // (3) обрабатываем его и выходим
        return;
    } finally {
        tx.end();
    }
}
----

Если же транзакция в `methodB()` будет создана через `createTransaction()`, то ее откат не окажет никакого влияния на коммит охватывающей транзакции в `methodA()`. 

====== Чтение и изменение данных во вложенной транзакции

Рассмотрим сначала зависимую вложенную транзакцию, создаваемую через `getTransaction()`:

[source, java]
----
void methodA() {
    Transaction tx = persistence.createTransaction();
    try {
        EntityManager em = persistence.getEntityManager();

        // (1) загружаем сущность, в которой name == "old name"
        Employee employee = em.find(Employee.class, id);
        assertEquals("old name", employee.getName());

        // (2) присваиваем новое значение полю
        employee.setName("name A");

        // (3) вызываем метод, создающий вложенную транзакцию
        methodB();

        // (8) здесь происходит коммит изменений в БД, и в ней
        //     окажется значение "name B"
        tx.commit();

    } finally {
        tx.end();
    }
}

void methodB() {
    Transaction tx = persistence.getTransaction();
    try {
        // (4) получаем тот же экземпляр EntityManager, что и methodA
        EntityManager em = persistence.getEntityManager();

        // (5) загружаем сущность с тем же идентификатором
        Employee employee = em.find(Employee.class, id);

        // (6) значение поля новое, т.к. мы работаем с тем же
        //     персистентным контекстом, и обращения к БД вообще
        //     не происходит
        assertEquals("name A", employee.getName());
        employee.setName("name B");

        // (7) в этот момент реально коммита не происходит
        tx.commit();
    } finally {
        tx.end();
    }
}
----

Теперь рассмотрим тот же самый пример с независимой вложенной транзакцией, создаваемой через `createTransaction()`: 

[source, java]
----
void methodA() {
    Transaction tx = persistence.createTransaction();
    try {
        EntityManager em = persistence.getEntityManager();

        // (1) загружаем сущность, в которой name == "old name"
        Employee employee = em.find(Employee.class, id);
        assertEquals("old name", employee.getName());

        // (2) присваиваем новое значение полю
        employee.setName("name A");

        // (3) вызываем метод, создающий вложенную транзакцию
        methodB();

        // (8) здесь возникнет исключение из-за оптимистичной блокировки
        //     и коммит не пройдет вообще
        tx.commit();

    } finally {
        tx.end();
    }
}

void methodB() {
    Transaction tx = persistence.createTransaction();
    try {
        // (4) создается новый экземпляр EntityManager, т.к. это
        //     новая транзакция
        EntityManager em = persistence.getEntityManager();

        // (5) загружаем сущность с тем же идентификатором
        Employee employee = em.find(Employee.class, id);

        // (6) значение поля старое, т.к. произошла загрузка из БД
        //     старого экземпляра сущности
        assertEquals("old name", employee.getName());

        employee.setName("name B");

        // (7) здесь происходит коммит изменений в БД, и в ней
        //     окажется значение "name B"
        tx.commit();

    } finally {
        tx.end();
    }
}
----

В последнем случае исключение в точке (8) возникнет, только если сущность является оптимистично блокируемой, т.е. если она реализует интерфейс `Versioned`.

[[transaction_timeout]]
===== Таймаут транзакции

Для создаваемой транзакции может быть указан таймаут в секундах, при превышении которого транзакция будет прервана и откачена. Таймаут транзакции ограничивает максимальную длительность запросов к базе данных.

При программном управлении транзакциями таймаут включается путем передачи объекта `TransactionParams` в метод `Persistence.createTransaction()`. Например:

[source, java]
----
Transaction tx = persistence.createTransaction(new TransactionParams().setTimeout(2));
----

При декларативном управлении транзакциями используется параметр `timeout` аннотации ` @Transactional`, например:

[source, java]
----
@Transactional(timeout = 2)
public void someServiceMethod() {
...
----

Таймаут по умолчанию может быть задан в свойстве приложения `
            <<cuba.defaultQueryTimeoutSec,cuba.defaultQueryTimeoutSec>>
          `. 

====== Особенности реализации для различных СУБД

*PostgreSQL*

К сожалению, JDBC драйвер *PostgreSQL* не поддерживает метод `setQueryTimeout()` интерфейса `java.sql.Statement`, поэтому в начале каждой транзакции, для которой определен таймаут (любым способом, включая ненулевое значение свойства `
              <<cuba.defaultQueryTimeoutSec,cuba.defaultQueryTimeoutSec>>
            `), выполняется дополнительный оператор в БД: `++set local statement_timeout to {value}++`. При этом в случае превышения таймаута запрос будет прерван самим сервером БД. 

Для снижения нагрузки от этих дополнительных операторов рекомендуется поступать следующим образом: 

* Таймаут по умолчанию устанавливать не на *Middleware* с помощью свойства `cuba.defaultQueryTimeoutSec`, а на самом сервере *PostgreSQL* в файле `postgresql.conf`, например, `++statement_timeout = 3000++` (это в миллисекундах). 

* Для методов, которым требуется большее время таймаута (отчеты и пр.), явно указывать желаемый таймаут в параметрах транзакции. 

*Microsoft SQL Server*

Драйвер JTDS поддерживает метод `setQueryTimeout()` интерфейса `java.sql.Statement`, поэтому для `EntityManager` просто устанавливается стандартное свойство `javax.persistence.query.timeout`, которое соответствующим образом влияет на JDBC запросы. 

