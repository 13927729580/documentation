[[middleware]]
=== Компоненты среднего слоя

На следующем рисунке приведены основные компоненты среднего слоя CUBA-приложения.

.Компоненты среднего слоя
image::Middleware.png[align="center"]

<<services,Services>> – управляемые <<container,контейнером>> компоненты, формирующие границу приложения и предоставляющие интерфейс клиентскому <<app_tiers,уровню>> приложения. Сервисы могут содержать бизнес-логику сами, либо делегировать выполнение <<managed_beans,Managed Beans>>.

<<managed_beans,Managed Beans>> – управляемые <<container,контейнером>> компоненты, содержащие бизнес-логику приложения. Вызываются <<services,сервисами>>, другими бинами или через опциональный <<jmx,JMX>>-интерфейс.

<<persistence,Persistence>> − инфраструктурный интерфейс для доступа к функциональности хранения данных: управлению <<transactions,транзакциями>> и <<orm,ORM>>.

[[services]]
==== Сервисы

Сервисы образуют слой компонентов, определяющий множество операций Middleware, доступных клиентскому <<app_tiers,уровню>> приложения. Другими словами, сервис представляет собой точку входа в бизнес-логику среднего слоя. В сервисе можно управлять <<transactions,транзакциями>>, проверять <<permissions,права>> пользователей, работать с базой данных или делегировать выполнение другим <<managed_beans,управляемым бинам>> среднего слоя.

Диаграмма классов сервиса, отображающая основные компоненты сервиса:

image::MiddlewareServices.png[align="center"]

Интерфейс сервиса располагается в модуле *global* и доступен на клиентском уровне и на Middleware. Во время выполнения, на клиентском уровне для интерфейса сервиса создается прокси-объект, который обеспечивает вызовы методов бина, реализующего сервис, с помощью механизма Spring HTTP Invoker.

Бин, реализующий сервис, располагается в модуле *core* и доступен только на среднем слое.

`ServiceInterceptor` автоматически вызывается для каждого метода сервиса через Spring AOP. Он провеяет наличие в потоке выполнения пользовательской сессии, а также трансформирует и логирует исключения, если сервис вызван с клиентского уровня.

[[service_creation]]
===== Создание сервиса

Имена интерфейсов сервисов должны заканчиваться на `Service`, имена классов реализации на `ServiceBean`.

При создании сервиса необходимо выполнить следующее:

. Создать интерфейс в <<app_modules,модуле>> *global* (т.к. интерфейс сервиса должен быть доступен на всех <<app_tiers,уровнях>>) и задать в нем имя сервиса. Имя рекомендуется задавать в формате `++{имя_проекта}_{имя_интерфейса}++`. Например:
+
[source, java]
----
include::{sourcesdir}/middleware/service_1.java[]
----

. Создать класс сервиса в модуле *core* и добавить ему аннотацию `@org.springframework.stereotype.Service` с именем, заданным в интерфейсе
+
[source, java]
----
include::{sourcesdir}/middleware/service_2.java[]
----

Класс сервиса, как и класс любого другого <<managed_beans,управляемого бина>>, должен находиться внутри дерева пакетов с корнем, заданным в элементе `context:component-scan` файла <<spring.xml,spring.xml>>. В нашем случае файл `spring.xml` содержит элемент:

[source, xml]
----
include::{sourcesdir}/middleware/service_3.xml[]
----

что означает, что поиск аннотированных бинов для данного блока приложения будет происходить начиная с пакета `com.sample.sales`.

Если некоторую бизнес-логику требуется вызывать из разных сервисов либо других компонентов Middleware, ее необходимо выделить и инкапсулировать внутри соответствующего <<managed_beans,Managed Bean>>. Например:

[source, java]
----
include::{sourcesdir}/middleware/service_7_1.java[]
----

[source, java]
----
include::{sourcesdir}/middleware/service_7_2.java[]
----

[source, java]
----
include::{sourcesdir}/middleware/service_7_3.java[]
----

[[service_import]]
===== Использование сервиса

Для того чтобы вызывать сервис, в клиентском блоке приложения для него должен быть создан соответствующий прокси-объект. Делается это путем объявления имени и интерфейса сервиса в параметрах фабрики прокси-объектов. Для блока Web Client это бин класса `WebRemoteProxyBeanCreator`, для Web Portal - `PortalRemoteProxyBeanCreator`, для Desktop Client - `RemoteProxyBeanCreator` .

Фабрика прокси-объектов конфигурируется в файле <<spring.xml,spring.xml>> соответствующего клиентского блока.

Например, чтобы в приложении *sales* вызвать с веб-клиента сервис `++sales_OrderService++`, необходимо добавить в файл `web-spring.xml` модуля *web* следующее:

[source, xml]
----
include::{sourcesdir}/middleware/service_4.xml[]
----

Все импортируемые сервисы объявляются в одном свойстве `remoteServices` в элементах `map/entry`.

[TIP]
====
CUBA Studio автоматически регистрирует сервисы во всех клиентских блоках приложения.
====

С точки зрения прикладного кода прокси-объект сервиса на клиентском уровне является обычным бином Spring и может быть получен либо инжекцией, либо с помощью класса `AppBeans`, например:

[source, java]
----
include::{sourcesdir}/middleware/service_5.java[]
----

[[dataService]]
===== DataService

`DataService` является фасадом для вызова серверной релизации <<dataManager,DataManager>> с клиентского уровня. `DataService` не рекомендуется использовать в прикладном коде. Вместо него и на клиентском уровне, и на Middleware следует использовать `DataManager`.

[[data_store]]
==== Data Stores

Предпочтительный способ работы с данными в CUBA-приложениях - использование сущностей: либо декларативно в <<datasources,источниках данных>> и связанных с данными компонентах, либо программно через <<dataManager,DataManager>> или <<entityManager,EntityManager>>. Сущности отображаются на данные в хранилище, которое обычно представляет собой реляционную БД. Приложение может работать с несколькими хранилищами, так что его <<data_model,модель данных>> будет содержать сущности, отображаемые на данные из разных БД.

Некоторая сущность может принадлежать только одному хранилищу. Сущности из разных хранилищ можно отображать на одном экране UI, при этом `DataManager` обеспечивает их чтение и запись в соответствующее хранилище. В зависимости от типа сущности, `DataManager` выбирает зарегистрированное хранилище, представленное реализацией интерфейса `DataStore`, и делегирует ему загрузку или сохранение. При управлении транзакциями и работе с сущностями через `EntityManager` необходимо явно указывать, какое хранилище использовать. Подробнее см. методы интерфейса <<persistence,Persistence>> и параметры аннотации <<transactions_decl,@Transactional>>.

Платформа содержит единственную реализацию интерфейса `DataStore`: `RdbmsStore`, предназначенную для работы с реляционными СУБД через слой <<orm,ORM>>. Кроме того, в проекте приложения можно реализовать `DataStore` для интеграции, например, с нереляционной СУБД или внешней системой, имеющей REST интерфейс.

Каждое CUBA-приложение имеет основное хранилище, которое содержит системные сущности и используется для входа пользователей в приложение. В данном руководстве под базой данных всегда имеется в виду основное хранилище, если явно не оговорено другое. Основное хранилище должно представлять собой реляционную БД, подключенную через источник данных JDBC. Источник данных основного хранилища находится в JNDI с именем, указанным в свойстве приложения <<cuba.dataSourceJndiName,cuba.dataSourceJndiName>> (по умолчанию `jdbc/CubaDS`).

Имена дополнительных хранилищ указываются в свойстве приложения <<cuba.additionalStores,cuba.additionalStores>>. Если дополнительное хранилище является реляционной БД (`RdbmsStore`), необходимо указать для него следующие свойства приложения:

* `cuba.dataSourceJndiName_{store_name}` - JNDI-имя соответствующего источника данных JDBC.
* `cuba.dbmsType_{store_name}` - тип базы данных хранилища.
* `cuba.persistenceConfig_{store_name}` - путь к фалу `persistence.xml` хранилища.

Если вы реализовали интерфейс `DataStore` в проекте, укажите имя бина реализации в свойстве приложения `cuba.storeImpl_{store_name}`.

Предположим, что в вашем проекте два дополнительных хранилища: `db1` (база данных PostgreSQL) and `mem1` (некоторое in-memory хранилище, реализованное бином проекта). Тогда необходимо указать следующие свойства приложения в файле `app.properties` модуля *core*:

[source,properties]
----
cuba.additionalStores = db1, mem1
cuba.dataSourceJndiName_db1 = jdbc/db1
cuba.dbmsType_db1 = postgres
cuba.persistenceConfig_db1 = com/company/sample/db1-persistence.xml
cuba.storeImpl_mem1 = sample_InMemoryStore
----

Свойства `cuba.additionalStores` и `cuba.persistenceConfig_db1` необходимо также указать в файлах свойств всех используемых блоков приложения (`web-app.properties`, `portal-app.properties`, и т.д.).

[TIP]
====
CUBA Studio позволяет настраивать дополнительные хранилища на вкладке *Project properties > Advanced*. Studio автоматически создает все необходимые свойства приложения и поддерживает соответствующие файлы `persistence.xml`. После этого хранилище можно будет указать в поле *Data store* редактора сущности. Кроме того, хранилище можно будет выбрать при запуске мастера *Generate model* для создания сущностей, отображенных на существующую схему БД.
====

[[cross_datastore_ref]]
Ссылки между сущностями из разных хранилищ::
+
--
<<dataManager,DataManager>> может автоматически поддерживать TO-ONE ссылки между сущностями из разных хранилищ, если они объявлены нужным образом. Например, рассмотрим случай, когда необходимо в сущности `Order`, находящейся в главном хранилище, иметь ссылку на сущность `Customer` из дополнительного хранилища. Необходимо сделать следующее:

* В сущности `Order` определить атрибут типа, соответствующего идентификатору `Customer`. Атрибут должен быть аннотирован как `@SystemLevel` чтобы исключить его из различных списков, доступных пользователям, в частности из атрибутов в <<gui_Filter,Filter>>:
+
[source,java]
----
@SystemLevel
@Column(name = "CUSTOMER_ID")
private Long customerId;
----

* В сущности `Order` определить неперсистентный атрибут-ссылку на `Customer` и указать атрибут `customerId` как "related":
+
[source,java]
----
@Transient
@MetaProperty(related = "customerId")
private Customer customer;
----

* Включите неперсистентный атрибут `customer` в нужные <<views,представления>>.

После этого, когда `Order` будет загружается с представление, включающим атрибут `customer`, `DataManager` будет автоматически загружать связанные экземпляры `Customer` из дополнительного хранилища. Загрузка коллекций оптимизирована по производительности: после загрузки списка заказов загрузка покупателей из доп. хранилища производится пакетами. Размер пакета определяется свойством приложения <<cuba.crossDataStoreReferenceLoadingBatchSize,cuba.crossDataStoreReferenceLoadingBatchSize>>.

При коммите графа объектов, включающего `Order` со ссылкой на `Customer`, `DataManager` сохранит сущности через соответствующие имплементации `DataStore`, а затем сохранит идентификатор `Customer` в атрибуте `customerId` сущности `Order`.

Ссылки между сущностями из разных хранилищ поддерживаются компонентом <<gui_Filter,Filter>>.

[TIP]
====
CUBA Studio автоматически поддерживает набор атрибутов для ссылок между сущностями из разных хранилищ, если в качестве ассоциации выбирается сущность из другого хранилища.
====
--

[[persistence]]
==== Интерфейс Persistence

Интерфейс `Persistence` является точкой входа в функциональность хранения данных, предоставляемую слоем <<orm,ORM>>.

Методы интерфейса:

* `createTransaction()`, `getTransaction()` - получить интерфейс управления <<transactions,транзакциями>>. Методы могут принимать имя <<data_store,хранилища данных>>. Если хранилище не указано, подразумевается основная база данных.

* `callInTransaction()`, `runInTransaction()` - выполнить код в новой транзакции с возвратом значения или без возврата значения. Методы могут принимать имя <<data_store,хранилища данных>>. Если хранилище не указано, подразумевается основная база данных.

* `isInTransaction()` - определяет, существует ли в данный момент активная транзакция.

* `getEntityManager()` - возвращает экземпляр <<entityManager,EntityManager>> для текущей транзакции. Метод может принимать имя <<data_store,хранилища данных>>. Если хранилище не указано, подразумевается основная база данных.

* `isSoftDeletion()` - позволяет определить, активен ли режим <<soft_deletion,мягкого удаления>>

* `setSoftDeletion()` - устанавливает или отключает режим мягкого удаления. Влияет на аналогичный признак всех создаваемых экземпляров `EntityManager`. По умолчанию мягкое удаление включено.

* `getDbTypeConverter()` - возвращает экземпляр <<dbTypeConverter,DbTypeConverter>> для основной базы данных или для дополнительного хранилища.

* `getDataSource()` - получить `javax.sql.DataSource` для основной базы данных или для дополнительного хранилища.
+
[WARNING]
====
Для всех объектов `javax.sql.Connection`, получаемых методом `getDataSource().getConnection()`, необходимо после использования соединения вызвать метод `close()` в секции `finally`. В противном случае соединение не вернется в пул, через какое-то время пул переполнится, и приложение не сможет выполнять запросы к базе данных. 
====

* `getTools()` - возвращает экземпляр интерфейса `PersistenceTools` (см. ниже).

[[persistenceTools]]
===== PersistenceTools

<<managed_beans,ManagedBean>>, содержащий вспомогательные методы работы с хранилищем данных. Интерфейс `PersistenceTools` можно получить либо методом `Persistence.getTools()`, либо как любой другой бин - инжекцией или через класс `AppBeans`.

Методы `PersistenceTools`:

* `getDirtyFields()` - возвращает коллекцию имен атрибутов сущности, измененных со времени последней загрузки экземпляра из БД. Для новых экземпляров возвращает пустую коллекцию.

* `isLoaded()` - определяет, загружен ли из БД указанный атрибут экземпляра. Атрибут может быть _не_ загружен, если он не указан в примененном при загрузке <<views,представлении>>. 
+
Данный метод работает только для экземпляров в состоянии <<entity_states,Managed>>.

* `getReferenceId()` - возвращает идентификатор связанной сущности без загрузки ее из БД. 
+
Предположим, в <<persistence_context,персистентный контекст>> загружен экземпляр `Order`, и нужно получить значение идентификатора экземпляра `Customer`, связанного с данным Заказом. Стандартное решение `order.getCustomer().getId()` приведет к выполнению SQL запроса к БД для загрузки экземпляра `Customer`, что в данном случае избыточно, так как значение идентификатора Покупателя физически находится также и в таблице Заказов. Выполнение же
+
[source, java]
----
include::{sourcesdir}/middleware/persistencetools_1.java[]
----

не вызовет никаких дополнительных запросов к базе данных. 

Данный метод работает только для экземпляров в состоянии <<entity_states,Managed>>.

Для расширения набора вспомогательных методов в конкретном приложении бин `PersistenceTools` можно <<bean_extension,переопределить>>. Примеры работы с расширенным интерфейсом:

[source, java]
----
include::{sourcesdir}/middleware/persistencetools_2.java[]
----

[source, java]
----
include::{sourcesdir}/middleware/persistencetools_3.java[]
----

[[dbTypeConverter]]
===== DbTypeConverter

Интерфейс, определяющий методы для конвертации данных между значениями атрибутов <<data_model,модели данных>> и параметрами и результатами запросов JDBC. Объект данного интерфейса можно получить методом `<<persistence,Persistence>>.getDbTypeConverter()`.

Методы `DbTypeConverter`:

* `getJavaObject()` - конвертирует результат JDBC запроса в тип, подходящий для присвоения атрибуту сущности. 

* `getSqlObject()` - конвертирует значение атрибута сущности в тип, подходящий для присвоения параметру JDBC запроса.

* `getSqlType()` - возвращает константу из `java.sql.Types`, соответствующую переданному типу атрибута сущности.

[[orm]]
==== Слой ORM

Object-Relational Mapping - объектно-реляционное отображение - технология связывания таблиц реляционной базы данных с объектами языка программирования. 

Преимущества использования ORM::: 

* Позволяет работать с данными реляционной СУБД, манипулируя объектами Java.

* Упрощает программирование, избавляя от рутины написания тривиальных SQL-запросов.

* Упрощает программирование, позволяя извлекать и сохранять целые графы объектов одной командой.

* Обеспечивает легкое портирование приложения на различные СУБД.

* Позволяет использовать лаконичный язык запросов <<jpql,JPQL>>.

Недостатки:::

* Требует понимания особенностей работы с ORM.

* Усложняет оптимизацию SQL и использование особенности применяемой СУБД.

В платформе CUBA используется реализация ORM основе фреймворка *EclipseLink*.

[[entityManager]]
===== EntityManager

`EntityManager` - основной интерфейс ORM, служит для управления персистентными <<data_model,сущностями>>.

[TIP]
====
В разделе <<dm_vs_em>> приведена информация о различиях между EntityManager и <<dataManager,DataManager>>.
====

Ссылку на `EntityManager` можно получить через интерфейс `Persistence`, вызовом метода `getEntityManager()`. Полученный экземпляр `EntityManager` привязан к текущей <<transactions,транзакции>>, то есть все вызовы `getEntityManager()` в рамках одной транзакции возвращают один и тот же экземпляр `EntityManager`. После завершения транзакции обращения к данному экземпляру невозможны.

Экземпляр `EntityManager` содержит в себе _персистентный контекст_ – набор экземпляров сущностей, загруженных из БД или только что созданных. Персистентный контекст является своего рода кэшем данных в рамках транзакции.`EntityManager` автоматически сбрасывает в БД все изменения, сделанные в его персистентном контексте, в момент коммита транзакции, либо при явном вызове метода `flush()`.

Интерфейс `EntityManager`, используемый в CUBA-приложениях, в основном повторяет стандартный link:$$http://docs.oracle.com/javaee/7/api/javax/persistence/EntityManager.html$$[javax.persistence.EntityManager]. Рассмотрим его основные методы:

* `persist()` - вводит <<entity_states,новый экземпляр>> сущности в персистентный контекст. При коммите транзакции командой SQL `INSERT` в БД будет создана соответствующая запись.

* `merge()` - переносит состояние <<entity_states,отсоединенного экземпляра>> сущности в персистентный контекст следующим образом: из БД загружается экземпляр с тем же идентификатором, в него переносится состояние переданного Detached экземпляра и возвращается загруженный Managed экземпляр. Далее надо работать именно с возвращенным Managed экземпляром. При коммите транзакции командой SQL `UPDATE` в БД будет сохранено состояние данного экземпляра.

* `remove()` - удалить объект из базы данных, либо, если включен режим <<soft_deletion,мягкого удаления>>, установить атрибуты `deleteTs` и `deletedBy`.
+
Если переданный экземпляр находится в Detached состоянии, сначала выполняется `merge()`.

* `find()` - загружает экземпляр сущности по идентификатору.
+
--
При формировании запроса к БД учитывается <<views,представление>>, переданное в параметре данного метода. В результате в персистентном контексте окажется граф объектов, для которого загружены все атрибуты представления.

[TIP]
====
В отличие от <<dataManager,DataManager>>, все локальные атрибуты сущностей загружаются наезависимо от того, указаны ли они в представлении или нет. В `EntityManager` представление влияет только на загрузку атрибутов-ссылок.
====
--

* `createQuery()` - создать объект `Query` или `TypedQuery` для выполнения <<query,JPQL запроса>>.

* `createNativeQuery()` - создать объект `Query` для выполнения <<nativeQuery,SQL запроса>>. 

* `addView()` - аналогичен методу `setView()`, но в случае наличия уже установленного в `EntityManager` представления, не заменяет его, а добавляет атрибуты переданного представления.

* `reload()` - перезагрузить экземпляр сущности с указанным <<views,представлением>>.

* `isSoftDeletion()` - проверяет, находится ли данный `EntityManager` в режиме <<soft_deletion,мягкого удаления>>.

* `setSoftDeletion()` - устанавливает режим <<soft_deletion,мягкого удаления>> для данного экземпляра `EntityManager`.

* `getConnection()` - возвращает `java.sql.Connection`, через который выполняет запросы данный экземпляр `EntityManager`, и, соответственно, текущая транзакция. Закрывать такое соединение не нужно, оно будет закрыто при завершении транзакции.

* `getDelegate()` - возвращает `javax.persistence.EntityManager`, предоставляемый реализацией ORM. 

Пример использования `EntityManager` в <<services,сервисе>>:

[source, java]
----
include::{sourcesdir}/middleware/entityManager_1.java[]
----

[[em_partial_entities]]
Частичные сущности::
+
--
По умолчанию, представления в EntityManager влияют только на загрузку связей, т.е. все локальные атрибуты всегда загружаются.

Вы можете заставить EntityManager загружать _частичные_ сущности, если установите атрибут `loadPartialEntities` представления в true. Однако, если загружаемая сущность <<entity_cache,кэшируется>>, данный признак игнорируется, и сущность все равно будет загружена со всеми локальными атрибутами.
--

[[entity_states]]
===== Состояния сущности

New:: 
+
--
Только что созданный в памяти экземпляр, например: `Car car = new Car()`.
Новый экземпляр может быть передан в `EntityManager.persist()` для сохранения в БД, при этом он переходит в состояние Managed.
--

Managed:: 
+
--
Загруженный из БД или новый, переданный в EntityManager.persist(), экземпляр. Принадлежит некоторому экземпляру `EntityManager`, другими словами, находится в его персистентном контексте.

Любые изменения экземпляра в состоянии Managed будут сохранены в БД в случае коммита транзакции, к которой принадлежит данный `EntityManager`.

--

Detached:: 
+
--
Экземпляр, загруженный из БД и отсоединенный от своего персистентного контекста (вследствие завершения транзакции или сериализации).

Изменения, вносимые в Detached экземпляр, запоминаются в самом этом экземпляре (в полях, добавленных с помощью bytecode enhancement). Эти изменения будут сохранены в БД, только если данный экземпляр будет снова переведен в состояние Managed путем передачи в метод `EntityManager.merge()`.
--

[[lazy_loading]]
===== Загрузка по требованию

Загрузка по требованию (lazy loading) позволяет загружать связанные сущности отложенно, т.е. только в момент первого обращения к их свойствам.

Загрузка по требованию в сумме порождает больше запросов к БД, чем <<eager_fetching,жадная загрузка>> (eager fetching), однако нагрузка при этом растянута во времени.

* Например, при извлечении списка N экземпляров сущности A, содержащих ссылку на экземпляр сущности B, в случае загрузки по требованию будет выполнено N+1 запросов к базе данных.

* Как правило, для минимизации времени отклика и снижения нагрузки необходимо стремиться к меньшему количеству обращений к БД. Для этого в платформе используется механизм <<views,представлений>>, с помощью которого в вышеописанном случае ORM может сформировать один запрос к БД с объединением таблиц.

Загрузка по требованию работает только для экземпляра в состоянии <<entity_states,Managed>>, то есть внутри транзакции, загрузившей данный экземпляр.

[[query]]
===== Выполнение JPQL запросов

Для выполнения <<jpql,JPQL>> запросов предназначен интерфейс `Query`, ссылку на который можно получить у текущего экземпляра `EntityManager` вызовом метода `createQuery()`. Если запрос предполагается использовать для извлечения сущностей, рекомендуется вызывать `createQuery()` с передачей типа результата, что приведет к созданию `TypedQuery`. 

Методы `Query` в основном соответствуют методам стандартного интерфейса JPA link:$$http://docs.oracle.com/javaee/7/api/javax/persistence/Query.html$$[`javax.persistence.Query`]. Рассмотрим отличия.

* `setParameter()` - устанавливает значение параметра запроса. При передаче в данный метод экземпляра сущности выполняет неявное преобразование экземпляра в его идентификатор. Например:
+
[source, java]
----
include::{sourcesdir}/middleware/jpqlquery_1.java[]
----
+
Обратите внимание на сравнение в запросе по идентификатору, но передачу в качестве параметра самого экземпляра сущности. 
+
Вариант метода с передачей `implicitConversions = false` не выполняет такого преобразования.

* `setView()`, `addView()` - устанавливают <<views,представление>>, используемое при загрузке данных.

* `getDelegate()` - возвращает экземпляр `javax.persistence.Query`, предоставляемый реализацией ORM.

При выполнении запроса через `Query` изменения в текущем персистентном контексте не учитываются, т.е. запрос просто выполняется в БД. Если результатом выборки являются экземпляры, уже находящиеся в персистентном контексте, то в результате запроса окажутся именно они, а не прочитанные из БД. Ситуацию поясняет следующий фрагмент теста:

[source, java]
----
include::{sourcesdir}/middleware/jpqlquery_2.java[]
----

Запросы, модифицирующие данные (`update`, `delete`) приводят к сбросу (flush) в базу данных текущего персистентного контекста перед выполнением. Другими словами, ORM сначала синхронизирует состояние сущностей в персистентном контексте и в БД, а уже потом выполняет модифицирующий запрос. Рекомендуется выполнять такие запросы в неизмененном персистентном контексте, чтобы исключить неявные действия ORM, которые могут отрицательно сказаться на производительности.

[[jpql_functions]]
====== Функции JPQL

В таблице ниже описаны функции JPQL, поддерживаемые и не поддерживаемые платформой CUBA.

[cols="1,1,5",width="100%"]
|===
|Функция |Поддерживается |Пример запроса

//Aggregate functions with scalar expression

.2+|Агрегатные функции

|ДА

m|SELECT AVG(o.quantity) FROM app$Order o

|_НЕТ: агрегатные функции со скалярными выражениями (особенность EclipseLink)_

m|_SELECT AVG(o.quantity)/2.0 FROM app$Order o_

_SELECT AVG(o.quantity * o.price) FROM app$Order o_

//ALL, ANY, SOME

|ALL, ANY, SOME

|ДА

m|SELECT emp FROM app$Employee emp WHERE emp.salary > ALL (SELECT m.salary FROM app$Manager m WHERE m.department = emp.department)

//Arithmetic Functions (INDEX, SIZE, ABS, SQRT, MOD)

|Арифметические функции (INDEX, SIZE, ABS, SQRT, MOD)

|ДА

m|SELECT w.name FROM app$Course c JOIN c.studentWaitlist w WHERE c.name = 'Calculus' AND INDEX(w) = 0

  SELECT w.name FROM app$Course c WHERE c.name = 'Calculus' AND SIZE(c.studentWaitlist) = 1

  SELECT w.name FROM app$Course c WHERE c.name = 'Calculus' AND ABS(c.time) = 10

  SELECT w.name FROM app$Course c WHERE c.name = 'Calculus' AND SQRT(c.time) = 10.5

  SELECT w.name FROM app$Course c WHERE c.name = 'Calculus' AND MOD(c.time, c.time1) = 2

//CASE Expression in UPDATE query

.2+|CASE

|ДА

m|SELECT e.name, f.name, CONCAT(CASE WHEN f.annualMiles > 50000 THEN 'Platinum ' WHEN f.annualMiles > 25000 THEN 'Gold ' ELSE '' END, 'Frequent Flyer')
  FROM app$Employee e JOIN e.frequentFlierPlan f

|_НЕТ: CASE в UPDATE-запросе_

m|_UPDATE app$Employee e SET e.salary = CASE e.rating WHEN 1 THEN e.salary * 1.1 WHEN 2 THEN e.salary * 1.05 ELSE e.salary * 1.01 END_

//Date Functions (CURRENT_DATE, CURRENT_TIME, CURRENT_TIMESTAMP)

|Функции даты и времени (CURRENT_DATE, CURRENT_TIME, CURRENT_TIMESTAMP)

|ДА

m|SELECT e FROM app$Order e WHERE e.date = CURRENT_DATE

//EclipseLink Functions (CAST, REGEXP, EXTRACT)

.2+|Функции EclipseLink (CAST, REGEXP, EXTRACT)

|ДА

m|SELECT EXTRACT(YEAR FROM e.createTs) FROM app$MyEntity e WHERE EXTRACT(YEAR FROM e.createTs) > 2012

  SELECT e FROM app$MyEntity e WHERE e.name REGEXP '.*'

  SELECT CAST(e.number text) FROM app$MyEntity e WHERE e.path LIKE CAST(:ds$myEntityDs.id text)

|_НЕТ: CAST в запросе GROUP BY_

m|_SELECT e FROM app$Order e WHERE e.amount > 100 GROUP BY CAST(e.orderDate date)_

//Entity Type Expression

.2+|Операторы типов сущности

|ДА: тип сущности передаётся как параметр

m|SELECT e FROM app$Employee e WHERE TYPE(e) IN (:empType1, :empType2)

|_НЕТ: прямая ссылка на сущность_

m|_SELECT e FROM app$Employee e WHERE TYPE(e) IN (app$Exempt, app$Contractor)_

//Function Invocation

.2+|Вызов функций

|ДА: результат с операторами сравнения

m|SELECT u FROM sec$User u WHERE function('DAYOFMONTH', u.createTs) = 1

|_НЕТ: прямое использование результата функции_

m|_SELECT u FROM sec$User u WHERE function('hasRoles', u.createdBy, u.login)_

//IN

|IN

|ДА

m|SELECT e FROM Employee e, IN(e.projects) p WHERE p.budget > 1000000

//IS EMPTY collection

|IS EMPTY для коллекций

|ДА

m|SELECT e FROM Employee e WHERE e.projects IS EMPTY

//KEY/VALUE

|KEY/VALUE

|_НЕТ_

m|_SELECT v.location.street, KEY(i).title, VALUE(i) FROM app$VideoStore v JOIN v.videoInventory i WHERE v.location.zipcode = '94301' AND VALUE(i) > 0_

//Literals
.2+|Литералы

|ДА

m|SELECT e FROM app$Employee e WHERE e.name = 'Bob'

  SELECT e FROM app$Employee e WHERE e.id = 1234

  SELECT e FROM app$Employee e WHERE e.id = 1234L

  SELECT s FROM app$Stat s WHERE s.ratio > 3.14F

  SELECT s FROM app$Stat s WHERE s.ratio > 3.14e32D

  SELECT e FROM app$Employee e WHERE e.active = TRUE

|_НЕТ: литералы даты и времени_

m|_SELECT e FROM app$Employee e WHERE e.startDate = {d'2012-01-03'}_

  _SELECT e FROM app$Employee e WHERE e.startTime = {t'09:00:00'}_

  _SELECT e FROM app$Employee e WHERE e.version = {ts'2012-01-03 09:00:00.000000001'}_

//MEMBER OF

.2+|MEMBER OF

|ДА: для полей и запросов

m|SELECT d FROM app$Department d WHERE (select e from app$Employee e where e.id = :eParam) MEMBER OF e.employees

|_НЕТ: для литералов_

m|_SELECT e FROM app$Employee e WHERE 'write code' MEMBER OF e.codes_

//NEW in SELECT

|NEW в SELECT

|_НЕТ_

m|_SELECT NEW com.acme.example.CustomerDetails(c.id, c.status, o.count) FROM app$Customer c JOIN c.orders o WHERE o.count > 100_

//NULLIF/COALESCE

|NULLIF/COALESCE

|ДА

m|SELECT NULLIF(emp.salary, 10) FROM app$Employee emp

  SELECT COALESCE(emp.salary, emp.salaryOld, 10) FROM app$Employee emp

//NULLS FIRST, NULLS LAST in order by

|NULLS FIRST, NULLS LAST в order by

|ДА

m|SELECT h FROM sec$GroupHierarchy h ORDER BY h.level DESC NULLS FIRST

//String Functions (CONCAT, SUBSTRING, TRIM, LOWER, UPPER, LENGTH, LOCATE)

.2+|Строковые функции (CONCAT, SUBSTRING, TRIM, LOWER, UPPER, LENGTH, LOCATE)

|ДА

m|SELECT x FROM app$Magazine x WHERE CONCAT(x.title, 's') = 'JDJs'

  SELECT x FROM app$Magazine x WHERE SUBSTRING(x.title, 1, 1) = 'J'

  SELECT x FROM app$Magazine x WHERE LOWER(x.title) = 'd'

  SELECT x FROM app$Magazine x WHERE UPPER(x.title) = 'D'

  SELECT x FROM app$Magazine x WHERE LENGTH(x.title) = 10

  SELECT x FROM app$Magazine x WHERE LOCATE('A', x.title, 4) = 6

  SELECT x FROM app$Magazine x WHERE TRIM(TRAILING FROM x.title) = 'D'

|_НЕТ: TRIM не поддерживается с trim char_

m|_SELECT x FROM app$Magazine x WHERE TRIM(TRAILING 'J' FROM x.title) = 'D'_

//Subquery
.2+|Вложенные запросы

|ДА

m|SELECT goodCustomer FROM app$Customer goodCustomer WHERE goodCustomer.balanceOwed < (SELECT AVG(c.balanceOwed) FROM app$Customer c)

|_НЕТ: path-выражения вместо имени сущности в FROM подзапроса_

m|_SELECT c FROM app$Customer c WHERE (SELECT AVG(o.price) FROM c.orders o) > 100_

//TREAT
.2+|TREAT

|ДА

m|SELECT e FROM app$Employee e JOIN TREAT(e.projects AS app$LargeProject) p WHERE p.budget > 1000000

|_НЕТ: TREAT в WHERE-выражениях_

m|_SELECT e FROM Employee e JOIN e.projects p WHERE TREAT(p as LargeProject).budget > 1000000_

|===

[[query_case_insensitive]]
====== Поиск подстроки без учета регистра

Для удобного формирования условия поиска без учета регистра символов и по любой части строки можно использовать префикс `(?i)` в значении параметра запроса. Например, имеется запрос:

[source, jpql]
----
select c from sales$Customer c where c.name like :name
----

Если в значении параметра `name` передать строку `(?i)%doe%`, то при наличии в БД записи со значением `John Doe` она будет найдена, несмотря на раличие в регистре символа. Это произойдет потому, что ORM выполнит SQL с условием вида `lower(C.NAME) like ?`.

Следует иметь в виду, что при таком поиске индекс, созданный в БД по полю `NAME`, не используется.

[[jpql_macro]]
====== Макросы в JPQL

Текст JPQL запроса может включать макросы, которые обрабатываются перед выполнением и превращаются в исполняемый JPQL, дополнительно модифицируя набор параметров.

Макросы решают следующие задачи:

* Позволяют обойти принципиальную невозможность средствами JPQL выразить условие зависимости значения поля от текущего момента времени (не работает арифметика типа current_date-1)

* Позволяют сравнивать с датой поля типа Timestamp (содержащие дату+время)

Рассмотрим их подробно:

@between:: 
+
--
Имеет вид `++@between(field_name, moment1, moment2, time_unit)++`, где 

* `++field_name++` - имя атрибута для сравнения 

* `moment1`, `moment2` - моменты времени, в которые должно попасть значение атрибута `++field_name++`. Каждый из моментов должен быть определен выражением с участием переменной `now`, к которой может быть прибавлено или отнято целое число 

* `++time_unit++` - определяет единицу измерения времени, которое прибавляется или вычитается из `now` в выражениях моментов, а также точность округления моментов. Может быть следующим: `year`, `month`, `day`, `hour`, `minute`, `second`.

Макрос преобразуется в следующее выражение JPQL: `++field_name >= :moment1 and field_name < :moment2++`

Пример 1. Покупатель создан сегодня:

[source, jpql]
----
select c from sales$Customer where @between(c.createTs, now, now+1, day)
----

Пример 2. Покупатель создан в течение последних 10 минут:

[source, jpql]
----
select c from sales$Customer where @between(c.createTs, now-10, now, minute)
----

Пример 3. Документы, датированные последними 5 рабочими днями (для проектов, включающих *workflow*): 

[source, jpql]
----
select d from sales$Doc where @between(d.createTs, now-5, now, workday)
----
--

@today:: 
+
--
Имеет вид `++@today(field_name)++` и обеспечивает формирование условия попадания значения атрибута в текущий день. По сути это частный случай макроса `@between`.

Пример. Пользователь создан сегодня:

[source, jpql]
----
select d from sales$Doc where @today(d.createTs)
----
--

@dateEquals:: 
+
--
Имеет вид `++@dateEquals(field_name, parameter)++` и позволяет сформировать условие попадания значения поля `++field_name++` типа `Timestamp` в дату, задаваемую параметром `parameter`.

Пример:

[source, jpql]
----
select d from sales$Doc where @dateEquals(d.createTs, :param)
----
--

@dateBefore:: 
+
--
Имеет вид `++@dateBefore(field_name, parameter++`) и позволяет сформировать условие, что дата значения поля `++field_name++` типа `Timestamp` меньше даты, задаваемой параметром `parameter`.

Пример:

[source, jpql]
----
select d from sales$Doc where @dateBefore(d.createTs, :param)
----
--

@dateAfter:: 
+
--
Имеет вид `++@dateAfter(field_name, parameter++`) и позволяет сформировать условие, что дата значения поля `++field_name++` типа `Timestamp` больше или равна дате, задаваемой параметром `parameter`.

Пример:

[source, jpql]
----
select d from sales$Doc where @dateAfter(d.createTs, :param)
----
--

@enum:: 
+
--
Позволяет использовать полное имя константы enum вместо ее идентификатора в БД. Это упрощает поиск использований enum в коде приложения.

Пример: 

[source, jpql]
----
select r from sec$Role where r.type = @enum(com.haulmont.cuba.security.entity.RoleType.SUPER) order by r.name
---- 
--

[[nativeQuery]]
===== Выполнение SQL запросов

ORM позволяет выполнять SQL запросы к базе данных, возвращая как списки отдельных полей, так и экземпляры сущностей. Для этого необходимо создать объект `Query` или `TypedQuery` вызовом одного из методов `EntityManager.createNativeQuery()`. 

Если выполняется выборка отдельных колонок таблицы, то результирующий список будет содержать строки в виде `Object[]`. Например:

[source, java]
----
include::{sourcesdir}/middleware/sqlquery_1.java[]
----

Если выполняется выборка единственной колонки или агрегатной функции, то результирующий список будет содержать эти значения непосредственно:

[source, java]
----
include::{sourcesdir}/middleware/sqlquery_3.java[]
----

Если вместе с текстом запроса передан класс результирующей сущности, то возвращается `TypedQuery` и после выполнения производится попытка отображения результатов запроса на атрибуты сущности. Например:

[source, java]
----
include::{sourcesdir}/middleware/sqlquery_2.java[]
----

Следует иметь в виду, что при использовании SQL колонки, соответствующие атрибутам сущностей типа `UUID`, возвращаются в виде `UUID` или в виде `String`, в зависимости от используемой СУБД:

* *HSQLDB* - `String`
* *PostgreSQL* - `UUID`
* *Microsoft SQL Server* - `String`
* *Oracle* - `String`
* *MySQL* – `String`

Параметры этого типа также должны задаваться либо как `UUID`, либо своим строковым представлением, в зависимости от используемой СУБД. Для обеспечения независимости кода от используемой СУБД рекомендуется использовать <<dbTypeConverter,DbTypeConverter>>, который обеспечивает конвертацию данных между объектами Java и параметрами и результатами JDBC.

В SQL запросах можно использовать позиционные или именованные параметры. Позиционные параметры обозначаются ? с последующим номером параметра начиная с 1. Именованные параметры обозначаются знаком #. См. примеры выше.

Поведение SQL запросов, возвращающих сущности, и модифицирующих запросов (`update`, `delete`), по отношению к текущему персистентному контексту аналогично описанному для <<query,JPQL запросов>>.

См. также <<queryRunner,>>.

[[entity_listeners]]
===== Entity Listeners

_Entity Listeners_ предназначены для реакции на события жизненного цикла экземпляров сущностей на уровне Middleware.

Слушатель представляет собой класс, реализующий один или несколько интерфейсов пакета `com.haulmont.cuba.core.listener`. Слушатель будет реагировать на события типов, соответствующих реализуемым интерфейсам.

BeforeDetachEntityListener::
+
--
Метод `onBeforeDetach()` вызывается перед отделением объекта от <<entityManager,EntityManager>> при коммите транзакции.

Данный слушатель можно использовать, например, для заполнения неперсистентных атрибутов сущности перед отправкой ее на клиентский уровень.
--

BeforeAttachEntityListener::
+
--
Метод `onBeforeAttach()` вызывается перед введением объекта в персистентный контекст при выполнении операции `EntityManager.merge()`.

Данный слушатель можно использовать, например, для заполнения персистентных атрибутов сущности перед сохранением ее в базе данных.
--

BeforeInsertEntityListener::
Метод `onBeforeInsert()` вызывается перед выполнением вставки записи в БД. В данном методе возможны любые операции с текущим `EntityManager`.

AfterInsertEntityListener::
Метод `onAfterInsert()` вызывается после выполнения вставки записи в БД, но до коммита транзакции. В данном методе нельзя модифицировать текущий персистентный контекст, однако можно производить изменения в БД с помощью <<queryRunner,QueryRunner>>.

BeforeUpdateEntityListener::
Метод `onBeforeUpdate()` вызывается перед изменением записи в БД. В данном методе возможны любые операции с текущим `EntityManager`.

AfterUpdateEntityListener::
Метод `onAfterUpdate()` вызывается после изменения записи в БД, но до коммита транзакции. В данном методе нельзя модифицировать текущий персистентный контекст, однако можно производить изменения в БД с помощью `QueryRunner`.

BeforeDeleteEntityListener::
Метод `onBeforeDelete()` вызывается перед удалением записи из БД (или в случае <<soft_deletion,мягкого удаления>> - перед изменением записи). В данном методе возможны любые операции с текущим `EntityManager`.

AfterDeleteEntityListener::
Метод `onAfterDelete()` вызывается после удаления записи из БД (или в случае мягкого удаления - после изменения записи), но до коммита транзакции. В данном методе нельзя модифицировать текущий персистентный контекст, однако можно производить изменения в БД с помощью `QueryRunner`.

Entity Listener должен являться управляемым бином, поэтому в нем можно использовать инжекцию:

[source, java]
----
include::{sourcesdir}/middleware/entitylisteners_1.java[]
----

Entity Listener может быть задан двумя способами:

* Статически - имена бинов слушателей указываются в аннотации <<listeners_annotation,@Listeners>> на классе сущности:
+
[source, java]
----
include::{sourcesdir}/middleware/entitylisteners_2.java[]
----

* Динамически - имя бина слушателя передается в метод `addListener()` бина `EntityListenerManager`. Пример динамического добавления слушателя рассматривается в разделе рецептов разработки: <<app_start_recipe,Выполнение кода на старте приложения>>.

Для всех экземпляров некоторого класса сущности создается _один_ экземпляр слушателя определенного типа, поэтому слушатель _не должен иметь состояния_.

Если для сущности объявлены несколько слушателей одного типа (например, аннотациями класса сущности и его предков, плюс динамически), то их вызов будет выполняться в следующем порядке:

. Для каждого предка, начиная с самого дальнего, вызываются его динамически добавленные слушатели, затем статически назначенные.

. После всех предков вызываются динамически добавленные слушатели данного класса, затем статически назначенные.

[TIP]
====
Если требуются некоторые вычисления и изменение атрибутов сразу _нескольких_ экземпляров сущностей при коммите транзакции, рассмотрите также возможность использования <<transaction_listeners,transaction listener>>.
====

[[transactions]]
==== Управление транзакциями

В данном разделе рассмотрены различные аспекты управления транзакциями в CUBA-приложениях.

[[transactions_prog]]
===== Программное управление транзакциями

Программное управление транзакциями осуществляется с помощью интерфейса `com.haulmont.cuba.core.Transaction`, ссылку на который можно получить методами `createTransaction()` или `getTransaction()` интерфейса инфраструктуры <<persistence,Persistence>>.

Метод `createTransaction()` создает новую транзакцию и возвращает интерфейс `Transaction`. Последующие вызовы методов `commit()`, `commitRetaining()`, `end()` этого интерфейса управляют созданной транзакцией. Если в момент создания существовала другая транзакция, то она будет приостановлена, и возобновлена после завершения созданной. 

Метод `getTransaction()` вызывает либо создание новой, либо присоединение к текущей транзакции. Если в момент вызова существовала активная транзакция, то метод успешно завершается, и последующие вызовы `commit()`, `commitRetaining()`, `end()` не оказывают никакого влияния на существующую транзакцию. Однако если `end()` вызван без предварительного вызова `commit()`, то текущая транзакция помечается как `RollbackOnly`.

Примеры программного управления транзакцией:

[source, java]
----
include::{sourcesdir}/middleware/transactions_1.java[]
----

Интерфейс Transaction имеет также метод `execute()`, принимающий на вход класс-действие или lambda-выражение, которое нужно выполнить в данной транзакции. Это позволяет организовать управление транзакциями в функциональном стиле, например:

[source, java]
----
include::{sourcesdir}/middleware/transactions_2.java[]
----

Следует иметь в виду, что метод `execute()` у некоторого экземпляра `Transaction` можно вызвать только один раз, так как после выполнения кода действия транзакция завершается.

[[transactions_decl]]
===== Декларативное управление транзакциями

Любой метод <<managed_beans,управляемого бина>> Middleware можно пометить аннотацией `@org.springframework.transaction.annotation.Transactional`, что вызовет автоматическое создание транзакции при вызове этого метода. В таком методе не нужно вызывать `Persistence.createTransaction()`, а можно сразу получать `EntityManager` и работать с ним.

Для аннотации `@Transactional` можно указать параметры, в том числе:

* `propagation` - режим создания транзакции. Значение `REQUIRED` соответствует `getTransaction()`, значение `++REQUIRES_NEW++` - `createTransaction()`. По умолчанию `REQUIRED`.
+
[source, java]
----
@Transactional(propagation = Propagation.REQUIRES_NEW)
public void doSomething() {
}
----

* `value` - имя <<data_store,хранилища данных>>. Если опущено, подразумевается основная БД. Например:
+
[source, java]
----
@Transactional("db1")
public void doSomething() {
}
----


Декларативное управление транзакциями позволяет уменьшить количество link:$$http://en.wikipedia.org/wiki/Boilerplate_code$$[boilerplate кода], однако имеет следующий недостаток: коммит транзакции происходит вне прикладного кода, что часто затрудняет отладку, т.к. скрывается момент отправки изменений в БД и перехода сущностей в состояние <<entity_states,Detached>>. Кроме того, следует иметь в виду, что декларативная разметка сработает только в случае вызова метода контейнером, т.е. вызов транзакционного метода из другого метода того же самого объекта не приведет к старту транзакции.

В связи с этим рекомендуется применять декларативное управление транзакциями только для простых случаев, таких как методы сервисов, читающих некоторый объект и возвращающих его клиенту.

[[transactions_interaction]]
===== Примеры взаимодействия транзакций

[[transactions_interaction_rollback_nested]]
====== Откат вложенной транзакции

Если вложенная транзакция создана через `getTransaction()`, то ее откат приведет к невозможности коммита охватывающей транзакции. Например:

[source, java]
----
include::{sourcesdir}/middleware/transactions_3.java[]
----

Если же транзакция в `methodB()` будет создана через `createTransaction()`, то ее откат не окажет никакого влияния на коммит охватывающей транзакции в `methodA()`. 

[[transactions_interaction_modify_nested]]
====== Чтение и изменение данных во вложенной транзакции

Рассмотрим сначала зависимую вложенную транзакцию, создаваемую через `getTransaction()`:

[source, java]
----
include::{sourcesdir}/middleware/transactions_4.java[]
----

Теперь рассмотрим тот же самый пример с независимой вложенной транзакцией, создаваемой через `createTransaction()`: 

[source, java]
----
include::{sourcesdir}/middleware/transactions_5.java[]
----

В последнем случае исключение в точке (8) возникнет, только если сущность является оптимистично блокируемой, т.е. если она реализует интерфейс `Versioned`.

[[transaction_params]]
===== Параметры транзакций

[[transaction_timeout]]
Таймаут транзакции::
+
--
Для создаваемой транзакции может быть указан таймаут в секундах, при превышении которого транзакция будет прервана и откачена. Таймаут транзакции ограничивает максимальную длительность запросов к базе данных.

При программном управлении транзакциями таймаут включается путем передачи объекта `TransactionParams` в метод `Persistence.createTransaction()`. Например:

[source, java]
----
include::{sourcesdir}/middleware/transactions_6.java[]
----

При декларативном управлении транзакциями используется параметр `timeout` аннотации `@Transactional`, например:

[source, java]
----
include::{sourcesdir}/middleware/transactions_7.java[]
----

Таймаут по умолчанию может быть задан в свойстве приложения <<cuba.defaultQueryTimeoutSec,cuba.defaultQueryTimeoutSec>>.
--

[[transaction_read_only]]
Read-only транзации::
+
--
Транзакцию можно пометить как read-only если она предназначена только для чтения данных из БД. Например, все методы `load` в <<dataManager,DataManager>> используют read-only транзакции по умолчанию. Read-only транзакции улучшают производительность системы, потому что платформа не выполняет код, обрабатывающий возможные изменения в сущностях. Кроме того, не вызываются `BeforeCommit` <<transaction_listeners,transaction listeners>>.

[WARNING]
====
Если персистентный контекст read-only транзакции содержит измененные сущности, то при попытке коммита транзакции будет выброшено исключение `IllegalStateException`. Это означает, что помечать транзакцию как read-only следует только если вы уверены, что она не модифицирует никакие сущности.
====

При программном управлении транзакциями признак read-only включается путем передачи объекта `TransactionParams` в метод `Persistence.createTransaction()`. Например:

[source, java]
----
include::{sourcesdir}/middleware/transactions_8.java[]
----

При декларативном управлении транзакциями используется параметр `readOnly` аннотации `@Transactional`, например:

[source, java]
----
include::{sourcesdir}/middleware/transactions_9.java[]
----
--

[[transaction_listeners]]
===== Transaction Listeners

Transaction listeners предназначены для реакции на события жизненного цикла транзакций. В отличие от <<entity_listeners,entity listeners>>, они не привязаны к типу сущности и вызываются для каждой транзакции.

Слушатель должен быть <<managed_beans,управляемым бином>>, реализующим один или оба интерфейса `BeforeCommitTransactionListener` и `AfterCompleteTransactionListener`.

BeforeCommitTransactionListener::
+
--
Метод `beforeCommit()` вызывается перед коммитом транзакции после всех <<entity_listeners,entity listeners>> если транзакция не является read-only. Метод принимает текущий <<entityManager,EntityManager>> и коллекцию сущностей текущего персистентного контекста.

Данный слушатель можно использовать для обеспечения сложных бизнес-правил, вовлекающих различные сущности. В примере ниже атрибут `amount` сущности `Order` должен рассчитываться на основе значения `discount`, находящегося в заказе, и атрибутов `price` и `quantity` экземпляров сущности `OrderLine`, составляющих заказ.

[source,java]
----
include::{sourcesdir}/middleware/tx_listener_1.java[]
----
--

AfterCompleteTransactionListener::
+
--
Метод `afterComplete()` вызывается после завершения транзакции. Метод принимает параметр, указывающий, была ли транзакция успешно закоммичена, и коллекцию detached сущностей, содержавшихся в персистентном контексте завершенной транзакции.

Пример использования:

[source,java]
----
include::{sourcesdir}/middleware/tx_listener_2.java[]
----
--

[[entity_cache]]
==== Кэши сущностей и запросов

Кэш сущностей (Entity Cache)::
+
--
Кэш сущностей предоставляется <<orm,ORM>> фреймворком EclipseLink. Он хранит в памяти недавно прочитанные или записанные экземпляры сущностей, тем самым сокращая доступ к базе данных и увеличивая производительность.

Кэш сущностей используется только при извлечении сущностей по идентификатору, поэтому запросы по другим атрибутам по прежнему выполняются на базе данных. Тем не менее, эти запросы могут стать проще и быстрее, если связанные сущности находятся в кэше. Например, если вы запрашиваете Заказы вместе со связанными Заказчиками, и не используете кэш, то SQL-запрос будет содержать JOIN с таблицей заказчиков. Если же сущность Заказчик закэширована, SQL-запрос будет только по таблице заказов, а связанные заказчики будут извлечены из кэша.

Для того, чтобы включить кэш сущностей, установите следующие свойства приложения в файле <<app_properties_files,app.properties>> модуля *core* вашего проекта:

* `eclipselink.cache.shared.sales$Customer = true` - включает кэширование сущности `sales$Customer`.

* `eclipselink.cache.size.sales$Customer = 500` - устанавливает размер кэша для сущности `sales$Customer` в 500 экземпляров. Размер по умолчанию - 100.

Факт кэширования сущности влияет на то, какой <<views,fetch mode>> выбирается платформой при загрузке графов сущностей. Если некоторый ссылочный атрибут представляет собой кэшируемую сущность, то fetch mode всегда будет `UNDEFINED`, что позволяет ORM извлекать ссылку из кэша вместо добавления в запрос JOIN или выполнения отдельного batch-запроса.

Платформа обеспечивает координацию кэша сущностей в <<cluster_mw_server,кластере middleware>>. Когда кэшированный экземпляр сущности обновляется или удаляется на одном узле кластера, тот же экземпляр на других узлах (если он загружен) будет инвалидирован, что приведет к загрузке свежего состояния из БД при следующей операции с данным экземпляром.

--

Кэш запросов (Query Cache)::
+
--
Кэш запросов сохраняет идентификаторы экземпляров сущностей, возвращаемых JPQL-запросами, тем самым естественно дополняя кэш сущностей.

Например, если для сущности `sales$Customer` разрешен entity cache, и запрос `select c from sales$Customer c where c.grade = :grade` выполняется первый раз, происходит следующее:

* ORM выполняет запрос в базе данных.

* Загруженные экземпляры сущности `Customer` помещаются в entity cache.

* В кэш запросов помещается соответствие между текстом запроса вместе с параметрами и списком идентификаторов загруженных экземпляров.

Когда этот же запрос с такими же параметрами выполняется второй раз, платформа находит запрос в кэше запросов и загружает экземпляры сущностей по идентификаторам из кэша сущностей, не обращаясь к базе данных.

Запросы по умолчанию не кэшируются. Указать, что запрос должен кэшироваться, можно на различных уровнях приложения:

* Методом `setCacheable()` интерфейса <<query,Query>> при работе с <<entityManager,EntityManager>>.

* Методом `setCacheable()` интерфейса `LoadContext.Query` при работе с <<dataManager,DataManager>>.

* Методом `setCacheable()` интерфейса `CollectionDatasource` или в XML-атрибуте `cacheable` при работе с <<datasources,источниками данных>>.

[WARNING]
====
Кэшируемые запросы следует использовать только если для возвращаемой сущности разрешен entity cache. В противном случае при каждом запросе экземпляры сущности будут загружаться из базы данных по идентификаторам по одному.
====

Кэш запросов автоматически инвалидируется, когда через <<orm,ORM>> выполняются операции создания, изменения или удаления с сущностями соответствующего типа. Инвалидация работает по всему <<cluster_mw,кластеру среднего слоя>>.

JMX-бин `app-core.cuba:type=QueryCacheSupport` можно использовать для мониторинга состояния кэша и для удаления запросов из кэша. Например, если вы изменили некоторый экземпляр сущности `sales$Customer` напрямую в БД, необходимо удалить все закэшированные запросы по этой сущности с помощью операции `evict()` с аргументом `sales$Customer`.

На поведение кэша запросов оказывают влияние следующие свойства приложения:

* <<cuba.queryCache.enabled,cuba.queryCache.enabled>>

* <<cuba.queryCache.maxSize,cuba.queryCache.maxSize>>
--

[[system_authentication]]
==== Системная аутентификация

При выполнении пользовательских запросов программному коду Middleware через интерфейс <<userSessionSource,UserSessionSource>> всегда доступна информация о текущем пользователе. Это возможно потому, что при получении запроса с клиентского уровня в потоке выполнения автоматически устанавливается соответствующий объект `<<securityContext,SecurityContext>>`.

Однако существуют ситуации, когда текущий поток выполнения не связан ни с каким пользователем системы: например, при вызове метода бина из <<scheduled_tasks_spring,планировщика>>, либо через JMX-интерфейс. Если при этом бин выполняет изменение сущностей в базе данных, то ему потребуется информация о том, кто выполняет изменения, то есть аутентификация.

Такого рода аутентификация называется системной, так как не требует участия пользователя - средний слой приложения просто создает (или использует имеющуюся) пользовательскую сессию, и устанавливает в потоке выполнения соответствующий объект `SecurityContext`.

Обеспечить системную аутентификацию некоторого участка кода можно следующими способами:

* явно используя бин `com.haulmont.cuba.security.app.Authentication`, например:
+
[source, java]
----
include::{sourcesdir}/middleware/auth_1.java[]
----

* добавив методу бина аннотацию `@Authenticated`, например:
+
[source, java]
----
include::{sourcesdir}/middleware/auth_2.java[]
----

Во втором случае также используется бин `Authentication`, но неявно, через интерцептор `AuthenticationInterceptor`, который перехватывает вызовы всех методов бинов с аннотацией `@Authenticated`.

В приведенных примерах пользовательская сессия будет создаваться от лица пользователя, логин которого указан в свойстве приложения <<cuba.jmxUserLogin,cuba.jmxUserLogin>>. Если требуется аутентификация от имени другого пользователя, нужно воспользоваться первым вариантом и передать в метод `begin()` логин нужного пользователя.

[WARNING]
====
Если в момент выполнения `Authentication.begin()` в текущем потоке выполнения присутствует активная пользовательская сессия, то она не заменяется - соответственно, код, требующий аутентификации, будет выполняться с имеющейся сессией, и последующий метод `end()` не будет очищать поток.

Например, вызов метода JMX-бина из встроенной в *Web Client* консоли JMX, если бин находится в той же JVM, что и блок WebClient, к которому в данный момент подключен пользователь, будет выполнен от имени текущего зарегистрированного в системе пользователя, независимо от наличия системной аутентификации.
====
