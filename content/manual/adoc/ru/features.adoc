[[features]]
=== Механизмы платформы

В данной главе рассматриваются различные опциональные возможности, предоставляемые платформой.

[[scheduled_tasks]]
==== Выполнение задач по расписанию

Платформа предлагает два способа запуска задач по расписанию:

* Использование стандартного механизма `TaskScheduler` фреймворка *Spring*

* Использование собственного механизма выполнения назначенных заданий

[[scheduled_tasks_spring]]
===== Spring TaskScheduler

Данный механизм подробно описан в разделе *Task Execution and Scheduling* руководства *Spring Framework*.

`TaskScheduler` можно использовать для запуска методов произвольных бинов Spring в любом <<app_tiers,блоке>> приложения - как на *Middleware*, так и на клиентском уровне.

Пример конфигурации в файле `<<spring.xml,spring.xml>>`:

[source, xml]
----
<beans xmlns="http://www.springframework.org/schema/beans"
     xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
     xmlns:context="http://www.springframework.org/schema/context"
     xmlns:task="http://www.springframework.org/schema/task"
     xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd
      http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd
      http://www.springframework.org/schema/task http://www.springframework.org/schema/task/spring-task-3.0.xsd ">

  ...

  <task:scheduled-tasks scheduler="scheduler">
      <task:scheduled ref="sales_Processor" method="someMethod" fixed-rate="60000"/>
      <task:scheduled ref="sales_Processor" method="someOtherMethod" cron="0 0 1 * * MON-FRI"/>
  </task:scheduled-tasks>
</beans>
----

Здесь объявлены две задачи, запускающие на выполнение методы `someMethod()` и `someOtherMethod()` бина `++sales_Processor++`. При этом `someMethod()` запускается с момента старта приложения через фиксированные промежутки времени - 60 сек. Метод `someOtherMethod()` запускается в соответствии с расписанием, заданным выражением Cron (описание формата таких выражений см. link:$$http://quartz-scheduler.org/documentation/quartz-1.x/tutorials/crontrigger$$[http://quartz-scheduler.org/documentation/quartz-1.x/tutorials/crontrigger]).

Собственно запуск задач выполняет бин типа `TaskScheduler`, заданный в атрибуте `scheduler` элемента `scheduled-tasks`. В данном случае используется бин `CubaThreadPoolTaskScheduler` с именем `scheduler`, который сконфигурирован в модулях *core* и *web* базового проекта *cuba* (см. `cuba-spring.xml`, `cuba-web-spring.xml`). Этот класс содержит специфическую реализацию, выполняющую очистку `<<securityContext,SecurityContext>>` в запускаемых на выполнение потоках.

[[scheduled_tasks_cuba]]
===== Назначенные задания CUBA

Механизм назначенных заданий *CUBA* предназначен для запуска по расписанию методов произвольных бинов Spring в блоке *Middleware*. Целью данного механизма и отличием его от вышеупомянутого стандартного механизма *Spring Framework* являются:

* возможность конфигурирования заданий во время работы приложения без остановки сервера

* координация выполнения синглтон-заданий в кластере *Middleware*, в том числе: 

** надежная защита от одновременного выполнения 

** привязка заданий к серверам по приоритетам

Под _синглтон_-заданием понимается задача, которая должна выполняться в некоторый момент времени только на одном сервере. Пример - чтение из очереди и отсылка email.

====== Регистрация задания

Задания регистрируются в таблице `++SYS_SCHEDULED_TASK++` базы данных, соответствующей сущности `ScheduledTask`. Для работы с заданиями существуют экраны просмотра и редактирования, доступные через меню *Администрирование* → *Назначенные задания*.

Рассмотрим атрибуты задания:

* *Defined by* - каким программным объектом реализуется задание. Возможные значения:

** *Bean* - задание реализуется методом бина Spring. Дополнительные атрибуты:

*** *Bean name* - имя бина. Бин отображается в списке и доступен для выбора, только если у него есть интерфейс, содержащий подходящие для вызова из задания методы. Бины без интерфейса не поддерживаются.

*** *Method name* - метод интерфейса бина для выполнения. Метод должен либо не иметь параметров, либо иметь все параметры типа `String`.

*** *Method parameters* - параметры выбранного метода. Поддерживаются только параметры типа `String`.

** *Class* - задание представляет собой класс, реализующий интерфейс `java.util.concurrent.Callable`. Класс должен иметь открытый конструктор без параметров. Дополнительные атрибуты:

*** *Class name* - имя класса

** *Script* - задание представляет собой скрипт Groovy. Скрипт выполняется через `Scripting.<<scripting.runGroovyScript,runGroovyScript>>()`. Дополнительные атрибуты:

*** *Script name* - имя скрипта.

* *User name* - имя пользователя, от имени которого будет будет выполняться задание. Если не задано, то задание будет выполнено от имени пользователя, указанного в свойстве приложения `<<cuba.jmxUserLogin,cuba.jmxUserLogin>>`.

* *Singleton* - признак, является ли задание синглтоном, т.е. выполняющимся только на одном сервере системы.

* *Scheduling type* - способ планирования задачи:

** *Cron* - с помощью Cron-выражения, представляющего собой последовательность из шести полей, разделенных пробелами: секунда, минута, час, день, месяц, день недели. Месяц и день недели могут быть представлены первыми тремя буквами английского названия. Примеры выражений:

*** 0 0 * * * * - начало каждого часа каждого дня.

*** */10 * * * * * - каждые 10 секунд.

*** 0 0 8-10 * * * - в 8, 9 и 10 часов каждого дня.

*** 0 0/30 8-10 * * * - 8:00, 8:30, 9:00, 9:30 и 10 часов каждого дня.

*** 0 0 9-17 * * MON-FRI - каждый час с 9 до 17 по рабочим дням.

*** 0 0 0 7 1 ? - каждое Рождество в полночь.

** *Period* - с помощью интервала между выполнениями.

* *Period* - период запуска задания в секундах для `Scheduling type = Period`.

* *Timeout* - время в секундах, по истечении которого считается, что задание закончило выполнение, независимо от того, есть ли информация о завершении задания, или нет. Если timeout не задан явно, он принимается равным 3 часам. 

* *Start date* - дата/время первого запуска для `Scheduling type = Period`. Если не установлено, то задание запускается сразу при старте сервера. Если установлено, то задание запускается в момент `++startDate + period * N++`, где N - целое число.
+
`Start date` имеет смысл указывать только для "нечастых" заданий - раз в 1 час, 1 сутки и т.п.

* *Time frame* - в случае заданного `Start date` или `Cron expression` определяет временное окно в секундах, в течение которого будет запущено задание, если время `++startDate + period * N++` прошло. Если Time frame не задано явно, оно принимается равным `period / 2`.
+
Если `Start date` не указано, то `Time frame` не принимается во внимание, т.е. задание будет запущено в любое время после прохождения промежутка времени  `Period` после предыдущего выполнения задания.

* *Permitted servers* - список перечисленных через запятую <<serverId,идентификаторов серверов>>, на которых возможен запуск данного задания. Если список не задан, то задание может выполняться на любом сервере.
+
Для синглтон-заданий порядок перечисления серверов указывает их приоритет - первый имеет больший приоритет чем последний. Сервер с большим приоритетом перехватит выполнение синглтона следующим образом: если сервер с большим приоритетом обнаруживает, что предыдущий раз задание было выполнено сервером с меньшим приоритетом, то он запускает задание независимо от того, пройден ли `Period` или нет.
[WARNING]
====
Приоритет серверов работает только в случае `Scheduling type = Period` и не указанного атрибута `Start date`. Если `Start date` указан, старт происходит в одно и то же время, и перехват невозможен.
====

* *Log start* - признак регистрации факта запуска задания в таблице `++SYS_SCHEDULED_EXECUTION++`, соответствующей сущности `ScheduledExecution`.
+
Если задание является синглтоном, то в текущей реализации регистрация факта запуска производится в любом случае, независимо от данного признака. 

* *Log finish* - признак регистрации факта завершения задания в таблице `++SYS_SCHEDULED_EXECUTION++`, соответствующей сущности `ScheduledExecution`. 
+
Если задание является синглтоном, то в текущей реализации регистрация факта завершения производится в любом случае, независимо от данного признака. 

* *Description* - произвольное текстовое описание задания.

Задание также имеет признак активности, который устанавливается в экране списка заданий. Неактивные задания не запускаются. 

====== Управление обработкой заданий

* Для запуска обработки назначенных заданий необходимо перед стартом сервера установить свойство приложения `<<cuba.schedulingActive,cuba.schedulingActive>>` в значение `true`.

* Для оперативного управления обработкой заданий можно использовать JMX-бин `app-core.cuba:type=Scheduling`, атрибут `Active` которого запускает/останавливает обработку заданий для текущего сеанса работы сервера. После перезапуска сервера обработка будет запущена только при установленном в `true` свойстве приложения `cuba.schedulingActive`.

* Все изменения в заданиях, сделанные через экраны системы, вступают в силу немедленно для всех серверов кластера. 

* Для удаления старой истории выполнения заданий можно использовать метод `removeExecutionHistory()` JMX-бина `app-core.cuba:type=Scheduling`. У него имееется два параметра:

** `age` - время в часах, прошедшее после выполнения задания.

** `maxPeriod` - максимальный период заданий в часах, выполнения которых надо удалять. Это позволяет удалять только историю "частых" задач, а историю выполняемых, например, раз в сутки и реже, хранить без ограничений.
+
Данный метод можно вызывать автоматически, для этого достаточно создать новое задание и установить для него следующие параметры:

** *Bean name* - cuba_SchedulingMBean

** *Method name* - removeExecutionHistory(`String age`, `String maxPeriod`)

** *Method parameters* - например, `age` = 72, `maxPeriod` = 12.

====== Особенности реализации

* Период вызова обработки заданий (метода `SchedulingAPI.processScheduledTasks()`) задается в `cuba-spring.xml` и по умолчанию равен 1 сек. Он задает минимальное значение периода запуска задания, которое должно быть в два раза больше, т.е. 2 сек. Уменьшать эти времена не рекомендуется.

* Текущая реализация планировщика основана на синхронизации с помощью блокировки строк в таблице базы данных. Это означает, что при значительной нагрузке БД может не успевать вовремя отвечать планировщику, и необходимо увеличивать период запуска (>1сек), и, соответственно, минимальный период запуска заданий также будет увеличиваться.

* Синглтон-задания в случае незаданного атрибута Permitted servers выполняются только на мастер-узле кластера (при выполнении прочих условий). Следует иметь в виду, что отдельный сервер вне кластера также является мастером. 

* Задание не запускается, если оно в данный момент не закончило предыдущее выполнение, и не истек указанный Timeout. Для синглтон-заданий в текущей реализации это обеспечивается информацией в базе данных, для не-синглтонов поддерживается таблица статуса выполнения в памяти сервера. 

* Механизм выполнения создает и кэширует <<userSession,пользовательские сессии>> в соответствии с указанными для заданий User name, либо свойством приложения `<<cuba.jmxUserLogin,cuba.jmxUserLogin>>`. Сессия доступна в потоке выполнения запускаемого задания обычным способом - через интерфейс `<<userSessionSource,UserSessionSource>>`.

[WARNING]
====
Для нормальной работы синглтон-заданий необходима точная синхронизация серверов *Middleware* по времени!
====

[[email_sending]]
==== Отправка email

Платформа предоставляет средства отправки сообщений электронной почты со следующими возможностями:

* Синхронная или асинхронная отправка. В случае синхронной отправки вызывающий код ожидает, пока сообщение не будет передано на SMTP сервер. При асинхронной отправке сообщение сохраняется в базе данных, и управление немедленно возвращается вызывающему коду. Отправка производится позже путем вызова из <<scheduled_tasks,назначенного задания>>. 

* Надежная фиксация факта отправки и ошибок в базе данных, как для синхронной, так и для асинхронной отправки.

* Пользовательский интерфейс для поиска и просмотра информации о посылаемых сообщениях, включая все атрибуты и содержимое сообщений, а также статус отправки и количество предпринятых попыток.

Пример использования данного механизма рассмотрен в рецепте <<sending_emails_recipe,Отправка email>>.


[[email_sending_methods]]
===== Методы отправки

Для отправки email на *Middleware* следует использовать бин `EmailerAPI`, на клиентском уровне - сервис `EmailService`.

Рассмотрим основные методы этих компонентов:

* `sendEmail()` - синхронная отправка сообщения. Вызывающий код блокируется на время отправки сообщения SMTP серверу.
+
Сообщение может быть передано как в виде набора параметров (список адресатов через запятую, тема, содержимое, массив вложений), так и в виде специального объекта `EmailInfo`, инкапсулирующего всю эту информацию, плюс позволяющего явно задать адрес отправителя и сформировать тело письма по шаблону *FreeMarker*.
+
При синхронной отправке может быть сгенерировано исключение `EmailException`, несущее в себе информацию о том, по каким адресам отправка не удалась, и соответствующие им сообщения об ошибках.
+
В процессе работы метода для каждого адресата в базе данных создается экземпляр сущности `SendingMessage`, который сначала получает статус `SendingStatus.SENDING`, а после успешной отправки - `SendingStatus.SENT`. В случае ошибки отправки статус сообщения меняется на `SendingStatus.NOTSENT`.

* `sendEmailAsync()` - асинхронная отправка сообщения. Данный метод возвращает список (по числу получателей) экземпляров `SendingMessage` со статусом `SendingStatus.QUEUE`, созданных в базе данных. Собственно отправка производится при последующем вызове метода `EmailerAPI.processQueuedEmails()`, который необходимо зарегистрировать в механизме <<scheduled_tasks,назначенных заданий>> с желаемой периодичностью.

[[email_attachments]]
===== Вложения

Объект `EmailAttachment` - обёртка, хранящая вложение в виде массива байт (поле `data`), имя файла (поле `name`), и при необходимости, уникальный для данного сообщения идентификатор вложения (необязательное, но полезное поле `contentId`). 

Идентификатор вложения может быть использован для вставки в сообщение изображений следующим образом:при создании `EmailAttachment` задаётся уникальный `contentId`, например, `myPic`. В теле письма для вставки вложения необходимо в качестве пути использовать запись вида: `cid:myPic`. Т.е. для вставки изображения нужно указать следующий элемент HTML:

[source, xml]
----
<img src="cid:myPic"/>
----

[[email_sending_properties]]
===== Настройка параметров отправки email

Параметры отправки email могут быть настроены с помощью перечисленных ниже <<app_properties,свойств приложения>>. Все они являются параметрами времени выполнения и хранятся в базе данных, однако могут быть переопределены для конкретного блока *Middleware* в его файле `app.properties`.

Все параметры отправки email доступны через конфигурационный интерфейс `EmailerConfig`.

* `cuba.email.fromAddress` - адрес отправителя по умолчанию. Принимается во внимание, если не указан атрибут `EmailInfo.from`.
+
Значение по умолчанию: `DoNotReply@localhost`

* `cuba.email.smtpHost` - адрес SMTP сервера.
+
Значение по умолчанию: `test.host`

* `cuba.email.smtpPort` - порт SMTP сервера.
+
Значение по умолчанию: `25`

* `cuba.email.smtpAuthRequired` - требуется ли аутентификация на SMTP сервере. Соответствует параметру `mail.smtp.auth`, передаваемому при создании объекта `javax.mail.Session`.
+
Значение по умолчанию: `false`

* `cuba.email.smtpStarttlsEnable` - задает использование команды `STARTTLS` при аутентификации на SMTP сервере. Соответствует параметру `mail.smtp.starttls.enable`, передаваемому при создании объекта `javax.mail.Session`.
+
Значение по умолчанию: `false`

* `cuba.email.smtpUser` - имя пользователя для аутентификации на SMTP сервере.

* `cuba.email.smtpPassword` - пароль пользователя для аутентификации на SMTP сервере.

* `cuba.email.delayCallCount` - используется при асинхронной отправке email из очереди для пропуска нескольких первых вызовов `EmailManager.queueEmailsToSend()` сразу после старта сервера, чтобы снизить нагрузку во время инициализации приложения. Отправка email начнется следующим вызовом.
+
Значение по умолчанию: `2`

* `cuba.email.messageQueueCapacity` - при асинхронной отправке количество сообщений, читаемое из очереди и отправляемое за один вызов `EmailManager.queueEmailsToSend()`.
+
Значение по умолчанию: `100`

* `cuba.email.defaultSendingAttemptsCount` - при асинхронной отправке email количество попыток отправки по умолчанию. Принимается во внимание, если при вызове `Emailer.sendEmailAsync()` не указан параметр `attemptsCount`.
+
Значение по умолчанию: `10`

* `cuba.email.maxSendingTimeSec` - максимальное предполагаемое время в секундах, требуемое для отправки сообщения на SMTP сервер. Используется при асинхронной отправке для оптимизации выборки объектов `SendingMessage` из очереди в БД.
+
Значение по умолчанию: 120

* `cuba.email.sendAllToAdmin` - указывает, что все сообщения должны отправляться на адрес `cuba.email.adminAddress`, независимо от указанного адреса получателя. Этот параметр рекомендуется использовать во время отладки системы.
+
Значение по умолчанию: `false`

* `cuba.email.adminAddress` - адрес, на который отправляются все сообщения при включенном свойстве `cuba.email.sendAllToAdmin`.
+
Значение по умолчанию: `admin@localhost`

* `cuba.emailerUserLogin` - логин пользователя системы, под которым регистрируется механизм асинхронной отправки email для того, чтобы иметь возможность сохранить информацию в базе данных. Рекомендуется создать отдельного пользователя (например `emailer`) без пароля, чтобы под его именем нельзя было войти через пользовательский интерфейс приложения. Это полезно для поиска в логе сервера сообщений, касаемых отсылки email.
+
Значение по умолчанию: `admin`

Просмотреть текущие значения параметров, а также отправить тестовое сообщение, можно с помощью JMX-бина `app-core.cuba:type=Emailer`.

[[dynamic_attributes]]
==== Динамические атрибуты

_Динамические атрибуты_ - это дополнительные поля сущности, которые можно добавлять без изменения схемы БД и перезагрузки приложения. Механизм динамических атрибутов предназначен для описания новых свойств сущностей на этапе настройки и эксплуатации системы.

Динамические атрибуты CUBA являются реализацией концепции link:$$http://en.wikipedia.org/wiki/Entity%E2%80%93attribute%E2%80%93value_model$$[Entity-Attribute-Value]. 

.Диаграмма классов механизма динамических атрибутов
image::dynamic_attributes.png[align="center"]

*  `Category` - определяет _категорию_ объектов, которая содержит описание структуры динамических атрибутов. Каждая категория относится к некоторому типу сущности.
+
Например, имеется сущность типа _Автомобиль_. Для нее можно определить две категории: _Грузовой_ и _Пассажирский_. При этом категория _Грузовой_ будет содержать атрибуты _Грузоподъемность_ и _Вид кузова_, а категория _Пассажирский_ - атрибуты _Количество мест_ и _Наличие детского сидения_. 

*  `CategoryAttribute` - определяет динамический атрибут, относящийся к некоторой категории. Каждый атрибут описывает одно поле определенного типа. У каждого атрибута имеется обязательное поле `Код` (`code`), которое используется в качестве его системного имени. `Имя` атрибута (`name`) используется для отображения пользователю. 

*  `CategoryAttributeValue` - значение динамического атрибута для конкретного экземпляра сущности. Физически значения динамических атрибутов хранятся в специальной таблице `++SYS_ATTR_VALUE++`. У каждой записи этой таблицы есть ссылка на определенную сущность (колонка `++ENTITY_ID++`). 

Экземпляр сущности может иметь атрибуты одновременно из всех категорий, связанных с этим типом сущности. Если необходимо, чтобы некоторый экземпляр сущности принадлежал только одной категории с соответствующим набором атрибутов (_Автомобиль_ может быть либо _Грузовым_, либо _Пассажирским_), класс сущности должен реализовывать интерфейс <<categorized_entity,Categorized>>. В этом случае экземпляр сущности будет содержать ссылку на категорию и динамические атрибуты только выбранной категории.

Загрузка и сохранение динамических атрибутов осуществляется в <<dataManager,DataManager>>. Для указания того, что динамические атрибуты должны быть загружены вместе с экземплярами сущностей, используется метод `LoadContext.setLoadDynamicAttributes()`. По умолчанию динамические атрибуты не загружаются. В то же время `DataManager` всегда сохраняет динамические атрибуты, содержащиеся в экземплярах сущностей, переданных в `commit()`.

Доступ к значениям динамических атрибутов может быть осуществлен через методы `getValue()` / `setValue()` любой персистентной сущности, унаследованной от `BaseGenericIdEntity`. В эти методы необходимо передавать код атрибута с префиксом `+++++`, например: 

[source, java]
----
include::{sourcesdir}/features/dynamicAttr_1.java[]
---- 

На самом деле, прямой доступ к значениям динамических атрибутов в коде приложения нужен крайне редко. Любой динамический атрибут может быть автоматически отображен в любом компоненте <<gui_Table,Table>> или <<gui_FieldGroup,FieldGroup>>, связанном с источником данных, содержащим сущность, для которой данный атрибут был создан. Экран редактирования атрибута позволяет указать, в каких экранах и компонентах отображать атрибут.

<<permissions,Разрешения>> пользователей на доступ к динамическим атрибутам назначаются в редакторе <<roles,ролей>> так же как и для обычных атрибутов. Динамические атрибуты отображаются с префиксом `+++++`.

[[dynamic_attributes_mgmt]]
===== Управление динамическими атрибутами

Управление категориями и описаниями атрибутов осуществляется с помощью специальных экранов, доступных через меню *Administration → Categories*.

.Экран списка категорий
image::categoryBrowser.png[align="center"]

Редактор категорий позволяет создать категорию для выбранного типа сущности и добавить в нее набор динамических атрибутов. Для категории обязательно указывается имя и соответствующий тип сущности. Флажок *Default* указывает, что данная категория будет автоматически выбрана для нового экземпляра сущности, реализующей интерфейс `Categorized`. 

.Экран редактирования категории
image::categoryEditor.png[align="center"]

Редактор динамического атрибута позволяет задать имя, системный код, тип значения и значение атрибута по умолчанию.

.Редактор динамического атрибута
image::runtimePropertyEditor.png[align="center"]

Динамический атрибут также имеет настройки видимости, описывающие, на каких экранах его нужно отображать. По умолчанию атрибут не отображается нигде. 

.Настройки видимости динамического атрибута
image::runtimePropertyVisibility.png[align="center"]

Кроме экрана можно также указать компонент, в котором атрибут должен появляться (например, для экранов, где несколько компонентов <<gui_FieldGroup,FieldGroup>> показывают поля одной и той же сущности). 

Если атрибут отмечен как видимый на каком-либо экране, он автоматически отобразится во всех группах полей и таблицах, отображающих объекты данного типа в данном экране. 

Доступ к динамическим атрибутам также может быть ограничен через настройки в <<roles,ролях пользователей>>. Настройки осуществляются так же, как для обычных атрибутов. 

Для того чтобы изменения в атрибутах и настройках видимости вступили в силу, необходимо нажать кнопку *Применить изменения* на экране со списком категорий. Изменения также можно применить через *Administration → JMX Console*, вызвав метод `clearDynamicAttributesCache()` JMX бина `app-core.cuba:type=CachingFacade`.

Ниже изображен динамический атрибут, добавленный в экран автоматически путем задания настроек отображения атрибута: 

image::runtimePropsApplyChanges.png[align="center"]

Динамические атрибуты можно добавить в экран вручную. Для этого необходимо выполнить следующее:

* В секции `dsContext` XML-дескриптора экрана для источника данных с загружаемой сущностью (сущностями) установить в `true` признак `loadDynamicAttributes` для источника данных с загружаемой сущностью (сущностями), например:
+
[source, xml]
----
<dsContext>
  <datasource id="carDs" class="com.company.sample.entity.Car" view="_local" loadDynamicAttributes="true"/>
</dsContext>
----

* В описании визуального компонента в качестве `property` нужно использовать код динамического атрибута с префиксом `+++++`:
+
[source, xml]
----
<textField id="numberOfSeats" datasource="carDs" property="+numberOfSeats"/>
----

[[categorized_entity]]
===== Категоризируемые сущности

Если сущность реализует интерфейс `com.haulmont.cuba.core.entity.Categorized`, то для работы с ее динамическими атрибутами можно использовать компонент `com.haulmont.cuba.gui.components.RuntimePropertiesFrame`. Этот компонент позволяет пользователю выбрать для экземпляра сущности некоторую категорию и указать значения динамических атрибутов этой категории.

Для использования `RuntimePropertiesFrame` в экране редактирования необходимо выполнить следующее: 

* В секции `dsContext` необходимо объявить два источника данных: 

**  `runtimePropsDatasource` - специфический источник, в который будут загружены экземпляры `CategoryAttributeValue`. Атрибут `mainDs` должен ссылаться на главный источник данных, содержащий редактируемую сущность. 

** обычный `collectionDatasource` для загрузки списка категорий данного типа сущности. 
+
Например: 
+
[source, xml]
----
<dsContext>
  <datasource id="carDs"
      class="com.company.sample.entity.Car"
      view="carEdit"/>

  <runtimePropsDatasource id="runtimePropsDs"
      mainDs="carDs"/>

  <collectionDatasource id="categories"
      class="com.haulmont.cuba.core.entity.Category"
      view="_local">
    <query>
         select c from sys$Category c where c.entityType='sample$Car'
    </query>
  </collectionDatasource>
</dsContext>
---- 

* После этого можно включить в XML-дескриптор экрана визуальный компонент `runtimeProperties`: 
+
[source, xml]
----
<runtimeProperties id="runtimePropsFrame"
  runtimeDs="runtimePropsDs"
  categoriesDs="categories"/>
----  

[[dynamic_attributes_in_rest_api]]
===== Динамические атрибуты в REST API

<<rest_api,REST API>> поддерживает загрузку и сохранение динамических атрибутов. Для этого достаточно добавить в URL запроса `find` or `query` параметр `dynamicAttributes=true`:

[source, plain]
----
app-portal/api/find.xml?e=sample$Car-9f789ba9-ca15-4758-a8b8-77e434f1d438&s=9f789ba9-ca15-4758-a8b8-77e434f1d438&dynamicAttributes=true
----

Динамические атрибуты в JSON и XML документах представляются так же как и обычные атрибуты, с той разницей, что имя динамического атрибута представляет собой его код с префиксом `+++++`.

REST API также сохраняет динамические атрибуты, переданные в `commit`.

[[pessimistic_locking]]
==== Пессимистичная блокировка

В данном разделе описано применение пессимистичной блокировки в CUBA-приложениях.

===== Блокировка редактирования сущностей

Пессимистичная блокировка сущностей применяется, если велика вероятность одновременного редактирования одного и того же экземпляра, и стандартная <<optimistic_locking,оптимистичная блокировка>>, основанная на версионности сущностей, порождает слишком много коллизий.

Пессимистичная блокировка использует явное блокирование экземпляра сущности при открытии его в <<screen_edit,экране редактирования>>. В результате только один пользователь в некоторый момент времени может редактировать данный экземпляр сущности.

Режим пессимистичной блокировки может быть задан для любого класса сущности в процессе настройки или эксплуатации системы. Для этого достаточно выполнить следующие действия:

* вставить в таблицу *SYS_LOCK_CONFIG* запись со следующими значениями полей:

** *ID* - произвольный идентификатор типа UUID.

** *NAME* - наименование блокируемого объекта. Для сущности это должно быть имя ее <<metaClass,мета-класса>>. 

** *TIMEOUT_SEC* - таймаут истечения блокировки в секундах.
+
Например: 
+
[source, sql]
----
insert into sys_lock_config (id, create_ts, name, timeout_sec) values (newid(), current_timestamp, 'sales$Order', 300)
----

* перезапустить сервер или выполнить метод `reloadConfiguration()` JMX-бина `app-core.cuba:type=LockManager`.

===== Блокировка произвольных процессов

Механизм пессимистичной блокировки можно использовать также для управления совместным выполнением произвольных процессов. Причем блокировки являются распределенными, т.к. информация о них реплицируется в кластере *Middleware*. 

Подробнее см. JavaDoc интерфейсов `LockManagerAPI` и `LockService`.

===== Мониторинг блокировок

Текущее состояние блокировок можно отслеживать через JMX-бин `app-core.cuba:type=LockManager`, или через специальный экран, доступный в меню *Администрирование* → *Блокировки*. Экран также позволяет разблокировать любой объект принудительно.

[[entity_statistics]]
==== Статистика сущностей

Механизм статистики сущностей предоставляет данные о текущем количестве экземпляров сущностей в базе данных. Эти данные используются для автоматического принятия решений о выборе способа поиска связанных сущностей и ограничении размера выборок в экранах пользовательского интерфейса.

Статистика хранится в таблице *SYS_ENTITY_STATISTICS*, соответствующей сущности `EntityStatistics`. Заполнить статистику можно как вручную, внося соответствующие записи в таблицу, так и автоматически с помощью метода `refreshStatistics()` JMX-бина `<<persistenceManagerMBean,PersistenceManagerMBean>>`. При указании в качестве параметра имени сущности статистика будет собрана только для данной сущности, в противном случае - для всех. Сбор статистики может занять значительное время и вызвать нежелательную нагрузку на БД, поэтому выполнять его нужно либо вручную, либо <<scheduled_tasks_cuba,назначенным заданием>> в подходящее время.

Программный доступ к статистике осуществляется с помощью интерфейса `PersistenceManagerAPI` на *Middleware* и `PersistenceManagerService` на клиентском уровне. Статистика кэшируется в памяти, поэтому если изменения статистики вносятся напрямую в базу данных, для вступления их в силу необходимо перезапустить сервер или вызвать метод `PersistenceManagerMBean.flushStatisticsCache()`.

Рассмотрим атрибуты `EntityStatistics` и их влияние на поведение системы.

* `name` (колонка *NAME*) - тип сущности в виде имени <<metaClass,мета-класса>>, например, `sales$Customer`.

* `instanceCount` (колонка *INSTANCE_COUNT*) - примерное текущее количество экземпляров сущности. 

* `fetchUI` (колонка *FETCH_UI*) - размер страницы данных, предлагаемый пользователю при извлечении списков сущностей. 
+
Например, компонент <<gui_Filter,Filter>> устанавливает это число в поле *Показывать N строк*.

* `maxFetchUI` (колонка *MAX_FETCH_UI*) - максимальное количество экземпляров сущности, которое может быть извлечено и передано на клиентский уровень. 
+
Данный параметр играет роль при отображении списков сущностей в компонентах типа `<<gui_LookupField,LookupField>>` и `<<gui_LookupPickerField,LookupPickerField>>`, а также в таблицах без универсального <<gui_Filter,фильтра>>, то есть когда на связанный <<datasources,источник данных>> не налагается ограничений методом `CollectionDatasource.setMaxResults()`. В этом случае сам источник данных ограничивает количество извлекаемых экземпляров значением `maxFetchUI`.

* `lookupScreenThreshold` (колонка *LOOKUP_SCREEN_THRESHOLD*) - порог количества экземпляров сущности, при превышении которого в универсальных механизмах пользовательского интерфейса для поиска связанных сущностей будут использоваться <<screen_lookup,экраны выбора>> вместо выпадающих списков. 
+
В частности, этот параметр принимается во внимание компонентом `<<gui_Filter,Filter>>` при выборе параметров фильтрации: до достижения порога используется компонент `<<gui_LookupField,LookupField>>`, при превышении порога - компонент `<<gui_PickerField,PickerField>>`. Поэтому, если необходимо заставить фильтр отображать выбор параметра некоторого типа через экран выбора, достаточно внести запись статистики для этой сущности со значением `lookupScreenThreshold` меньшим, чем `instanceCount`.

JMX-бин `PersistenceManagerMBean` в атрибутах `DefaultFetchUI`, `DefaultMaxFetchUI`, `DefaultLookupScreenThreshold` позволяет задать значения вышеперечисленных параметров по умолчанию. В результате, если для некоторой сущности статистика отсутствует (что является обычной ситуацией), будет использоваться соответствующий параметр по умолчанию. 

Кроме того, JMX-бин `PersistenceManagerMBean` позволяет ввести данные статистики для конкретной сущности с помощью операции `enterStatistics()`. Например, для того, чтобы для сущности `sales$Customer` установить размер страницы данных по умолчанию в 1000, а максимальное количество извлекаемых экземпляров в компонентах <<gui_LookupField,LookupField>> в 30000, следует вызвать операцию `enterStatistics()` со следующими параметрами:

[source, plain]
----
entityName: sales$Customer
fetchUI: 1000
maxFetchUI: 30000
----

[[entity_log]]
==== Журнал изменений сущностей

Механизм журналирования предназначен для отслеживания изменений атрибутов произвольных сущностей в процессе работы приложения. Измененные значения сохраняются в специальной таблице базы данных, список изменений для конкретного экземпляра сущности может быть отображен в пользовательском интерфейсе.

Данный механизм перехватывает сохранение сущностей в БД на уровне <<entity_listeners,Entity Listeners>>, т.е. гарантированно отслеживаются все изменения, проходящие через персистентный контекст `<<entityManager,EntityManager>>`. Непосредственное изменение сущностей в базе данных с помощью SQL, в том числе изнутри системы через <<nativeQuery,NativeQuery>> и `<<queryRunner,QueryRunner>>`, в журнал не попадает.

Измененные экземпляры сущностей перед сохранением в БД отправляются в методы `registerCreate()`, `registerModify()`, `registerDelete()` бина `EntityLogAPI`. Параметр `auto` этих методов позволяет отделить автоматическое журналирование посредством Entity Listeners от ручного вызова этих же методов в прикладном коде. При вызове из Entity Listeners в параметре `auto` передается `true`. 

Журнал содержит информация о том, кто и когда изменил данный экземпляр, а также новые значения измененных атрибутов. Записи журнала сохраняются в таблице *SEC_ENTITY_LOG* базы данных, соответствующей сущности `EntityLogItem`. Измененные значения атрибутов хранятся в этой же таблице в колонке *CHANGES*, а при чтении на *Middleware* преобразуются в экземпляры сущности `EntityLogAttr`. 

===== Настройка журналирования

Аудит настраивается при помощи сущностей `LoggedEntity` и `LoggedAttribute` (соответствующих таблицам *SEC_LOGGED_ENTITY* и *SEC_LOGGED_ATTR*).

`LoggedEntity` описывает тип сущности, изменения которой необходимо журналировать. Атрибуты `LoggedEntity`:

* `name` (колонка *NAME*) - тип сущности в виде имени <<metaClass,мета-класса>>, например, `sales$Customer`.

* `auto` (колонка *AUTO*) - нужно ли журналировать изменения при вызове `EntityLogAPI` с параметром `auto = true` (т.е. из <<entity_listeners,Entity Listeners>>).

* `manual` (колонка *MANUAL*) - нужно ли журналировать изменения при вызове `EntityLogAPI` с параметром `auto = false`.

`LoggedAttribute` описывает журналируемый атрибут сущности и содержит ссылку на `LoggedEntity` и имя атрибута.

Для настройки журналирования некоторой сущности достаточно внести соответствующие записи в таблицы *SEC_LOGGED_ENTITY* и *SEC_LOGGED_ATTR*. Например, для ведения журнала изменений атрибутов `name` и `grade` сущности `Customer`, необходимо выполнить:

[source, sql]
----
insert into SEC_LOGGED_ENTITY (ID, CREATE_TS, CREATED_BY, NAME, AUTO, MANUAL)
values ('25eeb644-e609-11e1-9ada-3860770d7eaf', now(), 'admin', 'sales$Customer', true, true);

insert into SEC_LOGGED_ATTR (ID, CREATE_TS, CREATED_BY, ENTITY_ID, NAME)
values (newid(), now(), 'admin', '25eeb644-e609-11e1-9ada-3860770d7eaf', 'name');

insert into SEC_LOGGED_ATTR (ID, CREATE_TS, CREATED_BY, ENTITY_ID, NAME)
values (newid(), now(), 'admin', '25eeb644-e609-11e1-9ada-3860770d7eaf', 'grade');
----

Для активации механизма журналирования необходимо установить в `true` атрибут `Enabled` JMX-бина `app-core.cuba:type=EntityLog`. Для вступления в силу изменений настройки журналирования, произведенных во время работы приложения, необходимо перезапустить сервер или вызвать метод `invalidateCache()` этого же бина.

===== Отображение журнала

Для просмотра журнала изменений некоторого экземпляра сущности достаточно обычным способом загрузить в источники данных экрана коллекцию экземпляров `EntityLogItem` и ассоциированных с ними `EntityLogAttr`, и создать визуальные компоненты, связанные с этими источниками. Например:

[source, xml]
----
<dsContext>
  <datasource id="customerDs"
              class="com.sample.sales.entity.Customer"
              view="customerEdit"/>

  <collectionDatasource id="logDs"
                        class="com.haulmont.cuba.security.entity.EntityLogItem"
                        view="logView">
      <query>
          select i from sec$EntityLog i
          where i.entityId = :ds$customerDs order by i.eventTs
      </query>

      <collectionDatasource id="logAttrDs"
                            property="attributes"/>
  </collectionDatasource>
</dsContext>
<layout>
...
  <split orientation="vertical" width="100%" height="100%">

      <table id="logTable" width="100%" height="100%">
          <columns>
              <column id="eventTs"/>
              <column id="user.login"/>
              <column id="type"/>
          </columns>
          <rows datasource="logDs"/>
      </table>

      <table id="logAttrTable" width="100%" height="100%">
          <columns>
              <column id="name"/>
              <column id="value"/>
          </columns>
          <rows datasource="logAttrDs"/>
      </table>

  </split>
...
</layout>
----

Для отображения локализованных значений журналируемых атрибутов эти атрибуты должны содержать аннотацию <<localizedValue_annotation,
          @LocalizedValue
        >>. При ее наличии механизм журналирования заполняет поле `EntityLogAttr.messagesPack`, и таблица, отображающая значения атрибутов из примера выше может использовать колонку `locValue` вместо `value`:

[source, xml]
----
<table id="logAttrTable" width="100%" height="100%">
  <columns>
      <column id="name"/>
      <column id="locValue"/>
  </columns>
  <rows datasource="logAttrDs"/>
</table>
----

[[entity_snapshots]]
==== Снимки сущностей

Механизм сохранения снимков сущностей, так же как и <<entity_log,журнал изменений>>, предназначен для отслеживания изменений данных в процессе работы приложения. Его отличительными особенностями являются:

* Сохраняются не изменения некоторых атрибутов одного экземпляра, а состояние (снимок) целого графа сущностей, определяемого заданным <<views,представлением>>.

* Процесс сохранения снимка вызывается явно из кода клиентского уровня.

* Платформа предоставляет возможность просмотра и сравнения между собой сохраненных снимков.

===== Сохранение снимков

Для сохранения снимка некоторого графа сущностей достаточно вызвать метод `EntitySnapshotService.createSnapshot()` и передать ему основную сущность графа и <<views,представление>>, описывающее граф. Снимок создается по загруженной сущности, никаких обращений к базе данных не производится, поэтому снимок в результате содержит не больше полей, чем представление, с которым была загружена основная сущность.

Граф Java объектов преобразуется в XML и сохраняется в базе данных вместе со ссылкой на основную сущность в таблице *SYS_ENTITY_SNAPSHOT*, соответствующей сущности `EntitySnapshot`. 

Как правило, снимки требуется сохранять после коммита <<screen_edit,экрана редактирования>>. Для этого можно переопределить метод `postCommit()` контроллера экрана, например:

[source, java]
----
public class CustomerEditor extends AbstractEditor<Customer> {

  @Inject
  protected Datasource<Customer> customerDs;

  @Inject
  protected EntitySnapshotService entitySnapshotService;

...
  @Override
  protected boolean postCommit(boolean committed, boolean close) {
      if (committed) {
          entitySnapshotService.createSnapshot(customerDs.getItem(), customerDs.getView());
      }
      return super.postCommit(committed, close);
  }
}
----

===== Отображение снимков

Для отображения сохраненных для некоторой сущности снимков можно использовать фрейм `com/haulmont/cuba/gui/app/core/entitydiff/diff-view.xml`, например:

[source, xml]
----
<frame id="diffFrame"
      src="/com/haulmont/cuba/gui/app/core/entitydiff/diff-view.xml"
      width="100%"
      height="100%"/>
----

В контроллере экрана редактирования необходимо вызвать загрузку снимков во фрейм:

[source, java]
----
public class CustomerEditor extends AbstractEditor<Customer> {

  @Inject
  protected EntityDiffViewer diffFrame;

...
  @Override
  protected void postInit() {
      if (!PersistenceHelper.isNew(getItem())) {
          diffFrame.loadVersions(getItem());
      }
  }
}
----

Фрейм `diff-view.xml` отображает список сохраненных для данной сущности снимков с возможностью их сравнения. Для каждого снимка указывается пользователь, дата и время сохранения. При выборе из списка некоторого снимка сущности в таблице сравнения показываются изменения данных по сравнению с предыдущим снимком. В первом снимке измененными считаются все атрибуты. Если выбрано два снимка, то в таблицу выводится результат их сравнения.

В таблице сравнения отображаются имена атрибутов и их новые значения, при выборе строки показывается детальная информация по изменениям атрибута в двух снимках. Ссылочные поля выводятся в соответствии с их шаблоном <<namePattern,
          @NamePattern
        >>. При сравнении коллекций добавленные и удаленные элементы выделяются цветом (зеленый, красный), а элементы с измененными атрибутами остаются без выделения. Изменение позиций элементов не учитывается. 

[[file_storage]]
==== Хранилище файлов

Хранилище файлов обеспечивает загрузку, хранение и выгрузку произвольных файлов, ассоциированных с сущностями системы. Стандартная реализация сохраняет файлы вне основной базы данных, в специальной структуре файловой системы.

Механизм работы с файлами состоит из следующих частей:

* Сущность `FileDescriptor` - описатель загруженного файла (не путать с `java.io.FileDescriptor`), позволяющий ссылаться на файл из объектов модели данных.

* Интерфейс `FileStorageAPI` - доступ к хранилищу файлов на <<app_tiers,уровне>> *Middleware*. Основные методы:

** `saveStream()` - сохранить содержимое файла, переданное в `InputStream`, по данным указанного `FileDescriptor`.

** `openStream()` - вернуть содержимое файла, указанного объектом `FileDescriptor`, в виде открытого `InputStream`.

* Класс `FileUploadController` - контроллер Spring MVC, позволяющий отправлять файлы с клиентского уровня на *Middleware* посредством HTTP POST запросов.

* Класс `FileDownloadController` - контроллер Spring MVC, позволяющий получать файлы с *Middleware* на клиентский уровень посредством HTTP GET запросов.

* Визуальные компоненты `<<gui_FileUploadField,FileUpload>>` и `<<gui_FileMultiUploadField,FileMultiUpload>>` - позволяют загрузить файлы с компьютера пользователя на клиентский уровень приложения, и затем организовать их передачу на *Middleware*.

* Интерфейс `FileUploadingAPI` - промежуточное хранилище загружаемых файлов на клиентском уровне. Используется вышеупомянутыми компонентами для загрузки файлов на клиентский уровень. В прикладном коде используется метод `putFileIntoStorage()`, перемещающий файл в постоянное хранилище на *Middleware*.

* `ExportDisplay` - интерфейс клиентского уровня, позволяющий выгружать различные ресурсы приложения на компьютер пользователя. Для получения файлов из хранилища можно использовать метод `show()`, принимающий `FileDescriptor`. Экземпляр `ExportDisplay` можно получить либо вызовом статического метода `AppConfig.createExportDisplay()`, либо <<screen_controller_injection,инжекцией>> в класс контроллера.

Передача файлов между пользовательским компьютером и хранилищем в обе стороны производится только путем копирования данных между потоками ввода-вывода. Ни на каком уровне приложения файл не оказывается целиком в памяти, поэтому возможна передача файлов практически любых размеров.

[[file_upload]]
===== Загрузка файлов

Для загрузки файлов с компьютера пользователя в хранилище следует использовать компоненты `<<gui_FileUploadField,FileUpload>>` и `<<gui_FileMultiUploadField,FileMultiUpload>>`. Примеры использования приведены в описании компонентов.

Промежуточное хранилище клиентского уровня `FileUploadingAPI` для хранения временных файлов использует каталог, заданный свойством приложения `<<cuba.tempDir,cuba.tempDir>>`. В случае сбоев в нем могут оставаться временные файлы, для удаления которых желательно в клиентских блоках приложения периодически вызывать метод `clearTempDirectory()` бина `++cuba_FileUploading++`. Это можно сделать, создав задание планировщика в файле `<<spring.xml,spring.xml>>` модуля *web* (и/или *desktop*) проекта приложения, например:

[source, xml]
----
<task:scheduled-tasks scheduler="scheduler">
  <task:scheduled ref="cuba_FileUploading" method="clearTempDirectory" cron="0 0 0 * * 2,4,6"/>
</task:scheduled-tasks>
----

В данном случае очистка будет производиться в 00:00:00 каждый вторник, четверг и субботу.

[[file_download]]
===== Выгрузка данных

Для выгрузки файлов на клиентском уровне следует использовать интерфейс `ExportDisplay`, получив ссылку на него вызовом статического метода `AppConfig.createExportDisplay()`, либо <<screen_controller_injection,инжекцией>> в класс контроллера. Например:

[source, java]
----
AppConfig.createExportDisplay(this).show(fileDescriptor);
----

Метод `show()` может принимать дополнительный параметр типа `ExportFormat`, в котором можно задать тип содержимого и расширение имени файла. Если формат не передан, расширение берется из `FileDescriptor`, а типом содержимого принимается `application/octet-stream`. 

При использовании пользователем веб-интерфейса от расширения имени файла зависит, будет ли файл выгружаться через диалог сохранения или открытия файлов браузера (`Content-Disposition = attachment`), или браузер попытается отобразить содержимое прямо в своем окне (`Content-Disposition = inline`). Список расширений файлов, отображаемых в окне браузера, задается свойством приложения `<<cuba.web.viewFileExtensions,cuba.web.viewFileExtensions>>`.

[[file_storage_impl]]
===== Стандартная реализация хранилища

Стандартная реализация хранит файлы в специальной структуре каталогов на одном или нескольких файловых ресурсах.

Корни структуры можно задать в свойстве приложения `<<cuba.fileStorageDir,cuba.fileStorageDir>>`. Формат - список путей через запятую. Например:

[source, properties]
----
cuba.fileStorageDir=/work/sales/filestorage,/mnt/backup/filestorage
----

Если данное свойство не задано, хранилище будет создано в подкаталоге `filestorage` <<work_dir,рабочего каталога>> *Middleware*. В стандартном варианте развертывания в Tomcat это каталог `tomcat/work/app-core/filestorage`. 

В случае указания нескольких ресурсов хранилище ведет себя следующим образом: 

* Первый каталог в списке является _основным_, остальные - _резервными_. 

* Запись сохраняемых файлов производится в основной каталог, а затем файл копируется во все резервные каталоги. 
+
Перед записью проверяется доступность каждого каталога. Если недоступен основной каталог, выбрасывается исключение и запись не производится. Если недоступен какой-то из резервных каталогов, запись все равно производится, в лог выводится сообщение об ошибке. 

* Чтение производится из основного каталога. 
+
При недоступности основного каталога чтение производится из первого резервного каталога, в котором имеется данный файл. В лог выводится сообщение об ошибке. 

Файловая структура хранилища организована следующим образом:

* Имеется три уровня каталогов, соответствующих дате загрузки файла - год, месяц, день.

* Файл сохраняется в каталоге дня. Именем файла является идентификатор соответствующего объекта `FileDescriptor`. Расширение файла - исходное.

* В корне структуры хранилища ведется файл `storage.log`, содержащий информацию о том, какой файл, когда и каким пользователем был записан в хранилище. Этот журнал не несет никакой функциональности, но может быть полезен при поиске проблем.

JMX-бин `app-core.cuba:type=FileStorage` отображает текущий список корней хранилища, а также предоставляет следующие методы для поиска проблем:

* `findOrphanDescriptors()` - найти в базе данных все экземпляры `FileDescriptor`, для которых не имеется соответствующего файла в хранилище.

* `findOrphanFiles()` - найти файлы в хранилище, для которых не имеется соответствующего экземпляра `FileDescriptor` в БД.

[[uniqueNumbers]]
==== Генерация последовательностей

Данный механизм позволяет генерировать уникальные последовательности чисел через единый API, независимо от используемой СУБД. 

Основной частью данного механизма является <<managed_beans,бин>> `UniqueNumbers` с интерфейсом `UniqueNumbersAPI`, доступный в блоке Middleware. Методы интерфейса:

* `getNextNumber()` - получить следующее значение последовательности. Механизм позволяет вести одновременно несколько последовательностей, идентифицируемых простыми строками. Имя последовательности, из которой нужно получить значение, передается в параметре `domain`.
+
Последовательности не требуют предварительной инициализации - при первом вызове `getNextNumber()` соответствующая последовательность будет создана и вернет значение 1. 

* `getCurrentNumber()` - получить текущее, то есть последнее сгенерированное, значение последовательности. Параметр `domain` - имя последовательности.

* `setCurrentNumber()` - установить текущее значение последовательности. Следующий вызов `getNextNumber()` вернет значение, увеличенное на 1.

Пример получения следующего значения последовательности в бине блока Middleware:

[source, java]
----
@Inject
private UniqueNumbersAPI uniqueNumbers;

private long getNextValue() {
  return uniqueNumbers.getNextNumber("mySequence");
}
----

Для получения значений последовательностей в клиентских блоках используется метод `getNextNumber()`<<services, сервиса>> `UniqueNumbersService`.

Для управления последовательностями можно использовать <<jmx_beans,JMX-бин>> `app-core.cuba:type=UniqueNumbers` с методами, дублирующими методы `UniqueNumbersAPI`.

Реализация механизма генерации последовательностей зависит от типа используемой СУБД. Для *HSQL*, *PostgreSQL*, *Microsoft SQL Server 2012+* и *Oracle* каждой последовательности `UniqueNumbersAPI` соответствует последовательность (sequence) `++sec_un_{domain}++` в базе данных. Для *Microsoft SQL Server* версии ниже 2012 каждой последовательности соответствует таблица `++sec_un_{domain}++` с автоинкрементным полем. В связи с этим управлять параметрами последовательности можно также напрямую в БД.

[[queryRunner]]
==== Выполнение SQL с помощью QueryRunner

`QueryRunner` - класс, предназначенный для выполнения SQL. Его следует использовать вместо *JDBC* везде, где есть необходимость работы с SQL и нежелательно применение аналогичных <<nativeQuery,средств ORM>>. 

QueryRunner платформы является вариантом link:$$http://commons.apache.org/dbutils/apidocs/org/apache/commons/dbutils/QueryRunner.html$$[Apache DbUtils QueryRunner], усовершенствованным для использования Java Generics.

Пример использования: 

[source, java]
----
QueryRunner runner = new QueryRunner(persistence.getDataSource());
try {
  Set<String> scripts = runner.query("select SCRIPT_NAME from SYS_DB_CHANGELOG",
          new ResultSetHandler<Set<String>>() {
              public Set<String> handle(ResultSet rs) throws SQLException {
                  Set<String> rows = new HashSet<String>();
                  while (rs.next()) {
                      rows.add(rs.getString(1));
                  }
                  return rows;
              }
          });
  return scripts;
} catch (SQLException e) {
  throw new RuntimeException(e);
}
----

Есть два варианта использования `QueryRunner` - либо в текущей транзакции, либо в отдельной в режиме autocommit.

* Для выполнения запроса в текущей транзакции необходимо создать экземпляр `QueryRunner` конструктором без параметров, не передавая `DataSource`. После этого нужно вызывать методы `query()` или `update()`, передавая в них `Connection`, полученный вызовом `EntityManager.getConnection()`. После выполнения закрывать `Connection` не нужно, он будет закрыт при коммите транзакции. 

* Для выполнения запроса в отдельной транзакции необходимо создать экземпляр `QueryRunner` конструктором с параметром `DataSource`, получив экземпляр `DataSource` вызовом `Persistence.getDataSource()`. После этого нужно вызывать методы `query()` или `update()` без передачи какого-либо `Connection`, оно будет создано из указанного `DataSource` и затем сразу закрыто. 

==== Интеграция с MyBatis

В состав платформы включен фреймворк link:$$http://www.mybatis.org$$[MyBatis], обладающий, по сравнению с <<nativeQuery,ORM>> и <<queryRunner,QueryRunner>>, более широкими возможностями по выполнению SQL и отображению результатов на объекты предметной области.

Для использование MyBatis в проекте необходимо добавить следующие бины в файл `<<spring.xml,spring.xml>>` модуля *core*:

[source, xml]
----
<bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean">
  <property name="dataSource" ref="dataSource"/>
  <property name="configLocation" value="cuba-mybatis.xml"/>
  <property name="mapperLocations" value="classpath*:com/sample/sales/core/sqlmap/*.xml"/>
</bean>

<bean id="sqlSession" class="org.mybatis.spring.SqlSessionTemplate">
  <constructor-arg index="0" ref="sqlSessionFactory" />
</bean>
----

В параметре `mapperLocations` задается путь (по правилам интерфейса `ResourceLoader` *Spring*) к файлам отображений *MyBatis*. 

Пример файла отображения для загрузки экземпляра сущности `Заказ` вместе со связанным `Покупателем` и коллекцией `Пунктов заказа`:

[source, xml]
----
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper
      PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
      "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.sample.sales">

  <select id="selectOrder" resultMap="orderResultMap">
      select
          o.ID as order_id,
          o.DATE as order_date,
          o.AMOUNT as order_amount,
          c.ID as customer_id,
          c.NAME as customer_name,
          c.EMAIL as customer_email,
          i.ID as item_id,
          i.QUANTITY as item_quantity,
          p.ID as product_id,
          p.NAME as product_name
      from
          SALES_ORDER o
          left join SALES_CUSTOMER c on c.ID = o.CUSTOMER_ID
          left join SALES_ITEM i on i.ORDER_ID = o.id and i.DELETE_TS is null
          left join SALES_PRODUCT p on p.ID = i.PRODUCT_ID
      where
          c.id = #{id}
  </select>

  <resultMap id="orderResultMap" type="com.sample.sales.entity.Order">
      <id property="id" column="order_id"/>
      <result property="date" column="order_date"/>
      <result property="amount" column="order_amount"/>

      <association property="customer" column="customer_id" javaType="com.sample.sales.entity.Customer">
          <id property="id" column="customer_id"/>
          <result property="name" column="customer_name"/>
          <result property="email" column="customer_email"/>
      </association>

      <collection property="items" ofType="com.sample.sales.entity.Item">
          <id property="id" column="item_id"/>
          <result property="quantity" column="item_quantity"/>
          <association property="product" column="product_id" javaType="com.sample.sales.entity.Product">
              <id property="id" column="product_id"/>
              <result property="name" column="product_name"/>
          </association>
      </collection>
  </resultMap>

</mapper>
----

Для получения результатов запроса в приведенном выше примере можно использовать следующий код:

[source, java]
----
Transaction tx = persistence.createTransaction();
try {
  SqlSession sqlSession = AppBeans.get("sqlSession");
  Order order = (Order) sqlSession.selectOne("com.sample.sales.selectOrder", orderId);
  tx.commit();
} finally {
  tx.end();
}
----

[[folders_pane]]
==== Панель папок

Панель папок предназначена для быстрого доступа пользователя к часто используемой информации. Она представляет собой скрываемую панель в левой части главного окна приложения, в которой располагается иерархическая структура, нажатие на элементы которой (папки) приводит к отображению соответствующих экранов системы с определенными параметрами.

На момент написания данного руководства панель папок реализована только для <<app_tiers,Web Client>>.

Платформа поддерживает три вида папок: _папки приложения_, _папки поиска_ и _наборы_ записей. Папки приложения отображаются в верхней части панели в отдельной иерархии, папки поиска и наборы - в нижней части панели в совместной иерархии. 

* Папки приложения:

** Открывают экраны с <<gui_Filter,фильтром>> или без него.

** Набор папок может зависеть от текущего сеанса пользователя. Видимость конкретной папки определяется путем выполнения скрипта Groovy.

** Пользователь может создавать или изменять папки приложения, только если у него есть специальное право.

** В заголовке папки может отображаться текущее количество входящих в папку записей, вычисляемое скриптом Groovy. 

** Заголовки папок приложения обновляются по таймеру, тем самым может изменяться счетчик записей и стиль отображения каждой папки.

* Папки поиска:

** Открывают экраны с <<gui_Filter,фильтром>>. 

** Могут быть как локальными - доступными только пользователю, их создавшему, так и глобальными - доступными всем пользователям.

** Локальные папки может создавать и изменять любой пользователь, глобальные - только имеющий специальное право.

* Наборы: 

** Открывают экраны с <<gui_Filter,фильтром>>, содержащим условие отбора отдельных записей по их идентификаторам.

** Содержимое набора редактируется с помощью специальных <<gui_Action,действий>> таблицы: *Добавить в набор*, *Удалить из набора*.

** Наборы локальны, то есть доступны только создавшему их пользователю.

На функционирование панели папок влияют следующие свойства приложения:

* <<cuba.web.foldersPaneEnabled,cuba.web.foldersPaneEnabled>>

* <<cuba.web.foldersPaneVisibleByDefault,cuba.web.foldersPaneVisibleByDefault>>

* <<cuba.web.foldersPaneDefaultWidth,cuba.web.foldersPaneDefaultWidth>>

* <<cuba.web.appFoldersRefreshPeriodSec,cuba.web.appFoldersRefreshPeriodSec>>

* <<cuba.web.showFolderIcons,cuba.web.showFolderIcons>>

[[application_folder]]
===== Папки приложения

Для создания папок приложения пользователь должен иметь специфическое право *Создание/изменение папок приложения* (код `cuba.gui.appFolder.global`).

Простейшая папка приложения может быть создана из контекстного меню панели папок. Такая папка не связана с экранами системы и предназначена только для группировки других папок в иерархии.

Для создания папки, открывающей некоторый экран с фильтром, необходимо выполнить следующее:

* Открыть экран и отобрать записи по нужному фильтру.

* В меню кнопки *Фильтр...* выбрать команду *Сохранить как папку приложения*.

* В окне добавления заполнить атрибуты папки:

** Наименование папки

** Заголовок окна - строка, добавляемая к заголовку окна, когда он открывается из папки

** Родительская папка - определяет место создаваемой папки в иерархии

** Скрипт видимости - скрипт Groovy, выполняемый в начале сеанса пользователя, и определяющий доступность для него данной папки. 
+
Скрипт должен вернуть булевское значение. Если скрипт не задан, либо возвращает null, папка доступна. Пример:
+
[source, java]
----
userSession.currentOrSubstitutedUser.login == 'admin'
----

** Cкрипт количества - скрипт Groovy, выполняемый в начале сеанса пользователя и по таймеру, для вычисления количества записей для данной папки и ее стиля отображения.
+
Скрипт должен вернуть числовое значение, целая часть которого будет использована в качестве счетчика. Если скрипт не задан, либо возвращает `null`, счетчик не будет отображаться. Кроме возвращаемого значения скрипт может установить переменную `style`, которая будет использована как имя стиля отображения папки. Пример:
+
[source, java]
----
import com.haulmont.cuba.core.EntityManager
import com.haulmont.cuba.core.Query

EntityManager em = persistence.getEntityManager()
Query q = em.createQuery('select count(o) from sales$Order o')
Number count = q.getSingleResult()

style = count > 0 ? 'emphasized' : null
return count
----
+
Для отображения указанного скриптом стиля тема приложения должна содержать описание этого стиля для элемента `v-tree-node` внутри `folderspane`, например:
+
[source, css]
----
.folderspane .v-tree-node.emphasized {
  font-weight: bold;
}
----

В скриптах доступны следующие переменные, установленные в контексте `groovy.lang.Binding`:

* `folder` - экземпляр сущности `AppFolder` - папка, для которой выполняется скрипт

* `userSession` - экземпляр `UserSession` - текущая <<userSession,пользовательская сессия>> 

* `persistence` - реализация интерфейса <<persistence,Persistence>>

* `metadata` - реализация интерфейса <<metadata,Metadata>>

При обновлении папок для всех скриптов используется один экземпляр `groovy.lang.Binding`, поэтому между ними можно передавать переменные для исключения дублирующихся запросов и повышения производительности. 

Тексты скриптов могут содержаться либо непосредственно в атрибутах сущности `AppFolder`, либо в отдельных файлах. В последнем случае атрибут должен содержать путь к файлу скрипта (обязательно с расширением ".groovy") по правилам интерфейса `<<resources,Resources>>`. Таким образом, если содержимое атрибута представляет собой строку, заканчивающуюся на ".groovy", текст скрипта загружается из указанного файла, в противном случае в качестве скрипта используется само содержимое атрибута.

Папки приложения представляют собой экземпляры сущности `AppFolder` и хранятся в связанных таблицах *SYS_FOLDER* и *SYS_APP_FOLDER*.

[[search_folder]]
===== Папки поиска

Папки поиска создаются пользователями аналогично папкам приложения - группирующие папки непосредственно из контекстного меню панели папок, связанные с экранами - из меню кнопки *Фильтр...* экрана командой *Сохранить как папку поиска*.

Для создания глобальной папки пользователь должен иметь специфическое право *Создание/изменение глобальных папок поиска* (код `cuba.gui.searchFolder.global`). 

Фильтр папки поиска можно изменить после ее создания - для этого достаточно открыть папку и в экране изменить фильтр *Папка: {имя папки}*. После сохранения фильтра он будет изменен и в папке тоже.

Папки поиска представляют собой экземпляры сущности `SearchFolder` и хранятся в связанных таблицах *SYS_FOLDER* и *SEC_SEARCH_FOLDER*.

[[record_set]]
===== Наборы

Использование наборов в экране возможно, если для компонента `<<gui_Filter,Filter>>` в атрибуте `applyTo` указан соответствующий компонент `<<gui_Table,Table>>`. Например:

[source, xml]
----
<layout>
  <filter id="customerFilter"
          datasource="customersDs"
          applyTo="customersTable"/>

  <groupTable id="customersTable"
              width="100%">
      <buttonsPanel>
          <button action="customersTable.create"/>
...
      </buttonsPanel>
...
----

При этом в контекстном меню таблицы появятся команды *Добавить в набор* или *Добавить в тек. набор* / *Удалить из набора*. Если таблица содержит внутри себя компонент `buttonsPanel` (как в приведенном выше примере), команды контекстного меню будут продублированы соответствующими кнопками.

Наборы представляют собой экземпляры сущности `SearchFolder` и хранятся в связанных таблицах *SYS_FOLDER* и *SEC_SEARCH_FOLDER*.

[[link_to_screen]]
==== Ссылки на экраны

Блок <<app_tiers,Web Client>> позволяет открывать экраны приложения по команде, переданной в URL. Причем если в данный момент в браузере нет сессии приложения с зарегистрированным пользователем, то сначала будет отображено окно логина, и сразу после успешной регистрации - главное окно приложения с требуемым экраном.

Набор возможных команд указывается в свойстве приложения `<<cuba.web.linkHandlerActions,cuba.web.linkHandlerActions>>`, по умолчанию это команды `open` и `o`. При обработке HTTP запроса анализируется последняя часть URL, и если она совпадает с одной из команд, управление передается бину `LinkHandler`. Стандартная реализация этого бина позволяет указывать следующие параметры:

* `screen` - имя экрана, указанное в `<<screens.xml,screens.xml>>`, например:
+
[source, plain]
----
http://localhost:8080/app/open?screen=sec$User.browse
----

* `item` - экземпляр сущности для передачи в <<screen_edit,экран редактирования>>, закодированный по правилам класса `EntityLoadInfo`, т.е. `entityName-instanceId` или `entityName-instanceId-viewName`. Для открытия экрана создания нового экземпляра сущности в данном параметре нужно передать строку вида `NEW-entityName`. Примеры:
+
[source, plain]
----
http://localhost:8080/app/open?screen=sec$User.edit&item=sec$User-60885987-1b61-4247-94c7-dff348347f93

http://localhost:8080/app/open?screen=sec$User.edit&item=sec$User-60885987-1b61-4247-94c7-dff348347f93-user.edit

http://localhost:8080/app/open?screen=sec$User.edit&item=NEW-sec$User
----

* `params` - параметры экрана, передаваемые в метод `init()` <<screen_controller,контроллера>>. Параметры кодируются в виде `name1:value1,name2:value2`. Значениями параметров могут быть экземпляры сущностей, в свою очередь закодированные по правилам класса `EntityLoadInfo`. Примеры:
+
[source, plain]
----
http://localhost:8080/app/open?screen=sales$Customer.lookup&params=p1:v1,p2:v2

http://localhost:8080/app/open?screen=sales$Customer.lookup&params=p1:sales$Customer-01e37691-1a9b-11de-b900-da881aea47a6
----

Бин `LinkHandler` может быть переопределен в проекте приложения для обеспечения специфической обработки ссылок. `LinkHandler` является прототипом, поэтому обязательно укажите атрибут `scope` при определении вашего бина в <<spring.xml,spring.xml>>, например: 

[source, xml]
----
<!-- web-spring.xml -→
<bean id="cuba_LinkHandler" class="com.company.sample.web.MyLinkHandler" scope="prototype"/>
----

==== Инспектор сущностей

Инспектор сущностей позволяет работать с любыми объектами предметной области без создания специфических экранов. Инспектор динамически генерирует экраны просмотра списка и редактирования экземпляра выбранной сущности.

Это дает возможность администратору системы просматривать и редактировать данные, которые недоступны в стандартных экранах в силу их дизайна, а на этапе прототипирования создать только модель данных и пункты главного меню, ссылающиеся на инспектор сущностей.

Точкой входа в инспектор является экран `com/haulmont/cuba/gui/app/core/entityinspector/entity-inspector-browse.xml`. 

Если в экран передан параметр `entity` типа `String` с именем сущности, то инспектор отобразит список экземпляров этой сущности с возможностью фильтрации, выбора и редактирования экземпляров. Параметр может быть указан при регистрации экрана в <<screens.xml,screens.xml>>, например:

`screens.xml`

[source, xml]
----
<screen id="sales$Product.lookup"
      template="/com/haulmont/cuba/gui/app/core/entityinspector/entity-inspector-browse.xml">
  <param name="entity"
         value="sales$Product"/>
</screen>
----

`menu.xml`

[source, xml]
----
<item id="sales$Product.lookup"/>
----

Идентификатор экрана вида `++{имя_сущности}.lookup++` дает возможность использовать этот экран компонентам `<<gui_PickerField,PickerField>>` и `<<gui_LookupPickerField,LookupPickerField>>` в стандартном действии `PickerField.LookupAction`.

В общем случае данный экран можно вызывать без передачи параметров, тогда в его верхней части отображается поле для выбора сущности. В базовом проекте *cuba* экран инспектора зарегистрирован с идентификатором `entityInspector.browse`, поэтому для его вызова достаточно наличия пункта меню:

[source, xml]
----
<item id="entityInspector.browse"/>
----

[[credits]]
==== Информация об используемом ПО

Платформа предоставляет средства для регистрации и отображения в пользовательском интерфейсе информации об используемом в приложении стороннем программном обеспечении (credits). Информация включает в себя название, ссылку на веб-сайт и текст лицензии.

<<base_projects,Базовые проекты>> платформы содержат собственные файлы описаний `cuba-credits.xml`, `reports-credits.xml` и т.д. В проекте приложения можно создать аналогичный файл и в свойстве приложения `<<cuba.creditsConfig,cuba.creditsConfig>>` определить список файлов описаний в зависимости от используемых базовых проектов.

Структура файла `credits.xml`: 

* Элемент `items` - перечисление используемых библиотек с указанием текста лицензии либо во вложенном элементе `license`, либо атрибутом `license` со ссылкой на текст в секции `licenses`.
+
Cсылаться можно на лицензии, объявленные не только в этом же файле, но и в любом другом файле, объявленном в переменной `cuba.creditsConfig` раньше, чем текущий. 

* Элемент `licenses` - перечисление текстов общеупотребительных лицензий.

Для отображения общего списка используемого ПО предназначен фрейм `com/haulmont/cuba/gui/app/core/credits/credits-frame.xml`, загружающий информацию из файлов, заданных в свойстве `cuba.creditsConfig`. Пример использования фрейма в экране:

[source, xml]
----
<layout expand="creditsBox">
  <groupBox id="creditsBox"
            caption="msg://credits"
            width="100%">
      <frame id="credits"
              src="/com/haulmont/cuba/gui/app/core/credits/credits-frame.xml"
              width="100%"
              height="100%"/>
  </groupBox>
</layout>
----

Если экран с фреймом открывается в модальном режиме (`WindowManager.OpenType.DIALOG`), ему необходимо задать высоту, иначе возможна неправильная работа скроллинга. Это можно сделать, например, в контроллере экрана, выводящего фрейм: 

[source, java]
----
@Override
public void init(Map<String, Object> params) {
  getDialogParams().setWidth(500).setHeight(400);
}
----

