[[rest_api_v2]]
=== REST API

Универсальный REST API предоставляет следующую функциональность:

* CRUD операции над сущностями.
* Выполнение предопределенных JPQL запросов.
* Вызов методов сервисов.
* Получение метаданных (сущности, представления, перечисления, типы данных).
* Получение разрешений для текущего пользователя (доступ к сущностям, атрибутам, специфические разрешения).
* Получение информации о текущем пользователе (имя, язык, временная зона и т.д.).
* Загрузка и скачивание файлов.

REST API использует протокол OAuth2 для аутентификации и поддерживает анонимный доступ.

[TIP]
====
Подробная документация по REST API написана согласно спецификации http://swagger.io/specification[Swagger] и доступна по следующему адресу: {rest_swagger_url}.

Любое запущенное приложение на CUBA также экспортирует документацию swagger по адресам `\http://HOST:PORT/APP_NAME/rest/v2/docs/swagger.yaml` и  `\http://HOST:PORT/APP_NAME/rest/v2/docs/swagger.json`.
====

Раздел <<rest_api_v2_usage_example>> сборника рецептов содержит большое количество примеров, демонстрирующих возможности REST API в действии.

В разделах ниже приведено формальное описание некоторых особенностей и конфигурационных параметров.

[[rest_api_v2_queries_config]]
==== Настройка предопределенных JPQL запросов

В приложении на CUBA предопределенные JPQL запросы должны быть объявлены в файлах, определенных свойством приложения <<cuba.rest.queriesConfig, cuba.rest.queriesConfig>>. Свойство должно быть определено в модуле *web* или *portal* (например, в файле `web-app.properties`):

[source,properties]
----
cuba.rest.queriesConfig = +com/company/myapp/rest-queries.xml
----

Файл `rest-queries.xml` должен находиться в главном пакете модуля *web* или *portal* (например, `com.company.myapp`). Его содержимое определяется схемой http://schemas.haulmont.com/cuba/{revnumber}/rest-queries.xsd[rest-queries.xsd], например:

[source, xml]
----
include::{sourcesdir}/rest/rest-queries-config.xml[]
----

Пример конфигурирования и исполнения запроса можно увидеть в разделе <<rest_api_v2_ex_query_get>> и <<rest_api_v2_ex_query_post>>.

Платформа также предоставляет встроенный запрос `all` для получения списка всех экземпляров некоторой сущности. Он может быть использован совместно с `/count` чтобы получить общее количество экземпляров сущности, например:

  http://localhost:8080/app/rest/v2/queries/sales$Order/all/count

[[rest_api_v2_services_config]]
==== Настройка сервисов среднего слоя

Список методов сервисов, доступных для вызова через REST API, должен быть объявлен в приложении в конфигурационных файлах, заданных свойством приложения <<cuba.rest.servicesConfig, cuba.rest.servicesConfig>>. Свойство должно быть определено в модуле *web* или *portal* (например, в файле `web-app.properties`):

[source,properties]
----
cuba.rest.servicesConfig = +com/company/myapp/rest-services.xml
----

Файл `rest-services.xml` должен находиться в главном пакете модуля *web* или *portal* (например, `com.company.myapp`). Его содержимое определяется схемой http://schemas.haulmont.com/cuba/{revnumber}/rest-services-v2.xsd[rest-services-v2.xsd], например:

[source, xml]
----
include::{sourcesdir}/rest/rest-services-config.xml[]
----

Типы параметров метода могут быть опущены, если сервис не содержит перегруженного метода с тем же количеством аргументов. Иначе типы параметров обязательны к указанию.

Пример конфигурирования и вызова сервиса можно увидеть в разделе <<rest_api_v2_ex_service_get>>.

[[rest_api_v2_data_model_versioning]]
==== Версионирование модели данных

REST API поддерживает работу с различными версиями модели данных. Это может быть полезно в случае, например, когда имя атрибута сущности было изменено, но клиент REST API не знает об этом изменении и ожидает, что атрибут все еще имеет старое имя.

Для подобных случаев вы можете описать правила трасформации JSON сущностей. Если клиентское приложение посылает версию модели данных в параметре запроса, то JSON ответа, сформированном REST API, или тело запроса к REST API будут трансформированы согласно правилам, объявленным для конкретной версии модели данных.

Правила трансформации JSON должны быть объявлены в файлах, зарегистрированных в свойстве приложения <<cuba.rest.jsonTransformationConfig, cuba.rest.jsonTransformationConfig>> для модуля *web* или *portal* (например, в файле `web-app.properties`):

[source,properties]
----
cuba.rest.jsonTransformationConfig = +com/company/myapp/rest-json-transformations.xml
----

Файл `rest-json-transformations.xml` должен быть расположен в модуле *web* или *portal* (например, в пакете `com.company.myapp`). Содержимое файла определяется схемой {xsd_url}/rest-json-transformations.xsd[rest-json-transformations.xsd]. Пример файла:

[source, xml]
----
include::{sourcesdir}/rest/rest-json-transformations.xml[]
----

Стандартные трансформеры, определяемые в конфигурационном файле, могут осуществлять следующие типы трансформаций JSON:

* переименование сущности

* переименование атрибута сущности

* удаление атрибута сущности

Трансформация JSON работает для следующих адресов REST API:

* */entities* - получение списка сущностей, одной сущности, создание сущности, изменение сущности, удаление сущности

* */queries* - JSON с сущностями, возращаемыми методом, будет трансформирован

* */services* - трансформации JSON применяются как к сущностям, возращаемым методом сервиса, так и к сущностям, переданным в качестве параметра метода.

Трансформации JSON применяются, если запрос к REST API содержит параметр `modelVersion` со значением версии модели данных в URL.

Раздел <<rest_api_v2_ex_json_transformations>> содержит примеры настройки версионирования модели данных и использования его из клиентских приложений.

[[rest_api_v2_cors]]
==== Настройки CORS

По умолчанию все кросс-доменные запросы к REST API разрешены. Для ограничения списка разрешенных хостов укажите список хостов через запятую в свойстве приложения <<cuba.rest.allowedOrigins, cuba.rest.allowedOrigins>>.

[[rest_api_v2_anonymous]]
==== Анонимный доступ

По умолчанию анонимный доступ к REST API запрещен. Для его включения установите свойство приложения <<cuba.rest.anonymousEnabled, cuba.rest.anonymousEnabled>> в `true`. Запрос считается анонимным, если в нем отсутствует заголовок `Authentication`. В этом случае <<securityContext, SecurityContext>> будет содержать анонимную сессию.

Чтобы определить разрешения для анонимного доступа необходимо задать набор <<roles, ролей>> для пользователя, имя которого хранится в свойстве приложения <<cuba.anonymousLogin, cuba.anonymousLogin>>.


[[rest_api_v2_settings]]
==== Прочие настройки REST API

<<cuba.rest.client.id, cuba.rest.client.id>> - определяет id клиента REST API по умолчанию.

<<cuba.rest.client.secret, cuba.rest.client.secret>> - определяет пароль клиента REST API по умолчанию.

<<cuba.rest.client.tokenExpirationTimeSec, cuba.rest.client.tokenExpirationTimeSec>> - определяет время жизни access токена в секундах для клиента по умолчанию.

<<cuba.rest.client.refreshTokenExpirationTimeSec, cuba.rest.client.refreshTokenExpirationTimeSec>> - определяет время жизни refresh токена в секундах для клиента по умолчанию.

<<cuba.rest.client.authorizedGrandTypes, cuba.rest.client.authorizedGrandTypes>> - определяеет список типов авторизации (grant type), поддерживаемых клиентом по умолчанию. Для отключения поддержки refresh-токенов, удалите элемент `refresh_token` из значения свойства.

<<cuba.rest.maxUploadSize, cuba.rest.maxUploadSize>> - определяет максимальный размер файла, который может быть загружен с помощью REST API.

<<cuba.rest.reuseRefreshToken, cuba.rest.reuseRefreshToken>> - определяет должен ли refresh-токен быть повторно использован.

[[rest_api_v2_custom_controllers]]
==== Собственные контроллеры, защищенные OAuth2

Если вам необходимо создать свой REST контроллер, защищенный с помощью OAuth2, сделайте следующее:

. Предположим, ваш контроллер выглядит следующим образом:
+
[source, java]
----
include::{sourcesdir}/features/MyController.java[]
----

. Создайте новый файл конфигурации Spring с именем `rest-dispatcher-spring.xml` внутри корневого пакета (например, `com.company.test`) модуля *web* или *portal*. Содержимое файла должно быть следующим:
+
[source, xml]
----
include::{sourcesdir}/rest/rest-dispatcher-spring.xml[]
----

. Задайте <<additive_app_properties,аддитивное>> свойство приложения `cuba.restSpringContextConfig` в файле свойств соответствующего модуля, например, в `portal-app.properties`:
+
[source, properties]
----
cuba.restSpringContextConfig = +com/company/test/rest-dispatcher-spring.xml
----

. Новый контроллер будет помещен в контекст, связанный с сервлетом `CubaRestApiServlet`, поэтому URL для доступа к методам контроллера будут начинаться с `/rest`, т.е. метод doSmth() будет доступен по адресу: `http://localhost:8080/app-portal/rest/myapi/dosmth`.
+
[WARNING]
====
Адреса для доступа к методам кастомных контроллеров НЕ ДОЛЖНЫ начинаться с `/rest/v2`.
====

[[rest_api_v2_security_constraints]]
==== Ограничения для атрибутов-коллекций

Если сущность, возвращеннная REST API, имеет атрибут-коллекцию, и для сущностей в этой коллекции имеется <<constraints,ограничение>>, то возращаемый JSON может содержать системный атрибут `+__securityToken+`. Если данная сущность будет в дальнейшем передана в методы REST API для обновления, то в объекте JSON необходимо определить атрибут `+__securityToken+` со значением, полученным при чтении сущности. Если этого не сделать, коллекция может быть сохранена некорректно.

Пример:

[source, json]
----
include::{sourcesdir}/features/securityToken.json[]
----

[[rest_api_v2_persistent_token_store]]
==== Персистентное хранилище токенов

По умолчанию OAuth токены хранятся только в памяти. Для того, чтобы параллельно хранить их базе данных установите свойство <<cuba.rest.storeTokensInDb,cuba.rest.storeTokensInDb>> в `true`. Значение свойства хранится в базе данных, следовательно редактировать его можно из экрана *Администрирование > Свойства приложения*.

Истекшие токены должны периодически удаляться из базы данных. Выражение cron, определяющее расписание процедуры удаления, определено свойством приложения <<cuba.rest.deleteExpiredTokensCron,cuba.rest.deleteExpiredTokensCron>>.
