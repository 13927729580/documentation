[[development]]
== Разработка приложений

Данная глава содержит практическую информацию по созданию приложений на основе платформы.

[[recommended_code_style]]
=== Рекомендуемый стиль кода

*Форматирование кода*

* Для Java и Groovy кода рекомендуется придерживаться стандартного стиля, описанного в документе link:$$http://www.oracle.com/technetwork/java/codeconv-138413.html$$[Code Conventions for the Java Programming Language]. При программировании в *IntelliJ IDEA* для этого достаточно использовать стиль по умолчанию, а для переформатирования применять сочетание клавиш *Ctrl-Alt-L*.
+
Максимальная длина строки − 120 символов. Длина отступа - 4 символа, использование пробелов вместо символов табуляции включено.

* XML код: длина отступа - 4 символа, использование пробелов вместо символов табуляции включено.

*Соглашения по именованию*

[cols="3*.^", frame="all", options="header"]
|===

^| Идентификатор ^| Правило именования ^| Пример

3+^| *Java и Groovy классы*

| Класс контроллера экрана
| UpperCamelCase

Контроллер экрана списка сущностей − `{КлассСущности}Browse`

Контроллер экрана редактирования − `{КлассСущности}Edit`

| `CustomerBrowse`

`OrderEdit`

3+^| *XML дескрипторы экранов*

| Идентификатор компонента, имена параметров в запросах
| lowerCamelCase, только буквы и цифры
| `attributesTable`

`:component$relevantTo`

`:ds$attributesDs`

| Идентификатор источника данных
| lowerCamelCase, только буквы и цифры, оканчивается на Ds
| `attributesDs`

3+^| *SQL скрипты*

| Зарезервированные слова| lowercase| `create table`

| Таблицы | UPPER_CASE. Название предваряется именем проекта для формирования пространства имен. В именах таблиц рекомендуется использовать единственное число.| `++SALES_CUSTOMER++`

| Колонки | UPPER_CASE| `CUSTOMER`

`++TOTAL_AMOUNT++`

|Колонки внешних ключей | UPPER_CASE. Состоит из имени таблицы, на которую ссылается колонка (без префикса проекта), и суффикса _ID.| `++CUSTOMER_ID++`

| Индексы | UPPER_CASE. Состоит из префикса IDX_, имени таблицы, для которой создается индекс (с префиксом проекта), и имен полей, включенных в индекс. | `++IDX_SALES_CUSTOMER_NAME++`

|===

[[project_file_structure]]
=== Файловая структура проекта

Рассмотрим файловую структуру проекта на примере простого приложения *Sales*, состоящего из <<app_tiers,блоков>> *Middleware*, *Web Client* и *Web Portal*.

.Файловая структура проекта
image::project_structure.png[align="center"]

В корне проекта расположены скрипты сборки `build.gradle`, `settings.gradle` и проектные файлы *IntelliJ IDEA*.

В каталоге `modules` расположены подкаталоги <<app_modules,модулей>> проекта − *global*, *core*, *gui*, *portal, web*. 

.Структура модуля global
image::project_structure_global.png[align="center"]

Модуль *global* содержит каталог исходных текстов `src`, в корне которого располагаются конфигурационные файлы `<<metadata.xml,metadata.xml>>`, `<<persistence.xml,persistence.xml>>` и <<views.xml,views.xml>>. Пакет `com.sample.sales.service` содержит интерфейсы сервисов *Middleware*, пакет `com.sample.sales.entity` - классы <<data_model,сущностей>> и <<message_packs,файлы локализации>> для них.

.Структура модуля core
image::project_structure_core.png[align="center"]

Модуль *core* содержит следующие каталоги:

* `db` - каталог <<db_scripts,скриптов создания и обновления>> базы данных.

* `src` - каталог исходных текстов, в корне которого расположены файл <<app_properties_files,свойств приложения>> блока *Middleware* и конфигурационный файл `<<spring.xml,spring.xml>>`. Пакет `com.samples.sales.service` содержит классы реализации <<services,сервисов>>.

* `web` - каталог с конфигурационными файлами веб-приложения, в которое собирается блок *Middleware*: `<<context.xml,context.xml>>` и `<<web.xml,web.xml>>`.

.Структура модуля gui
image::project_structure_gui.png[align="center"]

Модуль *gui* содержит каталог исходных текстов `src`, в корне которого располагается конфигурационный файл `<<screens.xml,screens.xml>>`. Пакет `com.sample.sales.gui` содержит XML-дескрипторы и контроллеры экранов и <<message_packs,файлы локализации>> для них.

.Структура модуля web
image::project_structure_web.png[align="center"]

Модуль *web* содержит следующие каталоги:

* `src` - каталог исходных текстов, в корне которого расположены файл <<app_properties_files,свойств приложения>> блока *Web Client* и конфигурационные файлы `<<menu.xml,web-menu.xml>>`, `<<permissions.xml,web-permissions.xml>>`, `<<screens.xml,web-screens.xml>>` и `<<spring.xml,web-spring.xml>>`. Пакет `com.samples.sales.web` содержит главный класс блока *Web Client* (наследник `DefaultApp`) и <<main_message_pack,главный пакет локализованных сообщений>>.

* `web` - каталог с конфигурационными файлами веб-приложения, в которое собирается блок *Web Client*: `<<context.xml,context.xml>>` и `<<web.xml,web.xml>>`.

[[build_scripts]]
=== Скрипты сборки

Для сборки проектов на основе платформы используется система сборки *Gradle*. Скрипты сборки представляют собой два файла в корневом каталоге проекта: 

* `settings.gradle` - задает название и состав <<app_modules,модулей>> проекта

* `build.gradle` - определяет конфигурацию сборки.

В данном разделе описывается структура скриптов, а также предназначение и параметры задач (tasks) Gradle.

[[build.gradle]]
==== Структура build.gradle

[[build.gradle_parameters]]
===== Configuration Parameters

В секции `buildscript` задается следующее:

* Версия базовых проектов, на которой основан данный проект.

* Набор репозиториев, из которых будут загружаться зависимости проекта. В качестве имени и пароля для доступа к репозиторию зависимостей используются либо значения свойств проекта `repoUser` и `repoPass`, либо стандартные значения, явно указанные в скрипте сборки. При сборке проекта вне Studio `repoUser` и `repoPass` можно передать в командной строке в аргументах `-P`:
+
[source]
--
gradlew assemble -PrepoUser=me -PrepoPass=mypassword
--

После секции `buildscript` обявдяются несколько переменных.

Логика сборки, специфичная для CUBA, сосредоточена в Gradle плагине *cuba*. Он подключается в корне скрипта и в секциях `configure` каждого модуля:

[source, groovy]
----
apply(plugin: 'cuba')
----

Параметры плагина *cuba* задаются в секции `cuba`:

[source, groovy]
----
include::{sourcesdir}/development/build_gradle_1.groovy[]
----

Рассмотрим доступные параметры:

* `artifact` - задает группу и версию собираемых <<artifact,артефактов>> проекта. Имена артефактов формируются на основе имен модулей, заданных в `settings.gradle`.

** `group` - группа артефактов.
** `version` - версия артефактов.
** `isSnapshot` - если установлено в `true`, то в именах артефактов будет присутствовать суффикс `SNAPSHOT`.

* `tomcat` - задает параметры сервера Tomcat, который используется для <<fast_deployment, быстрого развертывания>>.

** `dir` - расположение каталога <<build.gradle_setupTomcat, установки>> Tomcat.
** `port` - порт сервера; по умолчанию 8080.
** `debugPort` - порт для подключения Java отладчика; по умолчанию 8787.
** `shutdownPort` - порт для передачи команды `SHUTDOWN`; по умолчанию 8005.
** `ajpPort` - порт AJP connector; по умолчанию 8009.

* `ide` - задает некоторые параметры для Studio и IDE.

** `vcs` - тип используемой в проекте VCS. В данный момент поддерживаются только `Git` и `svn`.
** `copyright` - текст Copyright Notice, вставляемый в начало файлов исходных текстов.
** `classComment` - текст комментария, который будет расположен над объявлением класса в исходных текстах Java.

* `uploadRepository` - задает параметры <<artifact_repository,репозитория>>, в который будут выгружатся собранные артефакты проекта при выполнении задачи `uploadArchives`.
+
** `url` - URL репозитория. По умолчанию используется репозиторий Haulmont.
** `user` - имя пользователя репозитория.
** `password` - пароль пользователя репозитория.
+
Параметры репозитория выгрузки артефактов можно передать в командной строке с помощью следующих аргументов:
+
[source]
--
gradlew uploadArchives -PuploadUrl=http://myrepo.com/content/repositories/snapshots -PuploadUser=me -PuploadPassword=mypassword
--

[[build.gradle_tasks]]
===== Задачи сборки

Исполняемыми единицами в Gradle являются _задачи_ (tasks). Они задаются как внутри плагинов, так и в самом скрипте сборки. Рассмотрим специфические для CUBA задачи, параметры которых могут быть сконфигурированы в `build.gradle`. 

[[build.gradle_enhance]]
====== enhance

`enhance` - задача типа `CubaEnhancing`, выполняющая bytecode enhancement (weaving) классов сущностей. Объявляется в <<app_modules,модуле>> *global*.

Например:

[source, java]
----
task enhance(type: CubaEnhancing)
----

Optional parameters:

* `persistenceConfig` - позволяет явно указать набор файлов <<persistence.xml, persistence.xml>>. Если не установлено, задача будет обрабатывать все персистентные сущности, перечисленные в файлах `*persistence.xml`, найденных в CLASSPATH.

* `metadataXml` - позволяет явно указать файл <<metadata.xml, metadata.xml>> проекта. Если не установлено, задача будет обрабатывать все неперсистентные сущности, перечисленные в файле `*metadata.xml`, найденном в дереве исходных текстов модуля.

[[build.gradle_setupTomcat]]
====== setupTomcat

`setupTomcat` - задача типа `CubaSetupTomcat`, выполняющая установку и инициализацию локального сервера Tomcat для последующего <<fast_deployment,быстрого развертывания>> приложения. Эта задача автоматически добавляется в проект при подключении плагина сборки *cuba*, поэтому объявлять ее в `build.gradle` не нужно. Каталог установки Tomcat задается свойством `tomcat.dir` секции `cuba`. По умолчанию это подкаталог `build/tomcat` проекта.

[[build.gradle_deploy]]
====== deploy

`deploy` - задача типа `CubaDeployment`, выполняющая <<fast_deployment,быстрое развертывание>> модуля в Tomcat. Объявляется в модулях *core*, *web*, *portal*. Параметры:

* `appName` - имя веб-приложения, которое будет создано из модуля. Фактически это имя подкаталога внутри `tomcat/webapps`.

* `jarNames` - список имен JAR файлов (без версии), получающихся в результате сборки модуля, которые надо поместить в каталог `WEB-INF/lib` веб-приложения. Все остальные артефакты модуля и зависимостей будут записаны в `tomcat/shared/lib`.

Например:

[source, java]
----
task deploy(dependsOn: assemble, type: CubaDeployment) {
    appName = 'app-core'
    jarNames = ['cuba-global', 'cuba-core', 'app-global', 'app-core']
}
----

[[build.gradle_deployThemes]]
====== deployThemes

`deployThemes` - задача типа `CubaDeployThemeTask`, выполняющая сборку и развертывание определенных в проекте <<web_theme,тем>> в запущенное веб-приложение, развернутое задачей <<build.gradle_deploy,deploy>>. Изменения в темах применяются без рестарта сервера.

Например:

[source, groovy]
----
task deployThemes(type: CubaDeployThemeTask, dependsOn: buildScssThemes) {
}
----

[[build.gradle_buildWar]]
====== buildWar

`buildWar` - задача типа `CubaWarBuilding`, выполняющая сборку приложения и его зависимостей в WAR-файл. Должна быть объявлена в корне скрипта `build.gradle`. Собранные WAR-файлы находятся в подкаталоге `build/distributions` проекта.

Любое CUBA-приложение состоит как минимум из двух <<app_tiers,блоков>>: Middleware и Web Client. Поэтому наиболее естественный способ развертывания приложения это создание двух файлов WAR: один для Middleware, второй для Web Client. Это также позволяет <<scaling,масштабировать>> приложение при увеличении нагрузки. Однако раздельные WAR-файлы содержат дублированные зависимости, что увеличивает их общий размер. Кроме того, часто расширенные возможности развертывания не нужны и только усложняют процесс. Задача `CubaWarBuilding` может создавать WAR-файлы обоих типов: один файл на блок или единственный WAR содержащий оба блока. В последнем случае блоки приложения загружаются в раздельные class loaders внутри одного веб-приложения.

Создание раздельных WAR-файлов для Middleware и Web Client::
+
--
Для создания двух отдельных WAR файлов для Middleware и Web Client, используйте следующую конфигурацию:
[source, groovy]
----
include::{sourcesdir}/development/build_gradle_buildWar_2.groovy[]
----

Параметры задачи:

* `appName` - имя результирующего WAR-файла. Для Middleware WAR добавляется суффикс `-core`.

* `appHome` - путь к домашнему каталогу приложения. В домашнем каталоге будут располагаться <<conf_dir,конфигурационный>>, <<temp_dir,временный>> и <<work_dir,рабочий>> каталоги приложения.
+
В параметре `appHome` можно указать как абсолютный или относительный путь к домашнему каталогу, так и системную переменную, которая должна быть задана при запуске сервера. Например: `appHome = '/work/sales_home'` или `appHome = '${app.home}'`

* `appProperties` - опциональный мэп <<app_properties,свойств приложения>>. Эти свойства будут добавлены в файлы `/WEB-INF/local.app.properties` внутри создаваемых WAR.

* `singleWar` - должен быть установлен в `false` для создания раздельных WAR-файлов.

* `coreProject` - проект Gradle, представляющий модуль *core* (Middleware). Если не установлено, используется стандартный модуль *core* проекта.

* `webProject` - проект Gradle, представляющий модуль *web* (Web Client). Если не установлено, используется стандартный модуль *web* проекта.

* `portalProject` - проект Gradle, представляющий модуль *portal* (Web Portal). Установите данное свойство, если в проекте используется модуль *portal*. Например, `portalProject = project(':app-portal')`.
--

Создание единого WAR-файла::
+
--
Для создания единого файла WAR, включающего в себя блоки Middleware и Web Client, используйте следующую конфигурацию:

[source, groovy]
----
include::{sourcesdir}/development/build_gradle_buildWar_1.groovy[]
----

Следующие параметры должны быть указаны в дополнение к описанным выше:

* `singleWar` - должен быть опущен или установлен в `true`.

* `webXml` - файл, который будет использован в качестве `web.xml` единого WAR. Этот файл задает два servlet context listeners, которые загружают блоки приложения: `SingleAppCoreServletListener` и `SingleAppWebServletListener`. Все параметры инициализации передаются через параметры контекста.
+
Пример файла `single-war-web.xml`:
+
[source, xml]
----
include::{sourcesdir}/development/build_gradle_buildWar_3.xml[]
----

Единый WAR файл содержит только модули *core* и *web* (Middleware и Web Client). Для развертывания модуля *portal* используйте раздельные WAR-файлы.
--

В разделе <<war_deployment>> содержатся пошаговые инструкции по некоторым вариантам развертывания WAR-файлов.

[[build.gradle_createDb]]
====== createDb

`createDb` - задача типа `CubaDbCreation`, создающая базу данных приложения путем выполнения соответствующих <<db_scripts,скриптов>>. Объявляется в модуле *core*. Параметры:

* `dbms` - <<dbms_types, тип СУБД>>, задаваемый в виде строки `hsql`, `postgres`, `mssql`, или `oracle`.

* `dbName` - имя базы данных.

* `dbUser` - имя пользователя СУБД.

* `dbPassword` - пароль пользователя СУБД.

* `host` - хост и, опционально, порт СУБД в формате `host[:port]`. Если не задан, используется `localhost`.

* `masterUrl` - URL для подключения при создании БД. Если не задан, используется значение по умолчанию, зависящее от типа СУБД и параметра `host`.

* `dropDbSql` - команда SQL для удаления БД. Если не задана, используется значение по умолчанию, зависящее от типа СУБД.

* `createDbSql` - команда SQL для создания БД. Если не задана, используется значение по умолчанию, зависящее от типа СУБД.

* `driverClasspath` - список JAR файлов, содержащих JDBC драйвер. Элементы списка разделяются символом ":" на Linux и символом ";" на Windows. Если не задан, используются зависимости, входящие в конфигурацию `jdbc` данного модуля. Явное задание `driverClasspath` актуально при использовании Oracle, т.к. его JDBC драйвер не присутствует в зависимостях.

* `oracleSystemPassword` - при использовании Oracle пароль пользователя SYSTEM.
+
Пример для PostgreSQL:
+
[source, java]
----
task createDb(dependsOn: assemble, description: 'Creates local database', type: CubaDbCreation) {
    dbms = 'postgres'
    dbName = 'sales'
    dbUser = 'cuba'
    dbPassword = 'cuba'
}
----
+
Пример для MS SQL Server:
+
[source, java]
----
task createDb(dependsOn: assemble, description: 'Creates local database', type: CubaDbCreation) {
    dbms = 'mssql'
    dbName = 'sales'
    dbUser = 'sa'
    dbPassword = 'saPass1'
}
----
+
Пример для Oracle:
+
[source, java]
----
task createDb(dependsOn: assemble, description: 'Creates database', type: CubaDbCreation) {
    dbms = 'oracle'
    host = '192.168.1.10'
    dbName = 'orcl'
    dbUser = 'sales'
    dbPassword = 'sales'
    oracleSystemPassword = 'manager'
    driverClasspath = "$tomcatDir/lib/ojdbc6.jar"
}
----

[[build.gradle_updateDb]]
====== updateDb

`updateDb` - задача типа `CubaDbUpdate`, обновляющая базу данных приложения путем выполнения соответствующих <<db_scripts,скриптов>>. Аналогична задаче `createDb`, за исключением отсутствия параметров `dropDbSql` и `createDbSql`.

[[build.gradle_startDb]]
====== startDb

`startDb` - задача типа `CubaHsqlStart`, выполняющая запуск локального сервера HSQLDB. Параметры:

* `dbName` - имя базы данных, по умолчанию `cubadb`.

* `dbDataDir` - каталог, в котором размещена база данных, по умолчанию подкаталог `data` проекта.

* `dbPort` - порт сервера, по умолчанию 9001.

Например: 

[source, java]
----
include::{sourcesdir}/development/build_gradle_startDb_1.groovy[]
---- 

[[build.gradle_stopDb]]
====== stopDb

`stopDb` - задача типа `CubaHsqlStop`, выполняющая остановку локального сервера HSQLDB. Параметры аналогичны задаче `startDb`.

[[build.gradle_start]]
====== start

`start` - задача типа `CubaStartTomcat`, выполняющая запуск локального сервера Tomcat, установленного задачей <<build.gradle_setupTomcat,setupTomcat>>. Эта задача автоматически добавляется в проект при подключении плагина *cuba*, поэтому объявлять ее в `build.gradle` не нужно.

[[build.gradle_stop]]
====== stop

`stop` - задача типа `CubaStopTomcat`, выполняющая остановку локального сервера Tomcat, установленного задачей <<build.gradle_setupTomcat,setupTomcat>>. Эта задача автоматически добавляется в проект при подключении плагина *cuba*, поэтому объявлять ее в `build.gradle` не нужно.

[[build.gradle_restart]]
====== restart

`restart` - задача, выполняющая остановку, <<fast_deployment,быстрое развертывание>> и старт локального сервера Tomcat.

[[build.gradle_debugWidgetSet]]
====== debugWidgetSet

`debugWidgetSet` - задача типа `CubaWidgetSetDebug`, которая запускает GWT Code Server для отладки виджетов в веб-браузере.

Пример использования: 

[source, java]
----
include::{sourcesdir}/development/build_gradle_debugWidgetSet_1.groovy[]
---- 

Убедитесь, что кофигурация `runtime` модуля `web-toolkit` содержит зависимость от библиотеки Servlet API: 

[source, java]
----
include::{sourcesdir}/development/build_gradle_debugWidgetSet_2.groovy[]
---- 

См. <<debug_widgets,Отладка виджетов в веб-браузере>> для получения информации о том как отлаживать код в веб-браузере.

[[build_task_start]]
==== Запуск задач сборки

Задачи (tasks) Gradle, описанные в скриптах сборки, запускаются на исполнение следующими способами:

* Если работа с проектом ведется с помощью *CUBA Studio*, то при выполнении пунктов меню *Build* и *Run* производится подключение к демону Gradle (запущенному на старте сервера Studio), который и выполняет соответствующие задачи.

* С помощью исполняемого скрипта `gradlew` (Gradle wrapper), включенного в проект. Этот скрипт должен находится в корневом каталоге проекта, и может быть создан в Studio с помощью команды *Build* → *Create Gradle wrapper*.

* С помощью установленного вручную Gradle версии {gradleVersion}

В этом случае используется исполняемый скрипт `gradle`, находящийся в подкаталоге `bin` установленного Gradle.

[TIP]
====
Рекомендуется запускать команды `gradlew` или `gradle` с ключом `--daemon`, в этом случае демон Gradle остается в памяти и существенно ускоряет последующее выполнение.

Для удаления демона из памяти используется ключ `--stop`
====

Например, чтобы выполнить компиляцию Java файлов и сборку JAR файлов артефактов проекта, необходимо запустить следующую команду:

`gradlew --daemon assemble`

Рассмотрим типичные задачи сборки в обычном порядке их использования.

* `idea` - создать проектные файлы *IntelliJ IDEA*. При выполнении этой задачи из репозитория артефактов в локальный кэш *Gradle* загружаются зависимости вместе со своими исходными кодами.

* `cleanIdea` - удалить проектные файлы *IntelliJ IDEA*.

* `assemble` - выполнить компиляцию Java файлов и сборку JAR файлов артефактов проекта в подкаталогах `build` модулей.

* `clean` - удалить подкаталоги `build` всех модулей проекта.

* <<build.gradle_setupTomcat,setupTomcat>> - установить сервер *Tomcat* в путь, заданный свойством `ext.tomcatDir` скрипта `build.gradle`. 

* <<build.gradle_deploy,deploy>> - <<fast_deployment,быстрое развертывание>> приложения на сервере *Tomcat*, предварительно установленном задачей `setupTomcat`.

* <<build.gradle_createDb,createDb>> - создание базы данных приложения и выполнение соответствующих <<db_scripts,скриптов>>.

* <<build.gradle_updateDb,updateDb>> - обновление существующей базы данных приложения путем выполнения соответствующих <<db_scripts,скриптов>>.

* <<build.gradle_start,start>> - запуск сервера *Tomcat*.

* <<build.gradle_stop,stop>> - остановка запущенного сервера *Tomcat*. 

* <<build.gradle_restart,restart>> - последовательное выполнение задач `stop`, `deploy`, `start`. 

[[build_on_ci]]
==== Сборка на сервере Continuous Integration

Плагин CUBA для Gradle требует интерактивного принятия условий лицензии CUBA, если это первая сборка для данного пользователя. При автоматической сборке на CI-сервере это невозможно, поэтому существует два пути обхода интерактивного действия: 

. Создайте файл `${user.home}/.haulmont/license.properties`, где `${user.home}` - домашний каталог пользователя, от которого работает CI-сервер, и добавьте в него следующее: 
+
[source, properties]
----
accepted=true
----

. Если создание файла в домашнем каталоге нежелательно, укажите следующий параметр командной строки Gradle: 
+
[source, properties]
----
-PlicenseAgreementAccepted=true
----

[[project_creation]]
=== Создание проекта

Рекомендуемый способ создания нового проекта - использование *CUBA Studio*. Пример рассмотрен в главе <<qs_create_project,Быстрый старт>> данного руководства.

После создания проекта вы можете продолжить разрабатывать его в Studio, либо создать файлы проекта для *IntelliJ IDEA* или *Eclipse* и открыть проект в IDE.

[[logging]]
=== Логгирование

Для ведения логов в платформе используется фреймворк *Logback*.

Для вывода в лог используйте *SLF4J* API, получая логгер по имени текущего класса. Пример создания логгера и вывода в него:

[source, java]
----
include::{sourcesdir}/development/logging_1.java[]
---- 

Настройка логгирования для <<app_tiers,блоков>> Middleware, Web Client и Web Portal производится на уровне сервера приложения - в варианте <<fast_deployment,быстрого развертывания>> это Tomcat. Блок Desktop Client имеет самостоятельную настройку логгирования.

[[logging_setup_tomcat]]
==== Настройка логгирования в Tomcat

При выполнении задачи Gradle <<build.gradle_setupTomcat,setupTomcat>> в каталог проекта устанавливается сервер Tomcat, и производится его дополнительная конфигурация. В частности, в подкаталоге `tomcat/bin` создаются файлы `setenv.bat` и `setenv.sh`, а в подкаталоге `tomcat/conf` файл `logback.xml`.

Файлы `setenv.*` в переменной `CATALINA_OPTS` в числе прочего устанавливают параметры загрузки конфигурационного файла `logback.xml`.

Файл `logback.xml` определяет конфигурацию логгирования. Рассмотрим структуру этого файла.

* Элементы `appender` задают "устройства вывода" логов. Основными аппендерами являются `FILE` и `CONSOLE`. В параметре `level` элемента `filter` можно задать порог уровня сообщения. По умолчанию порог для файла - `DEBUG`, для консоли - `INFO`. Это означает, что в файл выводятся сообщения с уровнями `ERROR`, `WARN`, `INFO`, `DEBUG`, а в консоль - с уровнями `ERROR`, `WARN` и `INFO`.
+
Для файлового аппендера в параметре `file` задается путь к файлу лога. По умолчанию это файл `tomcat/logs/app.log`.

* Элементы `logger` задают параметры логгеров, через которые производится посылка сообщений из кода программы. Имена логгеров иерархические, то есть например настройки для логгера `com.company.sample` влияют на логгеры `com.company.sample.core.CustomerServiceBean`, `com.company.sample.web.CustomerBrowse`, если для них явно не заданы собственные настройки.
+
Минимальный уровень указывается в атрибуте `level`. Например, если для логгера задан приоритет `INFO`, то сообщения с уровнями `DEBUG` и `TRACE` выводиться не будут. Следует иметь в виду, что на вывод сообщения также влияет порог уровня, заданный в аппендере.

Оперативно изменять уровни для логгеров и пороги аппендеров для работающего сервера можно с помощью экрана *Администрирование* > *Журнал сервера*, доступного в веб клиенте. Сделанные настройки логгирования действуют только в текущем сеансе работы сервера и в файл не сохраняются. Этот экран позволяет также просматривать и загружать файлы логов из <<log_dir,каталога журналов>> сервера `tomcat/logs`.

Платформа автоматически добавляет к сообщениям, выводимым в лог, следующую информацию:

* _приложение_ - имя веб приложения, развернутого в Tomcat, код которого выводит данное сообщение. Эта информация помогает различить сообщения от разных блоков приложения (*Middleware*, *Web Client*), так как они выводятся в один файл.

* _пользователь_ - логин пользователя приложения, от имени которого в данный момент работает код, выводящий сообщение. Это позволяет в общем логе отслеживать активность конкретных пользователей. Если код, выводящий сообщение, не связан в момент вывода с пользовательской сессией, информация о пользователе не выводится.

Например, следующее сообщение в логе выведено кодом блока *Middleware* (`app-core`), работающим от имени пользователя `admin`:

[source, plain]
----
16:12:20.498 DEBUG [http-nio-8080-exec-7/app-core/admin] com.haulmont.cuba.core.app.DataManagerBean - loadList: ...
----

[[logging_setup_desktop]]
==== Настройка логгирования в десктоп-клиенте

Для десктоп клиента файл `logback.xml` должен находиться в каталоге исходников модуля *desktop* проекта. При сборке приложения он упаковывается в соответствующий JAR файл и доступен в CLASSPATH.

Для настройки логгирования в своем проекте выполните следующее:

* Создайте в каталоге `src` модуля *desktop* новый файл, например, `sample-logback.xml`, и скопируйте в него содержимое файла `cuba-logback.xml`. Файл `cuba-logback.xml` находится внутри одного из JAR-файлов платформы и его легко найти поиском в IDE, если правильно сконфигурированы базовые проекты.

* Установите путь к файлу лога в параметре `file` аппендера `FILE`.

* Добавьте настройки для логгеров вашего проекта.

* В классе-наследнике `com.haulmont.cuba.desktop.App` вашего проекта, например `SampleApp`, переопределите метод `getDefaultLogConfig()` и верните в нем путь относительно корня CLASSPATH к вашему файлу настроек. Например:
+
[source, java]
----
include::{sourcesdir}/development/logging_2.java[]
----

* При необходимости можно переопределить местонахождение файла конфигурации на старте приложения с помощью системного свойства <<logback.configurationFile,logback.configurationFile>>.

[[debuging]]
=== Отладка

В данном разделе содержится информация об использовании пошаговой отладки CUBA-приложений.

[[debug_setup]]
==== Подключение отладчика

Запустить сервер Tomcat в режиме отладки можно либо выполнением команды сборки

`gradle start`

либо запуском командного файла `++bin/debug.*++` установленного *Tomcat*.

После этого сервер будет принимать подключения отладчика на порту 8787. Порт можно изменить в файле `bin/setenv.*` в переменной `++JPDA_OPTS++`.

Для пошаговой отладки в *Intellij IDEA* необходимо в проекте приложения создать новый элемент *Run/Debug Configuration* типа *Remote*, и в его поле *Port* указать 8787.

[[debug_widgets]]
==== Отладка виджетов в веб-браузере

Для отладки виджетов на стороне браузера можно использовать *GWT Super Dev Mode*.

. Настройте задачу <<build.gradle_debugWidgetSet,debugWidgetSet>> в `build.gradle`. Настройте задачу <<build.gradle_debugWidgetSet,debugWidgetSet>> в `build.gradle`. 

. Разверните приложение и запустите Tomcat.Разверните приложение и запустите Tomcat.

. Запустите задачу `debugWidgetSet`:
+
`gradlew debugWidgetSet`
+
GWT Code Server будет перекомпилировать ваш widgetset при изменениях кода виджетов.Запустите задачу `debugWidgetSet`:
+
`gradlew debugWidgetSet`
+
GWT Code Server будет перекомпилировать ваш widgetset при изменениях кода виджетов.

. Откройте страницу `http://localhost:8080/app?debug&superdevmode` в браузере Chrome и подождите пока widgetset будет построен первый раз.

. Откройте консоль отладки браузера: 
+
image::debugWidgetSet_chrome_console.png[align="center"]

. После изменения Java-кода в модуле `web-toolkit` обновляйте страницу в браузере. Widgetset будет инкрементально перестраиваться примерно за 8-10 секунд.

[[testing]]
=== Тестирование

[[unit_tests]]
==== Модульные тесты

Модульные тесты (unit tests) можно создавать и выполнять и на <<app_tiers,уровне>> *Middleware*, и на клиентском уровне. Для этого платформа включает в себя фреймворки link:$$http://junit.org$$[JUnit] и link:$$http://code.google.com/p/jmockit$$[JMockit].

Допустим, имеется следующий контроллер экрана:

[source, java]
----
include::{sourcesdir}/development/testing_1.java[]
----

Тогда можно написать следующий тест, проверяющий работу метода `init()`:

[source, java]
----
include::{sourcesdir}/development/testing_2.java[]
----

[[integration_tests_mw]]
==== Интеграционные тесты Middleware

На уровне *Middleware* можно создавать интеграционные тесты, которые выполняются в полнофункциональном контейнере Spring с подключением к базе данных. В тестах такого типа можно выполнять код любого слоя внутри Middleware - от сервисов до ORM.

Платформа содержит класс `TestContainer`, который может быть использован в качестве базового для тестовых контейнеров приложения. Создайте наследника этого класса в модуле *core* своего проекта и в его конструкторе переопределите параметры загрузки <<app_properties_files, свойств приложения>> и подключения к БД. Например:

[source, java]
----
include::{sourcesdir}/development/testing_3.java[]
----

В качестве базы данных рекомендуется использовать отдельную тестовую БД, которую можно создавать, например, следующей <<build.gradle_createDb, задачей>> в `build.gradle`:

[source, groovy]
----
include::{sourcesdir}/development/testing_4.java[]
----

Тестовый контейнер используется в классах тестов в качестве JUnit rule, указанного с помощью аннотации `@ClassRule`:

[source, java]
----
include::{sourcesdir}/development/testing_5.java[]
----

В данном примере тестовый контейнер инициализируется один раз для всех тестовых методов класса, и уничтожается после того, как все они выполнены.

Так как запуск контейнера занимает некоторое время, имеет смысл инициализировать контейнер один раз для тестов из нескольких (или всех) классов. Для этого создайте общий синглтон-экземпляр тестового контейнера, например:

[source, java]
----
include::{sourcesdir}/development/testing_6.java[]
----

И используйте его в тестовых классах:

[source, java]
----
include::{sourcesdir}/development/testing_7.java[]
----

Класс `TestContainer` содержит следующие методы, которые можно использовать в коде тестов (см. пример `CustomerLoadTest` выше):

* `persistence()` - возвращает ссылку на интерфейс `<<persistence,Persistence>>`.

* `metadata()` - возвращает ссылку на интерфейс `<<metadata,Metadata>>`.

* `deleteRecord()` - этот набор перегруженных методов предназначен для использования в `@After` методах для удаления тестовых объектов из БД.

[[integration_tests_client]]
==== Интеграционные тесты клиентского уровня

Интеграционные тесты на клиентском уровне реализуются с применением фреймворка link:$$http://code.google.com/p/jmockit$$[JMockit]. С его помощью тест изолируется от *Middleware*, а также создаются необходимые объекты инфраструктуры.

Класс клиентского интеграционного теста должен быть унаследован от `CubaClientTestCase`. В методе `@Before` необходимо вызвать унаследованные методы `addEntityPackage()`, `setViewConfig()` и затем `setupInfrastructure()` для создания объектов `<<metadata,Metadata>>` и `<<configuration,Configuration>>` и развертывания метаданных по выбранным сущностям. Далее в методе `@Before` можно дополнить инфраструктуру необходимыми мок-объектами с помощью конструкции `Expectations` или `NonStrictExpectations`.

Пример инициализирующего метода `@Before` одного из тестов платформы:

[source, java]
----
include::{sourcesdir}/development/testing_8.java[]
----

[[dev_recipes]]
=== Рецепты разработки

В данном разделе рассматриваются способы решения некоторых практических задач. 

[[getting_messages]]
==== Получение локализованных сообщений

В данном разделе рассмотрены способы получения <<localization,локализованных сообщений>> в различных компонентах приложения.

* В <<screen_xml,XML-дескрипторах>> экранов атрибуты компонентов, отображающие статичный текст (например <<gui_attr_caption,caption>>), могут обращаться к локализованным сообщениям по правилам метода <<messageTools.loadString,MessageTools.loadString()>>. Например:

** `caption="msg://roleName"` - получить сообщение, заданное ключом `roleName` в пакете сообщений текущего экрана. Пакет сообщений экрана задается в атрибуте `messagesPack` корневого элемента `window`.

** `caption="msg://com.company.sample.entity/Role.name"` - получить сообщение, заданное ключом `Role.name` в пакете сообщений `com.company.sample.entity`.

* В <<screen_controller,контроллерах экранов>> локализованные сообщения можно получать следующими способами:

** Из пакета сообщений текущего экрана:

*** Методом `getMessage()`, унаследованным от базового класса <<abstractFrame,AbstractFrame>>. Например:
+
[source, java]
----
String msg = getMessage("warningMessage");
----

*** Методом `formatMessage()`, унаследованным от базового класса `AbstractFrame`. В этом случае сообщение используется для форматирования переданных параметров по правилам метода `String.format()`. Например:
+
messages.properties:
+
[source, plain]
----
warningMessage = Invalid email address: '%s'
----
+
Java-контроллер:
+
[source, java]
----
String msg = formatMessage("warningMessage", email);
----

** Из произвольного пакета сообщений путем инжекции интерфейса инфраструктуры <<messages,Messages>>. Например:
+
[source, java]
----
@Inject
private Messages messages;

@Override
public void init(Map<String, Object> params) {
    String msg = messages.getMessage(getClass(), "warningMessage");
    ...
} 
----

* В компонентах, управляемых контейнером Spring (<<managed_beans,управляемых бинах>>, <<services,сервисах>>, <<jmx_beans,JMX-бинах>>, контроллерах Spring MVC модуля *portal*) локализованные сообщения можно получать путем инжекции интерфейса инфраструктуры <<messages,Messages>>:
+
[source, java]
----
@Inject
protected Messages messages;
...
String msg = messages.getMessage(getClass(), "warningMessage");
----

* В любом коде приложения, где невозможна инжекция, интерфейс `Messages` может быть получен с помощью статического метода `get()` класса `AppBeans`:
+
[source, java]
----
protected Messages messages = AppBeans.get(Messages.class);
...
String msg = messages.getMessage(getClass(), "warningMessage");
----

[[init_values]]
==== Присвоение начальных значений

Присвоение начальных значений атрибутам новых экземпляров сущностей можно производить несколькими способами.

[[init_values_in_class]]
===== Инициализация полей сущности

Атрибуты простых типов (`Boolean`, `Integer` и т.д.) можно инициализировать прямо в объявлении соответствующего поля класса сущности, например: 

[source, java]
----
public class User extends StandardEntity {
...
    @Column(name = "ACTIVE")
    protected Boolean active = true;
...
}
----

Кроме того, в классе сущности можно создать специальный метод инициализации и добавить ему аннотацию <<postConstruct_entity_annotation,@PostConstruct>>. В этом случае в процессе инициализации можно использовать вызов любых глобальных <<infrastructure_interfaces,интерфейсов инфраструктуры>> и <<managed_beans,бинов>>, например: 

[source, java]
----
public class MyEntity extends StandardEntity {
...
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "USER_ID")
    protected User creator;
...
    @PostConstruct
    protected void init() {
       setCreator(AppBeans.get(UserSessionSource.class).getUserSession().getUser());
    }
}
----

[[init_values_in_CreateAction]]
===== Инициализация с помощью CreateAction

Если начальное значение атрибута зависит от данных вызывающего экрана, то можно воспользоваться методом `setInitialValues()` класса <<createAction,CreateAction>>.

Рассмотрим для примера две связанные сущности:

image::init_values_recipe_1.png[align="center"]

Фрагмент XML-дескриптора экрана, отображающего одновременно списки обоих сущностей:

[source, xml]
----
<dsContext>
    <collectionDatasource id="typesDs"
                          class="com.haulmont.sample.entity.DeviceType"
                          view="_local">
        <query>
            select e from sample$DeviceType e
        </query>
    </collectionDatasource>
    <collectionDatasource id="descriptionsDs"
                          class="com.haulmont.sample.entity.DeviceDescription"
                          view="_local">
        <query>
            select e from sample$DeviceDescription e where e.deviceType.id = :ds$typesDs
        </query>
    </collectionDatasource>
</dsContext>
<layout>
...
        <table id="typeTable">
            <actions>
                <action id="create"/>
                <action id="edit"/>
                <action id="remove"/>
            </actions>
            <columns>
                <column id="name"/>
            </columns>
            <rows datasource="typesDs"/>
        </table>
...
        <table id="descriptionTable">
            <actions>
                <action id="create"/>
                <action id="edit"/>
                <action id="remove"/>
            </actions>
            <columns>
                <column id="description"/>
            </columns>
            <rows datasource="descriptionsDs"/>
        </table>
    </split>
</layout>
----

Контроллер этого экрана:

[source, java]
----
public class DeviceTypeBrowse extends AbstractLookup {

    @Inject
    private CollectionDatasource<DeviceType, UUID> typesDs;

    @Named("descriptionTable.create")
    private CreateAction descrCreateAction;

    @Override
    public void init(Map<String, Object> params) {
        typesDs.addItemChangeListener(event -> {
            descrCreateAction.setInitialValues(Collections.<String, Object>singletonMap("deviceType", event.getItem()));
        });
    }
}
----

В контроллере источнику данных `typesDs` добавляется слушатель на событие изменения выбранной записи. При смене выбранной записи вызывается метод `setInitialValues()` действия, и ему передается мэп с одним элементом, ключом которого является навание атрибута - `deviceType`, а значением - выбранный экземпляр `DeviceType`. Таким образом при выполнении действия `CreateAction` в атрибуте `deviceType` нового экземпляра `DeviceDescription` будет сразу установлен выбранный в таблице экземпляр `DeviceType`.

[[init_values_in_initNewItem]]
===== Использование метода initNewItem

Начальные значения можно также задать в контроллере экрана создаваемой сущности в методе <<initNewItem,initNewItem()>>.

В качестве примера рассмотрим следующую задачу: в проекте имеется сущность `Employee` (сотрудник компании), которая должна быть связана один-к-одному с платформенной сущностью `User` (пользователь системы). При создании сотрудника должен создаваться новый экземпляр пользователя.

image::init_values_recipe_2.png[align="center"]

В XML-дескрипторе экрана редактирования сотрудника объявляем источник данных для экземпляра сотрудника и вложенный источник - для связанного пользователя:

[source, xml]
----
<dsContext>
    <datasource id="employeeDs"
                class="com.haulmont.sample.entity.Employee"
                view="employee-edit">
        <datasource id="userDs"
                    property="user"/>
    </datasource>
</dsContext>
----

В контроллере экрана редактирования сотрудника определяем:

[source, java]
----
@Inject
private Metadata metadata;

private Group defaultGroup;
private Role defaultRole;

@Override
protected void initNewItem(Employee item) {
    User user = metadata.create(User.class);
    user.setGroup(defaultGroup);
    final UserRole userRole = metadata.create(UserRole.class);
    userRole.setUser(user);
    userRole.setRole(defaultRole);
    getDsContext().addBeforeCommitListener(context -> {
        context.getCommitInstances().add(userRole);
    });
    item.setUser(user);
}
----

Здесь в методе `initNewItem()` создается новый экземпляр `User`, и для него устанавливается некоторая группа доступа `defaultGroup`. Связь с ролью `defaultRole` устанавливается с помощью нового экземпляра сущности `UserRole`. Для сохранения этой связи в БД при коммите экрана, экземпляр `UserRole` добавляется в коллекцию сохраняемых сущностей в методе `beforeCommit()` слушателя <<dsContext,DsContext.CommitListener>>. 

Новый экземпляр `User` устанавливается в соответствующем атрибуте редактируемой сущности `Employee`, и тем самым оказывается во вложенном источнике данных `userDs`. Это дает возможность редактировать нужные атрибуты пользователя в экране сотрудника, а также приводит к автоматическому сохранению экземпляра пользователя при коммите экрана в одной транзакции с остальными сущностями.

[[composition_recipe]]
==== Редактирование композитных сущностей

Платформа CUBA поддерживает два типа связи между сущностями: ассоциацию и композицию. В интерфейсе *CUBA Studio* они названы соответственно ASSOCIATION и COMPOSITION. Ассоциация - это связь между объектами, которые могут существовать отдельно друг от друга. Композиция же используется для связи типа "master-detail" когда экземпляры detail существуют только в составе master. Примером композиции может служить связь аэропорта и терминалов: терминал, не относящийся ни к какому аэропорту, не имеет смысла.

Как правило, редактирование сущностей, входящих в состав композиции, удобно осуществлять совместно. То есть, например, пользователь открывает экран редактирования аэропорта, видит в нем список терминалов, может создавать и редактировать их, но все изменения, как аэропорта, так и терминалов, сохраняются в базу данных вместе в одной транзакции, и только тогда, когда пользователь подтвердит сохранение главной сущности - аэропорта.

[[composition_impl_recipe]]
===== Реализация композиции

Рассмотрим реализацию композиции на примере сущностей `Airport` и `Terminal`:

image::composition_recipe_1.png[align="center"]

. Сущность `Terminal` содержит обязательную ссылку на `Airport`:
+
[source, java]
----
@Entity(name = "sample$Terminal")
@Table(name = "SAMPLE_TERMINAL")
public class Terminal extends StandardEntity {
...    
    @ManyToOne(optional = false, fetch = FetchType.LAZY)
    @JoinColumn(name = "AIRPORT_ID")
    private Airport airport;

    public Airport getAirport() {
        return airport;
    }

    public void setAirport(Airport airport) {
        this.airport = airport;
    }
}
----

. Сущность `Airport` содержит one-to-many коллекцию терминалов. Соответствующее поле помечается аннотацией <<composition_annotation,@Composition>> для огранизации композиции и <<onDelete_annotation,@OnDelete>> для каскадного мягкого удаления:
+
[source, java]
----
@Entity(name = "sample$Airport")
@Table(name = "SAMPLE_AIRPORT")
public class Airport extends StandardEntity {
...
    @OneToMany(fetch = FetchType.LAZY, mappedBy = "airport")
    @OnDelete(DeletePolicy.CASCADE)
    @Composition
    protected List<Terminal> terminals;

    public List<Terminal> getTerminals() {
        return terminals;
    }

    public void setTerminals(List<Terminal> terminals) {
        this.terminals = terminals;
    }
}
----
. <<views,Представление>>, используемое в экране редактирования аэропорта, должно содержать атрибут-коллецию `terminals`:
+
[source, xml]
----
<view entity="sample$Airport" name="airport-edit" extends="_local">
    <property name="terminals" view="_local"/>
</view>
----
+
Для сущности `Terminal` здесь выбрано представление `++_local++`, хотя она содержит ссылочный атрибут `airport` - ссылку на аэропорт. Дело в том, что атрибут `airport` устанавливается только при создании нового экземпляра `Terminal`, и не меняется в дальнейшем, поэтому загружать его не обязательно.

. В XML-дескрипторе экрана редактирования аэропорта определяем источники данных для экземпляра `Airport` и коллекции его терминалов:
+
[source, xml]
----
<dsContext>
    <datasource id="airportDs"
                class="com.haulmont.sample.entity.Airport"
                view="airport-edit">
        <collectionDatasource id="terminalsDs" property="terminals"/>
    </datasource>
</dsContext>
----

. В XML-дескрипторе экрана редактирования аэропорта определяем таблицу, отображающую терминалы, и <<list_actions,стандартные действия>> для нее:
+
[source, xml]
----
<table id="terminalsTable">
    <actions>
        <action id="create"/>
        <action id="edit"/>
        <action id="remove"/>
    </actions>
    <buttonsPanel>
        <button action="terminalsTable.create"/>
        <button action="terminalsTable.edit"/>
        <button action="terminalsTable.remove"/>
    </buttonsPanel>
    <columns>
        <column id="code"/>
        <column id="name"/>
        <column id="address"/>
    </columns>
    <rows datasource="terminalsDs"/>
</table>
----

. В экране редактирования терминала достаточно определить стандартные элементы: `datasource` для экземпляра `Terminal` и визуальные компоненты, связанные с этим `datasource`, для редактирования атрибутов терминала.

В результате редактирование экземпляра аэропорта работает следующим образом:

* В экране редактирования аэропорта отображается таблица терминалов.

* Пользователь может выбрать терминал и открыть экран его редактирования. При нажатии *OK* в экране редактирования терминала измененный экземпляр терминала сохраняется не в базу данных, а в источник данных `terminalsDs` экрана редактирования аэропорта. 

* Пользователь может создавать новые или удалять терминалы - все изменения сохраняются в источнике данных `terminalsDs`.

* Пользователь нажимает *OK* в экране редактирования аэропорта, и измененный `Airport` вместе со всеми измененными экземплярами `Terminal` отправляется на Middleware в метод <<dataManager,DataManager>>.commit() и сохраняется в базе данных в рамках одной транзакции. 

[[composition_deep_recipe]]
===== Глубокая композиция

Композиция может быть более глубокой, то есть состоять из нескольких уровней вложенности. Усложним приведенный выше пример, добавив сущность `MeetingPoint`, описывающую место встречи у терминала аэропорта:

image::composition_recipe_2.png[align="center"]

Теперь сущность `Terminal` содержит атрибут `meetingPoints` - коллекцию экземпляров `MeetingPoint`. Для того, чтобы все три сущности представляли собой единую композицию и редактировались совместно, нужно в дополнение к описанному в предыдущем разделе выполнить следующее:

. Атрибуту `meetingPoints` класса `Terminal` добавить аннотации `@Composition` и `@OnDelete` аналогично атрибуту `terminals` класса `Airport`.

. Создать новое представление для `Terminal`:
+
[source, xml]
----
<view entity="sample$Terminal" name="terminal-edit" extends="_local">
    <property name="meetingPoints" view="_local"/>
</view>
----
+
И использовать его в представлении `Airport` вместо `++_local++`:
+
[source, xml]
----
<view entity="sample$Airport" name="airport-edit" extends="_local">
    <property name="terminals" view="terminal-edit"/>
</view>
----

. В XML-дескрипторе экрана редактирования аэропорта определить источники данных для экземпляра `Airport` и вложенных сущностей на всю глубину композиции:
+
[source, xml]
----
<dsContext>
    <datasource id="airportDs"
                class="com.haulmont.sample.entity.Airport"
                view="airport-edit">
        <collectionDatasource id="terminalsDs" property="terminals">
            <collectionDatasource id="meetingPointsDs" property="meetingPoints"/>
        </collectionDatasource>  
    </datasource>
</dsContext>
----
+
Здесь источник данных `meetingPointsDs` не связан ни с какими визуальными компонентами, однако он необходим для корректной работы совместного редактирования композиции.

. В XML-дескрипторе экрана редактирования терминала в свою очередь определить для коллекции `meetingPoints` вложенный источник данных и соответствующую таблицу.

В результате измененные эземпляры `MeetingPoint`, так же как и экземпляры `Terminal`, будут сохраняться в базу данных только вместе с экземпляром `Airport` в одной транзакции.

[[app_start_recipe]]
==== Выполнение кода на старте приложения

Иногда бывает необходимо выполнить некоторый код сразу после старта приложения в момент, когда все механизмы гарантированно работоспособны. Для этого можно воспользоваться слушателем <<appContext,AppContext.Listener>>.

Рассмотрим следующую задачу: в проекте имеется сущность `Employee` (сотрудник компании), которая связана один-к-одному с платформенной сущностью `User` (пользователь системы):

image::init_values_recipe_2.png[align="center"]

Если атрибут `name` сущности `User` изменяется, например через стандартный экран управления пользователями, необходимо, чтобы изменялся также и атрибут `name` связанной сущности `Employee`. Это обычная задача для "денормализованных" данных, и решается она, как правило, с использованием <<entity_listeners,entity listeners>>. В данном случае ситуация осложняется тем, что необходимо отслеживать изменения не проектной, а платформенной сущности `User`, и добавить entity listener с помощью аннотации <<listeners_annotation,@Listeners>> невозможно. Однако, можно добавить listener динамически через бин `EntityListenerManager`, и сделать это лучше всего на старте приложения.

Для этого создадим в модуле *core* приложения бин `AppLifecycle`, имплементирующий интерфейс `AppContext.Listener`, и зарегистрируем его вызовом метода `AppContext.addListener()` в конструкторе объекта:

[source, java]
----
@ManagedBean("sample_AppLifecycle")
public class AppLifecycle implements AppContext.Listener {

    @Inject
    private EntityListenerManager entityListenerManager;

    public AppLifecycle() {
        AppContext.addListener(this);
    }

    @Override
    public void applicationStarted() {
        entityListenerManager.addListener(User.class, UserEntityListener.class);
    }

    @Override
    public void applicationStopped() {
    }

    public static class UserEntityListener implements BeforeUpdateEntityListener<User> {
        @Override
        public void onBeforeUpdate(User user) {
            Persistence persistence = AppBeans.get(Persistence.class);
            if (persistence.getTools().getDirtyFields(user).contains("name")) {
                EntityManager em = persistence.getEntityManager();
                TypedQuery<Employee> query = em.createQuery(
                        "select e from sample$Employee e where e.user.id = ?1", Employee.class);
                query.setParameter(1, user.getId());
                Employee employee = query.getFirstResult();
                if (employee != null) {
                    employee.setName(user.getName());
                }
            }
        }
    }
}
----

В результате сразу после старта <<app_tiers,блока>> Middleware будет вызван метод `applicationStarted()` данного бина. В этом методе в качестве entity listener сущности `User` регистрируется внутренний класс `UserEntityListener`. 

Метод `onBeforeUpdate()` класс `UserEntityListener` будет вызываться перед каждым сохранением изменений экземпляров `User` в базу данных. В методе проверяется, есть ли атрибут `name` среди измененных, и если да, загружается связанный экземпляр `Employee`, и в нем устанавливается это же значение `name`.

[[images_recipe]]
==== Загрузка и вывод изображений

Рассмотрим задачу загрузки, хранения и отображения фотографий сотрудников:

* Сотрудник представлен сущностью `Employee`.

* Файлы изображений хранятся в <<file_storage,FileStorage>>. Сущность `Employee` содержит ссылку на соответствующий `FileDescriptor`.

* Экран редактирования `Employee` отображает фотографию, а также дает возможность загрузить, выгрузить и очистить изображение.

Класс сущности со ссылкой на файл изображения:

[source, java]
----
@Table(name = "SAMPLE_EMPLOYEE")
@Entity(name = "sample$Employee")
public class Employee extends StandardEntity {
...
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "IMAGE_FILE_ID")
    protected FileDescriptor imageFile;

    public void setImageFile(FileDescriptor imageFile) {
        this.imageFile = imageFile;
    }

    public FileDescriptor getImageFile() {
        return imageFile;
    }
}
----

<<views,Представление>> для загрузки `Employee` вместе с `FileDescriptor` должно содержать все локальные атрибуты `FileDescriptor`:

[source, xml]
----
<view class="com.company.sample.entity.Employee"
      name="employee-edit">
    <property name="name"/>
    ...
    <property name="imageFile"
              view="_local">
    </property>
</view>
----


Фрагмент XML-дескриптора экрана редактирования `Employee`:

[source, xml]
----
<groupBox caption="Photo" spacing="true"
          height="250px" width="250px" expand="embeddedImage">
        <embedded id="embeddedImage" width="100%"
                  align="MIDDLE_CENTER"/>
    <hbox align="BOTTOM_LEFT"
          spacing="true">
        <upload id="uploadField"/>
        <button id="downloadImageBtn"
                caption="Download"
                invoke="onDownloadImageBtnClick"/>
        <button id="clearImageBtn"
                caption="Clear"
                invoke="onClearImageBtnClick"/>
    </hbox>
</groupBox>
----

Компоненты отображения и загрузки/выгрузки фотографии заключены внутрь контейнера <<gui_GroupBoxLayout,groupBox>>. В верхней его части с помощью компонента <<gui_Embedded,embedded>> выводится изображение, а в нижней слева направо расположены компонент <<gui_FileUploadField,upload>> для загрузки файла и <<gui_Button,кнопки>> выгрузки и очистки изображения. В результате эта часть экрана должна выглядеть следующим образом:

image::images_recipe.png[align="center"]

Теперь рассмотрим <<abstractEditor,контроллер экрана редактирования>>.

[source, java]
----
public class EmployeeEdit extends AbstractEditor<Employee> {

    private Logger log = LoggerFactory.getLogger(getClass());

    @Inject
    private DataSupplier dataSupplier;
    @Inject
    private FileStorageService fileStorageService;
    @Inject
    private FileUploadingAPI fileUploadingAPI;
    @Inject
    private ExportDisplay exportDisplay;

    @Inject
    private Embedded embeddedImage;
    @Inject
    private FileUploadField uploadField;
    @Inject
    private Button downloadImageBtn;
    @Inject
    private Button clearImageBtn;
    @Inject
    private Datasource<Employee> employeeDs;

    private static final int IMG_HEIGHT = 190;
    private static final int IMG_WIDTH = 220;

    @Override
    public void init(Map<String, Object> params) {
        uploadField.addFileUploadSucceedListener(event -> {
            FileDescriptor fd = uploadField.getFileDescriptor();
            try {
                fileUploadingAPI.putFileIntoStorage(uploadField.getFileId(), fd);
            } catch (FileStorageException e) {
                throw new RuntimeException("Error saving file to FileStorage", e);
            }
            getItem().setImageFile(dataSupplier.commit(fd));
            displayImage();
        });

        uploadField.addFileUploadErrorListener(event ->
                showNotification("File upload error", NotificationType.HUMANIZED));

        employeeDs.addItemPropertyChangeListener(event -> {
            if ("imageFile".equals(event.getProperty()))
                updateImageButtons(event.getValue() != null);
        });
    }

    @Override
    protected void postInit() {
        displayImage();
        updateImageButtons(getItem().getImageFile() != null);
    }

    public void onDownloadImageBtnClick() {
        if (getItem().getImageFile() != null)
            exportDisplay.show(getItem().getImageFile(), ExportFormat.OCTET_STREAM);
    }

    public void onClearImageBtnClick() {
        getItem().setImageFile(null);
        displayImage();
    }

    private void updateImageButtons(boolean enable) {
        downloadImageBtn.setEnabled(enable);
        clearImageBtn.setEnabled(enable);
    }

    private void displayImage() {
        byte[] bytes = null;
        if (getItem().getImageFile() != null) {
            try {
                bytes = fileStorageService.loadFile(getItem().getImageFile());
            } catch (FileStorageException e) {
                log.error("Unable to load image file", e);
                showNotification("Unable to load image file", NotificationType.HUMANIZED);
            }
        }
        if (bytes != null) {
            embeddedImage.setSource(getItem().getImageFile().getName(), new ByteArrayInputStream(bytes));
            embeddedImage.setType(Embedded.Type.IMAGE);
            BufferedImage image;
            try {
                image = ImageIO.read(new ByteArrayInputStream(bytes));
                int width = image.getWidth();
                int height = image.getHeight();

                if (((double) height / (double) width) > ((double) IMG_HEIGHT / (double) IMG_WIDTH)) {
                    embeddedImage.setHeight(String.valueOf(IMG_HEIGHT));
                    embeddedImage.setWidth(String.valueOf(width * IMG_HEIGHT / height));
                } else {
                    embeddedImage.setWidth(String.valueOf(IMG_WIDTH));
                    embeddedImage.setHeight(String.valueOf(height * IMG_WIDTH / width));
                }
            } catch (IOException e) {
                log.error("Unable to resize image", e);
            }
            // refresh image
            embeddedImage.setVisible(false);
            embeddedImage.setVisible(true);
        } else {
            embeddedImage.setVisible(false);
        }
    }
}
----

* В методе `init()` сначала инициализируется компонент `uploadField`, предназначенный для загрузки новой фотографии. В случае успешной загрузки из компонента получается экземпляр нового `FileDescriptor`, и соответствующий файл отправляется из временного хранилища в постоянное вызовом `FileUploadingAPI.putFileIntoStorage()`. После этого `FileDescriptor` сохраняется в БД вызовом <<dataSupplier,DataSupplier.commit()>>, и сохраненный экземпляр устанавливается в атрибуте `imageFile` редактируемой сущности `Employee`. Затем вызывается метод `displayImage()` контроллера для отображения загруженной фотографии.
+
Далее в методе `init()` источнику данных, содержащему редактируемый экземпляр `Employee`, добавляется слушатель для запрещения или разрешения кнопок выгрузки и очистки файла в зависимости от того, загружен файл или нет.

* Метод `postInit()` вызывает отображение файла и обновляет состояние кнопок в зависимости от наличия загруженного файла.

* Метод `onDownloadImageBtnClick()` вызывается при нажатии кнопки `downloadImageBtn` и выполняет выгрузку файла с помощью интерфейса <<file_download,ExportDisplay>>.

* Метод `onClearImageBtnClick()` вызывается при нажатии кнопки `clearImageBtn` и очищает атрибут `imageFile` сущности `Employee`. Удаления файла из хранилища не производится.

* Метод `displayImage()` выгружает файл из хранилища в байтовый массив, устанавливает содержимое компонента `embeddedImage`, и перерасчитывает его размеры для сохранения пропорций изображения.
+
Следует иметь в виду, что выгрузка файлов из хранилища в байтовый массив приемлема только для небольших файлов. Если размер файла непредсказуем, следует использовать только выгрузку через <<file_download,ExportDisplay>>, при которой файл передается через потоки ввода-вывода и нигде не оказывается в памяти целиком.

[[own_component_samples]]
==== Создание собственных визуальных компонентов

В данном разделе рассматриваются примеры создания и использования собственных визуальных компонентов.

[[vaadin_addon_sample]]
===== Пример использования стороннего компонента Vaadin

Способ подключения сторонних компонентов Vaadin описан в <<vaadin_addon,>>.

Рассмотрим пример использования компонента *Stepper*, доступного по адресу link:$$http://vaadin.com/addon/stepper$$[http://vaadin.com/addon/stepper]. Данный компонент позволяет пошагово изменять значение текстового поля с помощью клавиатуры, колесика мыши и встроенных кнопок вверх/вниз.

* Предположим, что в проекте имеется сущность `Customer` со строковым атрибутом name. В модуле *web* создан экран редактирования `customer-edit.xml` со следующей компоновкой:
+
[source, xml]
----
<layout expand="windowActions"
        spacing="true">
    <fieldGroup id="fieldGroup"
                datasource="customerDs">
        <column width="250px">
            <field id="name"/>
        </column>
    </fieldGroup>
    <iframe id="windowActions"
            screen="editWindowActions"/>
</layout>
----
+
Нам необходимо добавить атрибут `score` типа `Integer`, и обеспечить его пошаговое редактирование в данном экране.

* В CUBA Studio добавляем атрибут `score` сущности `Customer`:
+
[source, java]
----
@Column(name = "SCORE")
protected Integer score;

public void setScore(Integer score) {
    this.score = score;
}
public Integer getScore() {
    return score;
}
----
+
Генерируем скрипты обновления БД и запускаем обновление.

* Выполняем команду *Create web toolkit module* секции *Project properties* навигатора Studio.

* В <<build.gradle,build.gradle>> проекта добавляем зависимость модуля *web* от add-on, содержащего компонент:
+
[source, java]
----
configure(webModule) {
    ...
    dependencies {
        ...
        compile("org.vaadin.addons:stepper:2.1.2")
    }
----

* Пересоздаем проектные файлы IDE: меню *Create or update IDEA project files*.

* В файл `AppWidgetSet.gwt.xml` модуля *web-toolkit* проекта подключаем набор виджетов add-on после набора виджетов платформы:
+
[source, xml]
----
<module>
    <inherits name="com.haulmont.cuba.web.toolkit.ui.WidgetSet" />
    
    <inherits name="org.vaadin.risto.stepper.widgetset.StepperWidgetset" />

    <set-property name="user.agent" value="safari" />
----
+
Для более быстрой сборки виджетов на время разработки можно установить свойство `user.agent`. В данном примере набор виджетов будет собираться только для браузеров, основанных на WebKit: Chrome, Safari, и т.д.

* В XML-дескрипторе экрана редактирования `customer-edit.xml` добавляем кастомное поле `score` в компонент <<gui_FieldGroup,fieldGroup>>:
+
[source, xml]
----
<fieldGroup id="fieldGroup"
            datasource="customerDs">
    <column width="250px">
        <field id="name"/>
        <field id="score" custom="true" caption="Score"/>
    </column>
</fieldGroup>
----

* В контроллере экрана редактирования `CustomerEdit` добавляем следующий код:
+
[source, java]
----
public class CustomerEdit extends AbstractEditor<Customer> {

    @Inject
    private ComponentsFactory componentsFactory;
    @Inject
    private FieldGroup fieldGroup;

    private IntStepper stepper = new IntStepper();

    @Override
    public void init(Map<String, Object> params) {
        fieldGroup.addCustomField("score", new FieldGroup.CustomFieldGenerator() {
            @Override
            public Component generateField(final Datasource datasource, final String propertyId) {
                Component box = componentsFactory.createComponent(BoxLayout.VBOX);
                com.vaadin.ui.Layout layout = WebComponentsHelper.unwrap(box);
                layout.addComponent(stepper);
                stepper.setSizeFull();

                stepper.addValueChangeListener(new Property.ValueChangeListener() {
                    @Override
                    public void valueChange(Property.ValueChangeEvent event) {
                        datasource.getItem().setValue(propertyId, event.getProperty().getValue());
                    }
                });

                return box;
            }
        });
    }

    @Override
    protected void postInit() {
        stepper.setValue(getItem().getScore());
    }
}
----
+
Здесь в поле `stepper` создается экземпляр компонента, подключенного из add-on. В методе `init()` производится инициализация кастомного поля `score`. Через `ComponentsFactory` создается экземпляр <<gui_BoxLayout,BoxLayout>>, затем из него с помощью <<webComponentsHelper,WebComponentsHelper>> извлекается ссылка на Vaadin-контейнер, и в этот контейнер добавляется наш новый компонент. `BoxLayout` возвращается для отображения в кастомном поле.
+
Для связи компонента с данными во-первых, в методе `postInit()` ему устанавливается текущее значение из редактируемого `Customer`, а во-вторых, добавляется слушатель на изменение значения, который обновляет соответствующий атрибут сущности при изменении значения пользователем. 

* Новый компонент можно использовать и вне `FieldGroup` в произвольном месте экрана. Для этого в XML-дескрипторе объявим контейнер:
+
[source, xml]
----
<hbox id="scoreBox"
      spacing="true">
    <label value="Score"/>
</hbox>
----
+
В контроллере инжектируем контейнер, извлекаем ссылку на Vaadin-контейнер и добавляем в него компонент:
+
[source, java]
----
public class CustomerEdit extends AbstractEditor<Customer> {

    @Inject
    private BoxLayout scoreBox;

    private IntStepper stepper = new IntStepper();

    @Override
    public void init(Map<String, Object> params) {
        com.vaadin.ui.Layout box = WebComponentsHelper.unwrap(scoreBox);
        box.addComponent(stepper);

        stepper.addValueChangeListener(new Property.ValueChangeListener() {
            @Override
            public void valueChange(Property.ValueChangeEvent event) {
                getItem().setValue("score", event.getProperty().getValue());
            }
        });
    }

    @Override
    protected void postInit() {
        stepper.setValue(getItem().getScore());
    }
}
----
+
Связь с данными выполняется здесь аналогично примеру с `FieldGroup`.

* Для адаптации внешнего вида компонента создадим в проекте расширение темы. Для этого в *Studio* выполним команду *Create theme extension* секции *Project properties* навигатора. Затем откроем файл `themes/havana/havana-ext.scss` модуля *web*, и добавим в него следующий код:
+
[source, css]
----
@import "../havana/havana"; 
 
@mixin havana-ext { 
  @include havana; 
 
  /* Basic styles for stepper */
  .v-stepper { 
    /* Use box-sizing: border-box; for all browsers */
    @include box-defaults; 
 
    height: 25px; 
    border: 0; 
 
    /* Use theme fonts */
    font-family: $theme_fonts; 
  } 
 
  /* Basic styles for inner text box */
  .v-stepper input[type="text"] { 
    /* Use box-sizing: border-box; for all browsers */
    @include box-defaults; 
 
    height: 25px; 
    padding: 1px; 
    outline: 0; 
    margin: 0; 
 
    /* Use border color from theme */
    border: 1px solid $theme_fieldBorderColor; 
  } 
 
  /* Focused styles */
  .v-stepper.v-stepper input[type="text"]:focus { 
    /* Use focused border color from theme */
    border-color: $theme_fieldFocusedBorderColor; 
    /* hide default focus outline */
    outline: 0; 
  } 
 
  /* Readonly styles */
  .v-readonly.v-stepper input[type="text"], 
  .v-readonly.v-stepper input[type="text"]:focus { 
    /* Use readonly border color from theme */
    border-color: $theme_fieldReadonlyBorderColor; 
  } 
}
----

[[own_gui_component_sample]]
===== Пример интеграции компонента Vaadin в Generic UI

В <<own_gui_component,>> были рассмотрены принципы интеграции "нативных" компонентов в универсальный UI для того, чтобы их можно было объявлять в XML-дескрипторах экранов и связывать с данными.

В <<vaadin_addon_sample,предыдущем разделе>> мы подключили в проект сторонний компонент *Stepper*. Рассмотрим процесс интеграции в универсальный UI класса `IntStepper`, реализующего пошаговое изменение числового значения типа `int`.

* Интерфейс компонента в модуле *gui*:
+
[source, java]
----
package com.company.myproject.gui.components;

import com.haulmont.cuba.gui.components.Field;

public interface IntStepper extends Field {

    String NAME = "intStepper";

    boolean isManualInputAllowed();
    void setManualInputAllowed(boolean value);

    boolean isMouseWheelEnabled();
    void setMouseWheelEnabled(boolean value);

    int getStepAmount();
    void setStepAmount(int amount);

    int getMaxValue();
    void setMaxValue(int maxValue);

    int getMinValue();
    void setMinValue(int minValue);
}
----
+
В качестве базового для нашего компонента выбран интерфейс `Field`. Это позволяет осуществить связь с данными (data binding), то есть отображать и редактировать значение некоторого атрибута сущности. 

* Реализация компонента в модуле *web*:
+
[source, java]
----
package com.company.myproject.web.components;

import com.company.myproject.gui.components.IntStepper;
import com.haulmont.cuba.web.gui.components.WebAbstractField;

public class WebIntStepper 
        extends WebAbstractField<org.vaadin.risto.stepper.IntStepper> 
        implements IntStepper {

    public WebIntStepper() {
        component = new org.vaadin.risto.stepper.IntStepper();
    }

    @Override
    public boolean isManualInputAllowed() {
        return component.isManualInputAllowed();
    }
    @Override
    public void setManualInputAllowed(boolean value) {
        component.setManualInputAllowed(value);
    }

    @Override
    public boolean isMouseWheelEnabled() {
        return component.isMouseWheelEnabled();
    }
    @Override
    public void setMouseWheelEnabled(boolean value) {
        component.setMouseWheelEnabled(value);
    }

    @Override
    public int getStepAmount() {
        return component.getStepAmount();
    }
    @Override
    public void setStepAmount(int amount) {
        component.setStepAmount(amount);
    }

    @Override
    public int getMaxValue() {
        return component.getMaxValue();
    }
    @Override
    public void setMaxValue(int maxValue) {
        component.setMaxValue(maxValue);
    }

    @Override
    public int getMinValue() {
        return component.getMinValue();
    }
    @Override
    public void setMinValue(int minValue) {
        component.setMinValue(minValue);
    }
}
----
+
В качестве базового класса выбран `WebAbstractField`, который реализует логику интерфейса `Field` по связыванию с <<datasources,источником данных>> и другие его методы.

* XML-загрузчик компонента в модуле *gui*:
+
[source, java]
----
package com.company.myproject.gui.loaders;

import com.company.myproject.gui.components.IntStepper;
import com.haulmont.cuba.gui.components.Component;
import com.haulmont.cuba.gui.xml.layout.*;
import com.haulmont.cuba.gui.xml.layout.loaders.AbstractFieldLoader;
import org.dom4j.Element;

public class IntStepperLoader extends AbstractFieldLoader {

    public IntStepperLoader(Context context, LayoutLoaderConfig config, ComponentsFactory factory) {
        super(context, config, factory);
    }

    @Override
    public Component loadComponent(ComponentsFactory factory, Element element, Component parent) {
        IntStepper component = (IntStepper) super.loadComponent(factory, element, parent);

        String manualInput = element.attributeValue("manualInput");
        if (manualInput != null) {
            component.setManualInputAllowed(Boolean.valueOf(manualInput));
        }
        String mouseWheel = element.attributeValue("mouseWheel");
        if (mouseWheel != null) {
            component.setMouseWheelEnabled(Boolean.valueOf(mouseWheel));
        }
        String stepAmount = element.attributeValue("stepAmount");
        if (stepAmount != null) {
            component.setStepAmount(Integer.valueOf(stepAmount));
        }
        String maxValue = element.attributeValue("maxValue");
        if (maxValue != null) {
            component.setMaxValue(Integer.valueOf(maxValue));
        }
        String minValue = element.attributeValue("minValue");
        if (minValue != null) {
            component.setMinValue(Integer.valueOf(minValue));
        }
        return component;
    }
}
----
+
Логика загрузки базовых свойств компонента `Field` сосредоточена в классе `AbstractFieldLoader`. Нам достаточно загрузить только специфические свойства `IntStepper`.

* Палитра компонентов проекта в модуле *web*:
+
[source, java]
----
package com.company.myproject.web;

import com.company.myproject.gui.components.IntStepper;
import com.company.myproject.gui.loaders.IntStepperLoader;
import com.company.myproject.web.components.WebIntStepper;
import com.haulmont.cuba.gui.ComponentPalette;
import com.haulmont.cuba.gui.components.Component;
import com.haulmont.cuba.gui.xml.layout.ComponentLoader;
import java.util.HashMap;
import java.util.Map;

public class AppComponentPalette implements ComponentPalette {

    @Override
    public Map<String, Class<? extends ComponentLoader>> getLoaders() {
        Map<String, Class<? extends ComponentLoader>> loaders = new HashMap<>();
        loaders.put(IntStepper.NAME, IntStepperLoader.class);
        return loaders;
    }

    @Override
    public Map<String, Class<? extends Component>> getComponents() {
        Map<String, Class<? extends Component>> components = new HashMap<>();
        components.put(IntStepper.NAME, WebIntStepper.class);
        return components;
    }
}
----

* Регистрация палитры компонентов в классе `App` модуля *web*:
+
[source, java]
----
package com.company.myproject.web;

import com.haulmont.cuba.web.DefaultApp;
import com.haulmont.cuba.web.gui.WebUIPaletteManager;

public class App extends DefaultApp {

    static {
        WebUIPaletteManager.registerPalettes(new AppComponentPalette());
    }
}
----

* XSD компонентов проекта в модуле *gui*:
+
[source, xml]
----
<xs:schema targetNamespace="http://schemas.company.com/app/0.1/app-components.xsd"
           xmlns:xs="http://www.w3.org/2001/XMLSchema"
           xmlns="http://schemas.company.com/app/0.1/app-components.xsd"
           elementFormDefault="qualified"
           attributeFormDefault="unqualified">

    <xs:element name="intStepper">
        <xs:complexType>
            <xs:attribute name="id" type="xs:string"/>
            <xs:attribute name="caption" type="xs:string"/>
            <xs:attribute name="width" type="xs:string"/>
            <xs:attribute name="height" type="xs:string"/>
            <xs:attribute name="datasource" type="xs:string"/>
            <xs:attribute name="property" type="xs:string"/>
            <xs:attribute name="manualInput" type="xs:boolean"/>
            <xs:attribute name="mouseWheel" type="xs:boolean"/>
            <xs:attribute name="stepAmount" type="xs:int"/>
            <xs:attribute name="maxValue" type="xs:int"/>
            <xs:attribute name="minValue" type="xs:int"/>
        </xs:complexType>
    </xs:element>

</xs:schema>
----

* Использование компонента в экране внутри произвольного контейнера:
+
[source, xml]
----
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<window xmlns="http://schemas.haulmont.com/cuba/window.xsd"
        xmlns:app="http://schemas.company.com/app/0.1/app-components.xsd"
        caption="msg://editCaption"
        class="com.company.myproject.web.customer.CustomerEdit"
        datasource="customerDs"
        focusComponent="fieldGroup"
        messagesPack="com.company.myproject.web.customer">
    <dsContext>
        <datasource id="customerDs"
                    class="com.company.myproject.entity.Customer"
                    view="_local"/>
    </dsContext>
    <layout expand="windowActions"
            spacing="true">
        <app:intStepper id="stepper" datasource="customerDs" property="score" caption="Score"
                        minValue="1" maxValue="20"/>
        <iframe id="windowActions"
                screen="editWindowActions"/>
    </layout>
</window>
----
+
В данном примере компонент `intStepper` подсоединен к атрибуту `score` сущности `Customer`, экземпляр которой находится в источнике данных `customerDs`.

* Использование компонента в кастомном поле <<gui_FieldGroup,FieldGroup>>:
+
[source, xml]
----
<dsContext>
    <datasource id="customerDs"
                class="com.company.myproject.entity.Customer"
                view="_local"/>
</dsContext>
<layout expand="windowActions"
        spacing="true">
    <fieldGroup id="fieldGroup"
                datasource="customerDs">
        <column width="250px">
            <field id="name"/>
            <field id="score" custom="true" caption="Score"/>
        </column>
    </fieldGroup>
...
----
+
[source, java]
----
@Inject
private ComponentsFactory componentsFactory;
@Inject
private FieldGroup fieldGroup;

@Override
public void init(Map<String, Object> params) {
    fieldGroup.addCustomField("score", new FieldGroup.CustomFieldGenerator() {
        @Override
        public Component generateField(final Datasource datasource, final String propertyId) {
            IntStepper stepper = componentsFactory.createComponent(IntStepper.NAME);
            stepper.setDatasource(datasource, propertyId);
            stepper.setWidth("100%");
            return stepper;
        }
    });
}
---- 

[[sending_emails_recipe]]
==== Отправка email

В данном разделе рассматривается пример использования <<email_sending,механизма>> рассылки email.

Рассмотрим следующую задачу:

--
* Имеется сущность `NewsItem` и экран ее редактирования `NewsItemEdit`.

* Сущность `NewsItem` имеет следующие атрибуты: `date`, `caption`, `content`.

* Необходимо отсылать электронные письма каждый раз, когда через экран `NewsItemEdit` создается новый экземпляр сущности. Email должен содержать `NewsItem.caption` в качестве темы письма, тело письма должно формироваться на основе шаблона, включающего `NewsItem.content`.
--

. Добавьте следующий код в `NewsItemEdit.java`:
+
--
[source, java]
----
include::{sourcesdir}/development/sending_emails_1.java[]
----

Как видно, метод `sendByEmail()` вызывает сервис `EmailService` и передает ему экземпляр `EmailInfo`, описывающий сообщение. Тело сообщений будет создаваться на основе шаблона `news_item.txt`.
--

. Создайте шаблон тела письма в файле `news_item.txt` в пакете `com.company.demo.templates` модуля *core*:
+
--
[source, plain]
----
include::{sourcesdir}/development/sending_emails_2.txt[]
----

Это шаблон link:http://freemarker.incubator.apache.org[Freemarker], который использует параметры, переданные в `EmailInfo` (в данном случае единственный параметр `newsItem`).
--

. Запустите приложение, откройте браузер сущности `NewsItem` и нажмите *Create*. Откроется экран редактирования сущности. Заполните поля и нажмите *OK*. Появится диалог подтверждения с вопросом об отсылке email. Нажмите *Yes*.

. Перейдите в экран *Administration > Email History* вашего приложения. Вы увидите две записи (по числу получателей) со статусом `Queue`. Он означает, что сообщения находятся в очереди и еще не отосланы.

. Для обработки очереди необходимо создать <<scheduled_tasks_cuba,назначенное задание>>. Перейдите в экран *Administration > Scheduled Tasks* вашего приложения. Создайте новую задачу и установите ей следующие параметры:
+
--
* *Bean Name* - `cuba_Emailer`
* *Method Name* - `processQueuedEmails()`
* *Singleton* - да (этот параметр важен только при эксплуатации кластера серверов middleware)
* *Period, sec* - 10
--
+
Сохраните задачу и нажмите на ней *Activate*.
+
Если вы ранее не настраивали выполнение назначенных заданий для данного приложения ранее, то на данном этапе ничего не произойдет - новая задача не начнет выполняться пока вы не запустите весь механизм назначенных заданий.

. Откройте файл `modules/core/src/app.properties` и добавьте в него следующее <<cuba.schedulingActive,свойство>>:
+
[source, properties]
----
cuba.schedulingActive = true
----
+
Перезапустите сервер приложения. Механизм выполнения заданий теперь активен и вызывает обработку очереди email.

. Перейдите в экран *Administration > Email History*. Статус сообщений будет либо `Sent`, если они успешно отосланы, либо, что более вероятно, `Sending` или `Queue`, если произошла ошибка отправки. В последнем случае вы можете открыть журнал приложения в файле `build/tomcat/logs/app.log` и выяснить причину. Механизм отсылки email предпримет несколько (по умолчанию 10) попыток и в случае неудачи переведет сообщения в статус `Not sent`.

. Наиболее очевидной причиной ошибки отправки является то, что вы не настроили <<email_sending_properties,параметры>> SMTP-сервера. Эти параметры могут быть заданы в базе данных с помощью  JMX бина `app-core.cuba:type=Emailer` или в свойствах приложения блока middleware. Рассмотрим второй способ. Откройте файл `modules/core/src/app.properties` и добавьте в него требуемые <<email_sending_properties,параметры>>:
+
[source, properties]
----
include::{sourcesdir}/development/sending_emails_3.properties[]
----
+
Перезапустите сервер приложения. Перейдите в экран *Administration > JMX Console*, найдите JMX бин `Emailer` и попробуйте послать самому себе тестовое сообщение с помощью операции `sendTestEmail()`.

. Теперь механизм отсылки email настроен корректно, однако он не будет отсылать сообщения, уже переведенные в статус `Not sent`. Поэтому необходимо создать новый экземпляр `NewsItem` через экран редактирования. Сделайте это и понаблюдайте, как статус новых сообщений в экране *Email History* изменится на `Sent`.
