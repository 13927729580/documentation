[[chapter_development]]
== Разработка приложений

Данная глава содержит практическую информацию по созданию приложений на основе платформы.

=== Рекомендуемый стиль кода

*Форматирование кода*

* Для Java и Groovy кода рекомендуется придерживаться стандартного стиля, описанного в документе link:$$http://www.oracle.com/technetwork/java/codeconv-138413.html$$[Code Conventions for the Java Programming Language]. При программировании в *IntelliJ IDEA* для этого достаточно использовать стиль по умолчанию, а для переформатирования применять сочетание клавиш *Ctrl-Alt-L*.
+
Максимальная длина строки − 120 символов. Длина отступа - 4 символа, использование пробелов вместо символов табуляции включено.

* XML код: длина отступа - 4 символа, использование пробелов вместо символов табуляции включено.

*Соглашения по именованию*

[cols="3*.^", frame="all", options="header"]
|===

^| Идентификатор ^| Правило именования ^| Пример

3+^| *Java и Groovy классы*

| Класс контроллера экрана
| UpperCamelCase

Контроллер экрана списка сущностей − `{КлассСущности}Browse`

Контроллер экрана редактирования − `{КлассСущности}Edit`

| `CustomerBrowse`

`OrderEdit`

3+^| *XML дескрипторы экранов*

| Идентификатор компонента, имена параметров в запросах
| lowerCamelCase, только буквы и цифры
| `attributesTable`

`:component$relevantTo`

`:ds$attributesDs`

| Идентификатор источника данных
| lowerCamelCase, только буквы и цифры, оканчивается на Ds
| `attributesDs`

3+^| *SQL скрипты*

| Зарезервированные слова| lowercase| `create table`

| Таблицы | UPPER_CASE. Название предваряется именем проекта для формирования пространства имен. В именах таблиц рекомендуется использовать единственное число.| `++SALES_CUSTOMER++`

| Колонки | UPPER_CASE| `CUSTOMER`

`++TOTAL_AMOUNT++`

|Колонки внешних ключей | UPPER_CASE. Состоит из имени таблицы, на которую ссылается колонка (без префикса проекта), и суффикса _ID.| `++CUSTOMER_ID++`

| Индексы | UPPER_CASE. Состоит из префикса IDX_, имени таблицы, для которой создается индекс (с префиксом проекта), и имен полей, включенных в индекс. | `++IDX_SALES_CUSTOMER_NAME++`

|===

[[project_file_structure]]
=== Файловая структура проекта

Рассмотрим файловую структуру проекта на примере простого приложения *Sales*, состоящего из <<app_tiers,блоков>> *Middleware*, *Web Client* и *Web Portal*.

.Файловая структура проекта
image::project_structure.png[align="center"]

В корне проекта расположены скрипты сборки `build.gradle`, `settings.gradle` и проектные файлы *IntelliJ IDEA*.

В каталоге `modules` расположены подкаталоги <<app_modules,модулей>> проекта − *global*, *core*, *gui*, *portal, web*. 

.Структура модуля global
image::project_structure_global.png[align="center"]

Модуль *global* содержит каталог исходных текстов `src`, в корне которого располагаются конфигурационные файлы `<<metadata.xml,metadata.xml>>`, `<<persistence.xml,persistence.xml>>` и <<views.xml,views.xml>>. Пакет `com.sample.sales.service` содержит интерфейсы сервисов *Middleware*, пакет `com.sample.sales.entity` - классы <<data_model,сущностей>> и <<message_packs,файлы локализации>> для них.

.Структура модуля core
image::project_structure_core.png[align="center"]

Модуль *core* содержит следующие каталоги:

* `db` - каталог <<db_scripts,скриптов создания и обновления>> базы данных.

* `src` - каталог исходных текстов, в корне которого расположены файл <<app_properties_files,свойств приложения>> блока *Middleware* и конфигурационный файл `<<spring.xml,spring.xml>>`. Пакет `com.samples.sales.service` содержит классы реализации <<services,сервисов>>.

* `web` - каталог с конфигурационными файлами веб-приложения, в которое собирается блок *Middleware*: `<<context.xml,context.xml>>` и `<<web.xml,web.xml>>`.

.Структура модуля gui
image::project_structure_gui.png[align="center"]

Модуль *gui* содержит каталог исходных текстов `src`, в корне которого располагается конфигурационный файл `<<screens.xml,screens.xml>>`. Пакет `com.sample.sales.gui` содержит XML-дескрипторы и контроллеры экранов и <<message_packs,файлы локализации>> для них.

.Структура модуля web
image::project_structure_web.png[align="center"]

Модуль *web* содержит следующие каталоги:

* `src` - каталог исходных текстов, в корне которого расположены файл <<app_properties_files,свойств приложения>> блока *Web Client* и конфигурационные файлы `<<menu.xml,web-menu.xml>>`, `<<permissions.xml,web-permissions.xml>>`, `<<screens.xml,web-screens.xml>>` и `<<spring.xml,web-spring.xml>>`. Пакет `com.samples.sales.web` содержит главный класс блока *Web Client* (наследник `DefaultApp`) и <<main_message_pack,главный пакет локализованных сообщений>>.

* `web` - каталог с конфигурационными файлами веб-приложения, в которое собирается блок *Web Client*: `<<context.xml,context.xml>>` и `<<web.xml,web.xml>>`.

[[build_scripts]]
=== Описание скриптов сборки

Для сборки проектов на основе платформы используется система сборки *Gradle*. Скрипты сборки представляют собой два файла в корневом каталоге проекта: 

* `settings.gradle` - задает название и состав <<app_modules,модулей>> проекта

* `build.gradle` - определяет конфигурацию сборки.

В данном разделе описывается структура скриптов, а также предназначение и параметры задач (tasks) Gradle.

[[build.gradle]]
==== Структура build.gradle

Секция `allprojects` задает группу и версию собираемых <<artifact,артефактов>> проекта. Имена артефактов формируются на основе имен модулей, заданных в `settings.gradle`. Если свойство `ext.isSnapshot` равно `true`, то в именах артефактов будет присутствовать суффикс `SNAPSHOT`. Свойство `ext.tomcatDir` задает расположение каталога <<build.gradle_setupTomcat,установки>> *Tomcat*. Кроме того, в секции `allprojects` могут быть заданы следующие опциональные свойства: 

* `ext.copyright` - текст Copyright Notice, вставляемый *IntelliJ IDEA* в файлы исходных текстов.

* `ext.vcs` - тип используемой в проекте VCS. Если данное свойство указано, то в сгенерированных проектных файлах IntelliJ IDEA будет установлен параметр интеграции с данной VCS. Возможные значения: `svn`, `Git`. 

* `ext.uploadUrl` - URL <<artifact_repository,репозитория>>, в который будут выгружатся собранные артефакты проекта при выполнении задачи `uploadArchives`. По умолчанию используется репозиторий Haulmont.

* `ext.uploadUser` - имя пользователя репозитория для выгрузки собранных артефактов проекта. По умолчанию используется значение переменной окружения `++HAULMONT_REPOSITORY_USER++`.

* `ext.uploadPassword` - пароль пользователя репозитория для выгрузки собранных артефактов проекта. По умолчанию используется значение переменной окружения `++HAULMONT_REPOSITORY_PASSWORD++`. 

* Свойства `ext.tomcatPort`, `ext.tomcatShutdownPort` и `ext.tomcatDebugPort` оказывают влияние на задачу `setupTomcat` (см. ниже) и могут быть использованы для установки Tomcat с нестандартными портами.

 
[TIP]
====
Любое из свойств проекта можно задать не в самом `build.gradle`, а путем передачи в командной строке аргумента с префиксом `-P`, например:

`gradlew uploadArchives -PuploadUser=myuser -PuploadPassword=mypassword`
====

В секции `buildscript` выполняется следующее:

* Задается версия базовых проектов платформы, на которой основан данный проект.

* Задается набор репозиториев, из которых будут загружаться зависимости проекта. В качестве имени и пароля для доступа к репозиторию зависимостей используются либо значения свойств проекта `repoUser` и `repoPass`, либо стандартные значения, явно указанные в скрипте сборки. Как и другие свойства проекта, `repoUser` и `repoPass` можно передать в командной строке в аргументах `-P`.

* Объявляется зависимость от плагина *cuba-plugin*, в котором сосредоточена специфика сборки проектов на платформе. Плагин подключается далее в конфигурацию сборки модулей с помощью метода
+
[source, java]
----
apply(plugin: 'cuba')
----

Далее в секциях `configure` определяются параметры сборки модулей приложения.

Исполняемыми единицами в Gradle являются _задачи_ (tasks). Они задаются как внутри плагинов, так и в самом скрипте сборки. Рассмотрим специфические для CUBA задачи, параметры которых могут быть сконфигурированы в `build.gradle`. 

* `enhance` - задача типа `CubaEnhancing`, выполняющая bytecode enhancement классов персистентных сущностей. Объявляется в <<app_modules,модуле>> *global*. В параметре задачи `persistenceXml` указывается путь к файлу <<persistence.xml,persistence.xml>> проекта.
+
Например:
+
[source, java]
----
task enhance(type: CubaEnhancing) {
    persistenceXml = "${globalModule.projectDir}/src/persistence.xml"
}
----

* `enhanceTransient` - задача типа `CubaEnhanceTransient`, выполняющая bytecode enhancement классов неперсистентных сущностей. В параметре задачи `metadataXml` указывается путь к файлу <<metadata.xml,metadata.xml>> проекта.
+
Например: 
+
[source, java]
----
include::{sourcesdir}/development/build_gradle_enhanceTransient_1.groovy[]
----

* `setupTomcat` - задача типа `CubaSetupTomcat`, выполняющая установку и инициализацию локального сервера Tomcat для последующего <<fast_deployment,быстрого развертывания>> приложения. Эта задача автоматически добавляется в проект при подключении плагина сборки *cuba*, поэтому объявлять ее в `build.gradle` не нужно. Каталог установки Tomcat задается свойством `ext.tomcatDir` в секции `allprojects`. По умолчанию это подкаталог `build/tomcat` проекта.

* `deploy` - задача типа `CubaDeployment`, выполняющая <<fast_deployment,быстрое развертывание>> модуля в Tomcat. Объявляется в модулях *core*, *web*, *portal*. Параметры:

** `appName` - имя веб-приложения, которое будет создано из модуля. Фактически это имя подкаталога внутри `tomcat/webapps`.

** `jarNames` - список имен JAR файлов (без версии), получающихся в результате сборки модуля, которые надо поместить в каталог `WEB-INF/lib` веб-приложения. Все остальные артефакты модуля и зависимостей будут записаны в `tomcat/shared/lib`.
+
Например:
+
[source, java]
----
task deploy(dependsOn: assemble, type: CubaDeployment) {
    appName = 'app-core'
    jarNames = ['cuba-global', 'cuba-core', 'app-global', 'app-core']
}
----

* `buildWar` - задача типа `CubaWarBuilding`, выполняющая сборку модуля в WAR-файл. Может быть объявлена в модулях *core*, *web*, *portal*, если требуется <<war_deployment,развертывание приложения в WAR>>. Собранные WAR-файлы находятся в подкаталогах `build/distributions` модулей.
+
Параметры задачи:

** `appName` - имя результирующего WAR-файла.

** `appHome` - путь к домашнему каталогу приложения. В домашнем каталоге будут располагаться файл конфигурации <<logging,логгирования>>; каталог <<db_dir, скриптов базы данных>>; <<conf_dir,конфигурационный>>, <<temp_dir,временный>> и <<work_dir,рабочий>> каталоги приложения.
+
В параметре `appHome` можно указать как абсолютный путь к домашнему каталогу, так и системную переменную, которая должна быть задана при запуске сервера. Например: `++appHome = '/work/sales_home'++` или `++appHome = '${app.home}'++`

** `appProperties` - мэп свойств, которые будут записаны в файл `WEB-INF/local.app.properties` в дополнение к определенным в самой задаче. По умолчанию задача `buildWar` создает данный файл и определяет в нем свойства `cuba.logDir`, `cuba.confDir`, `cuba.tempDir`, `cuba.dataDir` для работы с домашним каталогом приложения, упомянутым выше. Кроме того, для приложения среднего слоя задается параметр 
+
[source, properties]
----
cuba.dataSourceJndiName = jdbc/CubaDS
----

а для приложения веб-клиента параметры 

[source, properties]
----
cuba.connectionUrlList = http://localhost:8080/${appName}-core
cuba.useLocalServiceInvocation = false
----

Пример задачи в модуле *web*: 

[source, java]
----
include::{sourcesdir}/development/build_gradle_buildWar_1.groovy[]
---- 

* `createWarDistr` - задача типа `CubaWarDistribution`, выполняющая подготовку дистрибутива, включающего в себя <<war_deployment,WAR-файлы>> приложений и их домашний каталог. Задача обязательно должна зависеть от задач `buildWar` модулей, и имеет следующие параметры:

** `appHome` - путь к домашнему каталогу приложения (подробнее см. описание задачи `buildWar`).

** `distrDir` - путь к каталогу, в который копируется содержимое дистрибутива. Это необязательный параметр, по умолчанию используется подкаталог `build/war` проекта.
+
Пример описания задачи:
+
[source, java]
----
task createWarDistr(dependsOn: [coreModule.buildWar, webModule.buildWar], type: CubaWarDistribution) {
    appHome = '${app.home}'
}
----

* `createDb` - задача типа `CubaDbCreation`, создающая базу данных приложения путем выполнения соответствующих <<db_scripts,скриптов>>. Объявляется в модуле *core*. Параметры:

** `dbms` - тип СУБД, см. <<dbms_types,Типы СУБД>>.

** `dbName` - имя базы данных. 

** `dbUser` - имя пользователя СУБД.

** `dbPassword` - пароль пользователя СУБД.

** `host` - хост и, опционально, порт СУБД в формате `host[:port]`. Если не задан, используется `localhost`. 

** `masterUrl` - URL для подключения при создании БД. Если не задан, используется значение по умолчанию, зависящее от типа СУБД и параметра `host`. 

** `dropDbSql` - команда SQL для удаления БД. Если не задана, используется значение по умолчанию, зависящее от типа СУБД. 

** `createDbSql` - команда SQL для создания БД. Если не задана, используется значение по умолчанию, зависящее от типа СУБД. 

** `driverClasspath` - список JAR файлов, содержащих JDBC драйвер. Элементы списка разделяются символом ":" на Linux и символом ";" на Windows. Если не задан, используются зависимости, входящие в конфигурацию `jdbc` данного модуля. Явное задание `driverClasspath` актуально при использовании Oracle, т.к. его JDBC драйвер не присутствует в зависимостях. 

** `oracleSystemPassword` - при использовании Oracle пароль пользователя SYSTEM.
+
Пример для PostgreSQL:
+
[source, java]
----
task createDb(dependsOn: assemble, description: 'Creates local database', type: CubaDbCreation) {
    dbms = 'postgres'
    dbName = 'sales'
    dbUser = 'cuba'
    dbPassword = 'cuba'
}
----
+
Пример для MS SQL Server:
+
[source, java]
----
task createDb(dependsOn: assemble, description: 'Creates local database', type: CubaDbCreation) {
    dbms = 'mssql'
    dbName = 'sales'
    dbUser = 'sa'
    dbPassword = 'saPass1'
}
----
+
Пример для Oracle:
+
[source, java]
----
task createDb(dependsOn: assemble, description: 'Creates database', type: CubaDbCreation) {
    dbms = 'oracle'
    host = '192.168.1.10'
    dbName = 'orcl'
    dbUser = 'sales'
    dbPassword = 'sales'
    oracleSystemPassword = 'manager'
    driverClasspath = "$tomcatDir/lib/ojdbc6.jar"
}
----

* `updateDb` - задача типа `CubaDbUpdate`, обновляющая базу данных приложения путем выполнения соответствующих <<db_scripts,скриптов>>. Аналогична задаче `createDb`, за исключением отсутствия параметров `dropDbSql` и `createDbSql`.

* `startDb` - задача типа `CubaHsqlStart`, выполняющая запуск локального сервера HSQLDB. Параметры:

** `dbName` - имя базы данных, по умолчанию `cubadb`.

** `dbDataDir` - каталог, в котором размещена база данных, по умолчанию подкаталог `data` проекта.

** `dbPort` - порт сервера, по умолчанию 9001.
+
Например: 
+
[source, java]
----
include::{sourcesdir}/development/build_gradle_startDb_1.groovy[]
---- 

* `stopDb` - задача типа `CubaHsqlStop`, выполняющая остановку локального сервера HSQLDB. Параметры аналогичны задаче `startDb`.

* `start` - задача типа `CubaStartTomcat`, выполняющая запуск локального сервера Tomcat, установленного задачей <<build.gradle_setupTomcat,setupTomcat>>. Эта задача автоматически добавляется в проект при подключении плагина *cuba*, поэтому объявлять ее в `build.gradle` не нужно.

* `stop` - задача типа `CubaStopTomcat`, выполняющая остановку локального сервера Tomcat, установленного задачей <<build.gradle_setupTomcat,setupTomcat>>. Эта задача автоматически добавляется в проект при подключении плагина *cuba*, поэтому объявлять ее в `build.gradle` не нужно.

* `restart` - задача, выполняющая остановку, <<fast_deployment,быстрое развертывание>> и старт локального сервера Tomcat.

* `debugWidgetSet` - задача типа `CubaWidgetSetDebug`, которая запускает GWT Code Server для отладки виджетов в веб-браузере.
+
Пример использования: 
+
[source, java]
----
include::{sourcesdir}/development/build_gradle_debugWidgetSet_1.groovy[]
---- 
+
Убедитесь, что кофигурация `runtime` модуля `web-toolkit` содержит зависимость от библиотеки Servlet API: 
+
[source, java]
----
include::{sourcesdir}/development/build_gradle_debugWidgetSet_2.groovy[]
---- 
+
См. <<debug_widgets,Отладка виджетов в веб-браузере>> для получения информации о том как отлаживать код в веб-браузере.

==== Запуск задач сборки

Задачи (tasks) Gradle, описанные в скриптах сборки, запускаются на исполнение следующими способами:

* Если работа с проектом ведется с помощью *CUBA Studio*, то при выполнении пунктов меню *Build* и *Run* производится подключение к демону Gradle (запущенному на старте сервера Studio), который и выполняет соответствующие задачи.

* С помощью исполняемого скрипта `gradlew` (Gradle wrapper), включенного в проект. Этот скрипт должен находится в корневом каталоге проекта, и может быть создан в Studio с помощью команды *Build* -> *Create Gradle wrapper*.

* С помощью установленного вручную Gradle версии {gradleVersion}

. В этом случае используется исполняемый скрипт `gradle`, находящийся в подкаталоге `bin` установленного Gradle.

[TIP]
====
Рекомендуется запускать команды `gradlew` или `gradle` с ключом `--daemon`, в этом случае демон Gradle остается в памяти и существенно ускоряет последующее выполнение.

Для удаления демона из памяти используется ключ `--stop`
====

Например, чтобы выполнить компиляцию Java файлов и сборку JAR файлов артефактов проекта, необходимо запустить следующую команду:

`gradlew --daemon assemble`

Рассмотрим типичные задачи сборки в обычном порядке их использования.

* `idea` - создать проектные файлы *IntelliJ IDEA*. При выполнении этой задачи из репозитория артефактов в локальный кэш *Gradle* загружаются зависимости вместе со своими исходными кодами.

* `cleanIdea` - удалить проектные файлы *IntelliJ IDEA*.

* `assemble` - выполнить компиляцию Java файлов и сборку JAR файлов артефактов проекта в подкаталогах `build` модулей.

* `clean` - удалить подкаталоги `build` всех модулей проекта.

* <<build.gradle_setupTomcat,setupTomcat>> - установить сервер *Tomcat* в путь, заданный свойством `ext.tomcatDir` скрипта `build.gradle`. 

* <<build.gradle_deploy,deploy>> - <<fast_deployment,быстрое развертывание>> приложения на сервере *Tomcat*, предварительно установленном задачей `setupTomcat`.

* <<build.gradle_createDb,createDb>> - создание базы данных приложения и выполнение соответствующих <<db_scripts,скриптов>>.

* <<build.gradle_updateDb,updateDb>> - обновление существующей базы данных приложения путем выполнения соответствующих <<db_scripts,скриптов>>.

* <<build.gradle_start,start>> - запуск сервера *Tomcat*.

* <<build.gradle_stop,stop>> - остановка запущенного сервера *Tomcat*. 

* <<build.gradle_restart,restart>> - последовательное выполнение задач `stop`, `deploy`, `start`. 

[[build_on_ci]]
==== Сборка на сервере Continuous Integration

Плагин CUBA для Gradle требует интерактивного принятия условий лицензии CUBA, если это первая сборка для данного пользователя. При автоматической сборке на CI-сервере это невозможно, поэтому существует два пути обхода интерактивного действия: 

. Создайте файл `${user.home}/.haulmont/license.properties`, где `${user.home}` - домашний каталог пользователя, от которого работает CI-сервер, и добавьте в него следующее: 
+
[source, plain]
----
accepted=true
----

. Если создание файла в домашнем каталоге нежелательно, укажите следующий параметр командной строки Gradle: 
+
[source, plain]
----
-PlicenseAgreementAccepted=true
----

[[project_creation]]
=== Создание проекта

Рекомендуемый способ создания нового проекта - использование *CUBA Studio*. Пример рассмотрен в главе <<qs_create_project,Быстрый старт>> данного руководства.

После создания проекта вы можете продолжить разрабатывать его в Studio, либо создать файлы проекта для *IntelliJ IDEA* или *Eclipse* и открыть проект в IDE.

[[db_dev]]
=== Проектирование БД

В данном разделе приведены практические рекомендации по работе с базой данных на этапе разработки приложения.

Рекомендации по работе с базой данных на стадии эксплуатации приложения приведены в <<db_update_in_prod,Создание и обновление БД при эксплуатации приложения>>.

[[db_update_in_dev]]
==== Создание схемы БД

В процессе разработки приложения возникает необходимость создания и поддержания схемы базы данных, соответствующей моделируемым сущностям. Для решения этой задачи платформа предлагает подход на основе <<db_scripts,скриптов создания и обновления БД>>. Далее рассматриваются практические шаги по применению этого подхода.

Задача по созданию и поддержке схемы БД состоит из двух частей: создание скриптов и их выполнение.

Скрипты могут быть созданы как вручную, так и с помощью Studio. Рассмотрим процесс создания скриптов в Studio. Для этого выполните команду *Generate DB scripts*, расположенную в секции *Entities*. При этом Studio подключается к базе данных, определенной на странице *Project properties*, и сравнивает имеющуюся схему БД с текущей моделью данных.

Если база данных отсутствует, либо в ней нет таблиц *SYS_DB_CHANGELOG* и *SEC_USER*, то генерируются только скрипты инициализации БД. В противном случае создаются также и скрипты обновления. Затем открывается страница, содержащая сгенерированные скрипты. 

На вкладке *Update scripts* отображаются скрипты обновления. Скрипты со статусом *new* отражают разницу между текущим состоянием модели данных и схемы БД. Для каждой создаваемой или изменяемой таблицы создается отдельный скрипт. В отдельные скрипты помещаются также наборы ограничений целостности таблиц (referential integrity constraints). При закрытии страницы нажатием *OK* скрипты сохраняются в каталог `db/update/{db_type}` модуля *core*.

Со статусом *applied* отображаются скрипты, уже имеющиеся в проекте и примененные в БД ранее. Они не могут быть отредактированы или удалены.

На вкладке *Update scripts* могут также отображаться скрипты со статусом *to be deleted*. Это файлы, имеющиеся в проекте, но не примененные в БД. При закрытии страницы нажатием *OK* эти файлы будут удалены. Это нормально, если эти скрипты были созданы вами при предыдущей генерации, но не были применены вызовом *Update database*. В этом случае они больше не нужны, так как текущая разница между схемой БД и моделью данных отражена в новых только что сгенерированных скриптах. Если же, например, эти скрипты получены вами из системы контроля версий от другого разработчика, то вам следует отменить сохранение и сначала применить чужие скрипты на своей БД, а уже потом генерировать новые.

Вкладки *Init tables*, *Init constraints*, *Init data* отображают скрипты _создания_ БД, располагающиеся в каталоге `db/init/{db_type}` модуля *core*.

На вкладке *Init tables* отображается скрипт создания таблиц `10.create-db.sql`. Код, относящийся к одной таблице, отделяется комментариями `++begin {table_name} ... end {table_name}++`. При изменении некоторой сущности в модели Studio заменит код только между комментариями для соответствующей таблицы, не трогая остальной код, в который могли быть внесены ручные изменения. Поэтому при ручном редактировании не удаляйте эти комментарии, иначе Studio не сможет правильно встраивать свои изменения в существующие файлы. 

На вкладке *Init constraints* отображается скрипт создания ограничений целостности `20.create-db.sql`. В нем также присутствуют разделяющие таблицы комментарии, которые нельзя удалять.

На вкладке *Init data* отображается скрипт `30.create-db.sql`, предназначенный для внесения дополнительной информации при инициализации БД. Это могут быть, например, функции, триггеры, или DML операторы для наполнения базы необходимыми данными. Содержимое данного скрипта создается вручную при необходимости.

[TIP]
====
На начальной стадии разработки приложения, когда модель данных активно меняется, рекомендуется пользоваться только скриптами _создания_ БД (расположенными на вкладках *Init tables*, *Init constraints*, *Init data*), а скрипты обновления на вкладке *Update scripts* удалять сразу после вызова команды *Generate DB scripts*. Это наиболее простой и надежный способ поддержания БД в актуальном состоянии. Разумеется, он имеет один существенный недостаток - при применении скриптов БД пересоздается с нуля, поэтому все внесенные в нее данные теряются. Этот недостаток можно частично компенсировать на этапе разработки, добавив в скрипт *Init data* команды для создания первичных данных при инициализации.

Скрипты _обновления_ становятся удобным и необходимым инструментом разработки и сопровождения БД на более позднем этапе, когда модель данных относительно стабильна, а в базах данных у разработчиков и в эксплуатации накоплены данные, которые нельзя терять при пересоздании БД с нуля.
====

Для применения скриптов используйте механизм <<db_update_gradle,выполнения скриптов БД задачами Gradle>>: чтобы пересоздать базу данных полностью, вызовите в главном меню пункт *Run* -> *Create database*, а чтобы применить скрипты обновления - пункт *Run* -> *Update database*. Следует иметь в виду, что эти пункты доступны, только если сервер приложения остановлен. Разумеется, соответствующие задачи Gradle (`createDb` и `updateDb`) можно вызвать в любой момент из командной строки, но если при этом база данных или какие-либо ее объекты заняты, выполнение скриптов завершится с ошибкой.

[[db_hsql_connect]]
==== Подключение к HSQLDB внешними инструментами

*HSQLDB*, он же *HyperSQL*, является удобной СУБД для прототипирования приложений, так как не требует установки, и запускается автоматически в CUBA Studio, если для проекта выбрано использование этой СУБД. В данном разделе описаны способы подключения к базе данных HSQLDB внешними инструментами, позволяющими работать со структурой и данными напрямую средствами SQL.

===== Подключение с помощью Squirrel SQL

*SQuirreL SQL Client* является свободно распространяемым Java-приложением, позволяющим работать с базами данных через JDBC. Загрузить Squirrel SQL можно по адресу link:$$http://squirrel-sql.sourceforge.net$$[http://squirrel-sql.sourceforge.net].

Запустите *Squirrel SQL* и перейдите на вкладку *Drivers*. Выделите в списке драйвер *HSQLDB Server*, нажмите на правую кнопку мыши и выберите *Modify Driver*.

image::dev_modifyDriver.png[align="center"]

Перейдите в открывшемся окне на вкладку *Extra Class Path* и нажмите на кнопку *Add*, чтобы добавить `.jar`-файл с драйвером. 

image::dev_addDriver.png[align="center"]

Далее нужно выбрать драйвер `hsqldb-x.x.x.jar`. Можно воспользоваться JAR-файлом, который поставляется вместе с *CUBA Studio* - он находится в подкаталоге `lib`.

image::dev_selectDriver.png[align="center"]

Далее создайте алиас для подключения к базе данных приложения.

image::dev_createAlias.png[align="center"]

В открывшемся окне укажите параметры подключения - Database URL, пользователя и пароль. По-умолчанию пользователь - sa, пароль отсутствует. Database URL можно найти на вкладке *Project properties* в CUBA Studio или скопировать из файла `modules/core/web/META-INF/context.xml` проекта.

image::dev_setAliasProperties.png[align="center"]

===== Подключение с помощью IntelliJ IDEA Ultimate

*IntelliJ IDEA Ultimate Edition* имеет удобные средства работы с базами данных. Рассмотрим, как подключиться к *HSQLDB* с ее помощью. Запустите *IDEA* и откройте панель *Database*. 

Создайте новый источник данных с помощью контекстного меню.

image::dev_idea_createDataSource.png[align="center"]

В открывшемся окне выберите драйвер `hsqldb-x.x.x.jar`. Можно воспользоваться JAR-файлом, который поставляется вместе с *CUBA Studio* - он находится в подкаталоге `lib`.

image::dev_idea_selectDriver.png[align="center"]

image::dev_idea_selectDriver2.png[align="center"]

Далее необходимо указать свойства источника данных: Dаtabase URL, пользователя и пароль. Database URL можно найти на вкладке *Project properties* в CUBA Studio или скопировать из файла `modules/core/web/META-INF/context.xml` проекта. По-умолчанию пользователь - sa, пароль отсутствует.

image::dev_idea_setDbProperties.png[align="center"]

[TIP]
====
Если вы используете *PostgreSQL* в качестве СУБД и `uuid` в качестве идентификатора, то при редактировании данных в *IDEA* может возникнуть ошибка `*ERROR: operator does not exist: uuid = character varying*`.

Для решения этой проблемы в настройках источника данных перейдите на вкладку *Advanced* и присвойте свойству `stringtype` значение `unspecified`.

image::dev_idea_setStringtype.png[align="center"]

====

[[db_postgres_features]]
==== Особенности PostgreSQL

Для создания базы данных PostgreSQL на Ubuntu-подобных операционных системах требуется установка пакета *postgresql-contrib*, содержащего функцию генерации UUID.

[[db_mssql_features]]
==== Особенности MS SQL Server

*Microsoft SQL Server* использует кластерные индексы для таблиц.

По умолчанию кластерный индекс создается по первичному ключу таблицы, однако используемые в CUBA-приложении ключи типа `UUID` плохо подходят для кластерного индекса. Поэтому необходимо для каждой таблицы правильно выбрать и создать кластерный индекс. Поле для кластерного индекса должно быть небольшим и монотонно возрастающим, поэтому ориентировочные правила следующие:

* Для большинства таблиц подходит поле *CREATE_TS*. При этом записи будут физически располагаться в порядке их создания. 

* Для композитных сущностей, если чтение превалирует над записью, имеет смысл использовать ссылку на владельца. При этом записи будут сгруппированы по владельцам, и их извлечение вместе с владельцем будет происходить быстрее. 

* Для небольших (< 100 записей) редко изменяемых таблиц тип кластерного индекса не важен, можно оставить *ID*.

* Для таблиц сущностей, унаследованных по стратегии `JOINED`, в которых нет поля *CREATE_TS*, нужно создать его искусственно с параметром `++default current_timestamp++`. 

Пример:

[source, sql]
----
create table SALES_CUSTOMER (
    ID uniqueidentifier not null,
    CREATE_TS datetime,
    ...
    primary key nonclustered (ID)
)^

create clustered index IDX_SALES_CUSTOMER_CREATE_TS on SALES_CUSTOMER (CREATE_TS)^
----

Пример композитной сущности: 

[source, sql]
----
create table SALES_ITEM (
    ID uniqueidentifier not null,
    CREATE_TS datetime,
    ...
    ORDER_ID uniqueidentifier,
    ...
    primary key nonclustered (ID),
    constraint FK_SALES_ITEM_ORDER foreign key (ORDER_ID) references SALES_ORDER(ID)
)^

create clustered index IDX_SALES_ITEM_ORDER on SALES_ITEM (ORDER_ID)^
----

Пример унаследованной сущности: 

[source, sql]
----
create table SALES_DOC (
    CARD_ID uniqueidentifier,
    CREATE_TS datetime default current_timestamp,
    NUMBER varchar(50),
    primary key nonclustered (CARD_ID),
    constraint FK_SALES_DOC_CARD foreign key (CARD_ID) references WF_CARD (ID)
)^

create clustered index IDX_SALES_DOC_CREATE_TS on SALES_DOC (CREATE_TS)^

create index IDX_SALES_DOC_CARD on SALES_DOC (CARD_ID)^
----

[[db_oracle_features]]
==== Особенности Oracle Database

В связи с политикой распространения JDBC драйвера Oracle его можно скачать только вручную с сайта link:$$http://www.oracle.com/technetwork/database/features/jdbc/index-091264.html$$[http://www.oracle.com/technetwork/database/features/jdbc/index-091264.html]. После скачивания скопируйте JAR с драйвером `ojdbc6.jar` в подкаталог `lib` *Studio* и подкаталог `lib` установленного сервера *Tomcat*. После этого необходимо остановить Studio, остановить демона Gradle, выполнив в командной строке `gradle --stop`, а затем снова запустить Studio.

[[logging]]
=== Логгирование

Для ведения логов в платформе используется фреймворк *Apache Log4j* версии 1.2.

Для вывода в лог рекомендуется использовать *Commons Logging* API, получая логгер по имени текущего класса. Пример создания логгера и вывода в него:

[source, java]
----
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

public class ...

    private Log log = LogFactory.getLog(getClass()); // create logger

    private void someMethod() {
        log.debug("someMethod invoked"); // output message with DEBUG level
    }
---- 

Настройка логгирования для <<app_tiers,блоков>> *Middleware*, *Web Client* и *Web Portal* производится на уровне сервера приложения - в варианте <<fast_deployment,быстрого развертывания>> это Tomcat. Блок *Desktop Client* имеет самостоятельную настройку логгирования.

[[logging_setup_tomcat]]
==== Настройка логгирования в Tomcat

При выполнении задачи Gradle <<build.gradle_setupTomcat,setupTomcat>> в каталог проекта устанавливается сервер Tomcat, и производится его дополнительная конфигурация. В частности, в подкаталоге `tomcat/bin` создаются файлы `setenv.bat` и `setenv.sh`, а в подкаталоге `tomcat/conf` файл `log4j.xml`.

Файлы `setenv.*` в переменной `++CATALINA_OPTS++` в числе прочего устанавливают параметры загрузки конфигурационного файла `log4j.xml`.

Файл `log4j.xml` определяет конфигурацию логгирования. Рассмотрим структуру этого файла.

* Элементы `appender` задают "устройства вывода" логов. Основными аппендерами являются `FILE` и `CONSOLE`. В параметре `Threshold` аппендера можно задать порог уровня сообщения. По умолчанию порог для файла - `DEBUG`, для консоли - `INFO`. Это означает, что в файл выводятся сообщения с уровнями `ERROR`, `WARN`, `INFO`, `DEBUG`, а в консоль - с уровнями `ERROR`, `WARN` и `INFO`.
+
Для файлового аппендера в параметре `File` задается путь к файлу лога, а в параметре `Append` - признак, стирать ли содержимое файла при перезапуске сервера, или добавлять в конец. Настройки по умолчанию задают файл `tomcat/logs/app.log` и режим стирания при перезапуске. На этапе эксплуатации приложения рекомендуется установить для параметра `Append` значение `true`.
+
Файловый аппендер по умолчанию реализуется классом `org.apache.log4j.DailyRollingFileAppender`, который ежедневно в 00:00:00 переименовывает накопившийся за день файл лога в имя с прошедшей датой, и начинает новый лог. Это позволяет избежать создания слишком больших файлов логов.

* Элементы `category` задают параметры логгеров, через которые производится посылка сообщений из кода программы. Имена категорий иерархические, то есть например настройки для категории `com.company.sample` влияют на логгеры `com.company.sample.core.CustomerServiceBean`, `com.company.sample.web.CustomerBrowse`, если для них явно не заданы собственные настройки.
+
Минимальный уровень указывается в элементе `priority`. Например, если для категории задан приоритет `INFO`, то сообщения с уровнями `DEBUG` и `TRACE` выводиться не будут. Следует иметь в виду, что на вывод сообщения также влияет порог уровня, заданный в аппендере.

Оперативно изменять уровни для категорий и пороги аппендеров для работающего сервера можно с помощью экрана *Администрирование* -> *Журнал сервера*, доступного в веб клиенте. Сделанные настройки логгирования действуют только в текущем сеансе работы сервера и в файл не сохраняются. Этот экран позволяет также просматривать и загружать файлы логов из <<log_dir,каталога журналов>> сервера `tomcat/logs`.

Платформа автоматически добавляет к сообщениям, выводимым в лог, следующую информацию:

* `*[приложение]*` - имя веб приложения, развернутого в Tomcat, код которого выводит данное сообщение. Эта информация помогает различить сообщения от разных блоков приложения (*Middleware*, *Web Client*), так как они выводятся в один файл.

* `*[пользователь]*` - логин пользователя приложения, от имени которого в данный момент работает код, выводящий сообщение. Это позволяет в общем логе отслеживать активность конкретных пользователей. Если код, выводящий сообщение, не связан в момент вывода с пользовательской сессией, информация о пользователе не выводится.

Например, следующее сообщение в логе выведено кодом блока *Middleware* (`*app-core*`), работающим от имени пользователя `*admin*`:

[source, plain]
----
2013-12-19 18:48:17,282 DEBUG [com.haulmont.cuba.core.app.DataManagerBean] [app-core] [admin] loadList: metaClass=sec$User, view=com.haulmont.cuba.security.entity.User/user.browse, query=select u from sec$User u, max=100
----

[[logging_setup_desktop]]
==== Настройка логгирования в десктоп клиенте

Для десктоп клиента файл `log4j.xml` должен находиться в каталоге исходников модуля *desktop* проекта. При сборке приложения он упаковывается в соответствующий JAR файл и доступен в CLASSPATH. 

Для настройки логгирования в своем проекте выполните следующее:

* Создайте в каталоге `src` модуля *desktop* новый файл, например, `sample-log4j.xml`, и скопируйте в него содержимое файла `cuba-log4j.xml`. Файл `cuba-log4j.xml` находится внутри одного из JAR-файлов платформы и его легко найти поиском в IDE, если правильно сконфигурированы базовые проекты.

* Установите путь к файлу лога в параметре `File` аппендера `FILE`.

* Добавьте настройки для категорий логгеров вашего проекта.

* В классе-наследнике `com.haulmont.cuba.desktop.App` вашего проекта, например `SampleApp`, переопределите метод `getDefaultLog4jConfig()` и верните в нем путь относительно корня CLASSPATH к вашему файлу настроек. Например:
+
[source, java]
----
public class SampleApp extends App {
...
    @Override
    protected String getDefaultLog4jConfig() {
        return "sample-log4j.xml";
    }
----

* При необходимости можно переопределить местонахождение файла конфигурации на старте приложения с помощью системного свойства `<<log4j.configuration,log4j.configuration>>`.

[[debug_and_testing]]
=== Отладка и тестирование

В данном разделе рассмотрены различные аспекты отладки и тестирования CUBA-приложений.

[[debug_setup]]
==== Подключение отладчика

Запустить сервер Tomcat в режиме отладки можно либо выполнением команды сборки

`gradle start`

либо запуском командного файла `bin/debug.*` установленного *Tomcat*.

После этого сервер будет принимать подключения отладчика на порту 8787. Порт можно изменить в файле `bin/setenv.*` в переменной `++JPDA_OPTS++`.

Для пошаговой отладки в *Intellij IDEA* необходимо в проекте приложения создать новый элемент *Run/Debug Configuration* типа *Remote*, и в его поле *Port* указать 8787.

[[debug_widgets]]
==== Отладка виджетов в веб-браузере

Для отладки виджетов на стороне браузера можно использовать *GWT Super Dev Mode*.

. Настройте задачу <<build.gradle_debugWidgetSet,debugWidgetSet>> в `build.gradle`. Настройте задачу <<build.gradle_debugWidgetSet,debugWidgetSet>> в `build.gradle`. 

. Разверните приложение и запустите Tomcat.Разверните приложение и запустите Tomcat.

. Запустите задачу `debugWidgetSet`:
+
`gradlew debugWidgetSet`
+
GWT Code Server будет перекомпилировать ваш widgetset при изменениях кода виджетов.Запустите задачу `debugWidgetSet`:
+
`gradlew debugWidgetSet`
+
GWT Code Server будет перекомпилировать ваш widgetset при изменениях кода виджетов.

. Откройте страницу `http://localhost:8080/app?debug&superdevmode` в браузере Chrome и подождите пока widgetset будет построен первый раз.

. Откройте консоль отладки браузера: 
+
image::debugWidgetSet_chrome_console.png[align="center"]

. После изменения Java-кода в модуле `web-toolkit` обновляйте страницу в браузере. Widgetset будет инкрементально перестраиваться примерно за 8-10 секунд.

[[testing]]
==== Тестирование

[[unit_tests]]
===== Модульные тесты

Модульные тесты (unit tests) можно создавать и выполнять и на <<app_tiers,уровне>> *Middleware*, и на клиентском уровне. Для этого платформа включает в себя фреймворки link:$$http://junit.org$$[JUnit] и link:$$http://code.google.com/p/jmockit$$[JMockit].

Допустим, имеется следующий контроллер экрана:

[source, java]
----
public class OrderEditor extends AbstractEditor {

    @Named("itemsTable.add")
    protected AddAction addAction;

    @Override
    public void init(Map<String, Object> params) {
        addAction.setWindowId("sales$Product.lookup");
        addAction.setHandler(new Lookup.Handler() {
            @Override
            public void handleLookup(Collection items) {
                // some code
            }
        });
    }
}
----

Тогда можно написать следующий тест, проверяющий работу метода `init()`:

[source, java]
----
public class OrderEditorTest {

    OrderEditor editor;

    @Mocked
    Window.Editor frame;

    @Mocked
    AddAction addAction;

    @Before
    public void setUp() throws Exception {
        editor = new OrderEditor();
        editor.setWrappedFrame(frame);
        editor.addAction = addAction;
    }

    @Test
    public void testInit() {
        editor.init(Collections.<String, Object>emptyMap());
        editor.setItem(new Order());

        new Verifications() {
            {
                addAction.setWindowId("sales$Product.lookup");
                addAction.setHandler(withInstanceOf(Window.Lookup.Handler.class));
            }
        };
    }
}
----

[[integration_tests_mw]]
===== Интеграционные тесты Middleware

На уровне *Middleware* можно создавать интеграционные тесты, которые выполняются в полнофункциональном контейнере *Spring* с подключением к базе данных. В тестах такого типа можно выполнять код любого слоя внутри *Middleware* - от сервисов до ORM. 

Для создания интеграционных тестов в модуле *core* проекта приложения должен быть создан базовый класс - наследник `CubaTestCase`. В этом классе должны быть переопределены методы инициализации доступа к данным и получения списка файлов конфигурации. Например: 

[source, java]
----
public class SalesTestCase extends CubaTestCase {

    @Override
    protected void initDataSources() throws Exception {
        Class.forName("org.postgresql.Driver");
        TestDataSource ds = new TestDataSource("jdbc:postgresql://localhost/sales_test", "cuba", "cuba");
        TestContext.getInstance().bind("java:comp/env/jdbc/CubaDS", ds);
    }

    @Override
    protected List<String> getTestAppProperties() {
        String[] files = {
                "cuba-app.properties",
                "app.properties",
                "test-app.properties",
        };
        return Arrays.asList(files);
    }
}
----

В качестве базы данных рекомендуется использовать отдельную тестовую БД, которую можно создавать, например, следующей задачей в `build.gradle`: 

[source, java]
----
configure(coreModule) {
...
    task createTestDb(dependsOn: assemble, description: 'Creates local Postgres database for tests', type: CubaDbCreation) {
        dbms = 'postgres'
        dbName = 'sales_test'
        dbUser = 'cuba'
        dbPassword = 'cuba'
    }
----

Класс `CubaTestCase` содержит следующие поля и методы, которые можно использовать в коде тестов:

* `persistence` - ссылка на интерфейс `<<persistence,Persistence>>`

* `metadata` - ссылка на интерфейс `<<metadata,Metadata>>`

* `deleteRecord()` - метод, который удобно использовать в `tearDown()` для удаления тестовых объектов из БД.

Пример теста, проверяющего чтение сущностей из базы данных:

[source, java]
----
public class CustomerLoadTest extends SalesTestCase {

    private UUID customerId;

    @Override
    public void setUp() throws Exception {
        super.setUp();
        persistence.createTransaction().execute(new Transaction.Runnable() {
            @Override
            public void run(EntityManager em) {
                Customer customer = new Customer();
                customerId = customer.getId();
                customer.setName("testCustomer");
                em.persist(customer);
            }
        });
    }

    @Override
    public void tearDown() throws Exception {
        deleteRecord("SALES_CUSTOMER", customerId);
        super.tearDown();
    }

    public void test() {
        Transaction tx = persistence.createTransaction();
        try {
            EntityManager em = persistence.getEntityManager();
            TypedQuery<Customer> query = em.createQuery(
                "select c from sales$Customer c", Customer.class);
            List<Customer> list = query.getResultList();
            tx.commit();
            assertTrue(list.size() > 0);
        } finally {
            tx.end();
        }
    }
}
----

[[integration_tests_client]]
===== Интеграционные тесты клиентского уровня

Интеграционные тесты на клиентском уровне реализуются с применением фреймворка link:$$http://code.google.com/p/jmockit$$[JMockit]. С его помощью тест изолируется от *Middleware*, а также создаются необходимые объекты инфраструктуры.

Класс клиентского интеграционного теста должен быть унаследован от `CubaClientTestCase`. В методе `@Before` необходимо вызвать унаследованные методы `addEntityPackage()`, `setViewConfig()` и затем `setupInfrastructure()` для создания объектов `<<metadata,Metadata>>` и `<<configuration,Configuration>>` и развертывания метаданных по выбранным сущностям. Далее в методе `@Before` можно дополнить инфраструктуру необходимыми мок-объектами с помощью конструкции `Expectations` или `NonStrictExpectations`.

Пример инициализирующего метода `@Before` одного из тестов платформы:

[source, java]
----
@Before
public void setUp() throws Exception {
    addEntityPackage("com.haulmont.cuba.security.entity");
    addEntityPackage("com.haulmont.cuba.core.entity");
    addEntityPackage("com.haulmont.cuba.gui.data.impl.testmodel1");
    setViewConfig("/com/haulmont/cuba/gui/data/impl/testmodel1/test-views.xml");
    setupInfrastructure();

    metadataSession = metadata.getSession();
    dataSupplier = new TestDataSupplier();

    dataSupplier.commitCount = 0;

    new NonStrictExpectations() {
        @Mocked ClientConfig clientConfig;
        @Mocked PersistenceHelper persistenceHelper;
        {
            configuration.getConfig(ClientConfig.class); result = clientConfig;

            clientConfig.getCollectionDatasourceDbSortEnabled(); result = true;

            persistenceManager.getMaxFetchUI(anyString); result = 10000;

            PersistenceHelper.isNew(any); result = false;
        }
    };
}
----

[[dev_recipes]]
=== Рецепты разработки

В данном разделе рассматриваются способы решения некоторых практических задач. 

[[getting_messages]]
==== Получение локализованных сообщений

В данном разделе рассмотрены способы получения <<localization,локализованных сообщений>> в различных компонентах приложения.

* В <<screen_xml,XML-дескрипторах>> экранов атрибуты компонентов, отображающие статичный текст (например <<gui_attr_basic_caption,caption>>), могут обращаться к локализованным сообщениям по правилам метода <<messageTools.loadString,MessageTools.loadString()>>. Например:

** `caption="msg://roleName"` - получить сообщение, заданное ключом `roleName` в пакете сообщений текущего экрана. Пакет сообщений экрана задается в атрибуте `messagesPack` корневого элемента `window`.

** `caption="msg://com.company.sample.entity/Role.name"` - получить сообщение, заданное ключом `Role.name` в пакете сообщений `com.company.sample.entity`.

* В <<screen_controller,контроллерах экранов>> локализованные сообщения можно получать следующими способами:

** Из пакета сообщений текущего экрана:

*** Методом `getMessage()`, унаследованным от базового класса <<abstractFrame,AbstractFrame>>. Например:
+
[source, java]
----
String msg = getMessage("warningMessage");
----

*** Методом `formatMessage()`, унаследованным от базового класса `AbstractFrame`. В этом случае сообщение используется для форматирования переданных параметров по правилам метода `String.format()`. Например:
+
messages.properties:
+
[source, plain]
----
warningMessage = Invalid email address: '%s'
----
+
Java-контроллер:
+
[source, java]
----
String msg = formatMessage("warningMessage", email);
----

** Из произвольного пакета сообщений путем инжекции интерфейса инфраструктуры <<messages,Messages>>. Например:
+
[source, java]
----
@Inject
private Messages messages;

@Override
public void init(Map<String, Object> params) {
    String msg = messages.getMessage(getClass(), "warningMessage");
    ...
} 
----

* В компонентах, управляемых контейнером Spring (<<managed_beans,управляемых бинах>>, <<services,сервисах>>, <<jmx_beans,JMX-бинах>>, контроллерах Spring MVC модуля *portal*) локализованные сообщения можно получать путем инжекции интерфейса инфраструктуры <<messages,Messages>>:
+
[source, java]
----
@Inject
protected Messages messages;
...
String msg = messages.getMessage(getClass(), "warningMessage");
----

* В любом коде приложения, где невозможна инжекция, интерфейс `Messages` может быть получен с помощью статического метода `get()` класса `AppBeans`:
+
[source, java]
----
protected Messages messages = AppBeans.get(Messages.class);
...
String msg = messages.getMessage(getClass(), "warningMessage");
----

[[init_values]]
==== Присвоение начальных значений

Присвоение начальных значений атрибутам новых экземпляров сущностей можно производить несколькими способами.

[[init_values_in_class]]
===== Инициализация полей сущности

Атрибуты простых типов (`Boolean`, `Integer` и т.д.) можно инициализировать прямо в объявлении соответствующего поля класса сущности, например: 

[source, java]
----
public class User extends StandardEntity {
...
    @Column(name = "ACTIVE")
    protected Boolean active = true;
...
}
----

Кроме того, в классе сущности можно создать специальный метод инициализации и добавить ему аннотацию <<postConstruct_entity_annotation,@PostConstruct>>. В этом случае в процессе инициализации можно использовать вызов любых глобальных <<infrastructure_interfaces,интерфейсов инфраструктуры>> и <<managed_beans,бинов>>, например: 

[source, java]
----
public class MyEntity extends StandardEntity {
...
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "USER_ID")
    protected User creator;
...
    @PostConstruct
    protected void init() {
       setCreator(AppBeans.get(UserSessionSource.class).getUserSession().getUser());
    }
}
----

[[init_values_in_CreateAction]]
===== Инициализация с помощью CreateAction

Если начальное значение атрибута зависит от данных вызывающего экрана, то можно воспользоваться методом `setInitialValues()` класса <<createAction,CreateAction>>.

Рассмотрим для примера две связанные сущности:

image::init_values_recipe_1.png[align="center"]

Фрагмент XML-дескриптора экрана, отображающего одновременно списки обоих сущностей:

[source, xml]
----
<dsContext>
    <collectionDatasource id="typesDs"
                          class="com.haulmont.sample.entity.DeviceType"
                          view="_local">
        <query>
            select e from sample$DeviceType e
        </query>
    </collectionDatasource>
    <collectionDatasource id="descriptionsDs"
                          class="com.haulmont.sample.entity.DeviceDescription"
                          view="_local">
        <query>
            select e from sample$DeviceDescription e where e.deviceType.id = :ds$typesDs
        </query>
    </collectionDatasource>
</dsContext>
<layout>
...
        <table id="typeTable">
            <actions>
                <action id="create"/>
                <action id="edit"/>
                <action id="remove"/>
            </actions>
            <columns>
                <column id="name"/>
            </columns>
            <rows datasource="typesDs"/>
        </table>
...
        <table id="descriptionTable">
            <actions>
                <action id="create"/>
                <action id="edit"/>
                <action id="remove"/>
            </actions>
            <columns>
                <column id="description"/>
            </columns>
            <rows datasource="descriptionsDs"/>
        </table>
    </split>
</layout>
----

Контроллер этого экрана:

[source, java]
----
public class DeviceTypeBrowse extends AbstractLookup {

    @Inject
    private CollectionDatasource<DeviceType, UUID> typesDs;

    @Named("descriptionTable.create")
    private CreateAction descrCreateAction;

    @Override
    public void init(Map<String, Object> params) {
        typesDs.addListener(new CollectionDsListenerAdapter<DeviceType>() {
            @Override
            public void itemChanged(Datasource<DeviceType> ds, @Nullable DeviceType prevItem, @Nullable DeviceType item) {
                descrCreateAction.setInitialValues(Collections.<String, Object>singletonMap("deviceType", item));
            }
        });
    }
}
----

В контроллере источнику данных `typesDs` добавляется слушатель на событие изменения выбранной записи. При смене выбранной записи вызывается метод `setInitialValues()` действия, и ему передается мэп с одним элементом, ключом которого является навание атрибута - `deviceType`, а значением - выбранный экземпляр `DeviceType`. Таким образом при выполнении действия `CreateAction` в атрибуте `deviceType` нового экземпляра `DeviceDescription` будет сразу установлен выбранный в таблице экземпляр `DeviceType`.

[[init_values_in_initNewItem]]
===== Использование метода initNewItem

Начальные значения можно также задать в контроллере экрана создаваемой сущности в методе <<initNewItem,initNewItem()>>.

В качестве примера рассмотрим следующую задачу: в проекте имеется сущность `Employee` (сотрудник компании), которая должна быть связана один-к-одному с платформенной сущностью `User` (пользователь системы). При создании сотрудника должен создаваться новый экземпляр пользователя.

image::init_values_recipe_2.png[align="center"]

В XML-дескрипторе экрана редактирования сотрудника объявляем источник данных для экземпляра сотрудника и вложенный источник - для связанного пользователя:

[source, xml]
----
<dsContext>
    <datasource id="employeeDs"
                class="com.haulmont.sample.entity.Employee"
                view="employee-edit">
        <datasource id="userDs"
                    property="user"/>
    </datasource>
</dsContext>
----

В контроллере экрана редактирования сотрудника определяем:

[source, java]
----
@Inject
private Metadata metadata;

private Group defaultGroup;
private Role defaultRole;

@Override
protected void initNewItem(Employee item) {
    User user = metadata.create(User.class);
    user.setGroup(defaultGroup);
    final UserRole userRole = metadata.create(UserRole.class);
    userRole.setUser(user);
    userRole.setRole(defaultRole);
    getDsContext().addListener(new DsContext.CommitListenerAdapter() {
        @Override
        public void beforeCommit(CommitContext context) {
            context.getCommitInstances().add(userRole);
        }
    });
    item.setUser(user);
}
----

Здесь в методе `initNewItem()` создается новый экземпляр `User`, и для него устанавливается некоторая группа доступа `defaultGroup`. Связь с ролью `defaultRole` устанавливается с помощью нового экземпляра сущности `UserRole`. Для сохранения этой связи в БД при коммите экрана, экземпляр `UserRole` добавляется в коллекцию сохраняемых сущностей в методе `beforeCommit()` слушателя <<dsContext,DsContext.CommitListener>>. 

Новый экземпляр `User` устанавливается в соответствующем атрибуте редактируемой сущности `Employee`, и тем самым оказывается во вложенном источнике данных `userDs`. Это дает возможность редактировать нужные атрибуты пользователя в экране сотрудника, а также приводит к автоматическому сохранению экземпляра пользователя при коммите экрана в одной транзакции с остальными сущностями.

[[composition_recipe]]
==== Редактирование композитных сущностей

Платформа CUBA поддерживает два типа связи между сущностями: ассоциацию и композицию. В интерфейсе *CUBA Studio* они названы соответственно ASSOCIATION и COMPOSITION. Ассоциация - это связь между объектами, которые могут существовать отдельно друг от друга. Композиция же используется для связи типа "master-detail" когда экземпляры detail существуют только в составе master. Примером композиции может служить связь аэропорта и терминалов: терминал, не относящийся ни к какому аэропорту, не имеет смысла.

Как правило, редактирование сущностей, входящих в состав композиции, удобно осуществлять совместно. То есть, например, пользователь открывает экран редактирования аэропорта, видит в нем список терминалов, может создавать и редактировать их, но все изменения, как аэропорта, так и терминалов, сохраняются в базу данных вместе в одной транзакции, и только тогда, когда пользователь подтвердит сохранение главной сущности - аэропорта.

===== Реализация композиции

Рассмотрим реализацию композиции на примере сущностей `Airport` и `Terminal`:

image::composition_recipe_1.png[align="center"]

. Сущность `Terminal` содержит обязательную ссылку на `Airport`:
+
[source, java]
----
@Entity(name = "sample$Terminal")
@Table(name = "SAMPLE_TERMINAL")
public class Terminal extends StandardEntity {
...    
    @ManyToOne(optional = false, fetch = FetchType.LAZY)
    @JoinColumn(name = "AIRPORT_ID")
    private Airport airport;

    public Airport getAirport() {
        return airport;
    }

    public void setAirport(Airport airport) {
        this.airport = airport;
    }
}
----

. Сущность `Airport` содержит one-to-many коллекцию терминалов. Соответствующее поле помечается аннотацией <<composition_annotation,@Composition>> для огранизации композиции и <<onDelete_annotation,@OnDelete>> для каскадного мягкого удаления:
+
[source, java]
----
@Entity(name = "sample$Airport")
@Table(name = "SAMPLE_AIRPORT")
public class Airport extends StandardEntity {
...
    @OneToMany(fetch = FetchType.LAZY, mappedBy = "airport")
    @OnDelete(DeletePolicy.CASCADE)
    @Composition
    protected List<Terminal> terminals;

    public List<Terminal> getTerminals() {
        return terminals;
    }

    public void setTerminals(List<Terminal> terminals) {
        this.terminals = terminals;
    }
}
----
. <<views,Представление>>, используемое в экране редактирования аэропорта, должно содержать атрибут-коллецию `terminals`:
+
[source, xml]
----
<view entity="sample$Airport" name="airport-edit" extends="_local">
    <property name="terminals" view="_local"/>
</view>
----
+
Для сущности `Terminal` здесь выбрано представление `++_local++`, хотя она содержит ссылочный атрибут `airport` - ссылку на аэропорт. Дело в том, что атрибут `airport` устанавливается только при создании нового экземпляра `Terminal`, и не меняется в дальнейшем, поэтому загружать его не обязательно.

. В XML-дескрипторе экрана редактирования аэропорта определяем источники данных для экземпляра `Airport` и коллекции его терминалов:
+
[source, xml]
----
<dsContext>
    <datasource id="airportDs"
                class="com.haulmont.sample.entity.Airport"
                view="airport-edit">
        <collectionDatasource id="terminalsDs" property="terminals"/>
    </datasource>
</dsContext>
----

. В XML-дескрипторе экрана редактирования аэропорта определяем таблицу, отображающую терминалы, и <<list_actions,стандартные действия>> для нее:
+
[source, xml]
----
<table id="terminalsTable">
    <actions>
        <action id="create"/>
        <action id="edit"/>
        <action id="remove"/>
    </actions>
    <buttonsPanel>
        <button action="terminalsTable.create"/>
        <button action="terminalsTable.edit"/>
        <button action="terminalsTable.remove"/>
    </buttonsPanel>
    <columns>
        <column id="code"/>
        <column id="name"/>
        <column id="address"/>
    </columns>
    <rows datasource="terminalsDs"/>
</table>
----

. В экране редактирования терминала достаточно определить стандартные элементы: `datasource` для экземпляра `Terminal` и визуальные компоненты, связанные с этим `datasource`, для редактирования атрибутов терминала.

В результате редактирование экземпляра аэропорта работает следующим образом:

* В экране редактирования аэропорта отображается таблица терминалов.

* Пользователь может выбрать терминал и открыть экран его редактирования. При нажатии *OK* в экране редактирования терминала измененный экземпляр терминала сохраняется не в базу данных, а в источник данных `terminalsDs` экрана редактирования аэропорта. 

* Пользователь может создавать новые или удалять терминалы - все изменения сохраняются в источнике данных `terminalsDs`.

* Пользователь нажимает *OK* в экране редактирования аэропорта, и измененный `Airport` вместе со всеми измененными экземплярами `Terminal` отправляется на Middleware в метод <<dataManager,DataManager>>.commit() и сохраняется в базе данных в рамках одной транзакции. 

===== Глубокая композиция

Композиция может быть более глубокой, то есть состоять из нескольких уровней вложенности. Усложним приведенный выше пример, добавив сущность `MeetingPoint`, описывающую место встречи у терминала аэропорта:

image::composition_recipe_2.png[align="center"]

Теперь сущность `Terminal` содержит атрибут `meetingPoints` - коллекцию экземпляров `MeetingPoint`. Для того, чтобы все три сущности представляли собой единую композицию и редактировались совместно, нужно в дополнение к описанному в предыдущем разделе выполнить следующее:

. Атрибуту `meetingPoints` класса `Terminal` добавить аннотации `@Composition` и `@OnDelete` аналогично атрибуту `terminals` класса `Airport`.

. Создать новое представление для `Terminal`:
+
[source, xml]
----
<view entity="sample$Terminal" name="terminal-edit" extends="_local">
    <property name="meetingPoints" view="_local"/>
</view>
----
+
И использовать его в представлении `Airport` вместо `++_local++`:
+
[source, xml]
----
<view entity="sample$Airport" name="airport-edit" extends="_local">
    <property name="terminals" view="terminal-edit"/>
</view>
----

. В XML-дескрипторе экрана редактирования аэропорта определить источники данных для экземпляра `Airport` и вложенных сущностей на всю глубину композиции:
+
[source, xml]
----
<dsContext>
    <datasource id="airportDs"
                class="com.haulmont.sample.entity.Airport"
                view="airport-edit">
        <collectionDatasource id="terminalsDs" property="terminals">
            <collectionDatasource id="meetingPointsDs" property="meetingPoints"/>
        </collectionDatasource>  
    </datasource>
</dsContext>
----
+
Здесь источник данных `meetingPointsDs` не связан ни с какими визуальными компонентами, однако он необходим для корректной работы совместного редактирования композиции.

. В XML-дескрипторе экрана редактирования терминала в свою очередь определить для коллекции `meetingPoints` вложенный источник данных и соответствующую таблицу.

В результате измененные эземпляры `MeetingPoint`, так же как и экземпляры `Terminal`, будут сохраняться в базу данных только вместе с экземпляром `Airport` в одной транзакции.

[[app_start_recipe]]
==== Выполнение кода на старте приложения

Иногда бывает необходимо выполнить некоторый код сразу после старта приложения в момент, когда все механизмы гарантированно работоспособны. Для этого можно воспользоваться слушателем <<appContext,AppContext.Listener>>.

Рассмотрим следующую задачу: в проекте имеется сущность `Employee` (сотрудник компании), которая связана один-к-одному с платформенной сущностью `User` (пользователь системы):

image::init_values_recipe_2.png[align="center"]

Если атрибут `name` сущности `User` изменяется, например через стандартный экран управления пользователями, необходимо, чтобы изменялся также и атрибут `name` связанной сущности `Employee`. Это обычная задача для "денормализованных" данных, и решается она, как правило, с использованием <<entity_listeners,entity listeners>>. В данном случае ситуация осложняется тем, что необходимо отслеживать изменения не проектной, а платформенной сущности `User`, и добавить entity listener с помощью аннотации <<listeners_annotation,@Listeners>> невозможно. Однако, можно добавить listener динамически через бин `EntityListenerManager`, и сделать это лучше всего на старте приложения.

Для этого создадим в модуле *core* приложения бин `AppLifecycle`, имплементирующий интерфейс `AppContext.Listener`, и зарегистрируем его вызовом метода `AppContext.addListener()` в конструкторе объекта:

[source, java]
----
@ManagedBean("sample_AppLifecycle")
public class AppLifecycle implements AppContext.Listener {

    @Inject
    private EntityListenerManager entityListenerManager;

    public AppLifecycle() {
        AppContext.addListener(this);
    }

    @Override
    public void applicationStarted() {
        entityListenerManager.addListener(User.class, UserEntityListener.class);
    }

    @Override
    public void applicationStopped() {
    }

    public static class UserEntityListener implements BeforeUpdateEntityListener<User> {
        @Override
        public void onBeforeUpdate(User user) {
            Persistence persistence = AppBeans.get(Persistence.class);
            if (persistence.getTools().getDirtyFields(user).contains("name")) {
                EntityManager em = persistence.getEntityManager();
                TypedQuery<Employee> query = em.createQuery(
                        "select e from sample$Employee e where e.user.id = ?1", Employee.class);
                query.setParameter(1, user.getId());
                Employee employee = query.getFirstResult();
                if (employee != null) {
                    employee.setName(user.getName());
                }
            }
        }
    }
}
----

В результате сразу после старта <<app_tiers,блока>> Middleware будет вызван метод `applicationStarted()` данного бина. В этом методе в качестве entity listener сущности `User` регистрируется внутренний класс `UserEntityListener`. 

Метод `onBeforeUpdate()` класс `UserEntityListener` будет вызываться перед каждым сохранением изменений экземпляров `User` в базу данных. В методе проверяется, есть ли атрибут `name` среди измененных, и если да, загружается связанный экземпляр ` Employee`, и в нем устанавливается это же значение `name`.

[[images_recipe]]
==== Загрузка и вывод изображений

Рассмотрим задачу загрузки, хранения и отображения фотографий сотрудников:

* Сотрудник представлен сущностью `Employee`.

* Файлы изображений хранятся в <<file_storage,FileStorage>>. Сущность `Employee` содержит ссылку на соответствующий `FileDescriptor`.

* Экран редактирования `Employee` отображает фотографию, а также дает возможность загрузить, выгрузить и очистить изображение.

Класс сущности со ссылкой на файл изображения:

[source, java]
----
@Table(name = "SAMPLE_EMPLOYEE")
@Entity(name = "sample$Employee")
public class Employee extends StandardEntity {
...
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "IMAGE_FILE_ID")
    protected FileDescriptor imageFile;

    public void setImageFile(FileDescriptor imageFile) {
        this.imageFile = imageFile;
    }

    public FileDescriptor getImageFile() {
        return imageFile;
    }
}
----

Фрагмент XML-дескриптора экрана редактирования `Employee`:

[source, xml]
----
<groupBox caption="Photo" spacing="true"
          height="250px" width="250px" expand="embeddedImage">
        <embedded id="embeddedImage" width="100%"
                  align="MIDDLE_CENTER"/>
    <hbox align="BOTTOM_LEFT"
          spacing="true">
        <upload id="uploadField"/>
        <button id="downloadImageBtn"
                caption="Download"
                invoke="onDownloadImageBtnClick"/>
        <button id="clearImageBtn"
                caption="Clear"
                invoke="onClearImageBtnClick"/>
    </hbox>
</groupBox>
----

Компоненты отображения и загрузки/выгрузки фотографии заключены внутрь контейнера <<gui_GroupBoxLayout,groupBox>>. В верхней его части с помощью компонента <<gui_Embedded,embedded>> выводится изображение, а в нижней слева направо расположены компонент <<gui_FileUploadField,upload>> для загрузки файла и <<gui_Button,кнопки>> выгрузки и очистки изображения. В результате эта часть экрана должна выглядеть следующим образом:

image::images_recipe.png[align="center"]

Теперь рассмотрим <<abstractEditor,контроллер экрана редактирования>>.

[source, java]
----
public class EmployeeEdit extends AbstractEditor<Employee> {

    private Log log = LogFactory.getLog(EmployeeEdit.class);

    @Inject
    private DataSupplier dataSupplier;
    @Inject
    private FileStorageService fileStorageService;
    @Inject
    private FileUploadingAPI fileUploading;
    @Inject
    private ExportDisplay exportDisplay;

    @Inject
    private Embedded embeddedImage;
    @Inject
    private FileUploadField uploadField;
    @Inject
    private Button downloadImageBtn;
    @Inject
    private Button clearImageBtn;
    @Inject
    private Datasource<Employee> employeeDs;

    private static final int IMG_HEIGHT = 190;
    private static final int IMG_WIDTH = 220;

    @Override
    public void init(Map<String, Object> params) {
        uploadField.addListener(new FileUploadField.ListenerAdapter() {
            @Override
            public void uploadSucceeded(Event event) {
                FileDescriptor fd = uploadField.getFileDescriptor();
                try {
                    fileUploading.putFileIntoStorage(uploadField.getFileId(), fd);
                } catch (FileStorageException e) {
                    throw new RuntimeException(e);
                }
                getItem().setImageFile(dataSupplier.commit(fd, null));
                displayImage();
            }

            @Override
            public void uploadFailed(Event event) {
                showNotification("Upload failed", NotificationType.HUMANIZED);
            }
        });

        employeeDs.addListener(new DsListenerAdapter<Employee>() {
            @Override
            public void valueChanged(Employee source, String property, 
                                     @Nullable Object prevValue, @Nullable Object value) {
                if ("imageFile".equals(property)) {
                    updateImageButtons(value != null);
                }
            }
        });
    }

    @Override
    protected void postInit() {
        displayImage();
        updateImageButtons(getItem().getImageFile() != null);
    }

    public void onDownloadImageBtnClick(Component source) {
        if (getItem().getImageFile() != null)
            exportDisplay.show(getItem().getImageFile(), ExportFormat.OCTET_STREAM);
    }

    public void onClearImageBtnClick(Component source) {
        getItem().setImageFile(null);
        displayImage();
    }

    private void updateImageButtons(boolean enable) {
        downloadImageBtn.setEnabled(enable);
        clearImageBtn.setEnabled(enable);
    }

    private void displayImage() {
        byte[] bytes = null;
        if (getItem().getImageFile() != null) {
            try {
                bytes = fileStorageService.loadFile(getItem().getImageFile());
            } catch (FileStorageException e) {
                log.error("Unable to load image file", e);
                showNotification("Unable to load image file", NotificationType.HUMANIZED);
            }
        }
        if (bytes != null) {
            embeddedImage.setSource(getItem().getImageFile().getName(), new ByteArrayInputStream(bytes));
            embeddedImage.setType(Embedded.Type.IMAGE);
            BufferedImage image;
            try {
                image = ImageIO.read(new ByteArrayInputStream(bytes));
                int width = image.getWidth();
                int height = image.getHeight();

                if (((double) height / (double) width) > ((double) IMG_HEIGHT / (double) IMG_WIDTH)) {
                    embeddedImage.setHeight(String.valueOf(IMG_HEIGHT));
                    embeddedImage.setWidth(String.valueOf(width * IMG_HEIGHT / height));
                } else {
                    embeddedImage.setWidth(String.valueOf(IMG_WIDTH));
                    embeddedImage.setHeight(String.valueOf(height * IMG_WIDTH / width));
                }
            } catch (IOException e) {
                log.error("Unable to resize image", e);
            }
            // refresh image
            embeddedImage.setVisible(false);
            embeddedImage.setVisible(true);
        } else {
            embeddedImage.setVisible(false);
        }
    }
}
----

* В методе `init()` сначала инициализируется компонент `uploadField`, предназначенный для загрузки новой фотографии. В случае успешной загрузки из компонента получается экземпляр нового `FileDescriptor`, и соответствующий файл отправляется из временного хранилища в постоянное вызовом `FileUploadingAPI.putFileIntoStorage()`. После этого `FileDescriptor` сохраняется в БД вызовом <<dataSupplier,DataSupplier.commit()>>, и сохраненный экземпляр устанавливается в атрибуте `imageFile` редактируемой сущности `Employee`. Затем вызывается метод `displayImage()` контроллера для отображения загруженной фотографии.
+
Далее в методе `init()` источнику данных, содержащему редактируемый экземпляр `Employee`, добавляется слушатель для запрещения или разрешения кнопок выгрузки и очистки файла в зависимости от того, загружен файл или нет.

* Метод `postInit()` вызывает отображение файла и обновляет состояние кнопок в зависимости от наличия загруженного файла.

* Метод `onDownloadImageBtnClick()` вызывается при нажатии кнопки `downloadImageBtn` и выполняет выгрузку файла с помощью интерфейса <<file_download,ExportDisplay>>.

* Метод `onClearImageBtnClick()` вызывается при нажатии кнопки `clearImageBtn` и очищает атрибут `imageFile` сущности `Employee`. Удаления файла из хранилища не производится.

* Метод `displayImage()` выгружает файл из хранилища в байтовый массив, устанавливает содержимое компонента `embeddedImage`, и перерасчитывает его размеры для сохранения пропорций изображения.
+
Следует иметь в виду, что выгрузка файлов из хранилища в байтовый массив приемлема только для небольших файлов. Если размер файла непредсказуем, следует использовать только выгрузку через <<file_download,ExportDisplay>>, при которой файл передается через потоки ввода-вывода и нигде не оказывается в памяти целиком.

[[own_component_samples]]
==== Создание собственных визуальных компонентов

В данном разделе рассматриваются примеры создания и использования собственных визуальных компонентов.

[[vaadin_addon_sample]]
===== Пример использования стороннего компонента Vaadin

Способ подключения сторонних компонентов Vaadin описан в <<vaadin_addon,>>.

Рассмотрим пример использования компонента *Stepper*, доступного по адресу link:$$http://vaadin.com/addon/stepper$$[http://vaadin.com/addon/stepper]. Данный компонент позволяет пошагово изменять значение текстового поля с помощью клавиатуры, колесика мыши и встроенных кнопок вверх/вниз.

* Предположим, что в проекте имеется сущность `Customer` со строковым атрибутом name. В модуле *web* создан экран редактирования `customer-edit.xml` со следующей компоновкой:
+
[source, xml]
----
<layout expand="windowActions"
        spacing="true">
    <fieldGroup id="fieldGroup"
                datasource="customerDs">
        <column width="250px">
            <field id="name"/>
        </column>
    </fieldGroup>
    <iframe id="windowActions"
            screen="editWindowActions"/>
</layout>
----
+
Нам необходимо добавить атрибут `score` типа `Integer`, и обеспечить его пошаговое редактирование в данном экране.

* В CUBA Studio добавляем атрибут `score` сущности `Customer`:
+
[source, java]
----
@Column(name = "SCORE")
protected Integer score;

public void setScore(Integer score) {
    this.score = score;
}
public Integer getScore() {
    return score;
}
----
+
Генерируем скрипты обновления БД и запускаем обновление.

* Выполняем команду *Create web toolkit module* секции *Project properties* навигатора Studio.

* В <<build.gradle,build.gradle>> проекта добавляем зависимость модуля *web* от add-on, содержащего компонент:
+
[source, java]
----
configure(webModule) {
    ...
    dependencies {
        ...
        compile("org.vaadin.addons:stepper:2.1.2")
    }
----

* Пересоздаем проектные файлы IDE: меню *Create or update IDEA project files*.

* В файл `AppWidgetSet.gwt.xml` модуля *web-toolkit* проекта подключаем набор виджетов add-on после набора виджетов платформы:
+
[source, xml]
----
<module>
    <inherits name="com.haulmont.cuba.web.toolkit.ui.WidgetSet" />
    
    <inherits name="org.vaadin.risto.stepper.widgetset.StepperWidgetset" />

    <set-property name="user.agent" value="safari" />
----
+
Для более быстрой сборки виджетов на время разработки можно установить свойство `user.agent`. В данном примере набор виджетов будет собираться только для браузеров, основанных на WebKit: Chrome, Safari, и т.д.

* В XML-дескрипторе экрана редактирования `customer-edit.xml` добавляем кастомное поле `score` в компонент <<gui_FieldGroup,fieldGroup>>:
+
[source, xml]
----
<fieldGroup id="fieldGroup"
            datasource="customerDs">
    <column width="250px">
        <field id="name"/>
        <field id="score" custom="true" caption="Score"/>
    </column>
</fieldGroup>
----

* В контроллере экрана редактирования `CustomerEdit` добавляем следующий код:
+
[source, java]
----
public class CustomerEdit extends AbstractEditor<Customer> {

    @Inject
    private ComponentsFactory componentsFactory;
    @Inject
    private FieldGroup fieldGroup;

    private IntStepper stepper = new IntStepper();

    @Override
    public void init(Map<String, Object> params) {
        fieldGroup.addCustomField("score", new FieldGroup.CustomFieldGenerator() {
            @Override
            public Component generateField(final Datasource datasource, final String propertyId) {
                Component box = componentsFactory.createComponent(BoxLayout.VBOX);
                com.vaadin.ui.Layout layout = WebComponentsHelper.unwrap(box);
                layout.addComponent(stepper);
                stepper.setSizeFull();

                stepper.addValueChangeListener(new Property.ValueChangeListener() {
                    @Override
                    public void valueChange(Property.ValueChangeEvent event) {
                        datasource.getItem().setValue(propertyId, event.getProperty().getValue());
                    }
                });

                return box;
            }
        });
    }

    @Override
    protected void postInit() {
        stepper.setValue(getItem().getScore());
    }
}
----
+
Здесь в поле `stepper` создается экземпляр компонента, подключенного из add-on. В методе `init()` производится инициализация кастомного поля `score`. Через `ComponentsFactory` создается экземпляр <<gui_BoxLayout,BoxLayout>>, затем из него с помощью <<webComponentsHelper,WebComponentsHelper>> извлекается ссылка на Vaadin-контейнер, и в этот контейнер добавляется наш новый компонент. `BoxLayout` возвращается для отображения в кастомном поле.
+
Для связи компонента с данными во-первых, в методе `postInit()` ему устанавливается текущее значение из редактируемого `Customer`, а во-вторых, добавляется слушатель на изменение значения, который обновляет соответствующий атрибут сущности при изменении значения пользователем. 

* Новый компонент можно использовать и вне `FieldGroup` в произвольном месте экрана. Для этого в XML-дескрипторе объявим контейнер:
+
[source, xml]
----
<hbox id="scoreBox"
      spacing="true">
    <label value="Score"/>
</hbox>
----
+
В контроллере инжектируем контейнер, извлекаем ссылку на Vaadin-контейнер и добавляем в него компонент:
+
[source, java]
----
public class CustomerEdit extends AbstractEditor<Customer> {

    @Inject
    private BoxLayout scoreBox;

    private IntStepper stepper = new IntStepper();

    @Override
    public void init(Map<String, Object> params) {
        com.vaadin.ui.Layout box = WebComponentsHelper.unwrap(scoreBox);
        box.addComponent(stepper);

        stepper.addValueChangeListener(new Property.ValueChangeListener() {
            @Override
            public void valueChange(Property.ValueChangeEvent event) {
                getItem().setValue("score", event.getProperty().getValue());
            }
        });
    }

    @Override
    protected void postInit() {
        stepper.setValue(getItem().getScore());
    }
}
----
+
Связь с данными выполняется здесь аналогично примеру с `FieldGroup`.

* Для адаптации внешнего вида компонента создадим в проекте расширение темы. Для этого в *Studio* выполним команду *Create theme extension* секции *Project properties* навигатора. Затем откроем файл `themes/havana/havana-ext.scss` модуля *web*, и добавим в него следующий код:
+
[source, css]
----
@import "../havana/havana"; 
 
@mixin havana-ext { 
  @include havana; 
 
  /* Basic styles for stepper */
  .v-stepper { 
    /* Use box-sizing: border-box; for all browsers */
    @include box-defaults; 
 
    height: 25px; 
    border: 0; 
 
    /* Use theme fonts */
    font-family: $theme_fonts; 
  } 
 
  /* Basic styles for inner text box */
  .v-stepper input[type="text"] { 
    /* Use box-sizing: border-box; for all browsers */
    @include box-defaults; 
 
    height: 25px; 
    padding: 1px; 
    outline: 0; 
    margin: 0; 
 
    /* Use border color from theme */
    border: 1px solid $theme_fieldBorderColor; 
  } 
 
  /* Focused styles */
  .v-stepper.v-stepper input[type="text"]:focus { 
    /* Use focused border color from theme */
    border-color: $theme_fieldFocusedBorderColor; 
    /* hide default focus outline */
    outline: 0; 
  } 
 
  /* Readonly styles */
  .v-readonly.v-stepper input[type="text"], 
  .v-readonly.v-stepper input[type="text"]:focus { 
    /* Use readonly border color from theme */
    border-color: $theme_fieldReadonlyBorderColor; 
  } 
}
----

[[own_gui_component_sample]]
===== Пример интеграции компонента Vaadin в Generic UI

В <<own_gui_component,>> были рассмотрены принципы интеграции "нативных" компонентов в универсальный UI для того, чтобы их можно было объявлять в XML-дескрипторах экранов и связывать с данными.

В <<vaadin_addon_sample,предыдущем разделе>> мы подключили в проект сторонний компонент *Stepper*. Рассмотрим процесс интеграции в универсальный UI класса `IntStepper`, реализующего пошаговое изменение числового значения типа `int`.

* Интерфейс компонента в модуле *gui*:
+
[source, java]
----
package com.company.myproject.gui.components;

import com.haulmont.cuba.gui.components.Field;

public interface IntStepper extends Field {

    String NAME = "intStepper";

    boolean isManualInputAllowed();
    void setManualInputAllowed(boolean value);

    boolean isMouseWheelEnabled();
    void setMouseWheelEnabled(boolean value);

    int getStepAmount();
    void setStepAmount(int amount);

    int getMaxValue();
    void setMaxValue(int maxValue);

    int getMinValue();
    void setMinValue(int minValue);
}
----
+
В качестве базового для нашего компонента выбран интерфейс `Field`. Это позволяет осуществить связь с данными (data binding), то есть отображать и редактировать значение некоторого атрибута сущности. 

* Реализация компонента в модуле *web*:
+
[source, java]
----
package com.company.myproject.web.components;

import com.company.myproject.gui.components.IntStepper;
import com.haulmont.cuba.web.gui.components.WebAbstractField;

public class WebIntStepper 
        extends WebAbstractField<org.vaadin.risto.stepper.IntStepper> 
        implements IntStepper {

    public WebIntStepper() {
        component = new org.vaadin.risto.stepper.IntStepper();
    }

    @Override
    public boolean isManualInputAllowed() {
        return component.isManualInputAllowed();
    }
    @Override
    public void setManualInputAllowed(boolean value) {
        component.setManualInputAllowed(value);
    }

    @Override
    public boolean isMouseWheelEnabled() {
        return component.isMouseWheelEnabled();
    }
    @Override
    public void setMouseWheelEnabled(boolean value) {
        component.setMouseWheelEnabled(value);
    }

    @Override
    public int getStepAmount() {
        return component.getStepAmount();
    }
    @Override
    public void setStepAmount(int amount) {
        component.setStepAmount(amount);
    }

    @Override
    public int getMaxValue() {
        return component.getMaxValue();
    }
    @Override
    public void setMaxValue(int maxValue) {
        component.setMaxValue(maxValue);
    }

    @Override
    public int getMinValue() {
        return component.getMinValue();
    }
    @Override
    public void setMinValue(int minValue) {
        component.setMinValue(minValue);
    }
}
----
+
В квчестве базового класса выбран `WebAbstractField`, который реализует логику интерфейса `Field` по связыванию с <<datasources,источником данных>> и другие его методы.

* XML-загрузчик компонента в модуле *gui*:
+
[source, java]
----
package com.company.myproject.gui.loaders;

import com.company.myproject.gui.components.IntStepper;
import com.haulmont.cuba.gui.components.Component;
import com.haulmont.cuba.gui.xml.layout.*;
import com.haulmont.cuba.gui.xml.layout.loaders.AbstractFieldLoader;
import org.dom4j.Element;

public class IntStepperLoader extends AbstractFieldLoader {

    public IntStepperLoader(Context context, LayoutLoaderConfig config, ComponentsFactory factory) {
        super(context, config, factory);
    }

    @Override
    public Component loadComponent(ComponentsFactory factory, Element element, Component parent) {
        IntStepper component = (IntStepper) super.loadComponent(factory, element, parent);

        String manualInput = element.attributeValue("manualInput");
        if (manualInput != null) {
            component.setManualInputAllowed(Boolean.valueOf(manualInput));
        }
        String mouseWheel = element.attributeValue("mouseWheel");
        if (mouseWheel != null) {
            component.setMouseWheelEnabled(Boolean.valueOf(mouseWheel));
        }
        String stepAmount = element.attributeValue("stepAmount");
        if (stepAmount != null) {
            component.setStepAmount(Integer.valueOf(stepAmount));
        }
        String maxValue = element.attributeValue("maxValue");
        if (maxValue != null) {
            component.setMaxValue(Integer.valueOf(maxValue));
        }
        String minValue = element.attributeValue("minValue");
        if (minValue != null) {
            component.setMinValue(Integer.valueOf(minValue));
        }
        return component;
    }
}
----
+
Логика загрузки базовых свойств компонента `Field` сосредоточена в классе `AbstractFieldLoader`. Нам достаточно загрузить только специфические свойства `IntStepper`.

* Палитра компонентов проекта в модуле *web*:
+
[source, java]
----
package com.company.myproject.web;

import com.company.myproject.gui.components.IntStepper;
import com.company.myproject.gui.loaders.IntStepperLoader;
import com.company.myproject.web.components.WebIntStepper;
import com.haulmont.cuba.gui.ComponentPalette;
import com.haulmont.cuba.gui.components.Component;
import com.haulmont.cuba.gui.xml.layout.ComponentLoader;
import java.util.HashMap;
import java.util.Map;

public class AppComponentPalette implements ComponentPalette {

    @Override
    public Map<String, Class<? extends ComponentLoader>> getLoaders() {
        Map<String, Class<? extends ComponentLoader>> loaders = new HashMap<>();
        loaders.put(IntStepper.NAME, IntStepperLoader.class);
        return loaders;
    }

    @Override
    public Map<String, Class<? extends Component>> getComponents() {
        Map<String, Class<? extends Component>> components = new HashMap<>();
        components.put(IntStepper.NAME, WebIntStepper.class);
        return components;
    }
}
----

* Регистрация палитры компонентов в классе `App` модуля *web*:
+
[source, java]
----
package com.company.myproject.web;

import com.haulmont.cuba.web.DefaultApp;
import com.haulmont.cuba.web.gui.WebUIPaletteManager;

public class App extends DefaultApp {

    static {
        WebUIPaletteManager.registerPalettes(new AppComponentPalette());
    }
}
----

* XSD компонентов проекта в модуле *gui*:
+
[source, xml]
----
<xs:schema targetNamespace="http://schemas.company.com/app/0.1/app-components.xsd"
           xmlns:xs="http://www.w3.org/2001/XMLSchema"
           xmlns="http://schemas.company.com/app/0.1/app-components.xsd"
           elementFormDefault="qualified"
           attributeFormDefault="unqualified">

    <xs:element name="intStepper">
        <xs:complexType>
            <xs:attribute name="id" type="xs:string"/>
            <xs:attribute name="caption" type="xs:string"/>
            <xs:attribute name="width" type="xs:string"/>
            <xs:attribute name="height" type="xs:string"/>
            <xs:attribute name="datasource" type="xs:string"/>
            <xs:attribute name="property" type="xs:string"/>
            <xs:attribute name="manualInput" type="xs:boolean"/>
            <xs:attribute name="mouseWheel" type="xs:boolean"/>
            <xs:attribute name="stepAmount" type="xs:int"/>
            <xs:attribute name="maxValue" type="xs:int"/>
            <xs:attribute name="minValue" type="xs:int"/>
        </xs:complexType>
    </xs:element>

</xs:schema>
----

* Использование компонента в экране внутри произвольного контейнера:
+
[source, xml]
----
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<window xmlns="http://schemas.haulmont.com/cuba/window.xsd"
        xmlns:app="http://schemas.company.com/app/0.1/app-components.xsd"
        caption="msg://editCaption"
        class="com.company.myproject.web.customer.CustomerEdit"
        datasource="customerDs"
        focusComponent="fieldGroup"
        messagesPack="com.company.myproject.web.customer">
    <dsContext>
        <datasource id="customerDs"
                    class="com.company.myproject.entity.Customer"
                    view="_local"/>
    </dsContext>
    <layout expand="windowActions"
            spacing="true">
        <app:intStepper id="stepper" datasource="customerDs" property="score" caption="Score"
                        minValue="1" maxValue="20"/>
        <iframe id="windowActions"
                screen="editWindowActions"/>
    </layout>
</window>
----
+
В данном примере компонент `intStepper` подсоединен к атрибуту `score` сущности `Customer`, экземпляр которой находится в источнике данных `customerDs`.

* Использование компонента в кастомном поле <<gui_FieldGroup,FieldGroup>>:
+
[source, xml]
----
<dsContext>
    <datasource id="customerDs"
                class="com.company.myproject.entity.Customer"
                view="_local"/>
</dsContext>
<layout expand="windowActions"
        spacing="true">
    <fieldGroup id="fieldGroup"
                datasource="customerDs">
        <column width="250px">
            <field id="name"/>
            <field id="score" custom="true" caption="Score"/>
        </column>
    </fieldGroup>
...
----
+
[source, java]
----
@Inject
private ComponentsFactory componentsFactory;
@Inject
private FieldGroup fieldGroup;

@Override
public void init(Map<String, Object> params) {
    fieldGroup.addCustomField("score", new FieldGroup.CustomFieldGenerator() {
        @Override
        public Component generateField(final Datasource datasource, final String propertyId) {
            IntStepper stepper = componentsFactory.createComponent(IntStepper.NAME);
            stepper.setDatasource(datasource, propertyId);
            stepper.setWidth("100%");
            return stepper;
        }
    });
}
---- 

