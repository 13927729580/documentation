[[development]]
== Разработка приложений

Данная глава содержит практическую информацию по созданию приложений на основе платформы.

[[recommended_code_style]]
=== Рекомендуемый стиль кода

*Форматирование кода*

* Для Java и Groovy кода рекомендуется придерживаться стандартного стиля, описанного в документе link:$$http://www.oracle.com/technetwork/java/codeconv-138413.html$$[Code Conventions for the Java Programming Language]. При программировании в *IntelliJ IDEA* для этого достаточно использовать стиль по умолчанию, а для переформатирования применять сочетание клавиш *Ctrl-Alt-L*.
+
Максимальная длина строки − 120 символов. Длина отступа - 4 символа, использование пробелов вместо символов табуляции включено.

* XML код: длина отступа - 4 символа, использование пробелов вместо символов табуляции включено.

*Соглашения по именованию*

[cols="3*.^", frame="all", options="header"]
|===

^| Идентификатор ^| Правило именования ^| Пример

3+^| *Java и Groovy классы*

| Класс контроллера экрана
| UpperCamelCase

Контроллер экрана списка сущностей − `{КлассСущности}Browse`

Контроллер экрана редактирования − `{КлассСущности}Edit`

| `CustomerBrowse`

`OrderEdit`

3+^| *XML дескрипторы экранов*

| Идентификатор компонента, имена параметров в запросах
| lowerCamelCase, только буквы и цифры
| `attributesTable`

`:component$relevantTo`

`:ds$attributesDs`

| Идентификатор источника данных
| lowerCamelCase, только буквы и цифры, оканчивается на Ds
| `attributesDs`

3+^| *SQL скрипты*

| Зарезервированные слова| lowercase| `create table`

| Таблицы | UPPER_CASE. Название предваряется именем проекта для формирования пространства имен. В именах таблиц рекомендуется использовать единственное число.| `++SALES_CUSTOMER++`

| Колонки | UPPER_CASE| `CUSTOMER`

`++TOTAL_AMOUNT++`

|Колонки внешних ключей | UPPER_CASE. Состоит из имени таблицы, на которую ссылается колонка (без префикса проекта), и суффикса _ID.| `++CUSTOMER_ID++`

| Индексы | UPPER_CASE. Состоит из префикса IDX_, имени таблицы, для которой создается индекс (с префиксом проекта), и имен полей, включенных в индекс. | `++IDX_SALES_CUSTOMER_NAME++`

|===

[[project_file_structure]]
=== Файловая структура проекта

Рассмотрим файловую структуру проекта на примере простого приложения *Sales*, состоящего из <<app_tiers,блоков>> *Middleware*, *Web Client* и *Web Portal*.

.Файловая структура проекта
image::project_structure.png[align="center"]

В корне проекта расположены скрипты сборки `build.gradle`, `settings.gradle` и проектные файлы *IntelliJ IDEA*.

В каталоге `modules` расположены подкаталоги <<app_modules,модулей>> проекта − *global*, *core*, *gui*, *portal, web*. 

.Структура модуля global
image::project_structure_global.png[align="center"]

Модуль *global* содержит каталог исходных текстов `src`, в корне которого располагаются конфигурационные файлы `<<metadata.xml,metadata.xml>>`, `<<persistence.xml,persistence.xml>>` и <<views.xml,views.xml>>. Пакет `com.sample.sales.service` содержит интерфейсы сервисов *Middleware*, пакет `com.sample.sales.entity` - классы <<data_model,сущностей>> и <<message_packs,файлы локализации>> для них.

.Структура модуля core
image::project_structure_core.png[align="center"]

Модуль *core* содержит следующие каталоги:

* `db` - каталог <<db_scripts,скриптов создания и обновления>> базы данных.

* `src` - каталог исходных текстов, в корне которого расположены файл <<app_properties_files,свойств приложения>> блока *Middleware* и конфигурационный файл `<<spring.xml,spring.xml>>`. Пакет `com.samples.sales.service` содержит классы реализации <<services,сервисов>>.

* `web` - каталог с конфигурационными файлами веб-приложения, в которое собирается блок *Middleware*: `<<context.xml,context.xml>>` и `<<web.xml,web.xml>>`.

.Структура модуля gui
image::project_structure_gui.png[align="center"]

Модуль *gui* содержит каталог исходных текстов `src`, в корне которого располагается конфигурационный файл `<<screens.xml,screens.xml>>`. Пакет `com.sample.sales.gui` содержит XML-дескрипторы и контроллеры экранов и <<message_packs,файлы локализации>> для них.

.Структура модуля web
image::project_structure_web.png[align="center"]

Модуль *web* содержит следующие каталоги:

* `src` - каталог исходных текстов, в корне которого расположены файл <<app_properties_files,свойств приложения>> блока *Web Client* и конфигурационные файлы `<<menu.xml,web-menu.xml>>`, `<<permissions.xml,web-permissions.xml>>`, `<<screens.xml,web-screens.xml>>` и `<<spring.xml,web-spring.xml>>`. Пакет `com.samples.sales.web` содержит главный класс блока *Web Client* (наследник `DefaultApp`) и <<main_message_pack,главный пакет локализованных сообщений>>.

* `web` - каталог с конфигурационными файлами веб-приложения, в которое собирается блок *Web Client*: `<<context.xml,context.xml>>` и `<<web.xml,web.xml>>`.

[[build_scripts]]
=== Скрипты сборки

Для сборки проектов на основе платформы используется система сборки *Gradle*. Скрипты сборки представляют собой два файла в корневом каталоге проекта: 

* `settings.gradle` - задает название и состав <<app_modules,модулей>> проекта

* `build.gradle` - определяет конфигурацию сборки.

В данном разделе описывается структура скриптов, а также предназначение и параметры задач (tasks) Gradle.

[[build.gradle]]
==== Структура build.gradle

В данном разделе описывается структура и основные элементы скрипта `build.gradle`.

buildscript::
+
--
В секции `buildscript` задается следующее:

* Версия платформы, на которой основан данный проект.

* Набор репозиториев, из которых будут загружаться зависимости проекта. Настройка доступа к репозиториям описана <<access_to_repo,ниже>>.

* Зависимости, используемые системой сборки, включая плагин CUBA для Gradle.

После секции `buildscript` обявляются несколько переменных, используемых далее в скрипте.
--

cuba::
+
--
Логика сборки, специфичная для CUBA, сосредоточена в Gradle плагине `cuba`. Он подключается в корне скрипта и в секциях `configure` каждого модуля:

[source, groovy]
----
apply(plugin: 'cuba')
----

Параметры плагина *cuba* задаются в секции `cuba`:

[source, groovy]
----
include::{sourcesdir}/development/build_gradle_1.groovy[]
----

Рассмотрим доступные параметры:

* `artifact` - задает группу и версию собираемых <<artifact,артефактов>> проекта. Имена артефактов формируются на основе имен модулей, заданных в `settings.gradle`.

** `group` - группа артефактов.
** `version` - версия артефактов.
** `isSnapshot` - если установлено в `true`, то в именах артефактов будет присутствовать суффикс `SNAPSHOT`.

* `tomcat` - задает параметры сервера Tomcat, который используется для <<fast_deployment, быстрого развертывания>>.

** `dir` - расположение каталога <<build.gradle_setupTomcat, установки>> Tomcat.
** `port` - порт сервера; по умолчанию 8080.
** `debugPort` - порт для подключения Java отладчика; по умолчанию 8787.
** `shutdownPort` - порт для передачи команды `SHUTDOWN`; по умолчанию 8005.
** `ajpPort` - порт AJP connector; по умолчанию 8009.

* `ide` - задает некоторые параметры для Studio и IDE.

** `vcs` - тип используемой в проекте VCS. В данный момент поддерживаются только `Git` и `svn`.
** `copyright` - текст Copyright Notice, вставляемый в начало файлов исходных текстов.
** `classComment` - текст комментария, который будет расположен над объявлением класса в исходных текстах Java.

* `uploadRepository` - задает параметры <<artifact_repository,репозитория>>, в который будут выгружатся собранные артефакты проекта при выполнении задачи `uploadArchives`.
+
** `url` - URL репозитория. По умолчанию используется репозиторий Haulmont.
** `user` - имя пользователя репозитория.
** `password` - пароль пользователя репозитория.
+
Параметры репозитория выгрузки артефактов можно передать в командной строке с помощью следующих аргументов:
+
[source]
----
gradlew uploadArchives -PuploadUrl=http://myrepo.com/content/repositories/snapshots -PuploadUser=me -PuploadPassword=mypassword
----
--

dependencies::
+
--
Данная секция описывает набор <<app_components,компонентов приложения>>, используемых в проекте. Компоненты указываются координатами артефакта их модуля *global*. В примере ниже используются три компонента: `com.haulmont.cuba` (компонент *cuba* платформы), `com.haulmont.reports` (премиум-дополнение *reports*) и `com.company.base` (кастомный компонент):

[source, groovy]
----
dependencies {
  appComponent("com.haulmont.cuba:cuba-global:$cubaVersion")
  appComponent("com.haulmont.reports:reports-global:$cubaVersion")
  appComponent("com.company.base:base-global:0.1-SNAPSHOT")
}
----
--

configure::
+
--
Секции `configure` описывают конфигурацию <<app_modules,модулей>>. Наиболее важная часть конфигурации - описание зависимостей, например:

[source,groovy]
----
include::{sourcesdir}/development/build_gradle_2.groovy[]
----

Нестандартные зависимости модулей можно задавать в Studio на вкладке *Project properties > Advanced*. См. также контекстную помощь Studio.
--

[[access_to_repo]]
==== Настройка доступа к репозиторию

Основной репозиторий::
+
--
При создании нового проекта в CUBA Studio вам необходимо выбрать основной репозиторий, содержащий артефакты платформы. По умолчанию имеется два таких репозитория (может быть больше если установлен <<private_repo,приватный репозиторий>>):

* `++https://repo.cuba-platform.com/content/groups/work++` - репозиторий, расположенный на сервере Haulmont. Он требует передачи общих имени и пароля, которые указываются прямо в скрипте сборки (`cuba` / `cuba123`).

* `++https://dl.bintray.com/cuba-platform/main++` - репозиторий, находящийся в https://bintray.com[JFrog Bintray]. Он предоставляет анонимный доступ.

Оба репозитория имеют идентичное содержимое для последних версий платформы, но Bintray не содержит снэпшотов. Мы предполагаем, что Bintray является более надежным для доступа из любой точки мира.

В случае Bintray, скрипт сборки сконфигурирован также для использования репозиториев Maven Central, JCenter и Vaadin Add-ons по отдельности.
--

Доступ к премиум-дополнениям CUBA::
+
--
Если ваш проект использует премиум-дополнения, Studio добавляет еще один репозиторий:

* В случае `repo.cuba-platform.com` это `++https://repo.cuba-platform.com/content/groups/premium++`

* В случае Bintray это `++https://cuba-platform.bintray.com/premium++`

Если используется <<private_repo,приватный репозиторий>>, автоматически ничего не добавляется, так как предполагается, что он проксирует все CUBA-репозитории, включая премиум.

Оба репозитория премиум-дополнений требуют указания имени пользователя и пароля, которые предоставляются по подписке на разработчика. Первая часть лицензионного ключа до тире представляет собой имя пользователя, вторая часть после тире - пароль. Например, если ваш ключ `111111222222-abcdefabcdef`, то имя - `111111222222`, пароль - `abcdefabcdef`

Studio передает Gradle параметры подключения когда запускает скрипт сборки. При сборке проекта вне Studio передайте `premiumRepoUser` и `premiumRepoPass` в командной строке в аргументах `-P`. В случае Bintray, к имени пользователя нужно в конце добавить `@cuba-platform`.

Пример сборки используя `repo.cuba-platform.com`:

[source]
----
gradlew assemble -PpremiumRepoUser=111111222222 -PpremiumRepoPass=abcdefabcdef
----

Пример сборки используя Bintray:

[source]
----
gradlew assemble -PpremiumRepoUser=111111222222@cuba-platform -PpremiumRepoPass=abcdefabcdef
----

Чтобы при сборке проекта из командной строки не передавать имя и пароль каждый раз, можно однократно задать их в переменных среды:

* `CUBA_PREMIUM_USER` - используется если не передан `premiumRepoUser`.

* `CUBA_PREMIUM_PASSWORD` - используется если не передан `premiumRepoPass`.
--

[[custom_repositories]]
Дополнительные репозитории::
+
--
Проект может использовать любые дополнительные репозитории, содержащие <<app_components,компоненты приложения>>. Они должны быть вручную указаны в `build.gradle` *после* основного репозитория, например:

[source,groovy]
----
include::{sourcesdir}/development/access_to_repo_1.groovy[]
----
--

[[build.gradle_tasks]]
==== Задачи сборки

Исполняемыми единицами в Gradle являются _задачи_ (tasks). Они задаются как внутри плагинов, так и в самом скрипте сборки. Рассмотрим специфические для CUBA задачи, параметры которых могут быть сконфигурированы в `build.gradle`. 

[[build.gradle_buildInfo]]
===== buildInfo

Задача `buildInfo` автоматически добавляется в конфигурацию модуля `global` плагином CUBA для Gradle. Она записывает файл `build-info.properties` с информацией о приложении в артефакт `global` (например, `app-global-1.0.0.jar`). Во время работы приложения, эта информация читается бином `BuildInfo` и отображается на экране *Help > About*. Данный бин может также вызываться другими механизмами для получения информации о имени, версии и т.д. приложения.

В проекте можно явно указать следующие параметры задачи:

* `appName` - имя приложения. По умолчанию используется имя проекта, заданное в `settings.gradle`.

* `artifactGroup` - группа артефактов, которая по конвенции равна корневому пакету проекта.

* `version` - версия приложения. По умолчанию используется версия, заданная в свойстве `cuba.artifact.version`.

* `properties` - мэп произвольных свойств. По умолчанию пусто.

Пример указания параметров задачи:

[source, groovy]
----
include::{sourcesdir}/development/build_gradle_buildInfo_1.groovy[]
----

[[build.gradle_buildUberJar]]
===== buildUberJar

`buildUberJar` – задача типа `CubaUberJarBuilding`, выполняющая сборку приложения и его зависимостей в JAR-файл вместе со встроенным HTTP-сервером Jetty. Можно создать либо один all-in-one JAR, либо несколько по числу <<app_tiers,блоков>> приложения, используемых в проекте, например, `app-core.jar` для Middleware и `app.jar` для Web Client.

Задача должна быть объявлена в корне скрипта `build.gradle`. Собранные JAR-файлы находятся в подкаталоге `build/distributions` проекта. Руководство по запуску собранных JAR-файлов смотрите в разделе  <<uberjar_deployment>>.

[TIP]
====
Эту задачу можно настроить на вкладке *Deployment settings > Uber JAR* в Studio.
====

Параметры задачи:

* `coreJettyEnvPath` - обязательный параметр, содержащий относительный (от корня проекта) путь к файлу, в котором содержатся определения ресурсов JNDI для HTTP-сервера Jetty. Как минимум, этот файл должен содержать определение источника данных JDBC для основной базы данных. Studio может сгенерировать этот файл, используя установленные параметры подключения к базе данных. Может быть задан во время работы приложения с помощью аргумента <<uberjar_deployment,командной строки>> `-jettyEnvPath`.

* `appProperties` - опциональный мэп <<app_properties,свойств приложения>>. Эти свойства будут добавлены в файлы `WEB-INF/local.app.properties` внутри создаваемых JAR.

* `singleJar` - если установлен в `true`, то создается единый JAR, включающий все модули проекта (core, web, portal). По умолчанию `false`.
+
[source, groovy]
----
task buildUberJar(type: CubaUberJarBuilding) {
    singleJar = true
    coreJettyEnvPath = 'modules/core/web/META-INF/jetty-env.xml'
    appProperties = ['cuba.automaticDatabaseUpdate' : true]
}
----

* `webPort` - порт встроенного HTTP-сервера для единого (если `singleJar=true`) или web JAR. Если не установлен, имеет значение `8080`. Может быть задан во время работы приложения с помощью аргумента командной строки `-port`.

* `corePort` - порт встроенного HTTP-сервера для core JAR. Если не установлен, имеет значение `8079`. Может быть задан во время работы приложения с помощью аргумента командной строки `-port`.

* `portalPort` - порт встроенного HTTP-сервера для portal JAR. Если не установлен, имеет значение `8081`. Может быть задан во время работы приложения с помощью аргумента командной строки `-port`.

* `appName` - имя приложения, по умолчанию `app`. Его можно изменить для всего проекта, заполнив поле *Module prefix* на вкладке *Project Properties > Advanced* в Studio, либо установить его только для задачи `buildUberJar`, использовав этот параметр, например:
+
[source, groovy]
----
task buildUberJar(type: CubaUberJarBuilding) {
    coreJettyEnvPath = 'modules/core/web/META-INF/jetty-env.xml'
    appProperties = ['cuba.automaticDatabaseUpdate' : true]
    appName = 'sales'
}
----
+
После изменения имени приложения на `sales` задача создаст файлы `sales-core.jar` и `sales.jar`, и веб-клиент будет доступен по адресу `++http://localhost:8080/sales++`. Вы также можете изменить веб-контекст (последнюю часть URL после /) во время работы приложения, не изменяя заранее имени приложения, с помощью аргумента командной строки `-contextName`, или просто переименовав сам JAR файл.

* `logbackConfigurationFile` - задает относительный путь к файлу, в котором содержится конфигурация логгирования.

* `webJettyConfPath` - относительный путь к файлу, который будет использован в качестве файла конфигурации сервера Jetty для единого JAR (если `singleJar=true`) или web JAR (если `singleJar=false`). См. https://www.eclipse.org/jetty/documentation/9.4.x/jetty-xml-config.html.

* `coreJettyConfPath` - относительный путь к файлу, который будет использован в качестве файла конфигурации сервера Jetty для core JAR (если `singleJar=false`),

* `portalJettyConfPath` - относительный путь к файлу, который будет использован в качестве файла конфигурации сервера Jetty для portal JAR (если `singleJar=false`).

* `coreWebXmlPath` - относительный путь к файлу, который будет использован в качестве `web.xml` для веб-приложения модуля core.

* `webWebXmlPath` - относительный путь к файлу, который будет использован в качестве `web.xml` для веб-приложения модуля web.

* `portalWebXmlPath` - относительный путь к файлу, который будет использован в качестве `web.xml` для веб-приложения модуля portal.

* `excludeResources` - шаблон файлов ресурсов, которые не должны быть включены в JAR.

* `mergeResources` - шаблон файлов ресурсов, которые необходимо объединить в JAR.

* `webContentExclude` - шаблон файлов ресурсов, которые не должны быть включены в web JAR.

* `coreProject` - проект Gradle, представляющий модуль core (Middleware). Если не установлено, используется стандартный модуль *core* проекта.

* `webProject` - проект Gradle, представляющий модуль web (Web Client). Если не установлено, используется стандартный модуль *web* проекта.

* `portalProject` - проект Gradle, представляющий модуль portal (Web Portal). Если не установлено, используется стандартный модуль *portal* проекта.

* `polymerProject` - проект Gradle, представляющий модуль Polymer UI. Если не установлено, используется стандартный модуль *polymer-client* проекта.

[[build.gradle_buildWar]]
===== buildWar

`buildWar` - задача типа `CubaWarBuilding`, выполняющая сборку приложения и его зависимостей в WAR-файл. Должна быть объявлена в корне скрипта `build.gradle`. Собранные WAR-файлы находятся в подкаталоге `build/distributions` проекта.

Любое CUBA-приложение состоит как минимум из двух <<app_tiers,блоков>>: Middleware и Web Client. Поэтому наиболее естественный способ развертывания приложения это создание двух файлов WAR: один для Middleware, второй для Web Client. Это также позволяет <<scaling,масштабировать>> приложение при увеличении нагрузки. Однако раздельные WAR-файлы содержат дублированные зависимости, что увеличивает их общий размер. Кроме того, часто расширенные возможности развертывания не нужны и только усложняют процесс. Задача `CubaWarBuilding` может создавать WAR-файлы обоих типов: один файл на блок или единственный WAR, содержащий оба блока. В последнем случае блоки приложения загружаются в раздельные class loaders внутри одного веб-приложения.

Создание раздельных WAR-файлов для Middleware и Web Client::
+
--
Для создания двух отдельных WAR-файлов для Middleware и Web Client используйте следующую конфигурацию:
[source, groovy]
----
include::{sourcesdir}/development/build_gradle_buildWar_2.groovy[]
----

Параметры задачи:

* `appHome` - путь к домашнему каталогу приложения. В домашнем каталоге будут располагаться <<conf_dir,конфигурационный>>, <<temp_dir,временный>> и <<work_dir,рабочий>> каталоги приложения.
+
В параметре `appHome` можно указать как абсолютный или относительный путь к домашнему каталогу, так и системную переменную, которая должна быть задана при запуске сервера. Например: `appHome = '/work/sales_home'` или `appHome = '${app.home}'`

* `appProperties` - опциональный мэп <<app_properties,свойств приложения>>. Эти свойства будут добавлены в файлы `/WEB-INF/local.app.properties` внутри создаваемых WAR.

* `singleWar` - должен быть установлен в `false` для создания раздельных WAR-файлов.

* `includeJdbcDriver` - включить JDBC драйвер, который используется в проекте. По умолчанию `false`.

* `includeContextXml` - включить файл `context.xml`, который используется в проекте. По умолчанию `false`.

* `coreContextXmlPath` - относительный путь к файлу, который должен быть использован вместо проектного `context.xml` если параметр `includeContextXml` установлен в `true`.

* `hsqlInProcess` - если установлен в `true`, то URL подключения к БД в `context.xml` будет изменен на подключение к HSQL в режиме in-process.

* `coreProject` - проект Gradle, представляющий модуль *core* (Middleware). Если не установлено, используется стандартный модуль *core* проекта.

* `webProject` - проект Gradle, представляющий модуль *web* (Web Client). Если не установлено, используется стандартный модуль *web* проекта.

* `portalProject` - проект Gradle, представляющий модуль *portal* (Web Portal). Установите данное свойство, если в проекте используется модуль *portal*. Например, `portalProject = project(':app-portal')`.

* `coreWebXmlPath`, `webWebXmlPath`, `portalWebXmlPath` - относительный путь к файлу, который будет использован в качестве `web.xml` соответствующего блока приложения.
+
Пример использования собственных `web.xml`:
+
[source, groovy]
----
include::{sourcesdir}/development/build_gradle_buildWar_4.groovy[]
----
--

Создание единого WAR-файла::
+
--
Для создания единого файла WAR, включающего в себя блоки Middleware и Web Client, используйте следующую конфигурацию:

[source, groovy]
----
include::{sourcesdir}/development/build_gradle_buildWar_1.groovy[]
----

Следующие параметры должны быть указаны в дополнение к описанным выше:

* `singleWar` - должен быть опущен или установлен в `true`.

* `webXmlPath` - относительный путь к файлу, который будет использован в качестве `web.xml` единого WAR. Этот файл задает два servlet context listeners, которые загружают блоки приложения: `SingleAppCoreServletListener` и `SingleAppWebServletListener`. Все параметры инициализации передаются через параметры контекста.
+
Пример файла `single-war-web.xml`:
+
[source, xml]
----
include::{sourcesdir}/development/build_gradle_buildWar_3.xml[]
----

Единый WAR файл содержит только модули *core* и *web* (Middleware и Web Client). Для развертывания модуля *portal* используйте раздельные WAR-файлы.
--

В разделе <<war_deployment>> содержатся пошаговые инструкции по некоторым вариантам развертывания WAR-файлов.

[[build.gradle_buildWidgetSet]]
===== buildWidgetSet

`buildWidgetSet` - задача типа `CubaWidgetSetBuilding`, которая собирает кастомный GWT widgetset если в проекте есть модуль `web-toolkit`. Данный модуль позволяет разрабатывать <<own_components,собственные визуальные компоненты>>.

Доступные параметры:

* `style` - стиль вывода скрипта: `OBF`, `PRETTY` или `DETAILED`. По умолчанию `OBF`.

* `logLevel` - уровень логгирования: `ERROR`, `WARN`, `INFO`, `TRACE`, `DEBUG`, `SPAM`, or `ALL`. По умолчанию `INFO`.

* `draft` - компилировать быстро с минимумом оптимизаций. По умолчанию `false`.

Пример использования:

[source, groovy]
----
include::{sourcesdir}/development/build_gradle_buildWidgetSet_1.groovy[]
----

[[build.gradle_createDb]]
===== createDb

`createDb` - задача типа `CubaDbCreation`, создающая базу данных приложения путем выполнения соответствующих <<db_scripts,скриптов>>. Объявляется в модуле *core*. Параметры:

* `dbms` - <<dbms_types, тип СУБД>>, задаваемый в виде строки `hsql`, `postgres`, `mssql`, или `oracle`.

* `dbName` - имя базы данных.

* `dbUser` - имя пользователя СУБД.

* `dbPassword` - пароль пользователя СУБД.

* `host` - хост и, опционально, порт СУБД в формате `host[:port]`. Если не задан, используется `localhost`.

* `connectionParams` - опциональная строка параметров которая будет добавлена в конец URL подключения.

* `masterUrl` - URL для подключения при создании БД. Если не задан, используется значение по умолчанию, зависящее от типа СУБД и параметра `host`.

* `dropDbSql` - команда SQL для удаления БД. Если не задана, используется значение по умолчанию, зависящее от типа СУБД.

* `createDbSql` - команда SQL для создания БД. Если не задана, используется значение по умолчанию, зависящее от типа СУБД.

* `driverClasspath` - список JAR файлов, содержащих JDBC драйвер. Элементы списка разделяются символом ":" на Linux и символом ";" на Windows. Если не задан, используются зависимости, входящие в конфигурацию `jdbc` данного модуля. Явное задание `driverClasspath` актуально при использовании Oracle, т.к. его JDBC драйвер не присутствует в зависимостях.

* `oracleSystemPassword` - при использовании Oracle пароль пользователя SYSTEM.
+
Пример для PostgreSQL:
+
[source, java]
----
task createDb(dependsOn: assemble, description: 'Creates local database', type: CubaDbCreation) {
    dbms = 'postgres'
    dbName = 'sales'
    dbUser = 'cuba'
    dbPassword = 'cuba'
}
----
+
Пример для MS SQL Server:
+
[source, java]
----
task createDb(dependsOn: assemble, description: 'Creates local database', type: CubaDbCreation) {
    dbms = 'mssql'
    dbName = 'sales'
    dbUser = 'sa'
    dbPassword = 'saPass1'
    connectionParams = ';instance=myinstance'
}
----
+
Пример для Oracle:
+
[source, java]
----
task createDb(dependsOn: assemble, description: 'Creates database', type: CubaDbCreation) {
    dbms = 'oracle'
    host = '192.168.1.10'
    dbName = 'orcl'
    dbUser = 'sales'
    dbPassword = 'sales'
    oracleSystemPassword = 'manager'
    driverClasspath = "$tomcatDir/lib/ojdbc6.jar"
}
----

[[build.gradle_debugWidgetSet]]
===== debugWidgetSet

`debugWidgetSet` - задача типа `CubaWidgetSetDebug`, которая запускает GWT Code Server для отладки виджетов в веб-браузере.

Пример использования:

[source, java]
----
include::{sourcesdir}/development/build_gradle_debugWidgetSet_1.groovy[]
----

Убедитесь, что кофигурация `runtime` модуля `web-toolkit` содержит зависимость от библиотеки Servlet API:

[source, java]
----
include::{sourcesdir}/development/build_gradle_debugWidgetSet_2.groovy[]
----

См. <<debug_widgets,Отладка виджетов в веб-браузере>> для получения информации о том как отлаживать код в веб-браузере.

[[build.gradle_deploy]]
===== deploy

`deploy` - задача типа `CubaDeployment`, выполняющая <<fast_deployment,быстрое развертывание>> модуля в Tomcat. Объявляется в модулях *core*, *web*, *portal*. Параметры:

* `appName` - имя веб-приложения, которое будет создано из модуля. Фактически это имя подкаталога внутри `tomcat/webapps`.

* `jarNames` - список имен JAR файлов (без версии), получающихся в результате сборки модуля, которые надо поместить в каталог `WEB-INF/lib` веб-приложения. Все остальные артефакты модуля и зависимостей будут записаны в `tomcat/shared/lib`.

Например:

[source, java]
----
task deploy(dependsOn: assemble, type: CubaDeployment) {
    appName = 'app-core'
    jarNames = ['cuba-global', 'cuba-core', 'app-global', 'app-core']
}
----

[[build.gradle_deployThemes]]
===== deployThemes

`deployThemes` - задача типа `CubaDeployThemeTask`, выполняющая сборку и развертывание определенных в проекте <<web_theme,тем>> в запущенное веб-приложение, развернутое задачей <<build.gradle_deploy,deploy>>. Изменения в темах применяются без рестарта сервера.

Например:

[source, groovy]
----
task deployThemes(type: CubaDeployThemeTask, dependsOn: buildScssThemes) {
}
----

[[build.gradle_deployWar]]
===== deployWar

`deployWar` - задача типа `CubaJelasticDeploy`, выполняющая развёртывание WAR-файла на сервер Jelastic.

Пример использования:

[source, groovy]
----
task deployWar(type: CubaJelasticDeploy, dependsOn: buildWar) {
   email = '<your@email.address>'
   password = '<your password>'
   context = '<app contex>'
   environment = '<environment name or ID>'
   hostUrl = '<Host API url>'
}
----

Параметры задачи:

* `appName` - имя приложения. По умолчанию совпадает с *Modules prefix*, например, `app`.

* `email` - логин учётной записи сервера Jelastic.

* `password` - пароль учётной записи сервера Jelastic.

* `context` - контекст приложения. Значение по умолчанию: `ROOT`.

* `environment` - окружение, в которое будет развернут WAR. Можно указать как имя, так и ID окружения.

* `hostUrl` - URL-адрес API хостинга. Обычно это `app.jelastic.<host name>`.

* `srcDir` - директория, в которой находится WAR. По умолчанию это `"${project.buildDir}/distributions/war"`.

[[build.gradle_enhance]]
===== enhance

`enhance` - задача типа `CubaEnhancing`, выполняющая bytecode enhancement (weaving) классов сущностей. Объявляется в <<app_modules,модуле>> *global*.

Например:

[source, java]
----
task enhance(type: CubaEnhancing)
----

Optional parameters:

* `persistenceConfig` - позволяет явно указать набор файлов <<persistence.xml, persistence.xml>>. Если не установлено, задача будет обрабатывать все персистентные сущности, перечисленные в файлах `*persistence.xml`, найденных в CLASSPATH.

* `metadataXml` - позволяет явно указать файл <<metadata.xml, metadata.xml>> проекта. Если не установлено, задача будет обрабатывать все неперсистентные сущности, перечисленные в файле `*metadata.xml`, найденном в дереве исходных текстов модуля.

[[build.gradle_restart]]
===== restart

`restart` - задача, выполняющая остановку, <<fast_deployment,быстрое развертывание>> и старт локального сервера Tomcat.

[[build.gradle_setupTomcat]]
===== setupTomcat

`setupTomcat` - задача типа `CubaSetupTomcat`, выполняющая установку и инициализацию локального сервера Tomcat для последующего <<fast_deployment,быстрого развертывания>> приложения. Эта задача автоматически добавляется в проект при подключении плагина сборки *cuba*, поэтому объявлять ее в `build.gradle` не нужно. Каталог установки Tomcat задается свойством `tomcat.dir` секции `cuba`. По умолчанию это подкаталог `build/tomcat` проекта.

[[build.gradle_start]]
===== start

`start` - задача типа `CubaStartTomcat`, выполняющая запуск локального сервера Tomcat, установленного задачей <<build.gradle_setupTomcat,setupTomcat>>. Эта задача автоматически добавляется в проект при подключении плагина *cuba*, поэтому объявлять ее в `build.gradle` не нужно.

[[build.gradle_startDb]]
===== startDb

`startDb` - задача типа `CubaHsqlStart`, выполняющая запуск локального сервера HSQLDB. Параметры:

* `dbName` - имя базы данных, по умолчанию `cubadb`.

* `dbDataDir` - каталог, в котором размещена база данных, по умолчанию подкаталог `deploy/hsqldb` проекта.

* `dbPort` - порт сервера, по умолчанию 9001.

Например:

[source, java]
----
include::{sourcesdir}/development/build_gradle_startDb_1.groovy[]
----

[[build.gradle_stop]]
===== stop

`stop` - задача типа `CubaStopTomcat`, выполняющая остановку локального сервера Tomcat, установленного задачей <<build.gradle_setupTomcat,setupTomcat>>. Эта задача автоматически добавляется в проект при подключении плагина *cuba*, поэтому объявлять ее в `build.gradle` не нужно.

[[build.gradle_stopDb]]
===== stopDb

`stopDb` - задача типа `CubaHsqlStop`, выполняющая остановку локального сервера HSQLDB. Параметры аналогичны задаче `startDb`.

[[build.gradle_tomcat]]
===== tomcat

`tomcat` – задача типа `Exec`, выполняющая запуск локального сервера Tomcat в текущем окне терминала, которое остаётся открытым даже в случае ошибок при старте. Это упрощает диагностику ошибок запуска Tomcat, например, связанных с версией Java.

[[build.gradle_updateDb]]
===== updateDb

`updateDb` - задача типа `CubaDbUpdate`, обновляющая базу данных приложения путем выполнения соответствующих <<db_scripts,скриптов>>. Аналогична задаче `createDb`, за исключением отсутствия параметров `dropDbSql` и `createDbSql`.

[[build.gradle_zipProject]]
===== zipProject

`zipProject` - задача типа `CubaZipProject`, создающая ZIP-архив проекта. Архив не будет содержать проектные файлы IDE, результаты сборки и сервер Tomcat. Однако база данных HSQL включается в архив (если присутствует в подкаталоге `build`).

Эта задача автоматически добавляется в проект при подключении плагина сборки *cuba*, поэтому объявлять ее в `build.gradle` не нужно.

[[build_task_start]]
==== Запуск задач сборки

Задачи (tasks) Gradle, описанные в скриптах сборки, запускаются на исполнение следующими способами:

* Если работа с проектом ведется с помощью CUBA Studio, то при выполнении пунктов меню *Build* и *Run* производится подключение к демону Gradle (запущенному на старте сервера Studio), который и выполняет соответствующие задачи.

* С помощью исполняемого скрипта `gradlew` (Gradle wrapper), включенного в проект. Этот скрипт должен находится в корневом каталоге проекта, и может быть создан в Studio с помощью команды *Build* → *Create Gradle wrapper*.

* С помощью установленного вручную Gradle версии {gradleVersion}. В этом случае используется исполняемый файл `gradle`, находящийся в подкаталоге `bin` установленного Gradle.

[TIP]
====
Рекомендуется запускать команды `gradlew` или `gradle` с ключом `--daemon`, в этом случае демон Gradle остается в памяти и существенно ускоряет последующее выполнение.

Для удаления демона из памяти используется ключ `--stop`
====

Например, чтобы выполнить компиляцию Java файлов и сборку JAR файлов артефактов проекта, необходимо запустить следующую команду:

[source]
----
gradlew --daemon assemble
----

[WARNING]
====
Если ваш проект использует Премиум Дополнения, и вы запускаете сборку вне Studio, передайте имя и пароль к репозиторию дополнений в аргументах `-P` командной строки, например:

[source]
----
gradle assemble -PpremiumRepoUser=111111222222 -PpremiumRepoPass=abcdefabcdef
----

Подробнее см. <<build.gradle, выше>>.
====

Рассмотрим типичные задачи сборки в обычном порядке их использования.

* `idea`, `eclipse` - создать проектные файлы IntelliJ IDEA или Eclipse. При выполнении этой задачи из репозитория артефактов в локальный кэш Gradle загружаются зависимости вместе со своими исходными кодами.

* `cleanIdea`, `cleanEclipse` - удалить проектные файлы IntelliJ IDEA или Eclipse.

* `assemble` - выполнить компиляцию Java файлов и сборку JAR файлов артефактов проекта в подкаталогах `build` модулей.

* `clean` - удалить подкаталоги `build` всех модулей проекта.

* <<build.gradle_setupTomcat,setupTomcat>> - установить сервер *Tomcat* в путь, заданный свойством `ext.tomcatDir` скрипта `build.gradle`. 

* <<build.gradle_deploy,deploy>> - <<fast_deployment,быстрое развертывание>> приложения на сервере *Tomcat*, предварительно установленном задачей `setupTomcat`.

* <<build.gradle_createDb,createDb>> - создание базы данных приложения и выполнение соответствующих <<db_scripts,скриптов>>.

* <<build.gradle_updateDb,updateDb>> - обновление существующей базы данных приложения путем выполнения соответствующих <<db_scripts,скриптов>>.

* <<build.gradle_start,start>> - запуск сервера Tomcat.

* <<build.gradle_stop,stop>> - остановка запущенного сервера Tomcat.

* <<build.gradle_restart,restart>> - последовательное выполнение задач `stop`, `deploy`, `start`. 

[[private_repo]]
==== Установка приватного репозитория артефактов

В этом разделе рассказывается, как установить приватный Maven репозиторий, чтобы использовать его для хранения артефактов платформы и других зависимостей, вместо публичного репозитория CUBA. Это рекомендуется делать в следующих случаях:

- У вас нестабильное или слабое интернет-соединение. Несмотря на то что Gradle кэширует артефакты на компьютере разработчика, время от времени все-таки необходимо подключаться к репозиторию артефактов, например, при первом запуске проекта или при переключении на новую версию платформы.
- У вас ограничен доступ к интернету из-за политики безопасности организации.
- Вы не собираетесь продлевать подписку на премиум-дополнения, но вы бы хотели продолжить разработку вашего приложения в будущем, используя загруженные версии артефактов.

Процесс установки приватного репозитория состоит из следующих шагов:

- Разверните локальный менеджер репозиториев, подключенный к интернету.
- Настройте приватный репозиторий как прокси для публичного репозитория CUBA.
- Настройте build-скрипт вашего проекта на использование приватного репозитория. Это можно сделать через Studio, либо через правку файла `build.gradle`.
- Выполните полную сборку проекта, чтобы все необходимые артефакты закэшировались в приватный репозиторий.
- Если требуется разрабатывать приложение CUBA в изолированной сети, то установите еще одну копию менеджера репозиториев в изолированной сети и скопируйте в него содержимое кеша из первого репозитория.

[[private_repo_install]]
===== Установка менеджера репозиториев

В данном руководстве будет рассмотрен пример установки менеджера репозитория Sonatype Nexus OSS в операционной системе Microsoft Windows.

- link:http://www.sonatype.org/downloads/nexus-latest-bundle.zip[Скачайте] на компьютер программу Sonatype Nexus OSS версии 2.x (протестирована версия 2.14.3)
- Распакуйте архив в папку `c:\nexus-2.14.3-02`
- Измените параметры в файле настроек `c:\nexus-2.14.3-02\conf\nexus.properties`
+
** Вы можете указать сетевой порт, по умолчанию установлен 8081
** Настройте путь к папке с данными кэша:
+
--
замените
--
+
[source]
----
nexus-work=${bundleBasedir}/../sonatype-work/nexus
----
+
--
на
--
+
[source]
----
nexus-work=${bundleBasedir}/nexus/sonatype-work/content
----

- Перейдите в папку `c:\nexus-2.14.3-02\bin`
-  Чтобы иметь возможность запускать *nexus* как службу, установите wrapper (запустите команду с правами Администратора):
+
[source]
----
nexus.bat install
----

- Запустите службу *nexus*.
- Откройте в браузере адрес `++http://localhost:8081/nexus++` и войдите, используя данные по умолчанию: логин `admin` и пароль `admin123`.

[[private_repo_configure]]
===== Настройка прокси-репозитория

Щелкните на ссылку *Repositories* в панели слева.

На открывшейся странице нажмите кнопку *Add*, затем выберите пункт *Proxy Repository*. Будет создан новый репозиторий. Заполните обязательные поля на вкладке *Configuration*:

- *Repository ID*: `cuba-work`
- *Repository Name*: `cuba-work`
- *Provider*: `Maven2`
- *Remote Storage Location*: `++https://repo.cuba-platform.com/content/groups/work++`
- Отключите опцию *Auto Blocking Enabled*: `false`
- Включите опцию *Authentication*, задайте имя пользователя *Username*: `cuba`, пароль *Password*: `cuba123`
- Нажмите кнопку *Save*.

Создайте группу репозиториев. В Nexus нажмите кнопку *Add*, затем выберите *Repository Group* и проделайте следующие шаги на вкладке *Configuration*:

- Введите *Group ID*: `cuba-group`
- Введите *Group Name*: `cuba-group`
- Выберите *Provider*: `Maven2`
- Перенесите репозиторий *cuba-work* из *Available Repositories* в *Ordered Group Repositories*
- Нажмите кнопку *Save*.

Если у вас есть подписка на Премиум-дополнения, то создайте еще один репозиторий со следующими настройками:

- *Repository ID*: `cuba-premium`
- *Repository Name*: `cuba-premium`
- *Provider*: `Maven2`
- *Remote Storage Location*: `++https://repo.cuba-platform.com/content/groups/premium++`
- Отключите опцию *Auto Blocking Enabled*: `false`
- Включите опцию *Authentication*, используйте первую часть лицензионного ключа (до дефиса) в поле *Username* и вторую часть ключа (после дефиса) в поле *Password*
- Нажмите кнопку *Save*
- Нажмите кнопку *Refresh*
- Щелкните по репозиторию *cuba-group*
- На вкладке *Configuration* добавьте репозиторий *cuba-premium* в группу *cuba-group* следом за репозиторием *cuba-work*
- Нажмите кнопку *Save*.

[[private_repo_usage]]
===== Использование приватного репозитория

Теперь приватный репозиторий готов к работе. Найдите URL группы *cuba-group* в верхней части экрана, например:
----
http://localhost:8081/nexus/content/groups/cuba-group
----

- Если вы создаете новый проект, нажмите кнопку в поле *Repository* окна *New project*.
- Для существующего проекта, откройте на редактирование *Project properties* и нажмите кнопку в поле *Repository*.
- В открывшемся диалоге, нажмите *Add*, введите URL репозитория и имя/пароль доступа к нему: `admin / admin123`.
- Выберите новый репозиторий и нажмите *OK* для использования его в проекте.
- Если вы создаете новый проект, нажмите *OK* в окне *New project*.
- Если вы работаете с существующим проектом, сохраните изменения на странице *Project properties* и соберите проект.

Во время первой сборки проекта ваш новый репозиторий скачает артефакты и сохранит их в кэше для дальнейшего использования. Вы можете найти эти файлы в папке `c:\nexus-2.14.3-02\sonatype-work`.

[[private_repo_in_isolated_network]]
===== Репозиторий в изолированной сети

Если вам требуется разработка приложения CUBA в сети без доступа к Интернет, то проделайте следующие шаги:

- Разверните копию менеджера репозиториев в указанной сети.
- Скопируйте содержимое <<private_repo_configure,репозитория>> из открытой сети в изолированную. Если вы следовали инструкциям выше, то данные находятся в папке
+
----
c:\nexus-2.14.3-02\sonatype-work
----
+
- Перезапустите службу *nexus*.

Если вам нужно добавить артефакты от новой платформы в изолированный репозиторий, вам потребуется вернуться в окружение, подключенное к интернету, затем выполнить сборку проекта через онлайн-репозиторий и скопировать содержимое кэша репозитория в изолированное окружение.

[[private_repo_studio_in_isolated_network]]
===== CUBA Studio в изолированной сети

Сейчас вы можете открыть CUBA Studio в изолированной сети:

- Скачайте https://services.gradle.org/distributions/[Gradle] (требуется версия {gradleVersion}) и установите на компьютер разработчика.
- Откройте окно CUBA Studio Server.
- Нажмите кнопку *Advanced* и задайте путь к папке, где установлен Gradle.
- Следуйте инструкции <<private_repo_usage,выше>> для конфигурации вашего проекта.

[[project_creation]]
=== Создание проекта

Рекомендуемый способ создания нового проекта - использование *CUBA Studio*. Пример рассмотрен в главе <<qs_create_project,Быстрый старт>> данного руководства.

После создания проекта вы можете продолжить разрабатывать его в Studio, либо создать файлы проекта для *IntelliJ IDEA* или *Eclipse* и открыть проект в IDE.

[[logging]]
=== Логгирование

Для ведения логов в платформе используется фреймворк *Logback*.

Для вывода в лог используйте *SLF4J* API, получая логгер по имени текущего класса. Пример создания логгера и вывода в него:

[source, java]
----
include::{sourcesdir}/development/logging_1.java[]
---- 

Настройка логгирования для <<app_tiers,блоков>> Middleware, Web Client и Web Portal производится на уровне сервера приложения - в варианте <<fast_deployment,быстрого развертывания>> это Tomcat. Блок Desktop Client имеет самостоятельную настройку логгирования.

[[logging_setup_tomcat]]
==== Настройка логгирования в Tomcat

При выполнении задачи Gradle <<build.gradle_setupTomcat,setupTomcat>> в каталог проекта устанавливается сервер Tomcat, и производится его дополнительная конфигурация. В частности, в подкаталоге `tomcat/bin` создаются файлы `setenv.bat` и `setenv.sh`, а в подкаталоге `tomcat/conf` файл `logback.xml`.

Файлы `setenv.*` в переменной `CATALINA_OPTS` в числе прочего устанавливают параметры загрузки конфигурационного файла `logback.xml`.

Файл `logback.xml` определяет конфигурацию логгирования. Рассмотрим структуру этого файла.

* Элементы `appender` задают "устройства вывода" логов. Основными аппендерами являются `FILE` и `CONSOLE`. В параметре `level` элемента `filter` можно задать порог уровня сообщения. По умолчанию порог для файла - `DEBUG`, для консоли - `INFO`. Это означает, что в файл выводятся сообщения с уровнями `ERROR`, `WARN`, `INFO`, `DEBUG`, а в консоль - с уровнями `ERROR`, `WARN` и `INFO`.
+
Для файлового аппендера в параметре `file` задается путь к файлу лога. По умолчанию это файл `tomcat/logs/app.log`.

* Элементы `logger` задают параметры логгеров, через которые производится посылка сообщений из кода программы. Имена логгеров иерархические, то есть например настройки для логгера `com.company.sample` влияют на логгеры `com.company.sample.core.CustomerServiceBean`, `com.company.sample.web.CustomerBrowse`, если для них явно не заданы собственные настройки.
+
Минимальный уровень указывается в атрибуте `level`. Например, если для логгера задан приоритет `INFO`, то сообщения с уровнями `DEBUG` и `TRACE` выводиться не будут. Следует иметь в виду, что на вывод сообщения также влияет порог уровня, заданный в аппендере.

Оперативно изменять уровни для логгеров и пороги аппендеров для работающего сервера можно с помощью экрана *Администрирование* > *Журнал сервера*, доступного в веб клиенте. Сделанные настройки логгирования действуют только в текущем сеансе работы сервера и в файл не сохраняются. Этот экран позволяет также просматривать и загружать файлы логов из <<log_dir,каталога журналов>> сервера `tomcat/logs`.

Платформа автоматически добавляет к сообщениям, выводимым в лог, следующую информацию:

* _приложение_ - имя веб приложения, развернутого в Tomcat, код которого выводит данное сообщение. Эта информация помогает различить сообщения от разных блоков приложения (*Middleware*, *Web Client*), так как они выводятся в один файл.

* _пользователь_ - логин пользователя приложения, от имени которого в данный момент работает код, выводящий сообщение. Это позволяет в общем логе отслеживать активность конкретных пользователей. Если код, выводящий сообщение, не связан в момент вывода с пользовательской сессией, информация о пользователе не выводится.

Например, следующее сообщение в логе выведено кодом блока *Middleware* (`app-core`), работающим от имени пользователя `admin`:

[source, plain]
----
16:12:20.498 DEBUG [http-nio-8080-exec-7/app-core/admin] com.haulmont.cuba.core.app.DataManagerBean - loadList: ...
----

[[logging_setup_desktop]]
==== Настройка логгирования в десктоп-клиенте

Для десктоп клиента файл `logback.xml` должен находиться в каталоге исходников модуля *desktop* проекта. При сборке приложения он упаковывается в соответствующий JAR файл и доступен в CLASSPATH.

Для настройки логгирования в своем проекте выполните следующее:

* Создайте в каталоге `src` модуля *desktop* новый файл, например, `sample-logback.xml`, и скопируйте в него содержимое файла `cuba-logback.xml`. Файл `cuba-logback.xml` находится внутри одного из JAR-файлов платформы и его легко найти поиском в IDE.

* Установите путь к файлу лога в параметре `file` аппендера `FILE`.

* Добавьте настройки для логгеров вашего проекта.

* В классе-наследнике `com.haulmont.cuba.desktop.App` вашего проекта, например `SampleApp`, переопределите метод `getDefaultLogConfig()` и верните в нем путь относительно корня CLASSPATH к вашему файлу настроек. Например:
+
[source, java]
----
include::{sourcesdir}/development/logging_2.java[]
----

* При необходимости можно переопределить местонахождение файла конфигурации на старте приложения с помощью системного свойства <<logback.configurationFile,logback.configurationFile>>.

[[debuging]]
=== Отладка

В данном разделе содержится информация об использовании пошаговой отладки CUBA-приложений.

[[debug_setup]]
==== Подключение отладчика

Запустить сервер Tomcat в режиме отладки можно либо выполнением команды сборки

`gradle start`

либо запуском командного файла `++bin/debug.*++` установленного *Tomcat*.

После этого сервер будет принимать подключения отладчика на порту 8787. Порт можно изменить в файле `bin/setenv.*` в переменной `++JPDA_OPTS++`.

Для пошаговой отладки в *Intellij IDEA* необходимо в проекте приложения создать новый элемент *Run/Debug Configuration* типа *Remote*, и в его поле *Port* указать 8787.

[[debug_widgets]]
==== Отладка виджетов в веб-браузере

Для отладки виджетов на стороне браузера можно использовать *GWT Super Dev Mode*.

. Настройте задачу <<build.gradle_debugWidgetSet,debugWidgetSet>> в `build.gradle`.

. Разверните приложение и запустите Tomcat.

. Запустите задачу `debugWidgetSet`:
+
`gradlew debugWidgetSet`
+
GWT Code Server будет перекомпилировать ваш widgetset при изменениях кода виджетов.

. Откройте страницу `http://localhost:8080/app?debug&superdevmode` в браузере Chrome и подождите, пока widgetset будет построен первый раз.

. Откройте консоль отладки браузера: 
+
image::debugWidgetSet_chrome_console.png[align="center"]

. После изменения Java-кода в модуле `web-toolkit` обновляйте страницу в браузере. Widgetset будет инкрементально перестраиваться примерно за 8-10 секунд.

[[testing]]
=== Тестирование

[[unit_tests]]
==== Модульные тесты

Модульные тесты (unit tests) можно создавать и выполнять и на <<app_tiers,уровне>> *Middleware*, и на клиентском уровне. Для этого платформа включает в себя фреймворки link:$$http://junit.org$$[JUnit] и link:$$http://code.google.com/p/jmockit$$[JMockit].

Допустим, имеется следующий контроллер экрана:

[source, java]
----
include::{sourcesdir}/development/testing_1.java[]
----

Тогда можно написать следующий тест, проверяющий работу метода `init()`:

[source, java]
----
include::{sourcesdir}/development/testing_2.java[]
----

[[integration_tests_mw]]
==== Интеграционные тесты Middleware

На уровне Middleware можно создавать интеграционные тесты, которые выполняются в полнофункциональном контейнере Spring с подключением к базе данных. В тестах такого типа можно выполнять код любого слоя внутри Middleware - от сервисов до ORM.

Для того, чтобы выполнять тесты из IDE, создайте каталог `test` в модуле *core* рядом с `src`. После этого пересоздайте проектные файлы IDE.

Платформа содержит класс `TestContainer`, который может быть использован в качестве базового для тестовых контейнеров приложения. Создайте наследника этого класса в каталоге `test` модуля *core* и в его конструкторе переопределите параметры загрузки <<app_components, компонентов>> и <<app_properties_files, свойств приложения>>, а также параметры подключения к тестовой БД. Например:

[source, java]
----
include::{sourcesdir}/development/testing_3.java[]
----

В качестве базы данных рекомендуется использовать отдельную тестовую БД, которую можно создавать, например, следующей <<build.gradle_createDb, задачей>> в `build.gradle`:

[source, groovy]
----
include::{sourcesdir}/development/testing_4.java[]
----

Тестовый контейнер используется в классах тестов в качестве JUnit rule, указанного с помощью аннотации `@ClassRule`:

[source, java]
----
include::{sourcesdir}/development/testing_5.java[]
----

В данном примере тестовый контейнер инициализируется один раз для всех тестовых методов класса, и уничтожается после того, как все они выполнены.

Так как запуск контейнера занимает некоторое время, имеет смысл инициализировать контейнер один раз для тестов из нескольких (или всех) классов. Для этого создайте общий синглтон-экземпляр тестового контейнера, например:

[source, java]
----
include::{sourcesdir}/development/testing_6.java[]
----

И используйте его в тестовых классах:

[source, java]
----
include::{sourcesdir}/development/testing_7.java[]
----

Класс `TestContainer` содержит следующие методы, которые можно использовать в коде тестов (см. пример `CustomerLoadTest` выше):

* `persistence()` - возвращает ссылку на интерфейс `<<persistence,Persistence>>`.

* `metadata()` - возвращает ссылку на интерфейс `<<metadata,Metadata>>`.

* `deleteRecord()` - этот набор перегруженных методов предназначен для использования в `@After` методах для удаления тестовых объектов из БД.

[[integration_tests_client]]
==== Интеграционные тесты клиентского уровня

Интеграционные тесты на клиентском уровне реализуются с применением фреймворка link:$$http://code.google.com/p/jmockit$$[JMockit]. С его помощью тест изолируется от *Middleware*, а также создаются необходимые объекты инфраструктуры.

Класс клиентского интеграционного теста должен быть унаследован от `CubaClientTestCase`. В методе `@Before` необходимо вызвать унаследованные методы `addEntityPackage()`, `setViewConfig()` и затем `setupInfrastructure()` для создания объектов `<<metadata,Metadata>>` и `<<configuration,Configuration>>` и развертывания метаданных по выбранным сущностям. Далее в методе `@Before` можно дополнить инфраструктуру необходимыми мок-объектами с помощью конструкции `Expectations` или `NonStrictExpectations`.

Пример инициализирующего метода `@Before` одного из тестов платформы:

[source, java]
----
include::{sourcesdir}/development/testing_8.java[]
----

[[dev_recipes]]
=== Рецепты разработки

В данном разделе рассматриваются способы решения некоторых практических задач. 

[[dm_vs_em]]
==== DataManager vs. EntityManager

И <<dataManager,DataManager>> и <<entityManager,EntityManager>> предназначены для операций с сущностями (CRUD). Ниже приведены различия между этими интерфейсами.

|===
|DataManager |EntityManager

|DataManager доступен и на среднем слое и на клиентском <<app_tiers,уровне>>.
|EntityManager доступен только на среднем слое.

|DataManager является синглтон-бином.
|Ссылку на EntityManager необходимо получать через интерфейс <<persistence,Persistence>>.

|DataManager содержит несколько высокоуровневых методов для работы с <<entity_states,detached>> сущностями: `load()`, `loadList()`, `reload()`, `commit()`.
|EntityManager в большой степени повторяет стандартный `javax.persistence.EntityManager`.

|DataManager всегда стартует новую <<transactions,транзакцию>> внутри.
|Для работы с EntityManager необходима открытая транзакция.

|DataManager загружает _частичные_ сущности в соответствие с <<views,представлением>>.
|EntityManager всегда загружает все локальные атрибуты. Если используется представление, оно влияет только на загрузку ссылочных атрибутов.

|Запросы в DataManager могут возвращать только сущности. Запросы, возвращающие одиночные атрибуты или агрегированные значения (SUM, COUNT) вызывают ошибку.
|EntityManager может выполнять любые JPQL или native запросы.

|DataManager применяет ограничения <<security_subsystem,безопасности>>, когда вызывается с клиентского уровня.
|EntityManager не накладывает ограничения безопасности.

|===

При работе на клиентском уровне доступен только `DataManager`. На среднем слое, используйте `EntityManager` когда необходимо реализовать атомарную логику внутри транзакции или выполнить запрос, возвращающий отдельные атрибуты или агрегированные значение. В противном случае, на среднем слое можно использовать любой из интерфейсов на выбор.

Если вам нужно обойти ограничения `DataManager` при работе на клиентском уровне, создайте свой <<services,сервис>> и используйте `EntityManager` для работы с данными. В сервисе можно проверять права пользователя с помощью интерфейса <<security,Security>> и возвращать клиенту данные в виде персистентных или неперсистентных сущностей или произвольных значений.

[[getting_messages]]
==== Получение локализованных сообщений

В данном разделе рассмотрены способы получения <<localization,локализованных сообщений>> в различных компонентах приложения.

* В <<screen_xml,XML-дескрипторах>> экранов атрибуты компонентов, отображающие статичный текст (например <<gui_attr_caption,caption>>), могут обращаться к локализованным сообщениям по правилам метода <<messageTools.loadString,MessageTools.loadString()>>. Например:

** `caption="msg://roleName"` - получить сообщение, заданное ключом `roleName` в пакете сообщений текущего экрана. Пакет сообщений экрана задается в атрибуте `messagesPack` корневого элемента `window`.

** `caption="msg://com.company.sample.entity/Role.name"` - получить сообщение, заданное ключом `Role.name` в пакете сообщений `com.company.sample.entity`.

* В <<screen_controller,контроллерах экранов>> локализованные сообщения можно получать следующими способами:

** Из пакета сообщений текущего экрана:

*** Методом `getMessage()`, унаследованным от базового класса <<abstractFrame,AbstractFrame>>. Например:
+
[source, java]
----
String msg = getMessage("warningMessage");
----

*** Методом `formatMessage()`, унаследованным от базового класса `AbstractFrame`. В этом случае сообщение используется для форматирования переданных параметров по правилам метода `String.format()`. Например:
+
messages.properties:
+
[source, plain]
----
warningMessage = Invalid email address: '%s'
----
+
Java-контроллер:
+
[source, java]
----
String msg = formatMessage("warningMessage", email);
----

** Из произвольного пакета сообщений путем инжекции интерфейса инфраструктуры <<messages,Messages>>. Например:
+
[source, java]
----
@Inject
private Messages messages;

@Override
public void init(Map<String, Object> params) {
    String msg = messages.getMessage(getClass(), "warningMessage");
    ...
} 
----

* В компонентах, управляемых контейнером Spring (<<managed_beans,управляемых бинах>>, <<services,сервисах>>, <<jmx_beans,JMX-бинах>>, контроллерах Spring MVC модуля *portal*) локализованные сообщения можно получать путем инжекции интерфейса инфраструктуры <<messages,Messages>>:
+
[source, java]
----
@Inject
protected Messages messages;
...
String msg = messages.getMessage(getClass(), "warningMessage");
----

* В любом коде приложения, где невозможна инжекция, интерфейс `Messages` может быть получен с помощью статического метода `get()` класса `AppBeans`:
+
[source, java]
----
protected Messages messages = AppBeans.get(Messages.class);
...
String msg = messages.getMessage(getClass(), "warningMessage");
----

[[init_values]]
==== Присвоение начальных значений

Присвоение начальных значений атрибутам новых экземпляров сущностей можно производить несколькими способами.

[[init_values_in_class]]
===== Инициализация полей сущности

Атрибуты простых типов (`Boolean`, `Integer` и т.д.) можно инициализировать прямо в объявлении соответствующего поля класса сущности, например: 

[source, java]
----
public class User extends StandardEntity {
...
    @Column(name = "ACTIVE")
    protected Boolean active = true;
...
}
----

Кроме того, в классе сущности можно создать специальный метод инициализации и добавить ему аннотацию <<postConstruct_entity_annotation,@PostConstruct>>. В этом случае в процессе инициализации можно использовать вызов любых глобальных <<infrastructure_interfaces,интерфейсов инфраструктуры>> и <<managed_beans,бинов>>, например: 

[source, java]
----
public class MyEntity extends StandardEntity {
...
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "USER_ID")
    protected User creator;
...
    @PostConstruct
    protected void init() {
       setCreator(AppBeans.get(UserSessionSource.class).getUserSession().getUser());
    }
}
----

[[init_values_in_CreateAction]]
===== Инициализация с помощью CreateAction

Если начальное значение атрибута зависит от данных вызывающего экрана, то можно воспользоваться методом `setInitialValues()` класса <<createAction,CreateAction>>.

Рассмотрим для примера две связанные сущности:

image::init_values_recipe_1.png[align="center"]

Фрагмент XML-дескриптора экрана, отображающего одновременно списки обоих сущностей:

[source, xml]
----
<dsContext>
    <collectionDatasource id="typesDs"
                          class="com.haulmont.sample.entity.DeviceType"
                          view="_local">
        <query>
            select e from sample$DeviceType e
        </query>
    </collectionDatasource>
    <collectionDatasource id="descriptionsDs"
                          class="com.haulmont.sample.entity.DeviceDescription"
                          view="_local">
        <query>
            select e from sample$DeviceDescription e where e.deviceType.id = :ds$typesDs
        </query>
    </collectionDatasource>
</dsContext>
<layout>
...
        <table id="typeTable">
            <actions>
                <action id="create"/>
                <action id="edit"/>
                <action id="remove"/>
            </actions>
            <columns>
                <column id="name"/>
            </columns>
            <rows datasource="typesDs"/>
        </table>
...
        <table id="descriptionTable">
            <actions>
                <action id="create"/>
                <action id="edit"/>
                <action id="remove"/>
            </actions>
            <columns>
                <column id="description"/>
            </columns>
            <rows datasource="descriptionsDs"/>
        </table>
    </split>
</layout>
----

Контроллер этого экрана:

[source, java]
----
public class DeviceTypeBrowse extends AbstractLookup {

    @Inject
    private CollectionDatasource<DeviceType, UUID> typesDs;

    @Named("descriptionTable.create")
    private CreateAction descrCreateAction;

    @Override
    public void init(Map<String, Object> params) {
        typesDs.addItemChangeListener(event -> {
            descrCreateAction.setInitialValues(Collections.<String, Object>singletonMap("deviceType", event.getItem()));
        });
    }
}
----

В контроллере источнику данных `typesDs` добавляется слушатель на событие изменения выбранной записи. При смене выбранной записи вызывается метод `setInitialValues()` действия, и ему передается мэп с одним элементом, ключом которого является навание атрибута - `deviceType`, а значением - выбранный экземпляр `DeviceType`. Таким образом при выполнении действия `CreateAction` в атрибуте `deviceType` нового экземпляра `DeviceDescription` будет сразу установлен выбранный в таблице экземпляр `DeviceType`.

[[init_values_in_initNewItem]]
===== Использование метода initNewItem

Начальные значения можно также задать в контроллере экрана создаваемой сущности в методе <<initNewItem,initNewItem()>>.

В качестве примера рассмотрим следующую задачу: в проекте имеется сущность `Employee` (сотрудник компании), которая должна быть связана с платформенной сущностью `User` (пользователь системы). При создании сотрудника должен создаваться новый экземпляр пользователя.

image::init_values_recipe_2.png[align="center"]

В XML-дескрипторе экрана редактирования сотрудника объявляем источник данных для экземпляра сотрудника и вложенный источник - для связанного пользователя:

[source, xml]
----
<dsContext>
    <datasource id="employeeDs"
                class="com.haulmont.sample.entity.Employee"
                view="employee-edit">
        <datasource id="userDs"
                    property="user"/>
    </datasource>
</dsContext>
----

В контроллере экрана редактирования сотрудника определяем:

[source, java]
----
@Inject
private Metadata metadata;

private Group defaultGroup;
private Role defaultRole;

@Override
protected void initNewItem(Employee item) {
    User user = metadata.create(User.class);
    user.setGroup(defaultGroup);
    final UserRole userRole = metadata.create(UserRole.class);
    userRole.setUser(user);
    userRole.setRole(defaultRole);
    getDsContext().addBeforeCommitListener(context -> {
        context.getCommitInstances().add(userRole);
    });
    item.setUser(user);
}
----

Здесь в методе `initNewItem()` создается новый экземпляр `User`, и для него устанавливается некоторая группа доступа `defaultGroup`. Связь с ролью `defaultRole` устанавливается с помощью нового экземпляра сущности `UserRole`. Для сохранения этой связи в БД при коммите экрана, экземпляр `UserRole` добавляется в коллекцию сохраняемых сущностей в методе `beforeCommit()` слушателя <<dsContext,DsContext.CommitListener>>. 

Новый экземпляр `User` устанавливается в соответствующем атрибуте редактируемой сущности `Employee`, и тем самым оказывается во вложенном источнике данных `userDs`. Это дает возможность редактировать нужные атрибуты пользователя в экране сотрудника, а также приводит к автоматическому сохранению экземпляра пользователя при коммите экрана в одной транзакции с остальными сущностями.

[[composition_recipe]]
==== Редактирование композитных сущностей

Платформа CUBA поддерживает два типа связи между сущностями: ассоциацию и композицию. В интерфейсе *CUBA Studio* они названы соответственно ASSOCIATION и COMPOSITION. Ассоциация - это связь между объектами, которые могут существовать отдельно друг от друга. Композиция же используется для связи типа "master-detail" когда экземпляры detail существуют только в составе master. Примером композиции может служить связь аэропорта и терминалов: терминал, не относящийся ни к какому аэропорту, не имеет смысла.

Как правило, редактирование сущностей, входящих в состав композиции, удобно осуществлять совместно. То есть, например, пользователь открывает экран редактирования аэропорта, видит в нем список терминалов, может создавать и редактировать их, но все изменения, как аэропорта, так и терминалов, сохраняются в базу данных вместе в одной транзакции, и только тогда, когда пользователь подтвердит сохранение главной сущности - аэропорта.

[[composition_impl_recipe]]
===== Композиция One-to-Many

Рассмотрим реализацию композиции на примере сущностей `Airport` и `Terminal`:

image::composition_recipe_1.png[align="center"]

. Сущность `Terminal` содержит обязательную ссылку на `Airport`:
+
include::{sourcesdir}/development/composition_recipe_1.java[]
----

. Сущность `Airport` содержит one-to-many коллекцию терминалов. Соответствующее поле помечается аннотацией <<composition_annotation,@Composition>> для огранизации композиции и <<onDelete_annotation,@OnDelete>> для каскадного мягкого удаления:
+
[source, java]
----
include::{sourcesdir}/development/composition_recipe_2.java[]
----

. <<views,Представление>>, используемое в экране редактирования аэропорта, должно содержать атрибут-коллецию `terminals`:
+
[source, xml]
----
include::{sourcesdir}/development/composition_recipe_3.xml[]
----
+
Для сущности `Terminal` здесь выбрано представление `++_local++`, хотя она содержит ссылочный атрибут `airport` - ссылку на аэропорт. Дело в том, что атрибут `airport` устанавливается только при создании нового экземпляра `Terminal`, и не меняется в дальнейшем, поэтому загружать его не обязательно.

. В XML-дескрипторе экрана редактирования аэропорта определяем источники данных для экземпляра `Airport` и коллекции его терминалов:
+
[source, xml]
----
include::{sourcesdir}/development/composition_recipe_4.xml[]
----

. В XML-дескрипторе экрана редактирования аэропорта определяем таблицу, отображающую терминалы, и <<list_actions,стандартные действия>> для нее:
+
[source, xml]
----
include::{sourcesdir}/development/composition_recipe_5.xml[]
----

. В экране редактирования терминала достаточно определить стандартные элементы: `datasource` для экземпляра `Terminal` и визуальные компоненты, связанные с этим `datasource`, для редактирования атрибутов терминала.

В результате редактирование экземпляра аэропорта работает следующим образом:

* В экране редактирования аэропорта отображается таблица терминалов.

* Пользователь может выбрать терминал и открыть экран его редактирования. При нажатии *OK* в экране редактирования терминала измененный экземпляр терминала сохраняется не в базу данных, а в источник данных `terminalsDs` экрана редактирования аэропорта. 

* Пользователь может создавать новые или удалять терминалы - все изменения сохраняются в источнике данных `terminalsDs`.

* Пользователь нажимает *OK* в экране редактирования аэропорта, и измененный `Airport` вместе со всеми измененными экземплярами `Terminal` отправляется на Middleware в метод <<dataManager,DataManager>>.commit() и сохраняется в базе данных в рамках одной транзакции. 

[[composition_oto_recipe]]
===== Композиция One-to-One

Композиция one-to-one рассматривается на примере сущностей `Customer` и `CustomerDetails`:

image::composition_recipe_3.png[align="center"]

. Сущность `Customer` содержит необязательную ссылку на `CustomerDetails`, аннотированную как `@Composition`:
+
[source, java]
----
include::{sourcesdir}/development/composition_recipe_6.java[]
----

. <<views,Представление>>, используемое в экране редактирования `Customer`, должно содержать атрибут `details`:
+
[source, xml]
----
include::{sourcesdir}/development/composition_recipe_7.xml[]
----

. В экране редактирования `Customer` объявлен вложенный источник данных для экземпляра `CustomerDetails`:
+
[source, xml]
----
include::{sourcesdir}/development/composition_recipe_8.xml[]
----

. Компонент `FieldGroup` в экране редактирования `Customer` содержит атрибут `details`:
+
[source, xml]
----
include::{sourcesdir}/development/composition_recipe_9.xml[]
----

В результате редактирование экземпляра `Customer` работает следующим образом:

* Экран редактирования `Customer` содержит компонент <<gui_PickerField,PickerField>> с двумя действиями: <<openAction,OpenAction>> и <<clearAction,ClearAction>>:

image::composition_recipe_oto_1.png[align="center"]

* Когда вызывается `OpenAction`, создается новый экземпляр `CustomerDetails` и он отображается в собственном экране редактирования. При нажатии *OK* в этом экране, экземпляр `CustomerDetails` сохраняется не в БД, а в источнике данных `detailsDs` редактора `Customer`.

* Компонент выбора отображает <<namePattern_annotation,instance name>> сущности `CustomerDetails`:

image::composition_recipe_oto_2.png[align="center"]

* Когда пользователь нажимает *OK* в редакторе `Customer`, измененный экземпляр `Customer` вместе с экземпляром `CustomerDetails` отправляется в метод `DataManager.commit()` на средний слой и сохраняется в БД в одной транзакции.

* Если пользователь вызывает `ClearAction` в поле выбора, экземпляр `CustomerDetails` удаляется и ссылка на него очищается в одной транзакции после коммита редактора `Customer`.

[[composition_deep_recipe]]
===== Глубокая композиция

Композиция может быть более глубокой и состоять из двух уровней вложенности. Усложним приведенный выше пример, добавив сущность `MeetingPoint`, описывающую место встречи у терминала аэропорта:

image::composition_recipe_2.png[align="center"]

Теперь сущность `Terminal` содержит атрибут `meetingPoints` - коллекцию экземпляров `MeetingPoint`. Для того, чтобы все три сущности представляли собой единую композицию и редактировались совместно, нужно в дополнение к описанному в предыдущем разделе выполнить следующее:

. Атрибуту `meetingPoints` класса `Terminal` добавить аннотации `@Composition` и `@OnDelete` аналогично атрибуту `terminals` класса `Airport`.

. Создать новое представление для `Terminal`:
+
[source, xml]
----
<view entity="sample$Terminal" name="terminal-edit" extends="_local">
    <property name="meetingPoints" view="_local"/>
</view>
----
+
И использовать его в представлении `Airport` вместо `++_local++`:
+
[source, xml]
----
<view entity="sample$Airport" name="airport-edit" extends="_local">
    <property name="terminals" view="terminal-edit"/>
</view>
----

. В XML-дескрипторе экрана редактирования аэропорта определить источники данных для экземпляра `Airport` и вложенных сущностей на всю глубину композиции:
+
[source, xml]
----
<dsContext>
    <datasource id="airportDs"
                class="com.haulmont.sample.entity.Airport"
                view="airport-edit">
        <collectionDatasource id="terminalsDs" property="terminals">
            <collectionDatasource id="meetingPointsDs" property="meetingPoints"/>
        </collectionDatasource>  
    </datasource>
</dsContext>
----
+
Здесь источник данных `meetingPointsDs` не связан ни с какими визуальными компонентами, однако он необходим для корректной работы совместного редактирования композиции.

. В XML-дескрипторе экрана редактирования терминала в свою очередь определить для коллекции `meetingPoints` вложенный источник данных и соответствующую таблицу.

В результате измененные эземпляры `MeetingPoint`, так же как и экземпляры `Terminal`, будут сохраняться в базу данных только вместе с экземпляром `Airport` в одной транзакции.

[[app_start_recipe]]
==== Выполнение кода на старте приложения

Иногда бывает необходимо выполнить некоторый код сразу после старта приложения в момент, когда все механизмы гарантированно работоспособны. Для этого можно воспользоваться слушателем <<appContext,AppContext.Listener>>.

Рассмотрим следующую задачу: в проекте имеется сущность `Employee` (сотрудник компании), которая связана один-к-одному с платформенной сущностью `User` (пользователь системы):

image::init_values_recipe_2.png[align="center"]

Если атрибут `name` сущности `User` изменяется, например через стандартный экран управления пользователями, необходимо, чтобы изменялся также и атрибут `name` связанной сущности `Employee`. Это обычная задача для "денормализованных" данных, и решается она, как правило, с использованием <<entity_listeners,entity listeners>>. В данном случае ситуация осложняется тем, что необходимо отслеживать изменения не проектной, а платформенной сущности `User`, и добавить entity listener с помощью аннотации <<listeners_annotation,@Listeners>> невозможно. Однако, можно добавить listener динамически через бин `EntityListenerManager`, и сделать это лучше всего на старте приложения.

Для этого создадим в модуле *core* приложения бин `AppLifecycle`, имплементирующий интерфейс `AppContext.Listener`, и зарегистрируем его вызовом метода `AppContext.addListener()` в конструкторе объекта:

[source, java]
----
include::{sourcesdir}/development/app_start_recipe_1.java[]
----

[source, java]
----
include::{sourcesdir}/development/app_start_recipe_2.java[]
----

В результате сразу после старта <<app_tiers,блока>> Middleware будет вызван метод `applicationStarted()` данного бина. В этом методе в качестве entity listener сущности `User` регистрируется бин `sample_UserEntityListener`.

Метод `onBeforeUpdate()` класса `UserEntityListener` будет вызываться перед каждым сохранением изменений экземпляров `User` в базу данных. В методе проверяется, есть ли атрибут `name` среди измененных, и если да, загружается связанный экземпляр `Employee`, и в нем устанавливается это же значение `name`.

[[images_recipe]]
==== Загрузка и вывод изображений

Рассмотрим задачу загрузки, хранения и отображения фотографий сотрудников:

* Сотрудник представлен сущностью `Employee`.

* Файлы изображений хранятся в <<file_storage,FileStorage>>. Сущность `Employee` содержит ссылку на соответствующий `FileDescriptor`.

* Экран редактирования `Employee` отображает фотографию, а также дает возможность загрузить, выгрузить и очистить изображение.

Класс сущности со ссылкой на файл изображения:

[source, java]
----
include::{sourcesdir}/development/images_1.java[]
----

<<views,Представление>> для загрузки `Employee` вместе с `FileDescriptor` должно содержать все локальные атрибуты `FileDescriptor`:

[source, xml]
----
include::{sourcesdir}/development/images_2.xml[]
----

Фрагмент XML-дескриптора экрана редактирования `Employee`:

[source, xml]
----
include::{sourcesdir}/development/images_3.xml[]
----

Компоненты отображения и загрузки/выгрузки фотографии заключены внутрь контейнера <<gui_GroupBoxLayout,groupBox>>. В верхней его части с помощью компонента <<gui_Image,image>> выводится изображение, а в нижней слева направо расположены компонент <<gui_FileUploadField,upload>> для загрузки файла и <<gui_Button,кнопки>> выгрузки и очистки изображения. В результате эта часть экрана должна выглядеть следующим образом:

image::images_recipe.png[align="center"]

Теперь рассмотрим <<abstractEditor,контроллер экрана редактирования>>.

[source, java]
----
include::{sourcesdir}/development/images.java[]
----

* В методе `init()` сначала инициализируется компонент `uploadField`, предназначенный для загрузки новой фотографии. В случае успешной загрузки из компонента получается экземпляр нового `FileDescriptor`, и соответствующий файл отправляется из временного хранилища в постоянное вызовом `FileUploadingAPI.putFileIntoStorage()`. После этого `FileDescriptor` сохраняется в БД вызовом <<dataSupplier,DataSupplier.commit()>>, и сохраненный экземпляр устанавливается в атрибуте `imageFile` редактируемой сущности `Employee`. Затем вызывается метод `displayImage()` контроллера для отображения загруженной фотографии.
+
Далее в методе `init()` источнику данных, содержащему редактируемый экземпляр `Employee`, добавляется слушатель для запрещения или разрешения кнопок выгрузки и очистки файла в зависимости от того, загружен файл или нет.

* Метод `postInit()` вызывает отображение файла и обновляет состояние кнопок в зависимости от наличия загруженного файла.

* Метод `onDownloadImageBtnClick()` вызывается при нажатии кнопки `downloadImageBtn` и выполняет выгрузку файла с помощью интерфейса <<file_download,ExportDisplay>>.

* Метод `onClearImageBtnClick()` вызывается при нажатии кнопки `clearImageBtn` и очищает атрибут `imageFile` сущности `Employee`. Удаления файла из хранилища не производится.

* Метод `displayImage()` выгружает файл из хранилища и устанавливает его в качестве содержимого компонента `image`.

[[images_in_table]]
===== Вывод изображений в колонках таблицы

Расширим задачу из предыдущего примера, настроив отображение фотографий на экране просмотра списка сотрудников.

Изображения можно отобразить как в отдельной колонке, так и внутри существующих колонок. В обоих случаях будет использоваться интерфейс <<gui_Table_addGeneratedColumn,Table.ColumnGenerator>>.

Фрагмент XML-дескриптора экрана просмотра списка `Employee`:

[source, xml]
----
include::{sourcesdir}/development/images_4.xml[]
----

Чтобы отображать фотографию рядом с именем сотрудника в колонке `name`, необходимо изменить стандартное представление данных в этой колонке. Например, можно использовать контейнер <<gui_BoxLayout,HBoxLayout>>, поместив внутрь него компонент <<gui_Image,Image>>:

[source, java]
----
include::{sourcesdir}/development/images_5.java[]
----

* В методе `init()` вызывается метод `addGeneratedColumn()`, который принимает два параметра: идентификатор колонки и реализацию интерфейса `Table.ColumnGenerator`, с помощью которого мы зададим своё представление для колонки `name`.

* В этом методе мы создадим компонент `Image`, пользуясь интерфейсом `ComponentsFactory`. Укажем <<gui_Image_scaleMode,режим масштабирования>> компонента (`CONTAIN`) и зададим его размеры.

* Затем получим экземпляр `FileDescriptor` с изображением, которое хранится в <<file_storage,File Storage>>. Ссылка на это изображение хранится в атрибуте `imageFile` сущности `Employee`. Используем тип ресурса `FileDescriptorImageResource`, чтобы задать источник данных для компонента `Image`.

* Атрибут `name` можно отобразить как компонент `Label` рядом с изображением.

* Оба компонента `Image` и `Label` обернём в контейнер `HBoxLayout`, который будет возвращать метод `addGeneratedColumn()` в качестве новой разметки ячейки.

image::image_recipe.png[align="center"]

Можно использовать также более декларативный подход с атрибутом <<gui_Table_column_generator,generator>>.

[[sending_emails_recipe]]
==== Отправка email

В данном разделе рассматривается пример использования <<email_sending,механизма>> рассылки email.

Рассмотрим следующую задачу:

--
* Имеется сущность `NewsItem` и экран ее редактирования `NewsItemEdit`.

* Сущность `NewsItem` имеет следующие атрибуты: `date`, `caption`, `content`.

* Необходимо отсылать электронные письма каждый раз, когда через экран `NewsItemEdit` создается новый экземпляр сущности. Email должен содержать `NewsItem.caption` в качестве темы письма, тело письма должно формироваться на основе шаблона, включающего `NewsItem.content`.
--

. Добавьте следующий код в `NewsItemEdit.java`:
+
--
[source, java]
----
include::{sourcesdir}/development/sending_emails_1.java[]
----

Как видно, метод `sendByEmail()` вызывает сервис `EmailService` и передает ему экземпляр `EmailInfo`, описывающий сообщение. Тело сообщений будет создаваться на основе шаблона `news_item.txt`.
--

. Создайте шаблон тела письма в файле `news_item.txt` в пакете `com.company.demo.templates` модуля *core*:
+
--
[source, plain]
----
include::{sourcesdir}/development/sending_emails_2.txt[]
----

Это шаблон link:http://freemarker.incubator.apache.org[Freemarker], который использует параметры, переданные в `EmailInfo` (в данном случае единственный параметр `newsItem`).
--

. Запустите приложение, откройте браузер сущности `NewsItem` и нажмите *Create*. Откроется экран редактирования сущности. Заполните поля и нажмите *OK*. Появится диалог подтверждения с вопросом об отсылке email. Нажмите *Yes*.

. Перейдите в экран *Administration > Email History* вашего приложения. Вы увидите две записи (по числу получателей) со статусом `Queue`. Он означает, что сообщения находятся в очереди и еще не отосланы.

. Для обработки очереди необходимо создать <<scheduled_tasks_cuba,назначенное задание>>. Перейдите в экран *Administration > Scheduled Tasks* вашего приложения. Создайте новую задачу и установите ей следующие параметры:
+
--
* *Bean Name* - `cuba_Emailer`
* *Method Name* - `processQueuedEmails()`
* *Singleton* - да (этот параметр важен только при эксплуатации кластера серверов middleware)
* *Period, sec* - 10
--
+
Сохраните задачу и нажмите на ней *Activate*.
+
Если вы ранее не настраивали выполнение назначенных заданий для данного приложения ранее, то на данном этапе ничего не произойдет - новая задача не начнет выполняться пока вы не запустите весь механизм назначенных заданий.

. Откройте файл `modules/core/src/app.properties` и добавьте в него следующее <<cuba.schedulingActive,свойство>>:
+
[source, properties]
----
cuba.schedulingActive = true
----
+
Перезапустите сервер приложения. Механизм выполнения заданий теперь активен и вызывает обработку очереди email.

. Перейдите в экран *Administration > Email History*. Статус сообщений будет либо `Sent`, если они успешно отосланы, либо, что более вероятно, `Sending` или `Queue`, если произошла ошибка отправки. В последнем случае вы можете открыть журнал приложения в файле `build/tomcat/logs/app.log` и выяснить причину. Механизм отсылки email предпримет несколько (по умолчанию 10) попыток и в случае неудачи переведет сообщения в статус `Not sent`.

. Наиболее очевидной причиной ошибки отправки является то, что вы не настроили <<email_sending_properties,параметры>> SMTP-сервера. Эти параметры могут быть заданы в базе данных с помощью  JMX бина `app-core.cuba:type=Emailer` или в свойствах приложения блока middleware. Рассмотрим второй способ. Откройте файл `modules/core/src/app.properties` и добавьте в него требуемые <<email_sending_properties,параметры>>:
+
[source, properties]
----
include::{sourcesdir}/development/sending_emails_3.properties[]
----
+
Перезапустите сервер приложения. Перейдите в экран *Administration > JMX Console*, найдите JMX бин `Emailer` и попробуйте послать самому себе тестовое сообщение с помощью операции `sendTestEmail()`.

. Теперь механизм отсылки email настроен корректно, однако он не будет отсылать сообщения, уже переведенные в статус `Not sent`. Поэтому необходимо создать новый экземпляр `NewsItem` через экран редактирования. Сделайте это и понаблюдайте, как статус новых сообщений в экране *Email History* изменится на `Sent`.

[[own_component_samples]]
==== Создание собственных визуальных компонентов

В разделе <<own_components>> был приведен обзор методов расширения набора стандартных визуальных компонентов в проекте. У вас есть следующие варианты:

. Подключение аддона Vaadin. Много сторонних компонентов Vaadin распространяются в виде дополнений (add-on). Библиотека аддонов находится по адресу https://vaadin.com/directory.

. Подключение компонента, написанного на JavaScript. Vaadin дает возможность создавать серверные компоненты, использующие JavaScript-библиотеку.

. Создание собственного компонента Vaadin с клиентской частью, написанной на GWT.

Далее вы можете интегрировать получившийся компонент Vaadin в универсальный пользовательский интерфейс CUBA, чтобы иметь возможность использовать его декларативно в XML-дескрипторах экранов и привязывать к источникам данных.

Финальным шагом интеграции является поддержка нового компонента в WYSIWYG редакторе экранов Studio.

Далее в этом разделе приводятся примеры создания новых визуальных компонентов каждым из описанных выше способов. Интеграция в Generic UI одинакова для всех трех способов, поэтому она описана только для примера с подключением аддона Vaadin.

[[vaadin_addon_sample]]
===== Подключение аддона Vaadin

Рассмотрим пример использования компонента *Stepper*, доступного по адресу http://vaadin.com/addon/stepper. Данный компонент позволяет пошагово изменять значение текстового поля с помощью клавиатуры, колесика мыши и встроенных кнопок вверх/вниз.

Создайте новый проект в CUBA Studio и назовите его `addon-demo`.

Для подключения аддона Vaadin проект должен иметь модуль *web-toolkit*. Создайте его, нажав на ссылку *Create web toolkit module* секции *Project properties* навигатора.

Далее нажмите на ссылку *New UI component*. Откроется окно создания визуального компонента *UI component generation*. В секции *Component type* выберите значение `Vaadin add-on`.

image::ui_component/studio_vaadin_addon_wizard_no_gui.png[align="center"]

Заполните следующие поля:

* *Add-on Maven dependency* - в этом поле необходимо указать Maven-координаты аддона Vaadin для подключения его как зависимости к текущему проекту. Указание координат возможно в двух форматах:

. XML, скопированный с сайта аддона (http://vaadin.com/addon/stepper):
+
[source, xml]
----
<dependency>
   <groupId>org.vaadin.addons</groupId>
   <artifactId>stepper</artifactId>
   <version>2.2.2</version>
</dependency>
----

. Одной строкой в том виде, как вы добавляете зависимости в <<build.gradle,build.gradle>>: `org.vaadin.addons:stepper:2.2.2`

* *Inherited widgetset* - в этом поле необходимо указать имя виджетсета подключаемого аддона:
+
[source]
----
org.vaadin.risto.stepper.widgetset.StepperWidgetset
----

* *Integrate into generic UI* - в данном примере флажок должен быть снят, т.к. мы не интегрируем компонент в универсальный интерфейс платформы.

Нажмите кнопку *OK*.

Если открыть проект в IDE, то можно увидеть, что Студия изменила два файла:

. <<build.gradle, build.gradle>>. В модуле *web* появилась новая зависимость от аддона, содержащего компонент:
+
[source, java]
----
configure(webModule) {
    ...
    dependencies {
        ...
        compile("org.vaadin.addons:stepper:2.2.2")
    }
----

. В файл `AppWidgetSet.gwt.xml` модуля *web-toolkit* проекта подключен виджетсет аддона после виджетсета платформы:
+
[source, xml]
----
<module>
    <inherits name="com.haulmont.cuba.web.toolkit.ui.WidgetSet" />

    <inherits name="org.vaadin.risto.stepper.widgetset.StepperWidgetset" />

    <set-property name="user.agent" value="safari" />
----
+
[TIP]
====
Для более быстрой сборки виджетов на время разработки вы можете установить свойство `user.agent`. В данном примере набор виджетов будет собираться только для браузеров, основанных на WebKit: Chrome, Safari, и т.д.
====

Компонент из аддона Vaadin подключен. Далее мы покажем как использовать его в экранах проекта.

* Создаем новую сущность `Customer` с двумя полями:

** `name` типа String
** `score` типа Integer

* Сгенерируем для новой сущности стандартные экраны. В диалоге генерации стандартных экранов убедитесь что значение поля *In module* - `Web Module`. Экраны, использующие компоненты Vaadin напрямую, должны располагаться в модуле *web*.
+
[TIP]
====
На самом деле экран может располагаться и в модуле *gui*, но тогда код, работающий с Vaadin компонентом, должен быть вынесен в отдельный <<companions,компаньон>>.
====

* Далее добавим компонент `stepper` на экран. Вы можете поместить его как в <<gui_FieldGroup,FieldGroup>>, так и вне ее. Рассмотрим оба способа.
+
--
. В XML-дескрипторе экрана редактирования `customer-edit.xml` для поля `score` компонента `fieldGroup` добавим атрибут `custom = "true"`:
+
[source, xml]
----
include::{sourcesdir}/ui_component/vaadin_no_gui/customer-edit-nogui-custom-field.xml[]
----
+
В контроллер экрана редактирования `CustomerEdit.java` добавим следующий код:
+
[source, java]
----
include::{sourcesdir}/ui_component/vaadin_no_gui/CustomerEditNoGuiCustomField.java[]
----
+
Здесь в поле `stepper` создается экземпляр компонента, подключенного из аддона. В методе `init()` производится инициализация кастомного поля `score`. Через `ComponentsFactory` создается экземпляр <<gui_BoxLayout>>, затем из него с помощью <<webComponentsHelper,WebComponentsHelper>> извлекается ссылка на Vaadin-контейнер, и в этот контейнер добавляется наш новый компонент. `BoxLayout` возвращается для отображения в кастомном поле.
+
Для связи компонента с данными во-первых, в методе `postInit()` ему устанавливается текущее значение из редактируемого `Customer`, а во-вторых, добавляется слушатель на изменение значения, который обновляет соответствующий атрибут сущности при изменении значения пользователем.

. Чтобы использовать новый компонент вне `FieldGroup` в произвольном месте экрана в XML-дескрипторе объявим контейнер `scoreBox` и удалим поле `score` из `fieldGroup`:
+
[source, xml]
----
include::{sourcesdir}/ui_component/vaadin_no_gui/customer-edit-nogui-container.xml[]
----
+
В контроллере инжектируем контейнер, извлекаем ссылку на Vaadin-контейнер и добавляем в него компонент:
+
[source, java]
----
include::{sourcesdir}/ui_component/vaadin_no_gui/CustomerEditNoGuiContainer.java[]
----
+
Связь с данными выполняется здесь аналогично примеру с `FieldGroup`.
--

* Для адаптации внешнего вида компонента создадим в проекте расширение темы. Для этого в Studio выполним команду *Create theme extension* секции *Project properties* навигатора. В списке тем для расширения выберем `halo` и нажмем кнопку *Create*. Затем откроем файл `themes/halo/halo-ext.scss` модуля *web*, и добавим в него следующий код:
+
[source, css]
----
include::{sourcesdir}/ui_component/vaadin_no_gui/halo-ext.scss[]
----

* Запускаем сервер приложения. Экран редактирования должен выглядеть следующим образом:

image::ui_component/customer_edit_result.png[align="center"]

[[vaadin_addon_sample_gui]]
===== Подключение аддона Vaadin с интеграцией в Generic UI

В <<vaadin_addon_sample,предыдущем разделе>> мы подключили в проект сторонний компонент Stepper. В данном разделе мы интегрируем его в универсальный пользовательский интерфейс CUBA, что даст разработчикам возможность использовать компонент декларативно в XML-дескрипторах экранов и связывать его с сущностями через <<datasources,источники данных>>.

Создадим новый проект в CUBA Studio и назовем его `addon-gui-demo`. В поле *Project namespace* введем значение `agd`.

Создадим модуль *web-toolkit*, нажав на кнопку *Create web toolkit module* секции *Project properties* навигатора Studio.

Далее нажимаем на кнопку *New UI component*. Откроется окно создания визуального компонента *UI component generation*. В секции *Component type* выбираем значение `Vaadin add-on`.

image::ui_component/studio_vaadin_addon_wizard_gui.png[align="center"]

Заполним поля *Add-on Maven dependency* и *Inherited widgetset* как описано в <<vaadin_addon_sample,предыдущем разделе>>.

Далее заполним поля в нижней секции:

* *Integrate into Generic UI* указывает на необходимости интеграции компонента в универсальный пользовательский интерфейс платформы.

* *Component XML element* -  имя элемента компонента в XML-дескрипторе экрана. Введите значение `stepper`.

* *Component interface name* - имя интерфейса компонента для универсального UI платформы. Введите `Stepper`.

* *FQN of Vaadin component from add-on* - полное имя класса компонента Vaadin из аддона. В нашем случае это `org.vaadin.risto.stepper.IntStepper`.

После нажатия кнопки *OK* Studio сделает следующее:

* Добавит аддон Vaadin в зависимости модуля *web* в файле `build.gradle`.

* Подключит виджетсет аддона в файле `AppWidgetSet.gwt.xml` модуля *web-toolkit*.

* Сгенерирует заготовки для следующих файлов:

** `Stepper` - интерфейс компонента в модуле *gui*.

** `WebStepper` - реализация компонента в модуле *web*.

** `StepperLoader` - XML-загрузчик компонента в модуле *gui*.

** `ui-component.xsd` - описатель схемы XML для нового компонента. Если файл уже существовал на момент генерации компонента, то информация о новом компоненте будет добавлена в существующий файл.

** `cuba-ui-component.xml` - файл регистрации загрузчика нового компонента в модуле *web*. Если файл существовал, то информация о новом компоненте будет добавлена в существующий файл.

Откройте проект в IDE.

Последовательно пройдемся по сгенерированным Studio заготовкам файлов и внесем в них необходимые изменения.

* Перейдите к интерфейсу `Stepper` в модуле *gui*. Замените его содержимое на следующий код:
+
[source, java]
----
include::{sourcesdir}/ui_component/vaadin_gui/Stepper.java[]
----
+
В качестве базового для нашего компонента выбран интерфейс `Field`. Это позволяет осуществить связь с данными (data binding), то есть отображать и редактировать значение некоторого атрибута сущности.

* Далее перейдите к классу `WebStepper` - реализации компонента в модуле *web*. Замените содержимое класса следующим кодом:
+
[source, java]
----
include::{sourcesdir}/ui_component/vaadin_gui/WebStepper.java[]
----
+
В качестве базового класса выбран `WebAbstractField`, который реализует логику интерфейса `Field`.

* `StepperLoader` в модуле *gui* загружает компонент из его представления в XML.
+
[source, java]
----
include::{sourcesdir}/ui_component/vaadin_gui/StepperLoader.java[]
----
+
Логика загрузки базовых свойств компонента `Field` сосредоточена в классе `AbstractFieldLoader`. Нам достаточно загрузить только специфические свойства `Stepper`.

* В файле `cuba-ui-component.xml`, расположенном в корне модуля *web*, регистрируется новый компонент и его загрузчик. Оставляем файл без изменений.
+
[source, xml]
----
include::{sourcesdir}/ui_component/vaadin_gui/cuba-ui-component.xml[]
----

* Файл `ui-component.xsd`, расположенный в корне модуля *gui*, это описатель XML схемы новых компонентов проекта. Добавим к элементу `stepper` описание его атрибутов.
+
[source, xml]
----
include::{sourcesdir}/ui_component/vaadin_gui/ui-component.xsd[]
----

Далее рассмотрим, как добавить новый компонент на экран.

* Создадим новую сущность `Customer` с двумя полями:

** `name` типа String
** `score` типа Integer

* Сгенерируем для новой сущности стандартные экраны.

* Далее добавим компонент `stepper` на экран. Вы можете поместить его как в <<gui_FieldGroup,FieldGroup>>, так и в отдельный контейнер. Рассмотрим оба способа.

. Использование компонента в экране внутри произвольного контейнера.
+
--
* Откройте файл `customer-edit.xml`.

* Объявите новое пространство имен `xmlns:app="http://schemas.company.com/agd/0.1/ui-component.xsd"`

* Удалите поле `score` из `fieldGroup`.

* Добавьте компонент `stepper` на экран.

В результате XML-дескриптор редактора должен выглядеть так:

[source, xml]
----
include::{sourcesdir}/ui_component/vaadin_gui/customer-edit-gui-container.xml[]
----

В данном примере компонент `stepper` подсоединен к атрибуту `score` сущности `Customer`, экземпляр которой находится в источнике данных `customerDs`.
--

. Использование компонента в поле <<gui_FieldGroup>>:
+
[source, xml]
----
include::{sourcesdir}/ui_component/vaadin_gui/customer-edit-gui-custom-field.xml[]
----
+
[source, java]
----
include::{sourcesdir}/ui_component/vaadin_gui/CustomerEditGuiCustomField.java[]
----

* Для адаптации внешнего вида компонента создадим в проекте расширение темы. Для этого в Studio выполним команду *Create theme extension* секции *Project properties* навигатора. В списке тем для расширения выберем `halo` и нажмем кнопку *Create*. Затем откроем файл `themes/halo/halo-ext.scss` модуля *web*, и добавим в него следующий код:
+
[source, css]
----
include::{sourcesdir}/ui_component/vaadin_gui/halo-ext.scss[]
----

* Запускаем сервер приложения. Экран редактирования должен выглядеть следующим образом:

image::ui_component/customer_edit_result.png[align="center"]

[[js_library_sample]]
===== Подключение JavaScript библиотеки

В данном примере мы подключим компонент https://jqueryui.com/slider/#range[Slider] из библиотеки *jQuery UI*. Слайдер будет иметь два ползунка, определяющих диапазон значений.

Создайте новый проект в CUBA Studio и назовите его `jscomponent`.

Далее нажмите на кнопку *New UI component*. Откроется окно создания визуального компонента *UI component generation*. В секции *Component type* выберите значение `JavaScript component`.

image::ui_component/studio_js_component_wizard.png[align="center"]

В поле *Vaadin component class name* диалога генерации компонента введите значение `SliderServerComponent`.

Уберите флажок *Integrate into Generic UI*. Процесс интеграции компонента в универсальный интерфейс аналогичен описанному в разделе <<vaadin_addon_sample_gui>>, поэтому рассматривать его здесь мы не будем.

После нажатия кнопки *OK* Studio сгенерирует файлы:

* `SliderServerComponent` - интегрированный с JavaScript компонент Vaadin.

* `SliderState` - класс состояния компонента Vaadin.

* `slider-connector.js` - JavaScript коннектор для компонента Vaadin

Последовательно пройдемся по сгенерированным заготовкам файлов и внесем в них необходимые изменения.

* Класс состояния `SliderState` определяет, какие данные будут пересылаться между сервером и клиентом. В нашем случае мы будем пересылать информацию о минимальном и максимальном возможном значении и выбранных значениях слайдера.
+
[source, java]
----
include::{sourcesdir}/ui_component/js/SliderState.java[]
----

* Серверный компонент Vaadin `SliderServerComponent`.
+
[source, java]
----
include::{sourcesdir}/ui_component/js/SliderServerComponent.java[]
----
+
Серверный компонент Vaadin определяет набор геттеров и сеттеров для работы с состоянием слайдера, а также интерфейс слушателя изменения значений. Класс компонента должен быть унаследован от `AbstractJavaScriptComponent`.
+
Метод `addFunction()` в конструкторе класса объявляет обработчик RPC-вызова функции `valueChanged()` с клиента.
+
Аннотации `@JavaScript` и `@StyleSheet` указывают на файлы, которые должны быть загружены на веб-страницу. В нашем примере это JavaScript файлы библиотеки jQuery UI и коннектора, а также файл со стилями для jQuery UI. Расположим их в одном Java-пакете с серверным компонентом.

Скачайте архив jQuery UI с сайта http://jqueryui.com/download и поместите файлы `jquery-ui.js` и `jquery-ui.css` в пакет с классом `SliderServerComponent`. На странице скачивания jQuery UI у вас будет возможность выбрать компоненты, которые будут помещены в архив. Для нашего примера достаточно выделить пункт `Slider` группы `Widgets`.

image::ui_component/js_project_structure.png[align="center"]

* JavaScript коннектор `slider-connector.js`.
+
[source, javascript]
----
include::{sourcesdir}/ui_component/js/slider-connector.js[]
----
+
Коннектор представляет собой функцию, которая при загрузке веб-страницы проинициализирует JavaScript компонент. Имя функции должно соответствовать полному имени класса серверного компонента, где точки в имени пакета заменены на символ подчеркивания.
+
Vaadin добавляет ряд полезных методов в фунцию коннектора. Например, `this.getElement()` возвращает HTML DOM элемент компонента, `this.getState()` возвращает объект-состояние.
+
В нашем примере коннектор делает следующее:
+
--
* Инициализирует компонент `slider` из библиотеки jQuery UI. При изменении положения одного из ползунков будет вызывана функция `slide()`. Мы видим, что она в свою очередь вызывает метод `valueChanged()` коннектора. `valueChanged()` - это метод, который мы объявили на стороне сервера в классе `SliderServerComponent`.

* Объявляет функцию `onStateChange()`. Она будет вызываться при изменении объекта-состояния на стороне сервера.
--

Для демонстрации работы компонента создадим сущность `Product` с тремя атрибутами:

* `name` типа String
* `minDiscount` типа Double
* `maxDiscount` типа Double

Затем сгенерируем стандартные экраны для данной сущности. Обратите внимание, что мы используем не универсальный компонент платформы, а "нативный" компонент Vaadin. Следовательно экраны должны располагаться в модуле Web, а не в GUI - укажите это в окне генерации стандартных экранов.

В редакторе сущности мы хотим устанавливать минимальное и максимальное значение скидки с помощью компонента `slider`, который мы только что создали.

Перейдите к файлу `product-edit.xml`. Поля `minDiscount` и `maxDiscount` сделайте нередактируемыми, добавив к соответствующим элементам атрибут `editable="false"`. Затем добавьте в `fieldGroup` новое кастомное поле `slider`.

В результате XML-дескриптор экрана редактирования должен выглядеть следующим образом:

[source, xml]
----
include::{sourcesdir}/ui_component/js/product-edit.xml[]
----

Перейдите к файлу `ProductEdit.java`. Замените его содержимое следующим кодом:

[source, java]
----
include::{sourcesdir}/ui_component/js/ProductEdit.java[]
----

В методе `initNewItem()` мы проставляем начальные значения скидок для нового продукта.

В методе `init()` инициализируем кастомное поле для слайдера. Для компонента слайдера мы проставляем текущие значения, максимальное и минимальное значения, а также объявляем слушатель изменений значений. При движении ползунка мы будем проставлять новые значения скидок в соответвующие поля редактируемой сущности.

Запустите проект и откройте экран редактирования продукта. Изменение положения ползунка на слайдере должно изменять значение в соответствующем текстовом поле.

image::ui_component/product_edit.png[align="center"]

[[gwt_component_sample]]
===== Создание GWT компонента

В данном примере мы рассмотрим создание простого GWT-компонента - поля рейтинга в виде 5 звезд, а также использование его в экранах приложения.

image::ui_component/rating_field_component.png[align="center"]

Создадим новый проект в CUBA Studio. Имя проекта - `ratingsample`.

Создайте модуль *web-toolkit*, нажав на кнопку *Create web-toolkit module* секции *Project properties* навигатора Studio.

Далее нажмите на ссылку *Create new UI component*. Откроется окно создания визуального компонента *New UI component*. В секции *Component type* выберите значение `New GWT component`.

image::ui_component/studio_gwt_component_wizard.png[align="center"]

В поле *Vaadin component class name* диалога генерации компонента введите значение `RatingFieldServerComponent`.

Снимите флажок *Integrate into Generic UI*. Процесс интеграции компонента в универсальный интерфейс аналогичен описанному в разделе <<vaadin_addon_sample_gui>>, поэтому рассматривать его здесь мы не будем.

После нажатия кнопки *OK* Studio сгенерирует файлы:

* `RatingFieldWidget.java` - виджет GWT в модуле *web-toolkit*.

* `RatingFieldServerComponent.java` - класс компонента Vaadin.

* `RatingFieldState.java` - класс состояния компонента.

* `RatingFieldConnector.java` - коннектор, связывающий клиентский код с серверным компонентом.

* `RatingFieldServerRpc.java` - класс, определяющий API сервера для клиентской части.

Последовательно рассмотрим сгенерированные студией заготовки файлов и внесем в них необходимые изменения.

* GWT виджет `RatingFieldWidget.java`. Замените содержимое файла на следующий код:
+
[source, java]
----
include::{sourcesdir}/ui_component/gwt/RatingFieldWidget.java[]
----
+
Виджет представляет собой клиентский класс, отвечающий за отображение компонента в веб-браузере и реакцию на события. Он определяет интерфейсы для работы с серверной частью. В нашем случае это метод `setValue()` и интерфейс `StarClickListener`.

* Класс компонента Vaadin `RatingFieldServerComponent`. Он определяет API для серверного кода, различные get/set методы, слушатели событий и подключение источников данных. Прикладные разработчики используют в своём коде методы этого класса.
+
[source, java]
----
include::{sourcesdir}/ui_component/gwt/RatingFieldServerComponent.java[]
----

* Класс состояния `RatingFieldState` отвечает за то, какие данные будут пересылаться между клиентом и сервером. В нём определяются публичные поля, которые будут автоматически сериализованы на сервере и десериализованы на клиенте.
+
[source, java]
----
include::{sourcesdir}/ui_component/gwt/RatingFieldState.java[]
----

* Интерфейс `RatingFieldServerRpc` — определяет API сервера для клиентской части, его методы могут вызываться с клиента при помощи механизма удалённого вызова процедур, встроенного в Vaadin. Этот интерфейс мы реализуем в самом компоненте, в данном случае просто вызываем метод `setValue()` нашего поля.
+
[source, java]
----
include::{sourcesdir}/ui_component/gwt/RatingFieldServerRpc.java[]
----

* Коннектор `RatingFieldConnector` связывает клиентский код с серверной частью.
+
[source, java]
----
include::{sourcesdir}/ui_component/gwt/RatingFieldConnector.java[]
----

Код виджета `RatingFieldWidget` не определяет внешний вид компонента, кроме назначения имён стилей ключевым элементам. Для того, чтобы определить внешний вид нашего компонента, создадим файлы стилей. Для этого можно воспользоваться ссылкой *Create theme extension* секции *Project properties* в навигаторе Studio. В появившемся диалоге выбираем тему `halo`. Эта тема использует вместо иконок глифы шрифта FontAwesome, чем мы и воспользуемся. Studio создаст пустые файлы SCSS для расширения темы в каталоге `themes` модуля *web*.

Стили каждого компонента принято выделять в отдельный файл `componentname.scss` в каталоге `components/componentname` в формате примеси SCSS. В каталоге `themes/halo` модуля `web` создадим структуру вложенных каталогов: `components/ratingfield`. Затем внутри `ratingfield` создадим файл `ratingfield.scss`:

image::ui_component/gwt_theme_ext_structure.png[align="center"]

[source, css]
----
include::{sourcesdir}/ui_component/gwt/ratingfield.scss[]
----

Подключим этот файл в главном файле темы `halo-ext.scss`:

[source, css]
----
include::{sourcesdir}/ui_component/gwt/halo-ext.scss[]
----

Для демонстрации работы компонента создадим новый экран в модуле *web*.

Назовите файл с экраном `rating-screen.xml`.

image::ui_component/gwt_rating_screen_designer.png[align="center"]

Добавим экран в меню приложения. Перейдите в секцию *Main menu* навигатора Studio и нажмите кнопку *Edit*. Откроется редактор меню. Добавьте созданный экран в меню `application`.

Перейдем к редактированию экрана `rating-screen.xml` в IDE. Нам понадобится контейнер для нашего компонента, объявим его в XML экрана:

[source, xml]
----
include::{sourcesdir}/ui_component/gwt/rating-screen.xml[]
----

Откроем класс контроллера экрана `RatingScreen.java` и добавим код размещения нашего компонента на экране:

[source, java]
----
include::{sourcesdir}/ui_component/gwt/RatingScreen.java[]
----

Запускаем сервер приложения и смотрим на результат.

image::ui_component/rating_screen_result.png[align="center"]

[[own_component_in_studio]]
===== Поддержка собственных компонентов в CUBA Studio

В данном разделе описывается, как добавить поддержку новых визуальных компонентов в дизайнер экранов CUBA Studio. Новый компонент появится в палитре компонентов, вы сможете перетаскивать его в рабочую область и редактировать его свойства в панели свойств компонента.

Рассмотрим процесс создания интеграции компонента `stepper`, создание которого было описано в разделе <<vaadin_addon_sample_gui>>.

Откроем проект, содержащий компонент `stepper`.

[TIP]
====
Если указанный проект вы не создавали, то вы можете воспроизвести шаги, описанные ниже, и на новом проекте. Вы увидите поддержку компонента в Studio, но не сможете запустить приложение.
====

Нажмем кнопку *Extend Studio* на панели *Project properties*.

image::ui_component/ui_component_extension_window.png[align="center"]

Рассмотрим поля, которые необходимо заполнить.

* *Configuration name* - идентификатор конфигурации. Введем значение `stepper`.

* *Component XML element* - имя компонента в том виде, как он должен быть добавлен в XML-дескриптор экрана. В нашем случае это `stepper`.
+
Поля *Component class name* и *Component model class name* будут заполнены автоматически на основе введенного значения. Оставьте их значения без изменения.

* *Component namespace URI* - пространство имен из XSD, описывающего компонент. Если вы генерировали новый компонент с помощью Studio, то узнать значение для этого поля вы можете в файле `ui-component.xsd`.

* *Component namespace prefix* - префикс XML-элемента компонента в XML-дескриптор экрана.

* *Standard properties* - стандартные свойства компонента, которые должны быть доступны для редактирования в панели свойств компонента в дизайнере экранов.
+
Выберите `caption`, `datasource` и `property`.
+
[TIP]
====
Свойства `id`, `align`, `height`, `width`, `enable`, `stylename`, `visible` по умолчанию доступны для всех компонентов.
====

* *Custom properties* - в данной таблице добавляются специфичные для компонента свойства, которые должны редактироваться в панели свойств дизайнера экранов.
+
--
Добавим следующие свойства:

* *manualInput*, тип `Boolean`, значение по умолчанию `true`

* *mouseWheel*, тип `Boolean`, значение по умолчанию `true`

* *stepAmount*, тип `Integer`, значение по умолчанию `0`

* *maxValue*, тип `Integer`, значение по умолчанию `0`

* *minValue*, тип `Integer`, значение по умолчанию `0`
--

Далее нажмитие кнопку *OK*.

Новые визуальные компоненты инициализируются при старте сервера Studio. Откройте окно сервера Studio, остановите сервер, выйдите из Studio, затем отройте и запустите его снова.

Сгенерируем стандартные экраны для сущности `Customer` заново, чтобы стереть результаты наших прошлых экспериментов.

Переходим в секцию *GENERIC UI* навигатора студии и открываем экран `customer-edit`.

Для начала удалим поле `score` из `fieldGroup`, т.к. мы хотим для его редактирования использовать специальный компонент.

На палитре компонентов найдите новый компонент `Stepper` и перетащите его на экран под `fieldGroup`.

image::ui_component/stepper_in_palette.png[align="center"]

Выделите компонент `stepper` и перейдите на закладку свойств компонента *Properties*.

image::ui_component/stepper_component_properties.png[align="center"]

Заполните необходимые поля:

* *id* - `stepper`

* *caption* - `Stepper`

* *datasource* - `customerDs`

* *property* - `score`

* *maxValue* - `50`

После этого перейдите на закладку *XML*, чтобы увидеть результат.

[source, xml]
----
include::{sourcesdir}/ui_component/studio_support/customer-edit.xml[]
----

В XML экрана объявлено пространство имен компонента с префиксом `app`, компонент `stepper` добавлен на экран, и у него установлены необходимые свойства.

[[app_components_sample]]
==== Использование компонентов приложения

Как упоминалось в разделе  <<app_components,>>, любое CUBA-приложение может быть компонентом другого приложения. Компонент приложения представляет собой по сути full-stack библиотеку, предоставляющую функциональность на всех уровнях - от схемы БД до бизнес-логики и UI.

В данном разделе рассматривается пример создания компонента приложения и использования его в проекте. Компонент будет предоставлять функциональность "Customer Management" и содержать сущность `Customer` и соответствующие экраны UI. Приложение будет использовать сущность `Customer` из компонента в качестве ссылки в собственной сущности `Order`.

image::app_components_sample.png[align="center"]

Создание компонента Customer Management::

. Создайте новый проект в Studio и укажите следующие значения в окне *New project*:

* *Project name* - `customers`

* *Project namespace* - `cust`

* *Root package* - `com.company.customers`

. Откройте *Project properties* на редактирование и на вкладке *Advanced* установите значение поля *Module prefix* в `cust`. Это необходимо для того, чтобы имена артефактов компонента имели префикс, отличный от `app`, принятого по умолчанию.

. Создайте сущность `Customer` с атрибутом `name`. Переключитесь на вкладку *Instance name* и укажите `name` в атрибутах name pattern.
+
[WARNING]
====
Если компонент содержит персистентные классы, аннотированные `@MappedSuperclass`, убедитесь, что в этом же проекте есть их наследники, являющиеся сущностями (т.е. аннотированные `@Entity`). В противном случае байткод таких базовых классов не будет необходимым образом модифицирован и они не будут правильно работать в приложениях, использующих компонент.
====

. Сгененрируйте скрипты БД и создайте стандартные экраны для сущности `Customer`: `cust$Customer.browse` и `cust$Customer.edit`. После этого откройте дизайнер меню и переименуйте пункт `application` в `customerManagement`.

. Нажмите на ссылку *App component descriptor* на панели *Project properties*. Сохраните сгенерированный <<app-component.xml,описатель компонента>> нажав *OK*.

. Проверьте функциональность Customer Management: *Run > Create database*, *Run > Start application server*, затем откройте `++http://localhost:8080/cust++` в веб-браузере.

. Установите компонент приложения в локальный Maven-репозиторий, выполнив команду главного меню *Run > Install app component*. Данная команда просто запускает задачу Gradle `install` после остановки демонов Gradle.

Создание приложения Sales::

. Создайте новый проект в Studio и укажите следующие значения в окне *New project*:

* *Project name* - `sales`

* *Project namespace* - `sales`

* *Root package* - `com.company.sales`

. Откройте *Project properties* на редактирование и на панели *App components* нажмите на кнопку добавления *Custom components*. В диалоге *Custom application component* выберите проект `customers` в списке *Registered project*. Данный список содержит все проекты, зарегистрированные в Studio и имеющие описатель `app-component.xml`. Нажмите в диалоге *OK*. В списке кастомных компонентов проекта появятся Maven-координаты компонента Customer Management. Сохраните страницу свойств проекта нажатием *OK*.

. Создайте сущность `Order` с атрибутами `date` и `amount`. Добавьте атрибут `customer` в виде many-to-one ассоциации с сущностью `Customer` - она дожна быть доступна в выпадающем списке *Type*.

. Сгенерируйте скрипты БД и создайте стандартные экраны для сущности `Order`. При создании экранов создайте представление `order-with-customer-view`, включающее атрибут `customer` и используйте его в экранах.

. Проверьте функциональность приложения: *Run > Create database*, *Run > Start application server*, затем откройте `++http://localhost:8080/app++` в веб-браузере. Приложение должно содержать два пункта меню верхнего уровня: *Customer Management* и *Application*.

Модификация компонента Customer Management::

Предположим, что необходимо изменить функциональность компонента (добавить атрибут в сущность `Customer`) и пересобрать приложение для внесения этих изменений.

. Откройте проект `customers` в Studio.

. Откройте сущность `Customer` на редактирование и добавьте атрибут `address`. При сохранении изменений выберите экраны браузера и редактора для включения нового атрибута.

. Сгенерируйте скрипты БД - будет создано новый скрипт обновления с изменением таблицы. Сохраните скрипты.

. Проверьте изменения в компоненте: *Run > Update database*, *Run > Start application server*, затем откройте `++http://localhost:8080/cust++` в веб-браузере.

. Переинсталлируйте компонент в локальный Maven-репозиторий выполнив команду меню *Run > Install app component*.

. Закройте проект `customers` и откройте `sales`.

. Выполните команды меню *Build > Clean*, затем *Build > Assemble project*.

. Запустите *Run > Update database* - будет выполнен скрипт обновления из компонента Customer Management.

. Выполните *Run > Start application server* и откройте `++http://localhost:8080/app++` в веб-браузере - приложение теперь содержит сущность `Customer` и соответствующие экраны с атрибутом `address`.

Предоставление общего доступа к компоненту Customer Management::

Компонент приложения можно выгрузить в удаленный Maven-репозиторий.

. Остановите сервер Studio.

. Установите репозиторий  как описано в разделе <<private_repo>>.

. Откройте `build.gradle` проекта `customers` в текстовом редакторе. Замените репозиторий и имя/пароль пользователя в секции `buildscript/repositories` и добавьте `uploadRepository` в секции `cuba`:
+
[source,groovy]
----
include::{sourcesdir}/development/app_comp_upload_1.groovy[]
----

. Откройте командную строку в корневом каталоге проекта `customers` и выполните `gradle assemble`. Это необходимо для того, чтобы новый репозиторий закэшировал артефакты CUBA, требуемые для работы Studio.

. В окне сервера Studio укажите ваш репозиторий и имя/пароль для доступа к нему вместо стандартного репозитория CUBA. Запустите сервер Studio.

. Откройте проект `customers` в Studio.

. Найдите в диалоге *Search* (Alt-/) задачу Gradle `uploadArchives` и запустите ее. Эту задачу можно запускать и из командной строки. Артефакты компонента Customer Management будет выгружены в ваш репозиторий.

. Удалите артефакты компонента из локального Maven-репозитория чтобы быть уверенным, что они загрузятся из удаленного репозитория при последующей сборке приложения `sales`: просто удалите каталог `.m2/repository/com/company`, находящийся в домашнем каталоге пользователя.

. Откройте проект `customers` в Studio. Адрес репозитория в `build.gradle` будет автоматически заменен на тот, который указан в окне сервера Studio.

. Теперь можно собрать и запустить приложение - компонент Customer Management будет загружен из удаленного репозитория.
