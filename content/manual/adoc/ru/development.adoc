[[development]]
== Разработка приложений

Данная глава содержит практическую информацию по созданию приложений на основе платформы.

[[recommended_code_style]]
=== Рекомендуемый стиль кода

*Форматирование кода*

* Для Java и Groovy кода рекомендуется придерживаться стандартного стиля, описанного в документе link:$$http://www.oracle.com/technetwork/java/codeconv-138413.html$$[Code Conventions for the Java Programming Language]. При программировании в *IntelliJ IDEA* для этого достаточно использовать стиль по умолчанию, а для переформатирования применять сочетание клавиш *Ctrl-Alt-L*.
+
Максимальная длина строки − 120 символов. Длина отступа - 4 символа, использование пробелов вместо символов табуляции включено.

* XML код: длина отступа - 4 символа, использование пробелов вместо символов табуляции включено.

*Соглашения по именованию*

[cols="3*.^", frame="all", options="header"]
|===

^| Идентификатор ^| Правило именования ^| Пример

3+^| *Java и Groovy классы*

| Класс контроллера экрана
| UpperCamelCase

Контроллер экрана списка сущностей − `{КлассСущности}Browse`

Контроллер экрана редактирования − `{КлассСущности}Edit`

| `CustomerBrowse`

`OrderEdit`

3+^| *XML дескрипторы экранов*

| Идентификатор компонента, имена параметров в запросах
| lowerCamelCase, только буквы и цифры
| `attributesTable`

`:component$relevantTo`

`:ds$attributesDs`

| Идентификатор источника данных
| lowerCamelCase, только буквы и цифры, оканчивается на Ds
| `attributesDs`

3+^| *SQL скрипты*

| Зарезервированные слова| lowercase| `create table`

| Таблицы | UPPER_CASE. Название предваряется именем проекта для формирования пространства имен. В именах таблиц рекомендуется использовать единственное число.| `++SALES_CUSTOMER++`

| Колонки | UPPER_CASE| `CUSTOMER`

`++TOTAL_AMOUNT++`

|Колонки внешних ключей | UPPER_CASE. Состоит из имени таблицы, на которую ссылается колонка (без префикса проекта), и суффикса _ID.| `++CUSTOMER_ID++`

| Индексы | UPPER_CASE. Состоит из префикса IDX_, имени таблицы, для которой создается индекс (с префиксом проекта), и имен полей, включенных в индекс. | `++IDX_SALES_CUSTOMER_NAME++`

|===

[[project_file_structure]]
=== Файловая структура проекта

Рассмотрим файловую структуру проекта на примере простого приложения *Sales*, состоящего из <<app_tiers,блоков>> *Middleware*, *Web Client* и *Web Portal*.

.Файловая структура проекта
image::project_structure.png[align="center"]

В корне проекта расположены скрипты сборки `build.gradle`, `settings.gradle` и проектные файлы *IntelliJ IDEA*.

В каталоге `modules` расположены подкаталоги <<app_modules,модулей>> проекта − *global*, *core*, *gui*, *portal, web*. 

.Структура модуля global
image::project_structure_global.png[align="center"]

Модуль *global* содержит каталог исходных текстов `src`, в корне которого располагаются конфигурационные файлы `<<metadata.xml,metadata.xml>>`, `<<persistence.xml,persistence.xml>>` и <<views.xml,views.xml>>. Пакет `com.sample.sales.service` содержит интерфейсы сервисов *Middleware*, пакет `com.sample.sales.entity` - классы <<data_model,сущностей>> и <<message_packs,файлы локализации>> для них.

.Структура модуля core
image::project_structure_core.png[align="center"]

Модуль *core* содержит следующие каталоги:

* `db` - каталог <<db_scripts,скриптов создания и обновления>> базы данных.

* `src` - каталог исходных текстов, в корне которого расположены файл <<app_properties_files,свойств приложения>> блока *Middleware* и конфигурационный файл `<<spring.xml,spring.xml>>`. Пакет `com.samples.sales.service` содержит классы реализации <<services,сервисов>>.

* `web` - каталог с конфигурационными файлами веб-приложения, в которое собирается блок *Middleware*: `<<context.xml,context.xml>>` и `<<web.xml,web.xml>>`.

.Структура модуля gui
image::project_structure_gui.png[align="center"]

Модуль *gui* содержит каталог исходных текстов `src`, в корне которого располагается конфигурационный файл `<<screens.xml,screens.xml>>`. Пакет `com.sample.sales.gui` содержит XML-дескрипторы и контроллеры экранов и <<message_packs,файлы локализации>> для них.

.Структура модуля web
image::project_structure_web.png[align="center"]

Модуль *web* содержит следующие каталоги:

* `src` - каталог исходных текстов, в корне которого расположены файл <<app_properties_files,свойств приложения>> блока *Web Client* и конфигурационные файлы `<<menu.xml,web-menu.xml>>`, `<<permissions.xml,web-permissions.xml>>`, `<<screens.xml,web-screens.xml>>` и `<<spring.xml,web-spring.xml>>`. Пакет `com.samples.sales.web` содержит главный класс блока *Web Client* (наследник `DefaultApp`) и <<main_message_pack,главный пакет локализованных сообщений>>.

* `web` - каталог с конфигурационными файлами веб-приложения, в которое собирается блок *Web Client*: `<<context.xml,context.xml>>` и `<<web.xml,web.xml>>`.

[[build_scripts]]
=== Скрипты сборки

Для сборки проектов на основе платформы используется система сборки *Gradle*. Скрипты сборки представляют собой два файла в корневом каталоге проекта: 

* `settings.gradle` - задает название и состав <<app_modules,модулей>> проекта

* `build.gradle` - определяет конфигурацию сборки.

В данном разделе описывается структура скриптов, а также предназначение и параметры задач (tasks) Gradle.

[[build.gradle]]
==== Структура build.gradle

В данном разделе описывается структура и основные элементы скрипта `build.gradle`.

buildscript::
+
--
В секции `buildscript` задается следующее:

* Версия платформы, на которой основан данный проект.

* Набор репозиториев, из которых будут загружаться зависимости проекта. Когда вы создаете новый проект в CUBA Studio, он содержит ссылку на репозиторий, который указан в окне сервера Studio. По умолчанию это публичный репозиторий:
+
[source]
----
https://repo.cuba-platform.com/content/groups/work
----
+
Если ваш проект использует Премиум Дополнения, Studio добавляет еще один репозиторий:
+
[source]
----
https://repo.cuba-platform.com/content/groups/premium
----
+
Оба репозитория требуют указания имени пользователя и пароля. В то время как публичный репозиторий использует общеизвестные параметры, указанные прямо в скрипте сборки (`cuba` / `cuba123`), параметры подключения к репозиторию дополнений предоставляются по подписке на разработчика. Первая часть лицензионного ключа до тире представляет собой имя пользователя, вторая часть после тире - пароль. Например, если ваш ключ `111111222222-abcdefabcdef`, то имя - `111111222222`, пароль - `abcdefabcdef`
+
Studio передает Gradle параметры подключения когда запускает скрипт сборки. При сборке проекта вне Studio передайте `premiumRepoUser` и `premiumRepoPass` в командной строке в аргументах `-P`:
+
[source]
----
gradle assemble -PpremiumRepoUser=111111222222 -PpremiumRepoPass=abcdefabcdef
----

* Зависимости, используемые системой сборки. Они включают в себя CUBA Gradle плагин и набор <<app_components,компонентов приложения>>, используемых в проекте. Компоненты указываются координатами артефакта их модуля *global*. В примере ниже используются два компонента: `com.haulmont.cuba` (компонент *cuba* платформы) и `com.company.base` (кастомный компонент):
+
[source, groovy]
----
dependencies {
    classpath "com.haulmont.gradle:cuba-plugin:$cubaVersion"

    classpath "com.haulmont.cuba:cuba-global:$cubaVersion"
    classpath "com.company.base:base-global:0.1-SNAPSHOT"
}
----

После секции `buildscript` обявляются несколько переменных, используемых далее в скрипте.
--

cuba::
+
--
Логика сборки, специфичная для CUBA, сосредоточена в Gradle плагине `cuba`. Он подключается в корне скрипта и в секциях `configure` каждого модуля:

[source, groovy]
----
apply(plugin: 'cuba')
----

Параметры плагина *cuba* задаются в секции `cuba`:

[source, groovy]
----
include::{sourcesdir}/development/build_gradle_1.groovy[]
----

Рассмотрим доступные параметры:

* `artifact` - задает группу и версию собираемых <<artifact,артефактов>> проекта. Имена артефактов формируются на основе имен модулей, заданных в `settings.gradle`.

** `group` - группа артефактов.
** `version` - версия артефактов.
** `isSnapshot` - если установлено в `true`, то в именах артефактов будет присутствовать суффикс `SNAPSHOT`.

* `tomcat` - задает параметры сервера Tomcat, который используется для <<fast_deployment, быстрого развертывания>>.

** `dir` - расположение каталога <<build.gradle_setupTomcat, установки>> Tomcat.
** `port` - порт сервера; по умолчанию 8080.
** `debugPort` - порт для подключения Java отладчика; по умолчанию 8787.
** `shutdownPort` - порт для передачи команды `SHUTDOWN`; по умолчанию 8005.
** `ajpPort` - порт AJP connector; по умолчанию 8009.

* `ide` - задает некоторые параметры для Studio и IDE.

** `vcs` - тип используемой в проекте VCS. В данный момент поддерживаются только `Git` и `svn`.
** `copyright` - текст Copyright Notice, вставляемый в начало файлов исходных текстов.
** `classComment` - текст комментария, который будет расположен над объявлением класса в исходных текстах Java.

* `uploadRepository` - задает параметры <<artifact_repository,репозитория>>, в который будут выгружатся собранные артефакты проекта при выполнении задачи `uploadArchives`.
+
** `url` - URL репозитория. По умолчанию используется репозиторий Haulmont.
** `user` - имя пользователя репозитория.
** `password` - пароль пользователя репозитория.
+
Параметры репозитория выгрузки артефактов можно передать в командной строке с помощью следующих аргументов:
+
[source]
----
gradlew uploadArchives -PuploadUrl=http://myrepo.com/content/repositories/snapshots -PuploadUser=me -PuploadPassword=mypassword
----
--

configure::
+
--
Секции `configure` описывают конфигурацию <<app_modules,модулей>>. Наиболее важная часть конфигурации - описание зависимостей, например:

[source,groovy]
----
include::{sourcesdir}/development/build_gradle_2.groovy[]
----

Нестандартные зависимости модулей можно задавать в Studio на вкладке *Project properties > Advanced*. См. также контекстную помощь Studio.
--

[[build.gradle_tasks]]
==== Задачи сборки

Исполняемыми единицами в Gradle являются _задачи_ (tasks). Они задаются как внутри плагинов, так и в самом скрипте сборки. Рассмотрим специфические для CUBA задачи, параметры которых могут быть сконфигурированы в `build.gradle`. 

[[build.gradle_enhance]]
===== enhance

`enhance` - задача типа `CubaEnhancing`, выполняющая bytecode enhancement (weaving) классов сущностей. Объявляется в <<app_modules,модуле>> *global*.

Например:

[source, java]
----
task enhance(type: CubaEnhancing)
----

Optional parameters:

* `persistenceConfig` - позволяет явно указать набор файлов <<persistence.xml, persistence.xml>>. Если не установлено, задача будет обрабатывать все персистентные сущности, перечисленные в файлах `*persistence.xml`, найденных в CLASSPATH.

* `metadataXml` - позволяет явно указать файл <<metadata.xml, metadata.xml>> проекта. Если не установлено, задача будет обрабатывать все неперсистентные сущности, перечисленные в файле `*metadata.xml`, найденном в дереве исходных текстов модуля.

[[build.gradle_setupTomcat]]
===== setupTomcat

`setupTomcat` - задача типа `CubaSetupTomcat`, выполняющая установку и инициализацию локального сервера Tomcat для последующего <<fast_deployment,быстрого развертывания>> приложения. Эта задача автоматически добавляется в проект при подключении плагина сборки *cuba*, поэтому объявлять ее в `build.gradle` не нужно. Каталог установки Tomcat задается свойством `tomcat.dir` секции `cuba`. По умолчанию это подкаталог `build/tomcat` проекта.

[[build.gradle_deploy]]
===== deploy

`deploy` - задача типа `CubaDeployment`, выполняющая <<fast_deployment,быстрое развертывание>> модуля в Tomcat. Объявляется в модулях *core*, *web*, *portal*. Параметры:

* `appName` - имя веб-приложения, которое будет создано из модуля. Фактически это имя подкаталога внутри `tomcat/webapps`.

* `jarNames` - список имен JAR файлов (без версии), получающихся в результате сборки модуля, которые надо поместить в каталог `WEB-INF/lib` веб-приложения. Все остальные артефакты модуля и зависимостей будут записаны в `tomcat/shared/lib`.

Например:

[source, java]
----
task deploy(dependsOn: assemble, type: CubaDeployment) {
    appName = 'app-core'
    jarNames = ['cuba-global', 'cuba-core', 'app-global', 'app-core']
}
----

[[build.gradle_deployThemes]]
===== deployThemes

`deployThemes` - задача типа `CubaDeployThemeTask`, выполняющая сборку и развертывание определенных в проекте <<web_theme,тем>> в запущенное веб-приложение, развернутое задачей <<build.gradle_deploy,deploy>>. Изменения в темах применяются без рестарта сервера.

Например:

[source, groovy]
----
task deployThemes(type: CubaDeployThemeTask, dependsOn: buildScssThemes) {
}
----

[[build.gradle_buildWar]]
===== buildWar

`buildWar` - задача типа `CubaWarBuilding`, выполняющая сборку приложения и его зависимостей в WAR-файл. Должна быть объявлена в корне скрипта `build.gradle`. Собранные WAR-файлы находятся в подкаталоге `build/distributions` проекта.

Любое CUBA-приложение состоит как минимум из двух <<app_tiers,блоков>>: Middleware и Web Client. Поэтому наиболее естественный способ развертывания приложения это создание двух файлов WAR: один для Middleware, второй для Web Client. Это также позволяет <<scaling,масштабировать>> приложение при увеличении нагрузки. Однако раздельные WAR-файлы содержат дублированные зависимости, что увеличивает их общий размер. Кроме того, часто расширенные возможности развертывания не нужны и только усложняют процесс. Задача `CubaWarBuilding` может создавать WAR-файлы обоих типов: один файл на блок или единственный WAR содержащий оба блока. В последнем случае блоки приложения загружаются в раздельные class loaders внутри одного веб-приложения.

Создание раздельных WAR-файлов для Middleware и Web Client::
+
--
Для создания двух отдельных WAR файлов для Middleware и Web Client, используйте следующую конфигурацию:
[source, groovy]
----
include::{sourcesdir}/development/build_gradle_buildWar_2.groovy[]
----

Параметры задачи:

* `appHome` - путь к домашнему каталогу приложения. В домашнем каталоге будут располагаться <<conf_dir,конфигурационный>>, <<temp_dir,временный>> и <<work_dir,рабочий>> каталоги приложения.
+
В параметре `appHome` можно указать как абсолютный или относительный путь к домашнему каталогу, так и системную переменную, которая должна быть задана при запуске сервера. Например: `appHome = '/work/sales_home'` или `appHome = '${app.home}'`

* `appProperties` - опциональный мэп <<app_properties,свойств приложения>>. Эти свойства будут добавлены в файлы `/WEB-INF/local.app.properties` внутри создаваемых WAR.

* `singleWar` - должен быть установлен в `false` для создания раздельных WAR-файлов.

* `includeJdbcDriver` - включить JDBC драйвер, который используется в проекте. По умолчанию `false`.

* `includeContextXml` - включить файл `context.xml`, который используется в проекте. По умолчанию `false`.

* `coreContextXmlPath` - относительный путь к файлу, который должен быть использован вместо проектного `context.xml` если параметр `includeContextXml` установлен в `true`.

* `hsqlInProcess` - если установлен в `true`, то URL подключения к БД в `context.xml` будет изменен на подключение к HSQL в режиме in-process.

* `coreProject` - проект Gradle, представляющий модуль *core* (Middleware). Если не установлено, используется стандартный модуль *core* проекта.

* `webProject` - проект Gradle, представляющий модуль *web* (Web Client). Если не установлено, используется стандартный модуль *web* проекта.

* `portalProject` - проект Gradle, представляющий модуль *portal* (Web Portal). Установите данное свойство, если в проекте используется модуль *portal*. Например, `portalProject = project(':app-portal')`.
--

Создание единого WAR-файла::
+
--
Для создания единого файла WAR, включающего в себя блоки Middleware и Web Client, используйте следующую конфигурацию:

[source, groovy]
----
include::{sourcesdir}/development/build_gradle_buildWar_1.groovy[]
----

Следующие параметры должны быть указаны в дополнение к описанным выше:

* `singleWar` - должен быть опущен или установлен в `true`.

* `webXmlPath` - относительный путь к файлу, который будет использован в качестве `web.xml` единого WAR. Этот файл задает два servlet context listeners, которые загружают блоки приложения: `SingleAppCoreServletListener` и `SingleAppWebServletListener`. Все параметры инициализации передаются через параметры контекста.
+
Пример файла `single-war-web.xml`:
+
[source, xml]
----
include::{sourcesdir}/development/build_gradle_buildWar_3.xml[]
----

Единый WAR файл содержит только модули *core* и *web* (Middleware и Web Client). Для развертывания модуля *portal* используйте раздельные WAR-файлы.
--

В разделе <<war_deployment>> содержатся пошаговые инструкции по некоторым вариантам развертывания WAR-файлов.

[[build.gradle_createDb]]
===== createDb

`createDb` - задача типа `CubaDbCreation`, создающая базу данных приложения путем выполнения соответствующих <<db_scripts,скриптов>>. Объявляется в модуле *core*. Параметры:

* `dbms` - <<dbms_types, тип СУБД>>, задаваемый в виде строки `hsql`, `postgres`, `mssql`, или `oracle`.

* `dbName` - имя базы данных.

* `dbUser` - имя пользователя СУБД.

* `dbPassword` - пароль пользователя СУБД.

* `host` - хост и, опционально, порт СУБД в формате `host[:port]`. Если не задан, используется `localhost`.

* `connectionParams` - опциональная строка параметров которая будет добавлена в конец URL подключения.

* `masterUrl` - URL для подключения при создании БД. Если не задан, используется значение по умолчанию, зависящее от типа СУБД и параметра `host`.

* `dropDbSql` - команда SQL для удаления БД. Если не задана, используется значение по умолчанию, зависящее от типа СУБД.

* `createDbSql` - команда SQL для создания БД. Если не задана, используется значение по умолчанию, зависящее от типа СУБД.

* `driverClasspath` - список JAR файлов, содержащих JDBC драйвер. Элементы списка разделяются символом ":" на Linux и символом ";" на Windows. Если не задан, используются зависимости, входящие в конфигурацию `jdbc` данного модуля. Явное задание `driverClasspath` актуально при использовании Oracle, т.к. его JDBC драйвер не присутствует в зависимостях.

* `oracleSystemPassword` - при использовании Oracle пароль пользователя SYSTEM.
+
Пример для PostgreSQL:
+
[source, java]
----
task createDb(dependsOn: assemble, description: 'Creates local database', type: CubaDbCreation) {
    dbms = 'postgres'
    dbName = 'sales'
    dbUser = 'cuba'
    dbPassword = 'cuba'
}
----
+
Пример для MS SQL Server:
+
[source, java]
----
task createDb(dependsOn: assemble, description: 'Creates local database', type: CubaDbCreation) {
    dbms = 'mssql'
    dbName = 'sales'
    dbUser = 'sa'
    dbPassword = 'saPass1'
    connectionParams = ';instance=myinstance'
}
----
+
Пример для Oracle:
+
[source, java]
----
task createDb(dependsOn: assemble, description: 'Creates database', type: CubaDbCreation) {
    dbms = 'oracle'
    host = '192.168.1.10'
    dbName = 'orcl'
    dbUser = 'sales'
    dbPassword = 'sales'
    oracleSystemPassword = 'manager'
    driverClasspath = "$tomcatDir/lib/ojdbc6.jar"
}
----

[[build.gradle_updateDb]]
===== updateDb

`updateDb` - задача типа `CubaDbUpdate`, обновляющая базу данных приложения путем выполнения соответствующих <<db_scripts,скриптов>>. Аналогична задаче `createDb`, за исключением отсутствия параметров `dropDbSql` и `createDbSql`.

[[build.gradle_startDb]]
===== startDb

`startDb` - задача типа `CubaHsqlStart`, выполняющая запуск локального сервера HSQLDB. Параметры:

* `dbName` - имя базы данных, по умолчанию `cubadb`.

* `dbDataDir` - каталог, в котором размещена база данных, по умолчанию подкаталог `deploy/hsqldb` проекта.

* `dbPort` - порт сервера, по умолчанию 9001.

Например: 

[source, java]
----
include::{sourcesdir}/development/build_gradle_startDb_1.groovy[]
---- 

[[build.gradle_stopDb]]
===== stopDb

`stopDb` - задача типа `CubaHsqlStop`, выполняющая остановку локального сервера HSQLDB. Параметры аналогичны задаче `startDb`.

[[build.gradle_start]]
===== start

`start` - задача типа `CubaStartTomcat`, выполняющая запуск локального сервера Tomcat, установленного задачей <<build.gradle_setupTomcat,setupTomcat>>. Эта задача автоматически добавляется в проект при подключении плагина *cuba*, поэтому объявлять ее в `build.gradle` не нужно.

[[build.gradle_stop]]
===== stop

`stop` - задача типа `CubaStopTomcat`, выполняющая остановку локального сервера Tomcat, установленного задачей <<build.gradle_setupTomcat,setupTomcat>>. Эта задача автоматически добавляется в проект при подключении плагина *cuba*, поэтому объявлять ее в `build.gradle` не нужно.

[[build.gradle_restart]]
===== restart

`restart` - задача, выполняющая остановку, <<fast_deployment,быстрое развертывание>> и старт локального сервера Tomcat.

[[build.gradle_buildWidgetSet]]
===== buildWidgetSet

`buildWidgetSet` - задача типа `CubaWidgetSetBuilding`, которая собирает кастомный GWT widgetset если в проекте есть модуль `web-toolkit`. Данный модуль позволяет разрабатывать <<own_components,собственные визуальные компоненты>>.

Доступные параметры:

* `style` - стиль вывода скрипта: `OBF`, `PRETTY` или `DETAILED`. По умолчанию `OBF`.

* `logLevel` - уровень логгирования: `ERROR`, `WARN`, `INFO`, `TRACE`, `DEBUG`, `SPAM`, or `ALL`. По умолчанию `INFO`.

* `draft` - компилировать быстро с минимумом оптимизаций. По умолчанию `false`.

Пример использования:

[source, groovy]
----
include::{sourcesdir}/development/build_gradle_buildWidgetSet_1.groovy[]
----

[[build.gradle_debugWidgetSet]]
===== debugWidgetSet

`debugWidgetSet` - задача типа `CubaWidgetSetDebug`, которая запускает GWT Code Server для отладки виджетов в веб-браузере.

Пример использования: 

[source, java]
----
include::{sourcesdir}/development/build_gradle_debugWidgetSet_1.groovy[]
---- 

Убедитесь, что кофигурация `runtime` модуля `web-toolkit` содержит зависимость от библиотеки Servlet API: 

[source, java]
----
include::{sourcesdir}/development/build_gradle_debugWidgetSet_2.groovy[]
---- 

См. <<debug_widgets,Отладка виджетов в веб-браузере>> для получения информации о том как отлаживать код в веб-браузере.

[[build.gradle_zipProject]]
===== zipProject

`zipProject` - задача типа `CubaZipProject`, создающая ZIP-архив проекта. Архив не будет содержать проектные файлы IDE, результаты сборки и сервер Tomcat. Однако база данных HSQL включается в архив (если присутствует в подкаталоге `build`).

Эта задача автоматически добавляется в проект при подключении плагина сборки *cuba*, поэтому объявлять ее в `build.gradle` не нужно.

[[build_task_start]]
==== Запуск задач сборки

Задачи (tasks) Gradle, описанные в скриптах сборки, запускаются на исполнение следующими способами:

* Если работа с проектом ведется с помощью CUBA Studio, то при выполнении пунктов меню *Build* и *Run* производится подключение к демону Gradle (запущенному на старте сервера Studio), который и выполняет соответствующие задачи.

* С помощью исполняемого скрипта `gradlew` (Gradle wrapper), включенного в проект. Этот скрипт должен находится в корневом каталоге проекта, и может быть создан в Studio с помощью команды *Build* → *Create Gradle wrapper*.

* С помощью установленного вручную Gradle версии {gradleVersion}. В этом случае используется исполняемый файл `gradle`, находящийся в подкаталоге `bin` установленного Gradle.

[TIP]
====
Рекомендуется запускать команды `gradlew` или `gradle` с ключом `--daemon`, в этом случае демон Gradle остается в памяти и существенно ускоряет последующее выполнение.

Для удаления демона из памяти используется ключ `--stop`
====

Например, чтобы выполнить компиляцию Java файлов и сборку JAR файлов артефактов проекта, необходимо запустить следующую команду:

[source]
----
gradlew --daemon assemble
----

[WARNING]
====
Если ваш проект использует Премиум Дополнения, и вы запускаете сборку вне Studio, передайте имя и пароль к репозиторию дополнений в аргументах `-P` командной строки, например:

[source]
----
gradle assemble -PpremiumRepoUser=111111222222 -PpremiumRepoPass=abcdefabcdef
----

Подробнее см. <<build.gradle, выше>>.
====

Рассмотрим типичные задачи сборки в обычном порядке их использования.

* `idea`, `eclipse` - создать проектные файлы IntelliJ IDEA или Eclipse. При выполнении этой задачи из репозитория артефактов в локальный кэш Gradle загружаются зависимости вместе со своими исходными кодами.

* `cleanIdea`, `cleanEclipse` - удалить проектные файлы IntelliJ IDEA или Eclipse.

* `assemble` - выполнить компиляцию Java файлов и сборку JAR файлов артефактов проекта в подкаталогах `build` модулей.

* `clean` - удалить подкаталоги `build` всех модулей проекта.

* <<build.gradle_setupTomcat,setupTomcat>> - установить сервер *Tomcat* в путь, заданный свойством `ext.tomcatDir` скрипта `build.gradle`. 

* <<build.gradle_deploy,deploy>> - <<fast_deployment,быстрое развертывание>> приложения на сервере *Tomcat*, предварительно установленном задачей `setupTomcat`.

* <<build.gradle_createDb,createDb>> - создание базы данных приложения и выполнение соответствующих <<db_scripts,скриптов>>.

* <<build.gradle_updateDb,updateDb>> - обновление существующей базы данных приложения путем выполнения соответствующих <<db_scripts,скриптов>>.

* <<build.gradle_start,start>> - запуск сервера Tomcat.

* <<build.gradle_stop,stop>> - остановка запущенного сервера Tomcat.

* <<build.gradle_restart,restart>> - последовательное выполнение задач `stop`, `deploy`, `start`. 

[[project_creation]]
=== Создание проекта

Рекомендуемый способ создания нового проекта - использование *CUBA Studio*. Пример рассмотрен в главе <<qs_create_project,Быстрый старт>> данного руководства.

После создания проекта вы можете продолжить разрабатывать его в Studio, либо создать файлы проекта для *IntelliJ IDEA* или *Eclipse* и открыть проект в IDE.

[[logging]]
=== Логгирование

Для ведения логов в платформе используется фреймворк *Logback*.

Для вывода в лог используйте *SLF4J* API, получая логгер по имени текущего класса. Пример создания логгера и вывода в него:

[source, java]
----
include::{sourcesdir}/development/logging_1.java[]
---- 

Настройка логгирования для <<app_tiers,блоков>> Middleware, Web Client и Web Portal производится на уровне сервера приложения - в варианте <<fast_deployment,быстрого развертывания>> это Tomcat. Блок Desktop Client имеет самостоятельную настройку логгирования.

[[logging_setup_tomcat]]
==== Настройка логгирования в Tomcat

При выполнении задачи Gradle <<build.gradle_setupTomcat,setupTomcat>> в каталог проекта устанавливается сервер Tomcat, и производится его дополнительная конфигурация. В частности, в подкаталоге `tomcat/bin` создаются файлы `setenv.bat` и `setenv.sh`, а в подкаталоге `tomcat/conf` файл `logback.xml`.

Файлы `setenv.*` в переменной `CATALINA_OPTS` в числе прочего устанавливают параметры загрузки конфигурационного файла `logback.xml`.

Файл `logback.xml` определяет конфигурацию логгирования. Рассмотрим структуру этого файла.

* Элементы `appender` задают "устройства вывода" логов. Основными аппендерами являются `FILE` и `CONSOLE`. В параметре `level` элемента `filter` можно задать порог уровня сообщения. По умолчанию порог для файла - `DEBUG`, для консоли - `INFO`. Это означает, что в файл выводятся сообщения с уровнями `ERROR`, `WARN`, `INFO`, `DEBUG`, а в консоль - с уровнями `ERROR`, `WARN` и `INFO`.
+
Для файлового аппендера в параметре `file` задается путь к файлу лога. По умолчанию это файл `tomcat/logs/app.log`.

* Элементы `logger` задают параметры логгеров, через которые производится посылка сообщений из кода программы. Имена логгеров иерархические, то есть например настройки для логгера `com.company.sample` влияют на логгеры `com.company.sample.core.CustomerServiceBean`, `com.company.sample.web.CustomerBrowse`, если для них явно не заданы собственные настройки.
+
Минимальный уровень указывается в атрибуте `level`. Например, если для логгера задан приоритет `INFO`, то сообщения с уровнями `DEBUG` и `TRACE` выводиться не будут. Следует иметь в виду, что на вывод сообщения также влияет порог уровня, заданный в аппендере.

Оперативно изменять уровни для логгеров и пороги аппендеров для работающего сервера можно с помощью экрана *Администрирование* > *Журнал сервера*, доступного в веб клиенте. Сделанные настройки логгирования действуют только в текущем сеансе работы сервера и в файл не сохраняются. Этот экран позволяет также просматривать и загружать файлы логов из <<log_dir,каталога журналов>> сервера `tomcat/logs`.

Платформа автоматически добавляет к сообщениям, выводимым в лог, следующую информацию:

* _приложение_ - имя веб приложения, развернутого в Tomcat, код которого выводит данное сообщение. Эта информация помогает различить сообщения от разных блоков приложения (*Middleware*, *Web Client*), так как они выводятся в один файл.

* _пользователь_ - логин пользователя приложения, от имени которого в данный момент работает код, выводящий сообщение. Это позволяет в общем логе отслеживать активность конкретных пользователей. Если код, выводящий сообщение, не связан в момент вывода с пользовательской сессией, информация о пользователе не выводится.

Например, следующее сообщение в логе выведено кодом блока *Middleware* (`app-core`), работающим от имени пользователя `admin`:

[source, plain]
----
16:12:20.498 DEBUG [http-nio-8080-exec-7/app-core/admin] com.haulmont.cuba.core.app.DataManagerBean - loadList: ...
----

[[logging_setup_desktop]]
==== Настройка логгирования в десктоп-клиенте

Для десктоп клиента файл `logback.xml` должен находиться в каталоге исходников модуля *desktop* проекта. При сборке приложения он упаковывается в соответствующий JAR файл и доступен в CLASSPATH.

Для настройки логгирования в своем проекте выполните следующее:

* Создайте в каталоге `src` модуля *desktop* новый файл, например, `sample-logback.xml`, и скопируйте в него содержимое файла `cuba-logback.xml`. Файл `cuba-logback.xml` находится внутри одного из JAR-файлов платформы и его легко найти поиском в IDE.

* Установите путь к файлу лога в параметре `file` аппендера `FILE`.

* Добавьте настройки для логгеров вашего проекта.

* В классе-наследнике `com.haulmont.cuba.desktop.App` вашего проекта, например `SampleApp`, переопределите метод `getDefaultLogConfig()` и верните в нем путь относительно корня CLASSPATH к вашему файлу настроек. Например:
+
[source, java]
----
include::{sourcesdir}/development/logging_2.java[]
----

* При необходимости можно переопределить местонахождение файла конфигурации на старте приложения с помощью системного свойства <<logback.configurationFile,logback.configurationFile>>.

[[debuging]]
=== Отладка

В данном разделе содержится информация об использовании пошаговой отладки CUBA-приложений.

[[debug_setup]]
==== Подключение отладчика

Запустить сервер Tomcat в режиме отладки можно либо выполнением команды сборки

`gradle start`

либо запуском командного файла `++bin/debug.*++` установленного *Tomcat*.

После этого сервер будет принимать подключения отладчика на порту 8787. Порт можно изменить в файле `bin/setenv.*` в переменной `++JPDA_OPTS++`.

Для пошаговой отладки в *Intellij IDEA* необходимо в проекте приложения создать новый элемент *Run/Debug Configuration* типа *Remote*, и в его поле *Port* указать 8787.

[[debug_widgets]]
==== Отладка виджетов в веб-браузере

Для отладки виджетов на стороне браузера можно использовать *GWT Super Dev Mode*.

. Настройте задачу <<build.gradle_debugWidgetSet,debugWidgetSet>> в `build.gradle`. Настройте задачу <<build.gradle_debugWidgetSet,debugWidgetSet>> в `build.gradle`. 

. Разверните приложение и запустите Tomcat.Разверните приложение и запустите Tomcat.

. Запустите задачу `debugWidgetSet`:
+
`gradlew debugWidgetSet`
+
GWT Code Server будет перекомпилировать ваш widgetset при изменениях кода виджетов.Запустите задачу `debugWidgetSet`:
+
`gradlew debugWidgetSet`
+
GWT Code Server будет перекомпилировать ваш widgetset при изменениях кода виджетов.

. Откройте страницу `http://localhost:8080/app?debug&superdevmode` в браузере Chrome и подождите пока widgetset будет построен первый раз.

. Откройте консоль отладки браузера: 
+
image::debugWidgetSet_chrome_console.png[align="center"]

. После изменения Java-кода в модуле `web-toolkit` обновляйте страницу в браузере. Widgetset будет инкрементально перестраиваться примерно за 8-10 секунд.

[[testing]]
=== Тестирование

[[unit_tests]]
==== Модульные тесты

Модульные тесты (unit tests) можно создавать и выполнять и на <<app_tiers,уровне>> *Middleware*, и на клиентском уровне. Для этого платформа включает в себя фреймворки link:$$http://junit.org$$[JUnit] и link:$$http://code.google.com/p/jmockit$$[JMockit].

Допустим, имеется следующий контроллер экрана:

[source, java]
----
include::{sourcesdir}/development/testing_1.java[]
----

Тогда можно написать следующий тест, проверяющий работу метода `init()`:

[source, java]
----
include::{sourcesdir}/development/testing_2.java[]
----

[[integration_tests_mw]]
==== Интеграционные тесты Middleware

На уровне Middleware можно создавать интеграционные тесты, которые выполняются в полнофункциональном контейнере Spring с подключением к базе данных. В тестах такого типа можно выполнять код любого слоя внутри Middleware - от сервисов до ORM.

Для того, чтобы выполнять тесты из IDE, создайте каталог `test` в модуле *core* рядом с `src`. После этого пересоздайте проектные файлы IDE.

Платформа содержит класс `TestContainer`, который может быть использован в качестве базового для тестовых контейнеров приложения. Создайте наследника этого класса в каталоге `test` модуля *core* и в его конструкторе переопределите параметры загрузки <<app_components, компонентов>> и <<app_properties_files, свойств приложения>>, а также параметры подключения к тестовой БД. Например:

[source, java]
----
include::{sourcesdir}/development/testing_3.java[]
----

В качестве базы данных рекомендуется использовать отдельную тестовую БД, которую можно создавать, например, следующей <<build.gradle_createDb, задачей>> в `build.gradle`:

[source, groovy]
----
include::{sourcesdir}/development/testing_4.java[]
----

Тестовый контейнер используется в классах тестов в качестве JUnit rule, указанного с помощью аннотации `@ClassRule`:

[source, java]
----
include::{sourcesdir}/development/testing_5.java[]
----

В данном примере тестовый контейнер инициализируется один раз для всех тестовых методов класса, и уничтожается после того, как все они выполнены.

Так как запуск контейнера занимает некоторое время, имеет смысл инициализировать контейнер один раз для тестов из нескольких (или всех) классов. Для этого создайте общий синглтон-экземпляр тестового контейнера, например:

[source, java]
----
include::{sourcesdir}/development/testing_6.java[]
----

И используйте его в тестовых классах:

[source, java]
----
include::{sourcesdir}/development/testing_7.java[]
----

Класс `TestContainer` содержит следующие методы, которые можно использовать в коде тестов (см. пример `CustomerLoadTest` выше):

* `persistence()` - возвращает ссылку на интерфейс `<<persistence,Persistence>>`.

* `metadata()` - возвращает ссылку на интерфейс `<<metadata,Metadata>>`.

* `deleteRecord()` - этот набор перегруженных методов предназначен для использования в `@After` методах для удаления тестовых объектов из БД.

[[integration_tests_client]]
==== Интеграционные тесты клиентского уровня

Интеграционные тесты на клиентском уровне реализуются с применением фреймворка link:$$http://code.google.com/p/jmockit$$[JMockit]. С его помощью тест изолируется от *Middleware*, а также создаются необходимые объекты инфраструктуры.

Класс клиентского интеграционного теста должен быть унаследован от `CubaClientTestCase`. В методе `@Before` необходимо вызвать унаследованные методы `addEntityPackage()`, `setViewConfig()` и затем `setupInfrastructure()` для создания объектов `<<metadata,Metadata>>` и `<<configuration,Configuration>>` и развертывания метаданных по выбранным сущностям. Далее в методе `@Before` можно дополнить инфраструктуру необходимыми мок-объектами с помощью конструкции `Expectations` или `NonStrictExpectations`.

Пример инициализирующего метода `@Before` одного из тестов платформы:

[source, java]
----
include::{sourcesdir}/development/testing_8.java[]
----

[[dev_recipes]]
=== Рецепты разработки

В данном разделе рассматриваются способы решения некоторых практических задач. 

[[dm_vs_em]]
==== DataManager vs. EntityManager

И <<dataManager,DataManager>> и <<entityManager,EntityManager>> предназначены для операций с сущностями (CRUD). Ниже приведены различия между этими интерфейсами.

|===
|DataManager |EntityManager

|DataManager доступен и на среднем слое и на клиентском <<app_tiers,уровне>>.
|EntityManager доступен только на среднем слое.

|DataManager является синглтон-бином.
|Ссылку на EntityManager необходимо получать через интерфейс <<persistence,Persistence>>.

|DataManager содержит несколько высокоуровневых методов для работы с <<entity_states,detached>> сущностями: `load()`, `loadList()`, `reload()`, `commit()`.
|EntityManager в большой степени повторяет стандартный `javax.persistence.EntityManager`.

|DataManager всегда стартует новую <<transactions,транзакцию>> внутри.
|Для работы с EntityManager необходима открытая транзакция.

|DataManager загружает _частичные_ сущности в соответствие с <<views,представлением>>.
|EntityManager всегда загружает все локальные атрибуты. Если используется представление, оно влияет только на загрузку ссылочных атрибутов.

|Запросы в DataManager могут возвращать только сущности. Запросы, возвращающие одиночные атрибуты или агрегированные значения (SUM, COUNT) вызывают ошибку.
|EntityManager может выполнять любые JPQL или native запросы.

|DataManager применяет ограничения <<security_subsystem,безопасности>>, когда вызывается с клиентского уровня.
|EntityManager не накладывает ограничения безопасности.

|===

При работе на клиентском уровне доступен только `DataManager`. На среднем слое, используйте `EntityManager` когда необходимо реализовать атомарную логику внутри транзакции или выполнить запрос, возвращающий отдельные атрибуты или агрегированные значение. В противном случае, на среднем слое можно использовать любой из интерфейсов на выбор.

Если вам нужно обойти ограничения `DataManager` при работе на клиентском уровне, создайте свой <<services,сервис>> и используйте `EntityManager` для работы с данными. В сервисе можно проверять права пользователя с помощью интерфейса <<security,Security>> и возвращать клиенту данные в виде персистентных или неперсистентных сущностей или произвольных значений.

[[getting_messages]]
==== Получение локализованных сообщений

В данном разделе рассмотрены способы получения <<localization,локализованных сообщений>> в различных компонентах приложения.

* В <<screen_xml,XML-дескрипторах>> экранов атрибуты компонентов, отображающие статичный текст (например <<gui_attr_caption,caption>>), могут обращаться к локализованным сообщениям по правилам метода <<messageTools.loadString,MessageTools.loadString()>>. Например:

** `caption="msg://roleName"` - получить сообщение, заданное ключом `roleName` в пакете сообщений текущего экрана. Пакет сообщений экрана задается в атрибуте `messagesPack` корневого элемента `window`.

** `caption="msg://com.company.sample.entity/Role.name"` - получить сообщение, заданное ключом `Role.name` в пакете сообщений `com.company.sample.entity`.

* В <<screen_controller,контроллерах экранов>> локализованные сообщения можно получать следующими способами:

** Из пакета сообщений текущего экрана:

*** Методом `getMessage()`, унаследованным от базового класса <<abstractFrame,AbstractFrame>>. Например:
+
[source, java]
----
String msg = getMessage("warningMessage");
----

*** Методом `formatMessage()`, унаследованным от базового класса `AbstractFrame`. В этом случае сообщение используется для форматирования переданных параметров по правилам метода `String.format()`. Например:
+
messages.properties:
+
[source, plain]
----
warningMessage = Invalid email address: '%s'
----
+
Java-контроллер:
+
[source, java]
----
String msg = formatMessage("warningMessage", email);
----

** Из произвольного пакета сообщений путем инжекции интерфейса инфраструктуры <<messages,Messages>>. Например:
+
[source, java]
----
@Inject
private Messages messages;

@Override
public void init(Map<String, Object> params) {
    String msg = messages.getMessage(getClass(), "warningMessage");
    ...
} 
----

* В компонентах, управляемых контейнером Spring (<<managed_beans,управляемых бинах>>, <<services,сервисах>>, <<jmx_beans,JMX-бинах>>, контроллерах Spring MVC модуля *portal*) локализованные сообщения можно получать путем инжекции интерфейса инфраструктуры <<messages,Messages>>:
+
[source, java]
----
@Inject
protected Messages messages;
...
String msg = messages.getMessage(getClass(), "warningMessage");
----

* В любом коде приложения, где невозможна инжекция, интерфейс `Messages` может быть получен с помощью статического метода `get()` класса `AppBeans`:
+
[source, java]
----
protected Messages messages = AppBeans.get(Messages.class);
...
String msg = messages.getMessage(getClass(), "warningMessage");
----

[[init_values]]
==== Присвоение начальных значений

Присвоение начальных значений атрибутам новых экземпляров сущностей можно производить несколькими способами.

[[init_values_in_class]]
===== Инициализация полей сущности

Атрибуты простых типов (`Boolean`, `Integer` и т.д.) можно инициализировать прямо в объявлении соответствующего поля класса сущности, например: 

[source, java]
----
public class User extends StandardEntity {
...
    @Column(name = "ACTIVE")
    protected Boolean active = true;
...
}
----

Кроме того, в классе сущности можно создать специальный метод инициализации и добавить ему аннотацию <<postConstruct_entity_annotation,@PostConstruct>>. В этом случае в процессе инициализации можно использовать вызов любых глобальных <<infrastructure_interfaces,интерфейсов инфраструктуры>> и <<managed_beans,бинов>>, например: 

[source, java]
----
public class MyEntity extends StandardEntity {
...
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "USER_ID")
    protected User creator;
...
    @PostConstruct
    protected void init() {
       setCreator(AppBeans.get(UserSessionSource.class).getUserSession().getUser());
    }
}
----

[[init_values_in_CreateAction]]
===== Инициализация с помощью CreateAction

Если начальное значение атрибута зависит от данных вызывающего экрана, то можно воспользоваться методом `setInitialValues()` класса <<createAction,CreateAction>>.

Рассмотрим для примера две связанные сущности:

image::init_values_recipe_1.png[align="center"]

Фрагмент XML-дескриптора экрана, отображающего одновременно списки обоих сущностей:

[source, xml]
----
<dsContext>
    <collectionDatasource id="typesDs"
                          class="com.haulmont.sample.entity.DeviceType"
                          view="_local">
        <query>
            select e from sample$DeviceType e
        </query>
    </collectionDatasource>
    <collectionDatasource id="descriptionsDs"
                          class="com.haulmont.sample.entity.DeviceDescription"
                          view="_local">
        <query>
            select e from sample$DeviceDescription e where e.deviceType.id = :ds$typesDs
        </query>
    </collectionDatasource>
</dsContext>
<layout>
...
        <table id="typeTable">
            <actions>
                <action id="create"/>
                <action id="edit"/>
                <action id="remove"/>
            </actions>
            <columns>
                <column id="name"/>
            </columns>
            <rows datasource="typesDs"/>
        </table>
...
        <table id="descriptionTable">
            <actions>
                <action id="create"/>
                <action id="edit"/>
                <action id="remove"/>
            </actions>
            <columns>
                <column id="description"/>
            </columns>
            <rows datasource="descriptionsDs"/>
        </table>
    </split>
</layout>
----

Контроллер этого экрана:

[source, java]
----
public class DeviceTypeBrowse extends AbstractLookup {

    @Inject
    private CollectionDatasource<DeviceType, UUID> typesDs;

    @Named("descriptionTable.create")
    private CreateAction descrCreateAction;

    @Override
    public void init(Map<String, Object> params) {
        typesDs.addItemChangeListener(event -> {
            descrCreateAction.setInitialValues(Collections.<String, Object>singletonMap("deviceType", event.getItem()));
        });
    }
}
----

В контроллере источнику данных `typesDs` добавляется слушатель на событие изменения выбранной записи. При смене выбранной записи вызывается метод `setInitialValues()` действия, и ему передается мэп с одним элементом, ключом которого является навание атрибута - `deviceType`, а значением - выбранный экземпляр `DeviceType`. Таким образом при выполнении действия `CreateAction` в атрибуте `deviceType` нового экземпляра `DeviceDescription` будет сразу установлен выбранный в таблице экземпляр `DeviceType`.

[[init_values_in_initNewItem]]
===== Использование метода initNewItem

Начальные значения можно также задать в контроллере экрана создаваемой сущности в методе <<initNewItem,initNewItem()>>.

В качестве примера рассмотрим следующую задачу: в проекте имеется сущность `Employee` (сотрудник компании), которая должна быть связана с платформенной сущностью `User` (пользователь системы). При создании сотрудника должен создаваться новый экземпляр пользователя.

image::init_values_recipe_2.png[align="center"]

В XML-дескрипторе экрана редактирования сотрудника объявляем источник данных для экземпляра сотрудника и вложенный источник - для связанного пользователя:

[source, xml]
----
<dsContext>
    <datasource id="employeeDs"
                class="com.haulmont.sample.entity.Employee"
                view="employee-edit">
        <datasource id="userDs"
                    property="user"/>
    </datasource>
</dsContext>
----

В контроллере экрана редактирования сотрудника определяем:

[source, java]
----
@Inject
private Metadata metadata;

private Group defaultGroup;
private Role defaultRole;

@Override
protected void initNewItem(Employee item) {
    User user = metadata.create(User.class);
    user.setGroup(defaultGroup);
    final UserRole userRole = metadata.create(UserRole.class);
    userRole.setUser(user);
    userRole.setRole(defaultRole);
    getDsContext().addBeforeCommitListener(context -> {
        context.getCommitInstances().add(userRole);
    });
    item.setUser(user);
}
----

Здесь в методе `initNewItem()` создается новый экземпляр `User`, и для него устанавливается некоторая группа доступа `defaultGroup`. Связь с ролью `defaultRole` устанавливается с помощью нового экземпляра сущности `UserRole`. Для сохранения этой связи в БД при коммите экрана, экземпляр `UserRole` добавляется в коллекцию сохраняемых сущностей в методе `beforeCommit()` слушателя <<dsContext,DsContext.CommitListener>>. 

Новый экземпляр `User` устанавливается в соответствующем атрибуте редактируемой сущности `Employee`, и тем самым оказывается во вложенном источнике данных `userDs`. Это дает возможность редактировать нужные атрибуты пользователя в экране сотрудника, а также приводит к автоматическому сохранению экземпляра пользователя при коммите экрана в одной транзакции с остальными сущностями.

[[composition_recipe]]
==== Редактирование композитных сущностей

Платформа CUBA поддерживает два типа связи между сущностями: ассоциацию и композицию. В интерфейсе *CUBA Studio* они названы соответственно ASSOCIATION и COMPOSITION. Ассоциация - это связь между объектами, которые могут существовать отдельно друг от друга. Композиция же используется для связи типа "master-detail" когда экземпляры detail существуют только в составе master. Примером композиции может служить связь аэропорта и терминалов: терминал, не относящийся ни к какому аэропорту, не имеет смысла.

Как правило, редактирование сущностей, входящих в состав композиции, удобно осуществлять совместно. То есть, например, пользователь открывает экран редактирования аэропорта, видит в нем список терминалов, может создавать и редактировать их, но все изменения, как аэропорта, так и терминалов, сохраняются в базу данных вместе в одной транзакции, и только тогда, когда пользователь подтвердит сохранение главной сущности - аэропорта.

[[composition_impl_recipe]]
===== Реализация композиции

Рассмотрим реализацию композиции на примере сущностей `Airport` и `Terminal`:

image::composition_recipe_1.png[align="center"]

. Сущность `Terminal` содержит обязательную ссылку на `Airport`:
+
[source, java]
----
@Entity(name = "sample$Terminal")
@Table(name = "SAMPLE_TERMINAL")
public class Terminal extends StandardEntity {
...    
    @ManyToOne(optional = false, fetch = FetchType.LAZY)
    @JoinColumn(name = "AIRPORT_ID")
    private Airport airport;

    public Airport getAirport() {
        return airport;
    }

    public void setAirport(Airport airport) {
        this.airport = airport;
    }
}
----

. Сущность `Airport` содержит one-to-many коллекцию терминалов. Соответствующее поле помечается аннотацией <<composition_annotation,@Composition>> для огранизации композиции и <<onDelete_annotation,@OnDelete>> для каскадного мягкого удаления:
+
[source, java]
----
@Entity(name = "sample$Airport")
@Table(name = "SAMPLE_AIRPORT")
public class Airport extends StandardEntity {
...
    @OneToMany(fetch = FetchType.LAZY, mappedBy = "airport")
    @OnDelete(DeletePolicy.CASCADE)
    @Composition
    protected List<Terminal> terminals;

    public List<Terminal> getTerminals() {
        return terminals;
    }

    public void setTerminals(List<Terminal> terminals) {
        this.terminals = terminals;
    }
}
----
. <<views,Представление>>, используемое в экране редактирования аэропорта, должно содержать атрибут-коллецию `terminals`:
+
[source, xml]
----
<view entity="sample$Airport" name="airport-edit" extends="_local">
    <property name="terminals" view="_local"/>
</view>
----
+
Для сущности `Terminal` здесь выбрано представление `++_local++`, хотя она содержит ссылочный атрибут `airport` - ссылку на аэропорт. Дело в том, что атрибут `airport` устанавливается только при создании нового экземпляра `Terminal`, и не меняется в дальнейшем, поэтому загружать его не обязательно.

. В XML-дескрипторе экрана редактирования аэропорта определяем источники данных для экземпляра `Airport` и коллекции его терминалов:
+
[source, xml]
----
<dsContext>
    <datasource id="airportDs"
                class="com.haulmont.sample.entity.Airport"
                view="airport-edit">
        <collectionDatasource id="terminalsDs" property="terminals"/>
    </datasource>
</dsContext>
----

. В XML-дескрипторе экрана редактирования аэропорта определяем таблицу, отображающую терминалы, и <<list_actions,стандартные действия>> для нее:
+
[source, xml]
----
<table id="terminalsTable">
    <actions>
        <action id="create"/>
        <action id="edit"/>
        <action id="remove"/>
    </actions>
    <buttonsPanel>
        <button action="terminalsTable.create"/>
        <button action="terminalsTable.edit"/>
        <button action="terminalsTable.remove"/>
    </buttonsPanel>
    <columns>
        <column id="code"/>
        <column id="name"/>
        <column id="address"/>
    </columns>
    <rows datasource="terminalsDs"/>
</table>
----

. В экране редактирования терминала достаточно определить стандартные элементы: `datasource` для экземпляра `Terminal` и визуальные компоненты, связанные с этим `datasource`, для редактирования атрибутов терминала.

В результате редактирование экземпляра аэропорта работает следующим образом:

* В экране редактирования аэропорта отображается таблица терминалов.

* Пользователь может выбрать терминал и открыть экран его редактирования. При нажатии *OK* в экране редактирования терминала измененный экземпляр терминала сохраняется не в базу данных, а в источник данных `terminalsDs` экрана редактирования аэропорта. 

* Пользователь может создавать новые или удалять терминалы - все изменения сохраняются в источнике данных `terminalsDs`.

* Пользователь нажимает *OK* в экране редактирования аэропорта, и измененный `Airport` вместе со всеми измененными экземплярами `Terminal` отправляется на Middleware в метод <<dataManager,DataManager>>.commit() и сохраняется в базе данных в рамках одной транзакции. 

[[composition_deep_recipe]]
===== Глубокая композиция

Композиция может быть более глубокой и состоять из двух уровней вложенности. Усложним приведенный выше пример, добавив сущность `MeetingPoint`, описывающую место встречи у терминала аэропорта:

image::composition_recipe_2.png[align="center"]

Теперь сущность `Terminal` содержит атрибут `meetingPoints` - коллекцию экземпляров `MeetingPoint`. Для того, чтобы все три сущности представляли собой единую композицию и редактировались совместно, нужно в дополнение к описанному в предыдущем разделе выполнить следующее:

. Атрибуту `meetingPoints` класса `Terminal` добавить аннотации `@Composition` и `@OnDelete` аналогично атрибуту `terminals` класса `Airport`.

. Создать новое представление для `Terminal`:
+
[source, xml]
----
<view entity="sample$Terminal" name="terminal-edit" extends="_local">
    <property name="meetingPoints" view="_local"/>
</view>
----
+
И использовать его в представлении `Airport` вместо `++_local++`:
+
[source, xml]
----
<view entity="sample$Airport" name="airport-edit" extends="_local">
    <property name="terminals" view="terminal-edit"/>
</view>
----

. В XML-дескрипторе экрана редактирования аэропорта определить источники данных для экземпляра `Airport` и вложенных сущностей на всю глубину композиции:
+
[source, xml]
----
<dsContext>
    <datasource id="airportDs"
                class="com.haulmont.sample.entity.Airport"
                view="airport-edit">
        <collectionDatasource id="terminalsDs" property="terminals">
            <collectionDatasource id="meetingPointsDs" property="meetingPoints"/>
        </collectionDatasource>  
    </datasource>
</dsContext>
----
+
Здесь источник данных `meetingPointsDs` не связан ни с какими визуальными компонентами, однако он необходим для корректной работы совместного редактирования композиции.

. В XML-дескрипторе экрана редактирования терминала в свою очередь определить для коллекции `meetingPoints` вложенный источник данных и соответствующую таблицу.

В результате измененные эземпляры `MeetingPoint`, так же как и экземпляры `Terminal`, будут сохраняться в базу данных только вместе с экземпляром `Airport` в одной транзакции.

[[app_start_recipe]]
==== Выполнение кода на старте приложения

Иногда бывает необходимо выполнить некоторый код сразу после старта приложения в момент, когда все механизмы гарантированно работоспособны. Для этого можно воспользоваться слушателем <<appContext,AppContext.Listener>>.

Рассмотрим следующую задачу: в проекте имеется сущность `Employee` (сотрудник компании), которая связана один-к-одному с платформенной сущностью `User` (пользователь системы):

image::init_values_recipe_2.png[align="center"]

Если атрибут `name` сущности `User` изменяется, например через стандартный экран управления пользователями, необходимо, чтобы изменялся также и атрибут `name` связанной сущности `Employee`. Это обычная задача для "денормализованных" данных, и решается она, как правило, с использованием <<entity_listeners,entity listeners>>. В данном случае ситуация осложняется тем, что необходимо отслеживать изменения не проектной, а платформенной сущности `User`, и добавить entity listener с помощью аннотации <<listeners_annotation,@Listeners>> невозможно. Однако, можно добавить listener динамически через бин `EntityListenerManager`, и сделать это лучше всего на старте приложения.

Для этого создадим в модуле *core* приложения бин `AppLifecycle`, имплементирующий интерфейс `AppContext.Listener`, и зарегистрируем его вызовом метода `AppContext.addListener()` в конструкторе объекта:

[source, java]
----
include::{sourcesdir}/development/app_start_recipe_1.java[]
----

[source, java]
----
include::{sourcesdir}/development/app_start_recipe_2.java[]
----

В результате сразу после старта <<app_tiers,блока>> Middleware будет вызван метод `applicationStarted()` данного бина. В этом методе в качестве entity listener сущности `User` регистрируется бин `sample_UserEntityListener`.

Метод `onBeforeUpdate()` класса `UserEntityListener` будет вызываться перед каждым сохранением изменений экземпляров `User` в базу данных. В методе проверяется, есть ли атрибут `name` среди измененных, и если да, загружается связанный экземпляр `Employee`, и в нем устанавливается это же значение `name`.

[[images_recipe]]
==== Загрузка и вывод изображений

Рассмотрим задачу загрузки, хранения и отображения фотографий сотрудников:

* Сотрудник представлен сущностью `Employee`.

* Файлы изображений хранятся в <<file_storage,FileStorage>>. Сущность `Employee` содержит ссылку на соответствующий `FileDescriptor`.

* Экран редактирования `Employee` отображает фотографию, а также дает возможность загрузить, выгрузить и очистить изображение.

Класс сущности со ссылкой на файл изображения:

[source, java]
----
@Table(name = "SAMPLE_EMPLOYEE")
@Entity(name = "sample$Employee")
public class Employee extends StandardEntity {
...
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "IMAGE_FILE_ID")
    protected FileDescriptor imageFile;

    public void setImageFile(FileDescriptor imageFile) {
        this.imageFile = imageFile;
    }

    public FileDescriptor getImageFile() {
        return imageFile;
    }
}
----

<<views,Представление>> для загрузки `Employee` вместе с `FileDescriptor` должно содержать все локальные атрибуты `FileDescriptor`:

[source, xml]
----
<view class="com.company.sample.entity.Employee"
      name="employee-edit">
    <property name="name"/>
    ...
    <property name="imageFile"
              view="_local">
    </property>
</view>
----


Фрагмент XML-дескриптора экрана редактирования `Employee`:

[source, xml]
----
<groupBox caption="Photo" spacing="true"
          height="250px" width="250px" expand="embeddedImage">
        <embedded id="embeddedImage" width="100%"
                  align="MIDDLE_CENTER"/>
    <hbox align="BOTTOM_LEFT"
          spacing="true">
        <upload id="uploadField"/>
        <button id="downloadImageBtn"
                caption="Download"
                invoke="onDownloadImageBtnClick"/>
        <button id="clearImageBtn"
                caption="Clear"
                invoke="onClearImageBtnClick"/>
    </hbox>
</groupBox>
----

Компоненты отображения и загрузки/выгрузки фотографии заключены внутрь контейнера <<gui_GroupBoxLayout,groupBox>>. В верхней его части с помощью компонента <<gui_Embedded,embedded>> выводится изображение, а в нижней слева направо расположены компонент <<gui_FileUploadField,upload>> для загрузки файла и <<gui_Button,кнопки>> выгрузки и очистки изображения. В результате эта часть экрана должна выглядеть следующим образом:

image::images_recipe.png[align="center"]

Теперь рассмотрим <<abstractEditor,контроллер экрана редактирования>>.

[source, java]
----
public class EmployeeEdit extends AbstractEditor<Employee> {

    private Logger log = LoggerFactory.getLogger(EmployeeEdit.class);

    @Inject
    private DataSupplier dataSupplier;
    @Inject
    private FileStorageService fileStorageService;
    @Inject
    private FileUploadingAPI fileUploadingAPI;
    @Inject
    private ExportDisplay exportDisplay;

    @Inject
    private Embedded embeddedImage;
    @Inject
    private FileUploadField uploadField;
    @Inject
    private Button downloadImageBtn;
    @Inject
    private Button clearImageBtn;
    @Inject
    private Datasource<Employee> employeeDs;

    private static final int IMG_HEIGHT = 190;
    private static final int IMG_WIDTH = 220;

    @Override
    public void init(Map<String, Object> params) {
        uploadField.addFileUploadSucceedListener(event -> {
            FileDescriptor fd = uploadField.getFileDescriptor();
            try {
                fileUploadingAPI.putFileIntoStorage(uploadField.getFileId(), fd);
            } catch (FileStorageException e) {
                throw new RuntimeException("Error saving file to FileStorage", e);
            }
            getItem().setImageFile(dataSupplier.commit(fd));
            displayImage();
        });

        uploadField.addFileUploadErrorListener(event ->
                showNotification("File upload error", NotificationType.HUMANIZED));

        employeeDs.addItemPropertyChangeListener(event -> {
            if ("imageFile".equals(event.getProperty()))
                updateImageButtons(event.getValue() != null);
        });
    }

    @Override
    protected void postInit() {
        displayImage();
        updateImageButtons(getItem().getImageFile() != null);
    }

    public void onDownloadImageBtnClick() {
        if (getItem().getImageFile() != null)
            exportDisplay.show(getItem().getImageFile(), ExportFormat.OCTET_STREAM);
    }

    public void onClearImageBtnClick() {
        getItem().setImageFile(null);
        displayImage();
    }

    private void updateImageButtons(boolean enable) {
        downloadImageBtn.setEnabled(enable);
        clearImageBtn.setEnabled(enable);
    }

    private void displayImage() {
        byte[] bytes = null;
        if (getItem().getImageFile() != null) {
            try {
                bytes = fileStorageService.loadFile(getItem().getImageFile());
            } catch (FileStorageException e) {
                log.error("Unable to load image file", e);
                showNotification("Unable to load image file", NotificationType.HUMANIZED);
            }
        }
        if (bytes != null) {
            embeddedImage.setSource(getItem().getImageFile().getName(), new ByteArrayInputStream(bytes));
            embeddedImage.setType(Embedded.Type.IMAGE);
            BufferedImage image;
            try {
                image = ImageIO.read(new ByteArrayInputStream(bytes));
                int width = image.getWidth();
                int height = image.getHeight();

                if (((double) height / (double) width) > ((double) IMG_HEIGHT / (double) IMG_WIDTH)) {
                    embeddedImage.setHeight(String.valueOf(IMG_HEIGHT));
                    embeddedImage.setWidth(String.valueOf(width * IMG_HEIGHT / height));
                } else {
                    embeddedImage.setWidth(String.valueOf(IMG_WIDTH));
                    embeddedImage.setHeight(String.valueOf(height * IMG_WIDTH / width));
                }
            } catch (IOException e) {
                log.error("Unable to resize image", e);
            }
            // refresh image
            embeddedImage.setVisible(false);
            embeddedImage.setVisible(true);
        } else {
            embeddedImage.setVisible(false);
        }
    }
}
----

* В методе `init()` сначала инициализируется компонент `uploadField`, предназначенный для загрузки новой фотографии. В случае успешной загрузки из компонента получается экземпляр нового `FileDescriptor`, и соответствующий файл отправляется из временного хранилища в постоянное вызовом `FileUploadingAPI.putFileIntoStorage()`. После этого `FileDescriptor` сохраняется в БД вызовом <<dataSupplier,DataSupplier.commit()>>, и сохраненный экземпляр устанавливается в атрибуте `imageFile` редактируемой сущности `Employee`. Затем вызывается метод `displayImage()` контроллера для отображения загруженной фотографии.
+
Далее в методе `init()` источнику данных, содержащему редактируемый экземпляр `Employee`, добавляется слушатель для запрещения или разрешения кнопок выгрузки и очистки файла в зависимости от того, загружен файл или нет.

* Метод `postInit()` вызывает отображение файла и обновляет состояние кнопок в зависимости от наличия загруженного файла.

* Метод `onDownloadImageBtnClick()` вызывается при нажатии кнопки `downloadImageBtn` и выполняет выгрузку файла с помощью интерфейса <<file_download,ExportDisplay>>.

* Метод `onClearImageBtnClick()` вызывается при нажатии кнопки `clearImageBtn` и очищает атрибут `imageFile` сущности `Employee`. Удаления файла из хранилища не производится.

* Метод `displayImage()` выгружает файл из хранилища в байтовый массив, устанавливает содержимое компонента `embeddedImage`, и перерасчитывает его размеры для сохранения пропорций изображения.
+
Следует иметь в виду, что выгрузка файлов из хранилища в байтовый массив приемлема только для небольших файлов. Если размер файла непредсказуем, следует использовать только выгрузку через <<file_download,ExportDisplay>>, при которой файл передается через потоки ввода-вывода и нигде не оказывается в памяти целиком.

[[sending_emails_recipe]]
==== Отправка email

В данном разделе рассматривается пример использования <<email_sending,механизма>> рассылки email.

Рассмотрим следующую задачу:

--
* Имеется сущность `NewsItem` и экран ее редактирования `NewsItemEdit`.

* Сущность `NewsItem` имеет следующие атрибуты: `date`, `caption`, `content`.

* Необходимо отсылать электронные письма каждый раз, когда через экран `NewsItemEdit` создается новый экземпляр сущности. Email должен содержать `NewsItem.caption` в качестве темы письма, тело письма должно формироваться на основе шаблона, включающего `NewsItem.content`.
--

. Добавьте следующий код в `NewsItemEdit.java`:
+
--
[source, java]
----
include::{sourcesdir}/development/sending_emails_1.java[]
----

Как видно, метод `sendByEmail()` вызывает сервис `EmailService` и передает ему экземпляр `EmailInfo`, описывающий сообщение. Тело сообщений будет создаваться на основе шаблона `news_item.txt`.
--

. Создайте шаблон тела письма в файле `news_item.txt` в пакете `com.company.demo.templates` модуля *core*:
+
--
[source, plain]
----
include::{sourcesdir}/development/sending_emails_2.txt[]
----

Это шаблон link:http://freemarker.incubator.apache.org[Freemarker], который использует параметры, переданные в `EmailInfo` (в данном случае единственный параметр `newsItem`).
--

. Запустите приложение, откройте браузер сущности `NewsItem` и нажмите *Create*. Откроется экран редактирования сущности. Заполните поля и нажмите *OK*. Появится диалог подтверждения с вопросом об отсылке email. Нажмите *Yes*.

. Перейдите в экран *Administration > Email History* вашего приложения. Вы увидите две записи (по числу получателей) со статусом `Queue`. Он означает, что сообщения находятся в очереди и еще не отосланы.

. Для обработки очереди необходимо создать <<scheduled_tasks_cuba,назначенное задание>>. Перейдите в экран *Administration > Scheduled Tasks* вашего приложения. Создайте новую задачу и установите ей следующие параметры:
+
--
* *Bean Name* - `cuba_Emailer`
* *Method Name* - `processQueuedEmails()`
* *Singleton* - да (этот параметр важен только при эксплуатации кластера серверов middleware)
* *Period, sec* - 10
--
+
Сохраните задачу и нажмите на ней *Activate*.
+
Если вы ранее не настраивали выполнение назначенных заданий для данного приложения ранее, то на данном этапе ничего не произойдет - новая задача не начнет выполняться пока вы не запустите весь механизм назначенных заданий.

. Откройте файл `modules/core/src/app.properties` и добавьте в него следующее <<cuba.schedulingActive,свойство>>:
+
[source, properties]
----
cuba.schedulingActive = true
----
+
Перезапустите сервер приложения. Механизм выполнения заданий теперь активен и вызывает обработку очереди email.

. Перейдите в экран *Administration > Email History*. Статус сообщений будет либо `Sent`, если они успешно отосланы, либо, что более вероятно, `Sending` или `Queue`, если произошла ошибка отправки. В последнем случае вы можете открыть журнал приложения в файле `build/tomcat/logs/app.log` и выяснить причину. Механизм отсылки email предпримет несколько (по умолчанию 10) попыток и в случае неудачи переведет сообщения в статус `Not sent`.

. Наиболее очевидной причиной ошибки отправки является то, что вы не настроили <<email_sending_properties,параметры>> SMTP-сервера. Эти параметры могут быть заданы в базе данных с помощью  JMX бина `app-core.cuba:type=Emailer` или в свойствах приложения блока middleware. Рассмотрим второй способ. Откройте файл `modules/core/src/app.properties` и добавьте в него требуемые <<email_sending_properties,параметры>>:
+
[source, properties]
----
include::{sourcesdir}/development/sending_emails_3.properties[]
----
+
Перезапустите сервер приложения. Перейдите в экран *Administration > JMX Console*, найдите JMX бин `Emailer` и попробуйте послать самому себе тестовое сообщение с помощью операции `sendTestEmail()`.

. Теперь механизм отсылки email настроен корректно, однако он не будет отсылать сообщения, уже переведенные в статус `Not sent`. Поэтому необходимо создать новый экземпляр `NewsItem` через экран редактирования. Сделайте это и понаблюдайте, как статус новых сообщений в экране *Email History* изменится на `Sent`.

[[own_component_samples]]
==== Создание собственных визуальных компонентов

В разделе <<own_components>> был приведен обзор методов расширения набора стандартных визуальных компонентов в проекте. У вас есть следующие варианты:

. Подключение аддона Vaadin. Много сторонних компонентов Vaadin распространяются в виде дополнений (add-on). Библиотека аддонов находится по адресу https://vaadin.com/directory.

. Подключение компонента, написанного на JavaScript. Vaadin дает возможность создавать серверные компоненты, использующие JavaScript-библиотеку.

. Создание собственного компонента Vaadin с клиентской частью, написанной на GWT.

Далее вы можете интегрировать получившийся компонент Vaadin в универсальный пользовательский интерфейс CUBA, чтобы иметь возможность использовать его декларативно в XML-дескрипторах экранов и привязывать к источникам данных.

Финальным шагом интеграции является поддержка нового компонента в WYSIWYG редакторе экранов Studio.

Далее в этом разделе приводятся примеры создания новых визуальных компонентов каждым из описанных выше способов. Интеграция в Generic UI одинакова для всех трех способов, поэтому она описана только для примера с подключением аддона Vaadin.

[[vaadin_addon_sample]]
===== Подключение аддона Vaadin

Рассмотрим пример использования компонента *Stepper*, доступного по адресу http://vaadin.com/addon/stepper. Данный компонент позволяет пошагово изменять значение текстового поля с помощью клавиатуры, колесика мыши и встроенных кнопок вверх/вниз.

Создайте новый проект в CUBA Studio и назовите его `addon-demo`.

Для подключения аддона Vaadin проект должен иметь модуль *web-toolkit*. Создайте его, нажав на ссылку *Create web toolkit module* секции *Project properties* навигатора.

Далее нажмите на ссылку *New UI component*. Откроется окно создания визуального компонента *UI component generation*. В секции *Component type* выберите значение `Vaadin add-on`.

image::ui_component/studio_vaadin_addon_wizard_no_gui.png[align="center"]

Заполните следующие поля:

* *Add-on Maven dependency* - в этом поле необходимо указать Maven-координаты аддона Vaadin для подключения его как зависимости к текущему проекту. Указание координат возможно в двух форматах:

. XML, скопированный с сайта аддона (http://vaadin.com/addon/stepper):
+
[source, xml]
----
<dependency>
   <groupId>org.vaadin.addons</groupId>
   <artifactId>stepper</artifactId>
   <version>2.2.2</version>
</dependency>
----

. Одной строкой в том виде, как вы добавляете зависимости в <<build.gradle,build.gradle>>:
+
[source, plain]
----
org.vaadin.addons:stepper:2.2.2
----

* *Inherited widgetset* - в этом поле необходимо указать имя виджетсета подключаемого аддона. В нашем случае это `org.vaadin.risto.stepper.widgetset.StepperWidgetset`.

* *Integrate into generic UI* - в данном примере флажок должен быть снят, т.к. мы не интегрируем компонент в универсальный интерфейс платформы.

Нажмите кнопку *OK*.

Если открыть проект в IDE, то можно увидеть, что Студия изменила два файла:

. <<build.gradle, build.gradle>>. В модуле *web* появилась новая зависимость от аддона, содержащего компонент:
+
[source, java]
----
configure(webModule) {
    ...
    dependencies {
        ...
        compile("org.vaadin.addons:stepper:2.2.2")
    }
----

. В файл `AppWidgetSet.gwt.xml` модуля *web-toolkit* проекта подключен виджетсет аддона после виджетсета платформы:
+
[source, xml]
----
<module>
    <inherits name="com.haulmont.cuba.web.toolkit.ui.WidgetSet" />

    <inherits name="org.vaadin.risto.stepper.widgetset.StepperWidgetset" />

    <set-property name="user.agent" value="safari" />
----
+
TIP: Для более быстрой сборки виджетов на время разработки вы можете установить свойство `user.agent`. В данном примере набор виджетов будет собираться только для браузеров, основанных на WebKit: Chrome, Safari, и т.д.

Компонент из аддона Vaadin подключен. Далее мы покажем как использовать его в экранах проекта.

* Создаем новую сущность `Customer` с двумя полями:

** `name` типа String
** `score` типа Integer

* Сгенерируем для новой сущности стандартные экраны. В диалоге генерации стандартных экранов убедитесь что значение поля *In module* - `Web Module`. Экраны, использующие компоненты Vaadin напрямую, должны располагаться в модуле *web*.
+
TIP: На самом деле экран может располагаться и в модуле *gui*, но тогда код, работающий с Vaadin компонентом, должен быть вынесен в отдельный <<companions,компаньон>>.

* Далее добавим компонент `stepper` на экран. Вы можете поместить его как в <<gui_FieldGroup,FieldGroup>>, так и вне ее. Рассмотрим оба способа.
+
--
. В XML-дескрипторе экрана редактирования `customer-edit.xml` для поля `score` компонента `fieldGroup` добавим атрибут `custom = "true"`:
+
[source, xml]
----
include::{sourcesdir}/ui_component/vaadin_no_gui/customer-edit-nogui-custom-field.xml[]
----
+
В контроллер экрана редактирования `CustomerEdit.java` добавим следующий код:
+
[source, java]
----
include::{sourcesdir}/ui_component/vaadin_no_gui/CustomerEditNoGuiCustomField.java[]
----
+
Здесь в поле `stepper` создается экземпляр компонента, подключенного из аддона. В методе `init()` производится инициализация кастомного поля `score`. Через `ComponentsFactory` создается экземпляр <<gui_BoxLayout>>, затем из него с помощью <<webComponentsHelper,WebComponentsHelper>> извлекается ссылка на Vaadin-контейнер, и в этот контейнер добавляется наш новый компонент. `BoxLayout` возвращается для отображения в кастомном поле.
+
Для связи компонента с данными во-первых, в методе `postInit()` ему устанавливается текущее значение из редактируемого `Customer`, а во-вторых, добавляется слушатель на изменение значения, который обновляет соответствующий атрибут сущности при изменении значения пользователем.

. Чтобы использовать новый компонент вне `FieldGroup` в произвольном месте экрана в XML-дескрипторе объявим контейнер `scoreBox` и удалим поле `score` из `fieldGroup`:
+
[source, xml]
----
include::{sourcesdir}/ui_component/vaadin_no_gui/customer-edit-nogui-container.xml[]
----
+
В контроллере инжектируем контейнер, извлекаем ссылку на Vaadin-контейнер и добавляем в него компонент:
+
[source, java]
----
include::{sourcesdir}/ui_component/vaadin_no_gui/CustomerEditNoGuiContainer.java[]
----
+
Связь с данными выполняется здесь аналогично примеру с `FieldGroup`.
--

* Для адаптации внешнего вида компонента создадим в проекте расширение темы. Для этого в Studio выполним команду *Create theme extension* секции *Project properties* навигатора. В списке тем для расширения выберем `halo` и нажмем кнопку *Create*. Затем откроем файл `themes/halo/halo-ext.scss` модуля *web*, и добавим в него следующий код:
+
[source, css]
----
include::{sourcesdir}/ui_component/vaadin_no_gui/halo-ext.scss[]
----

* Запускаем сервер приложения. Экран редактирования должен выглядеть следующим образом:

image::ui_component/customer_edit_result.png[align="center"]

[[vaadin_addon_sample_gui]]
===== Подключение аддона Vaadin с интеграцией в Generic UI

В <<vaadin_addon_sample,предыдущем разделе>> мы подключили в проект сторонний компонент Stepper. В данном разделе мы интегрируем его в универсальный пользовательский интерфейс CUBA, что даст разработчикам возможность использовать компонент декларативно в XML-дескрипторах экранов и связывать его с сущностями через <<datasources,источники данных>>.

Создадим новый проект в CUBA Studio и назовем его `addon-gui-demo`. В поле *Project namespace* введем значение `agd`.

Создадим модуль *web-toolkit*, нажав на кнопку *Create web toolkit module* секции *Project properties* навигатора Studio.

Далее нажимаем на кнопку *New UI component*. Откроется окно создания визуального компонента *UI component generation*. В секции *Component type* выбираем значение `Vaadin add-on`.

image::ui_component/studio_vaadin_addon_wizard_gui.png[align="center"]

Заполним поля *Add-on Maven dependency* и *Inherited widgetset* как описано в <<vaadin_addon_sample,предыдущем разделе>>.

Далее заполним поля в нижней секции:

* *Integrate into Generic UI* указывает на необходимости интеграции компонента в универсальный пользовательский интерфейс платформы.

* *Component XML element* -  имя элемента компонента в XML-дескрипторе экрана. Введите значение `stepper`.

* *Component interface name* - имя интерфейса компонента для универсального UI платформы. Введите `Stepper`.

* *FQN of Vaadin component from add-on* - полное имя класса компонента Vaadin из аддона. В нашем случае это `org.vaadin.risto.stepper.IntStepper`.

После нажатия кнопки *OK* Studio сделает следующее:

* Добавит аддон Vaadin в зависимости модуля *web* в файле `build.gradle`.

* Подключит виджетсет аддона в файле `AppWidgetSet.gwt.xml` модуля *web-toolkit*.

* Сгенерирует заготовки для следующих файлов:

** `Stepper` - интерфейс компонента в модуле *gui*.

** `WebStepper` - реализация компонента в модуле *web*.

** `StepperLoader` - XML-загрузчик компонента в модуле *gui*.

** `ui-component.xsd` - описатель схемы XML для нового компонента. Если файл уже существовал на момент генерации компонента, то информация о новом компоненте будет добавлена в существующий файл.

** `cuba-ui-component.xml` - файл регистрации загрузчика нового компонента в модуле *web*. Если файл существовал, то информация о новом компоненте будет добавлена в существующий файл.

Откройте проект в IDE.

Последовательно пройдемся по сгенерированным Studio заготовкам файлов и внесем в них необходимые изменения.

* Перейдите к интерфейсу `Stepper` в модуле *gui*. Замените его содержимое на следующий код:
+
[source, java]
----
include::{sourcesdir}/ui_component/vaadin_gui/Stepper.java[]
----
+
В качестве базового для нашего компонента выбран интерфейс `Field`. Это позволяет осуществить связь с данными (data binding), то есть отображать и редактировать значение некоторого атрибута сущности.

* Далее перейдите к классу `WebStepper` - реализации компонента в модуле *web*. Замените содержимое класса следующим кодом:
+
[source, java]
----
include::{sourcesdir}/ui_component/vaadin_gui/WebStepper.java[]
----
+
В качестве базового класса выбран `WebAbstractField`, который реализует логику интерфейса `Field`.

* `StepperLoader` в модуле *gui* загружает компонент из его представления в XML.
+
[source, java]
----
include::{sourcesdir}/ui_component/vaadin_gui/StepperLoader.java[]
----
+
Логика загрузки базовых свойств компонента `Field` сосредоточена в классе `AbstractFieldLoader`. Нам достаточно загрузить только специфические свойства `Stepper`.

* В файле `cuba-ui-component.xml`, расположенном в корне модуля *web*, регистрируется новый компонент и его загрузчик. Оставляем файл без изменений.
+
[source, xml]
----
include::{sourcesdir}/ui_component/vaadin_gui/cuba-ui-component.xml[]
----

* Файл `ui-component.xsd`, расположенный в корне модуля *gui*, это описатель XML схемы новых компонентов проекта. Добавим к элементу `stepper` описание его атрибутов.
+
[source, xml]
----
include::{sourcesdir}/ui_component/vaadin_gui/ui-component.xsd[]
----

Далее рассмотрим, как добавить новый компонент на экран.

* Создадим новую сущность `Customer` с двумя полями:

** `name` типа String
** `score` типа Integer

* Сгенерируем для новой сущности стандартные экраны.

* Далее добавим компонент `stepper` на экран. Вы можете поместить его как в <<gui_FieldGroup,FieldGroup>>, так и в отдельный контейнер. Рассмотрим оба способа.

. Использование компонента в экране внутри произвольного контейнера.
+
--
* Откройте файл `customer-edit.xml`.

* Объявите новое пространство имен `xmlns:app="http://schemas.company.com/agd/0.1/ui-component.xsd"`

* Удалите поле `score` из `fieldGroup`.

* Добавьте компонент `stepper` на экран.

В результате XML-дескриптор редактора должен выглядеть так:

[source, xml]
----
include::{sourcesdir}/ui_component/vaadin_gui/customer-edit-gui-container.xml[]
----

В данном примере компонент `stepper` подсоединен к атрибуту `score` сущности `Customer`, экземпляр которой находится в источнике данных `customerDs`.
--

. Использование компонента в поле <<gui_FieldGroup>>:
+
[source, xml]
----
include::{sourcesdir}/ui_component/vaadin_gui/customer-edit-gui-custom-field.xml[]
----
+
[source, java]
----
include::{sourcesdir}/ui_component/vaadin_gui/CustomerEditGuiCustomField.java[]
----

* Для адаптации внешнего вида компонента создадим в проекте расширение темы. Для этого в Studio выполним команду *Create theme extension* секции *Project properties* навигатора. В списке тем для расширения выберем `halo` и нажмем кнопку *Create*. Затем откроем файл `themes/halo/halo-ext.scss` модуля *web*, и добавим в него следующий код:
+
[source, css]
----
include::{sourcesdir}/ui_component/vaadin_gui/halo-ext.scss[]
----

* Запускаем сервер приложения. Экран редактирования должен выглядеть следующим образом:

image::ui_component/customer_edit_result.png[align="center"]

[[js_library_sample]]
===== Подключение JavaScript библиотеки

В данном примере мы подключим компонент https://jqueryui.com/slider/#range[Slider] из библиотеки *jQuery UI*. Слайдер будет иметь два ползунка, определяющих диапазон значений.

Создайте новый проект в CUBA Studio и назовите его `jscomponent`.

Далее нажмите на кнопку *New UI component*. Откроется окно создания визуального компонента *UI component generation*. В секции *Component type* выберите значение `JavaScript component`.

image::ui_component/studio_js_component_wizard.png[align="center"]

В поле *Vaadin component class name* диалога генерации компонента введите значение `SliderServerComponent`.

Уберите флажок *Integrate into Generic UI*. Процесс интеграции компонента в универсальный интерфейс аналогичен описанному в разделе <<vaadin_addon_sample_gui>>, поэтому рассматривать его здесь мы не будем.

После нажатия кнопки *OK* Studio сгенерирует файлы:

* `SliderServerComponent` - интегрированный с JavaScript компонент Vaadin.

* `SliderState` - класс состояния компонента Vaadin.

* `slider-connector.js` - JavaScript коннектор для компонента Vaadin

Последовательно пройдемся по сгенерированным заготовкам файлов и внесем в них необходимые изменения.

* Класс состояния `SliderState` определяет, какие данные будут пересылаться между сервером и клиентом. В нашем случае мы будем пересылать информацию о минимальном и максимальном возможном значении и выбранных значениях слайдера.
+
[source, java]
----
include::{sourcesdir}/ui_component/js/SliderState.java[]
----

* Серверный компонент Vaadin `SliderServerComponent`.
+
[source, java]
----
include::{sourcesdir}/ui_component/js/SliderServerComponent.java[]
----
+
Серверный компонент Vaadin определяет набор геттеров и сеттеров для работы с состоянием слайдера, а также интерфейс слушателя изменения значений. Класс компонента должен быть унаследован от `AbstractJavaScriptComponent`.
+
Метод `addFunction()` в конструкторе класса объявляет обработчик RPC-вызова функции `valueChanged()` с клиента.
+
Аннотации `@JavaScript` и `@StyleSheet` указывают на файлы, которые должны быть загружены на веб-страницу. В нашем примере это JavaScript файлы библиотеки jQuery UI и коннектора, а также файл со стилями для jQuery UI. Расположим их в одном Java-пакете с серверным компонентом.

Скачайте архив jQuery UI с сайта http://jqueryui.com/download и поместите файлы `jquery-ui.js` и `jquery-ui.css` в пакет с классом `SliderServerComponent`. На странице скачивания jQuery UI у вас будет возможность выбрать компоненты, которые будут помещены в архив. Для нашего примера достаточно выделить пункт `Slider` группы `Widgets`.

image::ui_component/js_project_structure.png[align="center"]

* JavaScript коннектор `slider-connector.js`.
+
[source, javascript]
----
include::{sourcesdir}/ui_component/js/slider-connector.js[]
----
+
Коннектор представляет собой функцию, которая при загрузке веб-страницы проинициализирует JavaScript компонент. Имя функции должно соответствовать полному имени класса серверного компонента, где точки в имени пакета заменены на символ подчеркивания.
+
Vaadin добавляет ряд полезных методов в фунцию коннектора. Например, `this.getElement()` возвращает HTML DOM элемент компонента, `this.getState()` возвращает объект-состояние.
+
В нашем примере коннектор делает следующее:
+
--
* Инициализирует компонент `slider` из библиотеки jQuery UI. При изменении положения одного из ползунков будет вызывана функция `slide()`. Мы видим, что она в свою очередь вызывает метод `valueChanged()` коннектора. `valueChanged()` - это метод, который мы объявили на стороне сервера в классе `SliderServerComponent`.

* Объявляет функцию `onStateChange()`. Она будет вызываться при изменении объекта-состояния на стороне сервера.
--

Для демонстрации работы компонента создадим сущность `Product` с тремя атрибутами:

* `name` типа String
* `minDiscount` типа Double
* `maxDiscount` типа Double

Затем сгенерируем стандартные экраны для данной сущности. Обратите внимание, что мы используем не универсальный компонент платформы, а "нативный" компонент Vaadin. Следовательно экраны должны располагаться в модуле Web, а не в GUI - укажите это в окне генерации стандартных экранов.

В редакторе сущности мы хотим устанавливать минимальное и максимальное значение скидки с помощью компонента `slider`, который мы только что создали.

Перейдите к файлу `product-edit.xml`. Поля `minDiscount` и `maxDiscount` сделайте нередактируемыми, добавив к соответствующим элементам атрибут `editable="false"`. Затем добавьте в `fieldGroup` новое кастомное поле `slider`.

В результате XML-дескриптор экрана редактирования должен выглядеть следующим образом:

[source, xml]
----
include::{sourcesdir}/ui_component/js/product-edit.xml[]
----

Перейдите к файлу `ProductEdit.java`. Замените его содержимое следующим кодом:

[source, java]
----
include::{sourcesdir}/ui_component/js/ProductEdit.java[]
----

В методе `initNewItem()` мы проставляем начальные значения скидок для нового продукта.

В методе `init()` инициализируем кастомное поле для слайдера. Для компонента слайдера мы проставляем текущие значения, максимальное и минимальное значения, а также объявляем слушатель изменений значений. При движении ползунка мы будем проставлять новые значения скидок в соответвующие поля редактируемой сущности.

Запустите проект и откройте экран редактирования продукта. Изменение положения ползунка на слайдере должно изменять значение в соответствующем текстовом поле.

image::ui_component/product_edit.png[align="center"]

[[gwt_component_sample]]
===== Создание GWT компонента

В данном примере мы рассмотрим создание простого GWT-компонента - поля рейтинга в виде 5 звезд, а также использование его в экранах приложения.

image::ui_component/rating_field_component.png[align="center"]

Создадим новый проект в CUBA Studio. Имя проекта - `ratingsample`.

Создайте модуль *web-toolkit*, нажав на кнопку *Create web-toolkit module* секции *Project properties* навигатора Studio.

Далее нажмите на ссылку *Create new UI component*. Откроется окно создания визуального компонента *New UI component*. В секции *Component type* выберите значение `New GWT component`.

image::ui_component/studio_gwt_component_wizard.png[align="center"]

В поле *Vaadin component class name* диалога генерации компонента введите значение `RatingFieldServerComponent`.

Снимите флажок *Integrate into Generic UI*. Процесс интеграции компонента в универсальный интерфейс аналогичен описанному в разделе <<vaadin_addon_sample_gui>>, поэтому рассматривать его здесь мы не будем.

После нажатия кнопки *OK* Studio сгенерирует файлы:

* `RatingFieldWidget.java` - виджет GWT в модуле *web-toolkit*.

* `RatingFieldServerComponent.java` - класс компонента Vaadin.

* `RatingFieldState.java` - класс состояния компонента.

* `RatingFieldConnector.java` - коннектор, связывающий клиентский код с серверным компонентом.

* `RatingFieldServerRpc.java` - класс, определяющий API сервера для клиентской части.

Последовательно рассмотрим сгенерированные студией заготовки файлов и внесем в них необходимые изменения.

* GWT виджет `RatingFieldWidget.java`. Замените содержимое файла на следующий код:
+
[source, java]
----
include::{sourcesdir}/ui_component/gwt/RatingFieldWidget.java[]
----
+
Виджет представляет собой клиентский класс, отвечающий за отображение компонента в веб-браузере и реакцию на события. Он определяет интерфейсы для работы с серверной частью. В нашем случае это метод `setValue()` и интерфейс `StarClickListener`.

* Класс компонента Vaadin `RatingFieldServerComponent`. Он определяет API для серверного кода, различные get/set методы, слушатели событий и подключение источников данных. Прикладные разработчики используют в своём коде методы этого класса.
+
[source, java]
----
include::{sourcesdir}/ui_component/gwt/RatingFieldServerComponent.java[]
----

* Класс состояния `RatingFieldState` отвечает за то, какие данные будут пересылаться между клиентом и сервером. В нём определяются публичные поля, которые будут автоматически сериализованы на сервере и десериализованы на клиенте.
+
[source, java]
----
include::{sourcesdir}/ui_component/gwt/RatingFieldState.java[]
----

* Интерфейс `RatingFieldServerRpc` — определяет API сервера для клиентской части, его методы могут вызываться с клиента при помощи механизма удалённого вызова процедур, встроенного в Vaadin. Этот интерфейс мы реализуем в самом компоненте, в данном случае просто вызываем метод `setValue()` нашего поля.
+
[source, java]
----
include::{sourcesdir}/ui_component/gwt/RatingFieldServerRpc.java[]
----

* Коннектор `RatingFieldConnector` связывает клиентский код с серверной частью.
+
[source, java]
----
include::{sourcesdir}/ui_component/gwt/RatingFieldConnector.java[]
----

Код виджета `RatingFieldWidget` не определяет внешний вид компонента, кроме назначения имён стилей ключевым элементам. Для того, чтобы определить внешний вид нашего компонента, создадим файлы стилей. Для этого можно воспользоваться ссылкой *Create theme extension* секции *Project properties* в навигаторе Studio. В появившемся диалоге выбираем тему `halo`. Эта тема использует вместо иконок глифы шрифта FontAwesome, чем мы и воспользуемся. Studio создаст пустые файлы SCSS для расширения темы в каталоге `themes` модуля *web*.

Стили каждого компонента принято выделять в отдельный файл `componentname.scss` в каталоге `components/componentname` в формате примеси SCSS. В каталоге `themes/halo` модуля `web` создадим структуру вложенных каталогов: `components/ratingfield`. Затем внутри `ratingfield` создадим файл `ratingfield.scss`:

image::ui_component/gwt_theme_ext_structure.png[align="center"]

[source, css]
----
include::{sourcesdir}/ui_component/gwt/ratingfield.scss[]
----

Подключим этот файл в главном файле темы `halo-ext.scss`:

[source, css]
----
include::{sourcesdir}/ui_component/gwt/halo-ext.scss[]
----

Для демонстрации работы компонента создадим новый экран в модуле *web*.

Назовите файл с экраном `rating-screen.xml`.

image::ui_component/gwt_rating_screen_designer.png[align="center"]

Добавим экран в меню приложения. Перейдите в секцию *Main menu* навигатора Studio и нажмите кнопку *Edit*. Откроется редактор меню. Добавьте созданный экран в меню `application`.

Перейдем к редактированию экрана `rating-screen.xml` в IDE. Нам понадобится контейнер для нашего компонента, объявим его в XML экрана:

[source, xml]
----
include::{sourcesdir}/ui_component/gwt/rating-screen.xml[]
----

Откроем класс контроллера экрана `RatingScreen.java` и добавим код размещения нашего компонента на экране:

[source, java]
----
include::{sourcesdir}/ui_component/gwt/RatingScreen.java[]
----

Запускаем сервер приложения и смотрим на результат.

image::ui_component/rating_screen_result.png[align="center"]

[[own_component_in_studio]]
===== Поддержка собственных компонентов в CUBA Studio

В данном разделе описывается, как добавить поддержку новых визуальных компонентов в дизайнер экранов CUBA Studio. Новый компонент появится в палитре компонентов, вы сможете перетаскивать его в рабочую область и редактировать его свойства в панели свойств компонента.

Рассмотрим процесс создания интеграции компонента `stepper`, создание которого было описано в разделе <<vaadin_addon_sample_gui>>.

Откроем проект, содержащий компонент `stepper`.

TIP: Если указанный проект вы не создавали, то вы можете воспроизвести шаги, описанные ниже, и на новом проекте. Вы увидите поддержку компонента в Studio, но не сможете запустить приложение.

Нажмем кнопку *Extend Studio* на панели *Project properties*.

image::ui_component/ui_component_extension_window.png[align="center"]

Рассмотрим поля, которые необходимо заполнить.

* *Configuration name* - идентификатор конфигурации. Введем значение `stepper`.

* *Component XML element* - имя компонента в том виде, как он должен быть добавлен в XML-дескриптор экрана. В нашем случае это `stepper`.
+
Поля *Component class name* и *Component model class name* будут заполнены автоматически на основе введенного значения. Оставьте их значения без изменения.

* *Component namespace URI* - пространство имен из XSD, описывающего компонент. Если вы генерировали новый компонент с помощью Studio, то узнать значение для этого поля вы можете в файле `ui-component.xsd`.

* *Component namespace prefix* - префикс XML-элемента компонента в XML-дескриптор экрана.

* *Standard properties* - стандартные свойства компонента, которые должны быть доступны для редактирования в панели свойств компонента в дизайнере экранов.
+
Выберите `caption`, `datasource` и `property`.
+
TIP: Свойства `id`, `align`, `height`, `width`, `enable`, `stylename`, `visible` по умолчанию доступны для всех компонентов.

* *Custom properties* - в данной таблице добавляются специфичные для компонента свойства, которые должны редактироваться в панели свойств дизайнера экранов.
+
--
Добавим следующие свойства:

* *manualInput*, тип `Boolean`, значение по умолчанию `true`

* *mouseWheel*, тип `Boolean`, значение по умолчанию `true`

* *stepAmount*, тип `Integer`, значение по умолчанию `0`

* *maxValue*, тип `Integer`, значение по умолчанию `0`

* *minValue*, тип `Integer`, значение по умолчанию `0`
--

Далее нажмитие кнопку *OK*.

Новые визуальные компоненты инициализируются при старте сервера Studio. Откройте окно сервера Studio, остановите сервер, выйдите из Studio, затем отройте и запустите его снова.

Сгенерируем стандартные экраны для сущности `Customer` заново, чтобы стереть результаты наших прошлых экспериментов.

Переходим в секцию *GENERIC UI* навигатора студии и открываем экран `customer-edit`.

Для начала удалим поле `score` из `fieldGroup`, т.к. мы хотим для его редактирования использовать специальный компонент.

На палитре компонентов найдите новый компонент `Stepper` и перетащите его на экран под `fieldGroup`.

image::ui_component/stepper_in_palette.png[align="center"]

Выделите компонент `stepper` и перейдите на закладку свойств компонента *Properties*.

image::ui_component/stepper_component_properties.png[align="center"]

Заполните необходимые поля:

* *id* - `stepper`

* *caption* - `Stepper`

* *datasource* - `customerDs`

* *property* - `score`

* *maxValue* - `50`

После этого перейдите на закладку *XML*, чтобы увидеть результат.

[source, xml]
----
include::{sourcesdir}/ui_component/studio_support/customer-edit.xml[]
----

В XML экрана объявлено пространство имен компонента с префиксом `app`, компонент `stepper` добавлен на экран, и у него установлены необходимые свойства.

[[app_components_sample]]
==== Использование компонентов приложения

Как упоминалось в разделе  <<app_components,>>, любое CUBA-приложение может быть компонентом другого приложения. Компонент приложения представляет собой по сути full-stack библиотеку, предоставляющую функциональность на всех уровнях - от схемы БД до бизнес-логики и UI.

В данном разделе рассматривается пример создания компонента приложения и использования его в проекте. Компонент будет предоставлять функциональность "Customer Management" и содержать сущность `Customer` и соответствующие экраны UI. Приложение будет использовать сущность `Customer` из компонента в качестве ссылки в собственной сущности `Order`.

image::app_components_sample.png[align="center"]

Создание компонента Customer Management::

. Создайте новый проект в Studio и укажите следующие значения в окне *New project*:

* *Project name* - `customers`

* *Project namespace* - `cust`

* *Root package* - `com.company.customers`

. Откройте *Project properties* на редактирование и на вкладке *Advanced* установите значение поля *Module prefix* в `cust`. Это необходимо для того, чтобы имена артефактов компонента имели префикс, отличный от `app`, принятого по умолчанию.

. Создайте сущность `Customer` с атрибутом `name`. Переключитесь на вкладку *Instance name* и укажите `name` в атрибутах name pattern.
+
[WARNING]
====
Если компонент содержит персистентные классы, аннотированные `@MappedSuperclass`, убедитесь, что в этом же проекте есть их наследники, являющиеся сущностями (т.е. аннотированные `@Entity`). В противном случае байткод таких базовых классов не будет необходимым образом модифицирован и они не будут правильно работать в приложениях, использующих компонент.
====

. Сгененрируйте скрипты БД и создайте стандартные экраны для сущности `Customer`: `cust$Customer.browse` и `cust$Customer.edit`. После этого откройте дизайнер меню и переименуйте пункт `application` в `customerManagement`.

. Нажмите на ссылку *App component descriptor* на панели *Project properties*. Сохраните сгенерированный <<app-component.xml,описатель компонента>> нажав *OK*.

. Проверьте функциональность Customer Management: *Run > Create database*, *Run > Start application server*, затем откройте `++http://localhost:8080/cust++` в веб-браузере.

. Установите компонент приложения в локальный Maven-репозиторий, выполнив команду главного меню *Run > Install app component*.
+
[TIP]
====
Использование команды *Install app component* требуется на Windows для избежания проблем с блокировкой файлов. На Linux или Mac OS можно напрямую выполнять задачу Gradle `install`.
====

Создание приложения Sales::

. Создайте новый проект в Studio и укажите следующие значения в окне *New project*:

* *Project name* - `sales`

* *Project namespace* - `sales`

* *Root package* - `com.company.sales`

. Откройте *Project properties* на редактирование и на панели *App components* нажмите на кнопку добавления *Custom components*. В диалоге *Custom application component* выберите проект `customers` в списке *Registered project*. Данный список содержит все проекты, зарегистрированные в Studio и имеющие описатель `app-component.xml`. Нажмите в диалоге *OK*. В списке кастомных компонентов проекта появятся Maven-координаты компонента Customer Management. Сохраните страницу свойств проекта нажатием *OK*.

. Создайте сущность `Order` с атрибутами `date` и `amount`. Добавьте атрибут `customer` в виде many-to-one ассоциации с сущностью `Customer` - она дожна быть доступна в выпадающем списке *Type*.

. Сгенерируйте скрипты БД и создайте стандартные экраны для сущности `Order`. При создании экранов создайте представление `order-with-customer-view`, включающее атрибут `customer` и используйте его в экранах.

. Проверьте функциональность приложения: *Run > Create database*, *Run > Start application server*, затем откройте `++http://localhost:8080/app++` в веб-браузере. Приложение должно содержать два пункта меню верхнего уровня: *Customer Management* и *Application*.

Модификация компонента Customer Management::

Предположим, что необходимо изменить функциональность компонента (добавить атрибут в сущность `Customer`) и пересобрать приложение для внесения этих изменений.

. Откройте проект `customers` в Studio.

. Откройте сущность `Customer` на редактирование и добавьте атрибут `address`. При сохранении изменений выберите экраны браузера и редактора для включения нового атрибута.

. Сгенерируйте скрипты БД - будет создано новый скрипт обновления с изменением таблицы. Сохраните скрипты.

. Проверьте изменения в компоненте: *Run > Update database*, *Run > Start application server*, затем откройте `++http://localhost:8080/cust++` в веб-браузере.

. Переинсталлируйте компонент в локальный Maven-репозиторий выполнив команду меню *Run > Install app component*.

. Закройте проект `customers` и откройте `sales`.

. Выполните команды меню *Build > Clean*, затем *Build > Assemble project*.

. Запустите *Run > Update database* - будет выполнен скрипт обновления из компонента Customer Management.

. Выполните *Run > Start application server* и откройте `++http://localhost:8080/app++` в веб-браузере - приложение теперь содержит сущность `Customer` и соответствующие экраны с атрибутом `address`.

Предоставление общего доступа к компоненту Customer Management::

Компонент приложения можно выгрузить в удаленный Maven-репозиторий.

. Остановите сервер Studio.

. Установите репозиторий и сделайте его прокси для публичного репозитория CUBA `++https://repo.cuba-platform.com/content/groups/work++`.

. Откройте `build.gradle` проекта `customers` в текстовом редакторе. Замените репозиторий и имя/пароль пользователя в секции `buildscript/repositories` и добавьте `uploadRepository` в секции `cuba`:
+
[source,groovy]
----
include::{sourcesdir}/development/app_comp_upload_1.groovy[]
----

. Откройте командную строку в корневом каталоге проекта `customers` и выполните `gradle assemble`. Это необходимо для того, чтобы новый репозиторий закэшировал артефакты CUBA, требуемые для работы Studio.

. В окне сервера Studio укажите ваш репозиторий и имя/пароль для доступа к нему вместо стандартного репозитория CUBA. Запустите сервер Studio.

. Откройте проект `customers` в Studio.

. Найдите в диалоге *Search* (Alt-/) задачу Gradle `uploadArchives` и запустите ее. Эту задачу можно запускать и из командной строки. Артефакты компонента Customer Management будет выгружены в ваш репозиторий.

. Удалите артефакты компонента из локального Maven-репозитория чтобы быть уверенным, что они загрузятся из удаленного репозитория при последующей сборке приложения `sales`: просто удалите каталог `.m2/repository/com/company`, находящийся в домашнем каталоге пользователя.

. Откройте проект `customers` в Studio. Адрес репозитория в `build.gradle` будет автоматически заменен на тот, который указан в окне сервера Studio.

. Теперь можно собрать и запустить приложение - компонент Customer Management будет загружен из удаленного репозитория.
