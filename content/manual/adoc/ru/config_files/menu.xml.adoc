:sourcesdir: ../../../source

[[menu.xml]]
=== menu.xml

Файлы данного типа используются в <<app_tiers,блоках>> *Web Client* и *Desktop Client*, реализующих <<gui_framework,универсальный пользовательский интерфейс>>, для описания структуры главного меню приложения.

Схема XML доступна по адресу {xsd_url}/menu.xsd.

Расположение файла `menu.xml` задается в свойстве приложения <<cuba.menuConfig,cuba.menuConfig>>. При создании нового проекта в Studio, она создает файл `web-menu.xml` в корневом пакете модуля *web*, например `modules/web/src/com/company/sample/web-menu.xml`.

Рассмотрим структуру файла.

`menu-config` - корневой элемент

Элементы `menu-config`, образующие древовидную структуру:

* `menu` - раскрывающееся меню, содержащее пункты и другие раскрывающиеся меню
+
--
Атрибуты `menu`:

** `id` - идентификатор элемента, использующийся для формирования локализованного названия (см. <<menu.xml_localized,ниже>>).

** `description` - текст, появляющийся во всплывающей подсказке при наведении курсора мыши. Можно использовать локализованные сообщения из главного пакета сообщений.

** `icon` - значок для элемента меню. См. <<gui_attr_icon,icon>>.

** `insertBefore`, `insertAfter` - идентификатор элемента или пункта меню, перед которым или после которого нужно вставить данный элемент. Используется в прикладном проекте для вставки элемента в нужное место меню, определенного в аналогичных файлах компонентов приложения. Разумеется, использование одного из этих атрибутов для конкретного элемента исключает возможность использования второго атрибута для данного элемента.

** `stylename` - задает имя стиля пункта меню. См. <<gui_themes>>.

Элементы `menu`:

** `menu`

** `item` - пункт меню, см. далее

** `separator` - разделитель
--

* `item` - пункт меню
+
--
Атрибуты `item`:

** `id` - уникальный идентификатор элемента, использующийся для формирования локализованного названия (см. ниже). Может использоваться для связи с элементом файла <<screens.xml,screens.xml>>, в котором зарегистрированы экраны UI, если не задано других действий. При выборе пункта меню в главном окне приложения будет открыт соответствующий экран.

** `bean` - имя бина, который можно получить через `AppBeans` (например, `cuba_Messages`).

** `beanMethod` - имя метода бина (должно быть использовано вместе с атрибутом `bean`).
+
[source, xml]
----
<item bean="cuba_Messages"
      beanMethod="getMainMessagePack"/>
----

** `class` - полное имя класса, унаследованного от `Runnable`.
+
[source, xml]
----
<item class="com.haulmont.cuba.core.sys.SecurityContextAwareRunnable"/>
----

** `description` - текст, появляющийся во всплывающей подсказке при наведении курсора мыши. Можно использовать локализованные сообщения из главного пакета сообщений.
+
[source, xml]
----
<item id="ref$Colour.browse"
      description="mainMsg://carsColours"/>
----

** `screen` - неуникальный идентификатор экрана (например, `sec$User.browse`). Может быть использован в качестве `id`, если последний не задан.
+
[source, xml]
----
<item screen="sec$User.browse"/>
----

** `shortcut` - горячая клавиша для вызова данного пункта меню. Возможные модификаторы - `ALT`, `CTRL`, `SHIFT` - отделяются символом "`-`". Например:
+
[source, xml]
----
shortcut="ALT-C"
shortcut="ALT-CTRL-C"
shortcut="ALT-CTRL-SHIFT-C"
----
+
Горячие клавиши можно также задавать в <<app_properties,свойствах приложения>> и использовать в `menu.xml` следующим образом:
+
[source, properties]
----
shortcut="${sales.menu.customer}"
----

** `openType` - тип открытия экрана, возможные значения соответствуют перечислению `WindowManager.OpenType`: `++NEW_TAB++`, `++THIS_TAB++`, `DIALOG`, `++NEW_WINDOW++`.
+
По умолчанию - `++NEW_TAB++`. 
+
Значение `++NEW_WINDOW++` поддерживается только в *Desktop Client*, в *Web Client* оно эквивалентно `++NEW_TAB++`.

** `icon` - значок для элемента меню. См. <<gui_attr_icon,icon>>.

** `insertBefore`, `insertAfter` - идентификатор элемента или пункта меню, перед которым или после которого нужно вставить данный элемент. 
+
Атрибуты `insertBefore`, `insertAfter` для элемента `item` не поддерживаются в Studio. Поэтому если вы задали эти атрибуты вручную, не открывайте дизайнер меню Studio, иначе они будут удалены.

** `resizable` - актуально для типа открытия экрана `DIALOG` - задает окну возможность изменения размера. Возможные значения: `true`, `false`.
+
По умолчанию главное меню не влияет на возможность изменения размера диалоговых окон.

** `stylename` - задает имя стиля пункта меню. См. <<gui_themes>>.

Элементы `item`:

** `param` - задает параметр экрана, передаваемый в мэп метода `init()` <<screen_controller,контроллера>>. Параметры, заданные в `menu.xml`, переопределяют одноименные параметры, заданные в <<screens.xml,screens.xml>>.
+
Атрибуты `param`:

*** `name` - имя параметра

*** `value` - значение параметра. Строковое значение может преобразовываться в некоторый объект по следующим правилам:

**** Если строка представляет собой идентификатор сущности, записанный по правилам класса `EntityLoadInfo`, то загружается указанный экземпляр сущности.

**** Если строка имеет вид `++${some_name}++`, то значением параметра будет свойство приложения `some_name`.

**** Строки `true` и `false` преобразуются в соответствующие значения типа `Boolean`.

**** Если ничего из вышеперечисленного не подходит, значением параметра становится сама строка.

** `permissions` - элемент, позволяющий задать набор разрешений текущего пользователя, при которых данный пункт меню доступен. Данный механизм имеет смысл использовать только если необходимо привязать доступность пункта к специфическим разрешениям, или не к одному, а к нескольким разрешениям сразу. В большинстве случаев достаточно стандартной возможности подсистемы безопасности управлять доступностью пунктов меню по идентификаторам экранов.
+
Данный элемент должен содержать вложенные элементы `permission`, каждый из которых описывает одно требуемое разрешение. Пункт меню доступен только при наличии всех требуемых разрешений.
+
Атрибуты `permission`:

*** `type` - тип требуемого разрешения, задаваемый значением перечисления `PermissionType`: `SCREEN`, `++ENTITY_OP++`, `++ENTITY_ATTR++`, `SPECIFIC`, `UI`.

*** `target` - объект, на который проверяется наличие разрешения. Зависит от типа разрешения:

**** `SCREEN` - идентификатор экрана, например `sales$Customer.lookup`.

**** `++ENTITY_OP++` - строка вида `++{entity_name}:{op}++`, где `{op}` - `read`, `create`, `update`, `delete`. Например: `sales$Customer:create`.

**** `++ENTITY_ATTR++` - строка вида `++{entity_name}:{attribute}++`, например `sales$Customer:name`.

**** `SPECIFIC` - идентификатор специфического разрешения, например `sales.runInvoicing`.

**** `UI` - путь к визуальному компоненту экрана.
--

Пример файла меню:

[source, xml]
----
<menu-config xmlns="http://schemas.haulmont.com/cuba/menu.xsd">

  <menu id="sales" insertBefore="administration">
      <item id="sales$Customer.lookup"/>
      <separator/>
      <item id="sales$Order.lookup"/>
  </menu>

</menu-config>
----

[[menu.xml_localized]]
Локализованное название элемента меню формируется следующим образом: к идентификатору элемента добавляется префикс `menu-config` с точкой на конце, и полученная строка используется как ключ в <<main_message_pack,главном пакете сообщений>>. Например:

[source, plain]
----
menu-config.sales=Sales
menu-config.sales$Customer.lookup=Customers
----

Если атрибут `id` не задан, имя элемента меню будет составлено из имени класса (если задан атрибут `class`) или имени бина и его метода (если задан атрибут `bean`), поэтому для локализации рекомендуется указывать атрибут `id`.

