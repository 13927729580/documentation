[[gui_vcl]]
==== Библиотека визуальных компонентов

<<gui_components,Компоненты>>

<<gui_layouts,Контейнеры>>

<<gui_misc,Разное>>

[[gui_components]]
===== Компоненты

.Диаграмма компонентов
image::Components_new.png[align="center"]

`Component` − предок всех визуальных компонентов. Он содержит базовые атрибуты, позволяющие идентифицировать компонент и располагать его на экране.

[cols="<.^1,<.^4", frame="none", width="60%", grid="none"]
|===

| *Buttons*|

| <<gui_Button,Button>>| image:Button.png[]

| <<gui_PopupButton,PopupButton>>| image:PopupButton.png[]

| <<gui_LinkButton,LinkButton>>| image:LinkButton.png[]

| |

| *Text*|

| <<gui_Label,Label>>| image:gui_label.png[]

| |

| *Text inputs*|

| <<gui_TextField,TextField>>| image:gui_textField.png[]

| <<gui_PasswordField,PasswordField>>| image:gui_PasswordField.png[]

| <<gui_MaskedField,MaskedField>>| image:gui_MaskedField.png[]

| <<gui_TextArea,TextArea>>| image:gui_TextArea.png[]

| <<gui_RichTextArea,RichTextArea>>| image:gui_RichTextArea.png[]

| |

| *Date inputs*|

| <<gui_DateField,DateField>>| image:gui_dateField.png[]

| <<gui_TimeField,TimeField>>| image:gui_timeField.png[]

| |

| *Selects*|

| <<gui_CheckBox,CheckBox>>| image:CheckBox.png[]

| <<gui_OptionsGroup,OptionsGroup>>| image:gui_optionsGroup.png[]

| <<gui_PickerField,PickerField>>| image:PickerField.png[]

| <<gui_LookupField,LookupField>>| image:LookupField.png[]

| <<gui_LookupPickerField,LookupPickerField>>| image:LookupPickerField.png[]

| <<gui_SearchPickerField,SearchPickerField>>| image:gui_searchPickerField.png[]

| <<gui_TwinColumn,TwinColumn>>| image:TwinColumn.png[]

| |

| *Uploads*|

| <<gui_FileUploadField,FileUploadField>>| image:Upload.png[]

| <<gui_FileMultiUploadField,FileMultiUploadField>>

|

| *Tables and trees*|

| <<gui_Table,Table>>| image:gui_table.png[]

| <<gui_GroupTable,GroupTable>>| image:gui_groupTable.png[]

| <<gui_TreeTable,TreeTable>>| image:gui_treeTable.png[]

| <<gui_Tree,Tree>>| image:gui_Tree.png[]

| |

| *Others*|

| <<gui_FieldGroup,FieldGroup>>| image:gui_fieldGroup.png[]

| <<gui_TokenList,TokenList>>| image:gui_tokenList.png[]

| <<gui_Filter,Filter>>| image:gui_filter_mini.png[]

|===

[[gui_Button]]
====== Button

Кнопка (`Button`) − компонент, обеспечивающий выполнение действия при нажатии.

XML-имя компонента: `button`

image::gui_Button_dia.png[align="center"]

Компонент кнопки реализован для блоков *Web Client* и *Desktop Client*.

Кнопка может содержать текст или пиктограмму (или и то и другое). На рисунке ниже отображены разные виды кнопок.

image::gui_buttonTypes.png[align="center"]

Пример кнопки с названием, взятым из <<message_packs,пакета локализованных сообщений>>, и с всплывающей подсказкой:

[source, xml]
----
include::{sourcesdir}/gui_vcl/button_1.xml[]
----

Название кнопки задается с помощью атрибута <<gui_attr_caption,caption>>, всплывающая подсказка − с помощью атрибута <<gui_attr_description,description>>.

Атрибут <<gui_attr_icon,icon>> указывает на местоположение пиктограммы. Подробную информацию о том, где следует располагать файлы пиктограмм, можно прочитать в <<gui_themes,Создание темы приложения>>.

Пример создания кнопки с пиктограммой:

[source, xml]
----
include::{sourcesdir}/gui_vcl/button_2.xml[]
----

[[gui_Button_invoke]]
Основная функция кнопки − выполнить некоторое действие при нажатии на нее. Определить метод контроллера, который будет вызываться при нажатии на кнопку, можно с помощью атрибута `invoke`. Значением атрибута должно быть имя метода контроллера, удовлетворяющего следующим условиям:

* Метод должен быть `public`.

* Метод должен возвращать `void`.

* Метод должен либо не иметь аргументов, либо иметь один аргумент типа `Component`. Если метод имеет аргумент `Component`, то при вызове в него будет передан экземпляр вызвавшей кнопки.

В качестве примера показано описание кнопки, вызывающей метод `someMethod:`

[source, xml]
----
include::{sourcesdir}/gui_vcl/button_3.xml[]
----

В контроллере экрана необходимо определить метод `someMethod`:

[source, java]
----
include::{sourcesdir}/gui_vcl/button_4.java[]
----

[[gui_Button_action]]
Атрибут `invoke` игнорируется, если для кнопки задан атрибут `action`. Атрибут `action` содержит имя <<gui_Action,действия>>, соответствующего данной кнопке.

Пример кнопки с атрибутом `action`:

[source, xml]
----
include::{sourcesdir}/gui_vcl/button_5.xml[]
----

Кнопке можно назначить любое действие, имеющееся в каком-либо компоненте, реализующем интерфейс `Component.ActionsHolder` (это актуально для <<gui_Table,Table>>, <<gui_GroupTable,GroupTable>>, <<gui_TreeTable,TreeTable>>, <<gui_Tree,Tree>>). Причем неважно, каким образом эти действия добавлены - декларативно в XML-дескрипторе или программно в контроллере. В любом случае для использования такого действия достаточно в атрибуте `action` указать через точку имя компонента и идентификатор нужного действия. Например, в следующем примере кнопке назначается действие `create` таблицы `coloursTable`:

[source, xml]
----
include::{sourcesdir}/gui_vcl/button_6.xml[]
----

Действие для кнопки можно также создавать программно, в контроллере экрана, используя наследование от класса <<baseAction,BaseAction>>.

Если для `Button` установлен экземпляр `Action`, то кнопка возьмет из него следующие свои свойства: <<gui_attr_caption,caption>>, <<gui_attr_description,description>>, <<gui_attr_icon,icon>>, <<gui_attr_enable,enable>>, <<gui_attr_visible,visible>>. Свойства `caption` и `description` будут проставлены из действия только в том случае, если они не установлены в самом `Button`. Остальные перечисленные свойства действия имеют безусловный приоритет над свойствами кнопки. Если свойства действия меняются уже после установки этого `Action` для `Button`, то соответственно меняться будут и свойства `Button`, то есть кнопка слушает изменение свойств действия. В этом случае меняется и свойства `caption` и `description`, причем даже если они изначально были назначены на саму кнопку.

'''

Атрибуты button::
<<gui_Button_action,action>> -
<<gui_attr_align,align>> -
<<gui_attr_caption,caption>> -
<<gui_attr_description,description>> -
<<gui_attr_enable,enable>> -
<<gui_attr_icon,icon>> -
<<gui_attr_id,id>> -
<<gui_Button_invoke,invoke>> -
<<gui_attr_stylename,stylename>> -
<<gui_attr_visible,visible>> -
<<gui_attr_width,width>>

'''

[[gui_BulkEditor]]
====== BulkEditor

`BulkEditor` - компонент, позволяющий менять значения атрибутов сразу нескольких выбранных экземпляров сущностей. Компонент представляет собой кнопку, добавляющуюся к <<gui_Table,таблице>> или <<gui_Tree,дереву>> и при нажатии открывающую редактор сущностей.

image::gui_bulkEdit.png[align="center"]

XML-имя компонента: `bulkEditor`

image::gui_BulkEditor_dia.png[align="center"]

Компонент реализован для блоков *Web Client* и *Desktop Client*.

Для использования `BulkEditor` у таблицы или дерева должен быть задан атрибут `multiselect="true"`.

Экран редактирования сущностей генерируется автоматически на основе заданного представления (содержащего только поля данной сущности, в том числе ссылки) и разрешений пользователя. Системные атрибуты в редакторе также не отображаются. 

Атрибуты сущности в редакторе сортируются по алфавиту. По умолчанию они пусты. При коммите экрана заданные на экране непустые значения атрибутов проставляются всем выбранным экземплярам сущности. 

Редактор позволяет удалить значение определенного поля в БД у всех выбранных сущностей, установив его в `null`. Для этого необходимо нажать на кнопку image:gui_bulkEditorSetNullButton.png[] рядом с соответствующим полем. После этого поле становится нередактируемым. Разблокировать поле можно, нажав на кнопку эту же кнопку снова.

image::gui_invoiceBulkEdit.png[align="center"]

Пример описания компонента `bulkEditor` для таблицы:

[source, xml]
----
include::{sourcesdir}/gui_vcl/bulkEditor_1.xml[]
----
[[gui_BulkEditor_for]]
Атрибут `for` является обязательным. В нем указывается идентификатор таблицы или дерева, в данном случае - `invoiceTable`.

[[gui_BulkEditor_exclude]]
Атрибут `exclude` может содержать регулярное выражения для явного исключения определенных полей из списка редактируемых. Например: `date|customer`

image::gui_TableBulkEdit.png[align="center"]

'''

Атрибуты bulkEditor::
<<gui_attr_align,align>> -
<<gui_attr_caption,caption>> -
<<gui_attr_description,description>> -
<<gui_attr_enable,enable>> -
<<gui_BulkEditor_exclude,exclude>> -
<<gui_BulkEditor_for,for>> -
<<gui_attr_icon,icon>> -
<<gui_attr_id,id>> -
<<gui_attr_openType,openType>> -
<<gui_attr_stylename,stylename>> -
<<gui_attr_visible,visible>> -
<<gui_attr_width,width>>

'''

[[gui_CheckBox]]
====== CheckBox

Флажок (`CheckBox`) − компонент, имеющий два состояния: выбран, не выбран.

image::CheckBox.png[align="center"]

XML-имя компонента: `checkBox`.

image::gui_checkBox_dia.png[align="center"]

Компонент `CheckBox` реализован для блоков *Web Client* и *Desktop Client*.

Пример флажка с надписью, взятой из <<message_packs,пакета локализованных сообщений>>:

[source, xml]
----
include::{sourcesdir}/gui_vcl/checkbox_1.xml[]
----

Сброс или установка флажка изменяет его значение: `Boolean.TRUE` или `Boolean.FALSE`. Значение может быть получено с помощью метода `getValue()` и установлено с помощью метода `setValue()`. Если в `setValue()` передать `null`, то устанавливается значение `Boolean.FALSE` и флажок снимается.

Изменение значения флажка, так же как и любого другого компонента, реализующего интерфейс `Field`, можно отслеживать с помощью слушателя `ValueChangeListener`. Например:

[source, java]
----
include::{sourcesdir}/gui_vcl/checkbox_2.java[]
----

Для создания флажка, связанного с данными, необходимо использовать атрибуты <<gui_attr_datasource,datasource>> и <<gui_attr_property,property>>.

[source, xml]
----
include::{sourcesdir}/gui_vcl/checkbox_3.xml[]
----

Как видно из примера, в экране описывается <<datasources,источник данных>> `customerDs` для некоторой сущности Покупатель (`Customer`), имеющей атрибут `active`. В компоненте `checkBox` в атрибуте `datasource` указывается ссылка на источник данных, а в атрибуте `property` − название атрибута сущности, значение которого должно быть отображено флажком. Атрибут должен быть типа `Boolean`. Значением атрибута может быть `null`, при этом флажок снимается.

'''

Атрибуты checkBox::
<<gui_attr_align,align>> -
<<gui_attr_caption,caption>> -
<<gui_attr_datasource,datasource>> -
<<gui_attr_description,description>> -
<<gui_attr_editable,editable>> -
<<gui_attr_enable,enable>> -
<<gui_attr_height,height>> -
<<gui_attr_id,id>> -
<<gui_attr_property,property>> -
<<gui_attr_stylename,stylename>> -
<<gui_attr_visible,visible>> -
<<gui_attr_width,width>>

'''

[[gui_DateField]]
====== DateField

Поле для отображения и ввода даты и времени. Представляет собой поле даты, внутри которого имеется кнопка с выпадающим календарем, а правее находится поле для ввода времени.

image::gui_dateFieldSimple.png[align="center"]

XML-имя компонента: `dateField`.

image::gui_dateField_dia.png[align="center"]

Компонент `DateField` реализован для блоков *Web Client* и *Desktop Client*. 

* Для создания поля даты, связанного с данными, необходимо использовать атрибуты <<gui_attr_datasource,datasource>> и <<gui_attr_property,property>>:
+
[source, xml]
----
include::{sourcesdir}/gui_vcl/datefield_1.xml[]
---- 
+
Как видно из примера, в экране описывается источник данных `orderDs` для некоторой сущности Заказ (`Order`), имеющей атрибут `date`. В компоненте ввода даты в атрибуте <<gui_attr_datasource,datasource>> указывается ссылка на источник данных, а в атрибуте <<gui_attr_property,property>> − название атрибута сущности, значение которого должно быть отображено в поле.

* Если поле связано с атрибутом сущности, то оно автоматически принимает соответствующий вид:

** Если атрибут типа `java.sql.Date` или указана аннотация `@Temporal(TemporalType.DATE)`, то поле времени не отображается. Формат даты определяется <<datatype,типом данных>> `date` и задается в <<main_message_pack,главном пакете локализованных сообщений>> в ключе `dateFormat`.

** В противном случае отображается также поле времени с часами и минутами. Формат времени определяется <<datatype,типом данных>> `time` и задается в <<main_message_pack,главном пакете локализованных сообщений>> в ключе `timeFormat`.

[[gui_DateField_dateFormat]]
* Изменить формат представления даты и времени можно с помощью атрибута `dateFormat`. Значением атрибута может быть либо сама строка формата, либо ключ в пакете сообщений (если значение начинается с `msg://`).
+
Формат задается по правилам класса `SimpleDateFormat` (http://docs.oracle.com/javase/8/docs/api/java/text/SimpleDateFormat.html). Если в формате отсутствуют символы `H` или `h`, то поле времени не выводится.
+
[source, xml]
----
include::{sourcesdir}/gui_vcl/datefield_2.xml[]
----
+
image::gui_dateField_format.png[align="center"]
+
[WARNING]
====
`DateField` в основном предназначен для быстрого ввода с клавиатуры путем заполнения маски. Поэтому компонент поддерживает только форматы с цифрами и разделителями. Сложные форматы с текстовым представлением дня недели или месяца не будут работать.
====

[[gui_DateField_resolution]]
* Точность представления даты и времени можно определить с помощью атрибута `resolution`. Значение атрибута должно соответствовать перечислению `DateField.Resolution` − `SEC`, `MIN`, `HOUR`, `DAY`, `MONTH`, `YEAR`. По умолчанию - `MIN`, то есть до минут.
+
Если `resolution="DAY"` и не указан атрибут `dateFormat`, то в качестве формата будет взят формат, указанный в <<main_message_pack,главном пакете сообщений>> с ключом `dateFormat`.
+
Если `resolution="MIN"` и не указан атрибут `dateFormat`, то в качестве формата будет взят формат, указанный в <<main_message_pack,главном пакете сообщений>> с ключом `dateTimeFormat`.
+
Ниже показано определения поля для ввода даты с точностью до месяца.
+
[source, xml]
----
<dateField resolution="MONTH" caption="msg://monthOnlyDateField"/>
----
+
image::gui_dateField_resolution.png[align="center"]

* Если для пользователя методом `setTimeZone()` задан <<timeZone,часовой пояс>>, то `DateField` может преобразовывать значения типа timestamp между часовыми поясами сервера и пользователя. Если компонент привязан к атрибуту типа timestamp, часовой пояс автоматически берется из текущей <<userSession,пользовательской сессии>>. Если нет, то можно вызвать метод `setTimeZone()` в контроллере экрана, чтобы `DateField` выполнил необходимые преобразования.

'''

Атрибуты dateField::
<<gui_attr_align,align>> -
<<gui_attr_caption,caption>> -
<<gui_attr_datasource,datasource>> -
<<gui_DateField_dateFormat,dateFormat>> -
<<gui_attr_description,description>> -
<<gui_attr_editable,editable>> -
<<gui_attr_enable,enable>> -
<<gui_attr_height,height>> -
<<gui_attr_id,id>> -
<<gui_attr_property,property>> -
<<gui_attr_stylename,stylename>> -
<<gui_attr_required,required>> -
<<gui_attr_requiredMessage,requiredMessage>> -
<<gui_DateField_resolution,resolution>> -
<<gui_attr_visible,visible>> -
<<gui_attr_width,width>>

Элементы dateField::
<<gui_validator,validator>>

'''

[[gui_Embedded]]
====== Embedded

Компонент `Embedded` предназначен для вывода изображений и встраивания в экран произвольных веб-страниц.

XML-имя компонента: `embedded`

image::gui_Embedded_dia.png[align="center"]

Компонент реализован для блоков *Web Client* и *Desktop Client*. В десктоп-клиенте поддерживается только вывод изображений.

Рассмотрим пример использования компонента для вывода изображения из файла, сохраненного в <<file_storage,FileStorage>>. 

* Объявляем компонент в XML-дескрипторе экрана:
+
[source, xml]
----
include::{sourcesdir}/gui_vcl/embedded_1.xml[]
----

* В контроллере экрана инжектируем компонент и интерфейс `FileStorageService`. Затем в методе `init()` получаем из параметров экрана переданный из вызывающего кода `FileDescriptor`, загружаем соответствующий файл в байтовый массив, создаем для него `ByteArrayInputStream` и передаем в метод `setSource()` компонента:
+
[source, java]
----
include::{sourcesdir}/gui_vcl/embedded_2.java[]
----

Веб-клиент позволяет выводить изображения из произвольных файлов на диске, доступных блоку Web Client. Для этого нужно определить каталог ресурсных файлов в свойстве приложения <<cuba.web.resourcesRoot,cuba.web.resourcesRoot>>, и указать для компонента `Embedded` имя файла внутри этого каталога:

[source, java]
----
include::{sourcesdir}/gui_vcl/embedded_3.java[]
----

Для встраивания в экран веб-клиента внешней веб-страницы необходимо передать компоненту URL:

[source, java]
----
include::{sourcesdir}/gui_vcl/embedded_4.java[]
----

'''

Атрибуты embedded::
<<gui_attr_align,align>> -
<<gui_attr_height,height>> -
<<gui_attr_id,id>> -
<<gui_attr_stylename,stylename>> -
<<gui_attr_visible,visible>> -
<<gui_attr_width,width>>

'''

[[gui_FieldGroup]]
====== FieldGroup

Компонент `FieldGroup` предназначен для совместного отображения и редактирования нескольких атрибутов сущностей. 

image::gui_fieldGroup.png[align="center"]

XML-имя компонента: `fieldGroup`

image::gui_FieldGroup_dia.png[align="center"]

Компонент реализован для блоков *Web Client* и *Desktop Client*.

Пример описания группы полей в XML-дескрипторе экрана: 

[source, xml]
----
include::{sourcesdir}/gui_vcl/fieldgroup_1.xml[]
---- 

Здесь в элементе `dsContext` определен <<datasources,источник данных>> `datasource`, который содержит один экземпляр сущности `Order`. Для компонента `fieldGroup` в атрибуте `datasource` указывается используемый источник данных, а в элементах `field` - какие атрибуты сущности, содержащейся в источнике данных, необходимо отобразить.

Элементы `fieldGroup`:

* `column` - необязательный элемент, позволяющий располагать поля в несколько колонок. Для этого элементы `field` должны находиться не непосредственно внутри `fieldGroup`, а внутри своего `column`. Например: 
+
[source, xml]
----
include::{sourcesdir}/gui_vcl/fieldgroup_2.xml[]
---- 
+
В данном случае поля будут расположены в две колонки, причем в первой колонке все поля будут шириной `250px`, а во второй - `400px`.
+
Атрибуты `column`:
+
--
[[gui_FieldGroup_column_width]]
** `width` - задает ширину полей данной колонки. По умолчанию ширина полей - `200px`. В данном атрибуте ширина может быть задана как в пикселах, так и в процентах от общего размера колонки по горизонтали.

[[gui_FieldGroup_column_flex]]
** `flex` - число, задающее степень изменения общего размера данной колонки по горизонтали относительно других колонок при изменении ширины всего компонента `fieldGroup`. Например, можно задать одной колонке `flex=1` а другой `flex=3`.

[[gui_FieldGroup_column_id]]
** `id` - необязательный идентификатор колонки, позволяющий ссылаться на нее в случае <<screen_extension,расширении экрана>>.
--

* `field` - основной элемент компонента, описывает одно поле компонента. 
+
Атрибуты элемента `field`:
+
--
[[gui_FieldGroup_field_id]]
** `id` - обязательный атрибут, должен содержать либо название атрибута сущности, выводимого в поле, либо произвольный уникальный идентификатор программно определяемого поля. В последнем случае элемент `field` должен иметь также атрибут `custom="true"` (см. далее).

[[gui_FieldGroup_field_caption]]
** `caption` − позволяет задать заголовок поля. Если не задан, будет отображено <<entity_localization,локализованное название атрибута>> сущности.

[[gui_FieldGroup_field_visible]]
** `visible` − позволяет скрыть поле вместе с заголовком.

[[gui_FieldGroup_field_datasource]]
** `datasource` − позволяет задать для данного поля <<datasources,источник данных>>, отличный от заданного для всего компонента `fieldGroup`. Таким образом в группе полей могут отображаться атрибуты разных сущностей.

** `optionsDatasource` − задает имя <<datasources,источника данных>>, используемого для формирования списка опций. Данный атрибут можно задать для поля, связанного со ссылочным атрибутом сущности. По умолчанию выбор связанной сущности производится через экран выбора, а если `optionsDatasource` указан, то связанную сущность можно выбирать из выпадающего списка опций. Фактически указание `optionsDatasource` приводит к тому, что вместо компонента <<gui_PickerField,PickerField>> в поле используется <<gui_LookupPickerField,LookupPickerField>>. 

[[gui_FieldGroup_field_width]]
** `width` − позволяет задать ширину поля без учета заголовка. По умолчанию ширина поля - `200px`. Ширина может быть задана как в пикселах, так и в процентах от общего размера колонки по горизонтали. Для указания ширины всех полей одновременно можно использовать атрибут `width` элемента `column`, описанный выше.

[[gui_FieldGroup_field_custom]]
** `custom` - установка этого атрибута в `true` позволяет задать собственное представление поля, или говорит о том, что идентификатор поля не ссылается на атрибут сущности, и компонент, находящийся в поле, будет задан программно с помощью метода `addCustomField()` компонента `FieldGroup` (см. ниже). 

[[gui_FieldGroup_field_link]]
** `link` - установка атрибута в `true` позволяет отобразить вместо поля выбора сущности ссылку на экран просмотра экземпляра сущности (поддерживается только для *Web Client*). Такое поведение может быть необходимо, если требуется дать пользователю возможность просматривать связанную сущность, но саму связь он менять не должен.

[[gui_FieldGroup_field_linkScreen]]
** `linkScreen` - позволяет указать идентификатор экрана, который будет открыт по нажатию на ссылку, включенную свойством `link`.

[[gui_FieldGroup_field_linkScreenOpenType]]
** `linkScreenOpenType` - задает режим открытия экрана редактирования (`++THIS_TAB++`, `++NEW_TAB++` или `DIALOG`).

[[gui_FieldGroup_field_linkInvoke]]
** `linkInvoke` - позволяет заменить открытие окна на вызов метода контроллера.

Следующие атрибуты элемента `field` можно применять в зависимости от типа атрибута сущности, отображаемого полем:

[[gui_FieldGroup_field_mask]]
** Если для текстового атрибута сущности задать значение атрибута `mask`, то в поле вместо компонента <<gui_TextField,TextField>> будет использоваться компонент <<gui_MaskedField,MaskedField>> с соотвествующей маской. В этом случае можно также задать атрибут `valueMode`.

[[gui_FieldGroup_field_rows]]
** Если для текстового атрибута сущности задать значение атрибута `rows`, то в поле вместо компонента <<gui_TextField,TextField>> будет использоваться компонент <<gui_TextArea,TextArea>> с соответствующим количеством строк. В этом случае можно также задать атрибут `cols`.

** Для текстового атрибута сущности можно задать атрибут `maxLength` аналогично описанному для <<gui_TextField,TextField>>.

** Для атрибута сущности типа `date` или `dateTime` можно задать атрибуты `dateFormat` и `resolution` для параметризации находящегося в поле компонента <<gui_DateField,DateField>>.

** Для атрибута сущности типа `time` можно задать атрибут `showSeconds` для параметризации находящегося в поле компонента <<gui_TimeField,TimeField>>.
--

Атрибуты `fieldGroup`:

[[gui_FieldGroup_border]]
* Атрибут `border` может принимать значение `hidden` или `visible`. По умолчанию - `hidden`. При установке в значение `visible` компонент `fieldGroup` выделяется рамкой. В веб-реализации компонента отображение рамки осуществляется добавлением CSS-класса `cuba-fieldgroup-border`. 

Методы интерфейса `FieldGroup`:

* Метод `addCustomField()` используется вместе с атрибутом `custom="true"` элемента `field` и позволяет задать собственное представление поля. Он принимает два параметра: идентификатор поля, заданный в атрибуте `id` элемента `field`, и реализацию интерфейса `FieldGroup.CustomFieldGenerator`.
+
Метод `generateField()` интерфейса `CustomFieldGenerator` вызывается компонентом `FieldGroup`, и в него передается <<datasources,источник данных>> и идентификатор поля, для которого зарегистрирован данный генератор. Метод должен вернуть визуальный компонент (или контейнер), который и будет отображен в поле.
+
Пример использования: 
+
[source, java]
----
include::{sourcesdir}/gui_vcl/fieldgroup_3.java[]
---- 

* Метод `getFieldComponent()` возвращает визуальный компонент, находящийся в поле с указанным идентификатором. Это может потребоваться для дополнительной параметризации компонента, недоступной через атрибуты XML-элемента `field`, описанные выше. 
+
Вместо явного вызова `getFieldComponent()` для получения ссылки на компонент поля в контроллере экрана можно использовать <<screen_controller_injection,инжекцию>>. Для этого следует использовать аннотацию `@Named` с указанием идентификатора самого `fieldGroup`, и через точку - идентификатора поля. 
+
Например, следующим образом в поле выбора связанной сущности можно добавить действие открытия экземпляра и убрать действие очистки поля: 
+
[source, xml]
----
include::{sourcesdir}/gui_vcl/fieldgroup_4.xml[]
----
+
[source, java]
----
include::{sourcesdir}/gui_vcl/fieldgroup_5.java[]
----
+
Для использования метода `getFieldComponent()` или инжекции компонентов полей необходимо знать тип компонента, находящегося в поле. В следующей таблице приведено соответствие типов атрибутов сущностей и создаваемых для них компонентов:
+
[cols="3*.^", frame="all"]
|===
| Тип атрибута сущности | Дополнительные условия| Тип компонента поля

.2+| Связанная сущность
| Задан атрибут `optionsDatasource`
| <<gui_LookupPickerField,LookupPickerField>>

|
| <<gui_PickerField,PickerField>>

| Перечисление (`enum`)
|
| <<gui_LookupField,LookupField>>

.3+| `string`
| Задан атрибут `mask`
| <<gui_MaskedField,MaskedField>>

| Задан атрибут `rows`
| <<gui_TextArea,TextArea>>

|
| <<gui_TextField,TextField>>

| `boolean`
|
| <<gui_CheckBox,CheckBox>>

| `date`, `dateTime`
|
| <<gui_DateField,DateField>>

| `time`
|
| <<gui_TimeField,TimeField>>

| `int`, `long`, `double`, `decimal`
|
| <<gui_TextField,TextField>>

|===

'''

Атрибуты fieldGroup::
<<gui_attr_align,align>> -
<<gui_FieldGroup_border,border>> -
<<gui_attr_caption,caption>> -
<<gui_attr_datasource,datasource>> -
<<gui_attr_editable,editable>> -
<<gui_attr_enable,enable>> -
<<gui_attr_id,id>> -
<<gui_attr_height,height>> -
<<gui_attr_stylename,stylename>> -
<<gui_attr_visible,visible>> -
<<gui_attr_width,width>>

Атрибуты column::
<<gui_FieldGroup_column_flex,flex>> -
<<gui_FieldGroup_column_id,id>> -
<<gui_FieldGroup_column_width,width>>

Атрибуты field::
<<gui_FieldGroup_field_caption,caption>> -
<<gui_attr_captionProperty,captionProperty>> -
<<gui_FieldGroup_field_rows,cols>> -
<<gui_FieldGroup_field_custom,custom>> -
<<gui_FieldGroup_field_datasource,datasource>> -
<<gui_DateField_dateFormat,dateFormat>> -
<<gui_attr_description,description>> -
<<gui_attr_editable,editable>> -
<<gui_attr_enable,enable>> -
<<gui_FieldGroup_field_id,id>> -
<<gui_FieldGroup_field_link,link>> -
<<gui_FieldGroup_field_linkInvoke,linkInvoke>> -
<<gui_FieldGroup_field_linkScreen,linkScreen>> -
<<gui_FieldGroup_field_linkScreenOpenType,linkScreenOpenType>> -
<<gui_FieldGroup_field_mask,mask>> -
<<gui_TextField_maxLength,maxLength>> -
<<gui_attr_optionsDatasource,optionsDatasource>> -
<<gui_attr_required,required>> -
<<gui_attr_requiredMessage,requiredMessage>> -
<<gui_DateField_resolution,resolution>> -
<<gui_FieldGroup_field_rows,rows>> -
<<gui_TimeField_showSeconds,showSeconds>> -
<<gui_FieldGroup_field_visible,visible>> -
<<gui_attr_width,width>>

Элементы field::
<<gui_validator,validator>>

'''

[[gui_FileMultiUploadField]]
====== FileMultiUploadField

Компонент `FileMultiUploadField` позволяет пользователю загружать файлы на сервер. Компонент представляет собой кнопку, при нажатии на которую на экране отображается стандартное для операционной системы окно выбора файлов, в котором можно выбрать сразу несколько файлов для загрузки.

image::gui_multipleUpload.png[align="center"]

XML-имя компонента: `multiUpload`.

image::gui_FileMultiUploadField_dia.png[align="center"]

Компонент реализован для блоков *Web Client* и *Desktop Client*.

Рассмотрим пример использования компонента.

* Объявляем компонент в XML-дескрипторе экрана:
+
[source, xml]
----
include::{sourcesdir}/gui_vcl/multiupload_1.xml[]
----

* В контроллере экрана инжектируем сам компонент, а также интерфейсы <<file_upload,FileUploadingAPI>> и <<dataSupplier,DataSupplier>>. Затем в методе `init()` добавляем слушателей, которые будут реагировать на события успешной загрузки или ошибки:
+
[source, java]
----
include::{sourcesdir}/gui_vcl/multiupload_2.java[]
----
+
Компонент загружает выбранные файлы во временное хранилище клиентского <<app_tiers,уровня>> и вызывает листенер добавленный методом `addQueueUploadCompleteListener()`. В данном листенере вызовом метода `getUploadsMap()` у компонента можно получить мэп идентификаторов файлов во временном хранилище на имена файлов. Далее для каждого элемента мэп создается соответствующий объект `FileDescriptor` путем вызова `FileUploadingAPI.getFileDescriptor()`. Объект `com.haulmont.cuba.core.entity.FileDescriptor` (не путать с `java.io.FileDescriptor`) является персистентной сущностью, которая однозначно идентифицирует загруженный файл и впоследствии используется для выгрузки файла из системы.
+
Метод `FileUploadingAPI.putFileIntoStorage()` используется для перемещения загружаемого файла из временного хранилища клиентского уровня в <<file_storage,FileStorage>>. Параметрами этого метода являются идентификатор файла во временном хранилище и объект `FileDescriptor`. 
+
После загрузки файла в `FileStorage` выполняется сохранение экземпляра `FileDescriptor` в базе данных посредством вызова `DataSupplier.commit()`. Возвращаемый этим методом сохраненный экземпляр может быть установлен в атрибут какой-либо сущности предметной области, связанной с данным файлом. В данном же случае `FileDescriptor` просто сохраняется в базе данных. Соответствующий файл будет доступен через экран *Administration* → *External Files*.
+
После обработки файлов необходимо очистить список файлов вызовом `clearUploads()` на случай повторной загрузки.

* Максимальный размер загружаемого файла определяется свойством приложения <<cuba.client.maxUploadSizeMb,cuba.client.maxUploadSizeMb>> и по умолчанию равен 20MB. При выборе пользователем файла большего размера выдается соответствующее сообщение и загрузка прерывается.

В разделе <<images_recipe>> приведен более сложный пример работы с загруженными файлами.

'''

Атрибуты multiUpload::
<<gui_attr_align,align>> -
<<gui_attr_caption,caption>> -
<<gui_attr_description,description>> -
<<gui_attr_enable,enable>> -
<<gui_attr_height,height>> -
<<gui_attr_id,id>> -
<<gui_attr_stylename,stylename>> -
<<gui_attr_visible,visible>> -
<<gui_attr_width,width>>

'''

[[gui_FileUploadField]]
====== FileUploadField

Компонент `FileUploadField` позволяет пользователю загружать файлы на сервер. Компонент представляет собой кнопку, при нажатии на которую на экране отображается стандартное для операционной системы окно, в котором можно выбрать один файл. Чтобы дать пользователю возможность загружать сразу несколько файлов, используйте компонент <<gui_FileMultiUploadField,FileMultiUploadField>>.

image::gui_upload.png[align="center"]

XML-имя компонента: `upload`.

image::gui_FileUploadField_dia.png[align="center"]

Компонент реализован для блоков *Web Client* и *Desktop Client*. 

Рассмотрим пример использования компонента.

* Объявляем компонент в XML-дескрипторе экрана:
+
[source, xml]
----
include::{sourcesdir}/gui_vcl/upload_1.xml[]
----

* В контроллере экрана инжектируем сам компонент, а также интерфейсы <<file_upload,FileUploadingAPI>> и <<dataSupplier,DataSupplier>>. Затем в методе `init()` добавляем  слушатели, которые будут реагировать на события успешной загрузки или ошибки:
+
[source, java]
----
include::{sourcesdir}/gui_vcl/upload_2.java[]
----
+
Компонент загружает файл во временное хранилище клиентского <<app_tiers,уровня>> и вызывает листенер, добавленный методом `addFileUploadSucceedListener()`. В этом листенере у компонента запрашивается объект `FileDescriptor`, соответствующий загруженному файлу. Объект `com.haulmont.cuba.core.entity.FileDescriptor` (не путать с `java.io.FileDescriptor`) является персистентной сущностью, которая однозначно идентифицирует загруженный файл и впоследствии используется для выгрузки файла из системы.
+
Метод `FileUploadingAPI.putFileIntoStorage()` используется для перемещения загружаемого файла из временного хранилища клиентского уровня в <<file_storage,FileStorage>>. Параметрами этого метода являются идентификатор файла во временном хранилище и объект `FileDescriptor`. Оба эти параметра предоставляет `FileUploadField`.
+
После загрузки файла в `FileStorage` выполняется сохранение экземпляра `FileDescriptor` в базе данных посредством вызова `DataSupplier.commit()`. Возвращаемый этим методом сохраненный экземпляр может быть установлен в атрибут какой-либо сущности предметной области, связанной с данным файлом. В данном же случае `FileDescriptor` просто сохраняется в базе данных. Соответствующий файл будет доступен через экран *Administration* → *External Files*.
+
Листенер, добавленный методом `addFileUploadErrorListener()` вызывается в случае ошибки загрузки файла во временное хранилище клиентского уровня.

* Максимальный размер загружаемого файла определяется свойством приложения <<cuba.client.maxUploadSizeMb,cuba.client.maxUploadSizeMb>> и по умолчанию равен 20MB. При выборе пользователем файла большего размера выдается соответствующее сообщение и загрузка прерывается.

В разделе <<images_recipe>> приведен более сложный пример работы с загруженными файлами.

'''

Атрибуты upload::
<<gui_attr_align,align>> -
<<gui_attr_enable,enable>> -
<<gui_attr_caption,caption>> -
<<gui_attr_description,description>> -
<<gui_attr_height,height>> -
<<gui_attr_id,id>> -
<<gui_attr_stylename,stylename>> -
<<gui_attr_visible,visible>> -
<<gui_attr_width,width>>

'''

[[gui_Filter]]
====== Filter

Компонент `Filter` − универсальное средство фильтрации списков сущностей, извлекаемых из базы данных для отображения в табличном виде. Компонент позволяет производить быструю фильтрацию данных по произвольному набору условий, а также создавать фильтры для многократного использования.

`Filter` должен быть связан с <<datasources,источником данных>> `collectionDatasource` содержащим <<datasource_query,запрос>> на JPQL. Принцип действия фильтра основан на модификации этого запроса в соответствии с критериями, заданными пользователем. Таким образом фильтрация осуществляется на уровне БД при выполнении транслированного из JPQL в SQL запроса, и на Middleware и клиентский <<app_tiers,уровень>> загружаются только отобранные данные.

[[gui_Filter_use]]
*Использование фильтра*

Типичный фильтр выглядит следующим образом:

image::gui_filter_descr.png[align="center"]

По умолчанию, компонент находится в режиме быстрой фильтрации. Это означает, что пользователь может добавить набор условий для однократного поиска данных. После закрытия экрана просмотра экземпляров сущности условия будут удалены.

Для того чтобы создать быстрый фильтр, нажмите на ссылку *Add search condition (Добавить условие поиска)*. Отобразится экран выбора условий:

image::gui_filter_conditions.png[align="center"]

Рассмотрим возможные типы условий:

* *Properties (Атрибуты)* – атрибуты данной сущности и связанных с ней сущностей. Отображаются персистентные атрибуты, явно заданные в элементе `property` XML-описателя фильтра, либо соответствующие правилам, указанным в элементе <<gui_Filter_properties,properties>>.

* *Custom conditions (Специальные условия)* – условия, заданные разработчиком в элементах `custom` XML-описателя фильтра.

* *Create new (Создать новое)* – позволяет создать новое произвольное условие на JPQL. Данный пункт доступен пользователю, если у него есть специфическое <<permissions,разрешение>> `cuba.gui.filter.customConditions`.

Выбранные условия отображаются в верхней части панель фильтра. Рядом с каждым условием находится кнопка image:gui_filter_remove_condition.png[], позволяющая удалить их из набора.

Быстрый фильтр можно сохранить для повторного использования в дальнейшем. Для этого нажмите на кнопку настроек фильтра и выберите *Save/Save as (Сохранить/Сохранить как)*. Во всплывающем окне задайте имя нового фильтра:

image::gui_filter_name.png[align="center"]

Фильтр будет сохранен в выпадающем меню кнопки *Search (Поиск)*.

Пункт меню *Reset filter (Сбросить фильтр)* позволяет сбросить все текущие условия поиска.

image::gui_filter_reset.png[align="center"]

Кнопка настроек фильтра содержит выпадающий список опций для управления фильтром:

* *Save (Сохранить)* – сохранить изменения в текущем фильтре.

* *Save as (Сохранить как)* – сохранить фильтр под новым именем.

* *Edit (Редактировать)* – открыть редактор фильтра (см. ниже).

* *Make default (Установить по умолчанию)* – установить фильтр по умолчанию для данного экрана. Фильтр будет автоматически выводиться на панель при каждом открытии экрана.

* *Remove (Удалить)* – удалить текущий фильтр. 

* *Pin applied (Закрепить)* – использовать результаты последнего поиска для последовательной фильтрации данных (см. <<gui_Filter_sequential_apply,Последовательное наложение фильтров>>).

* *Save as search folder (Сохранить как папку поиска)* – создать <<search_folder,папку поиска>> на основе текущего фильтра.

* *Save as application folder (Сохранить как папку приложения)* – создать <<search_folder,папку приложения>> на основе текущего фильтра. Эта опция доступна только пользователям со специфическим разрешением `cuba.gui.appFolder.global`.

Опция *Edit* открывает редактор фильтра, который дает возможность расширенной настройки текущего фильтра:

image::gui_filter_editor.png[align="center"]

Название фильтра указывается в поле *Filter name (Имя фильтра)*. Это имя будет отображаться в списке доступных фильтров для текущего экрана.

Фильтр можно сделать _global_ (то есть доступным для всех пользователей) с помощью установки флажка *Available for all users (Общий)* для всех пользователей, или установить текущий фильтр в качестве фильтра по умолчанию с помощью установки флажка *Default (По умолчанию)*.

В дереве содержатся условия фильтра. Условия можно добавлять с помощью кнопки *Add (Добавить)* менять местами при помощи кнопок image:gui_filter_cond_down.png[]/image:gui_filter_cond_up.png[] или удалять с помощью кнопки *Remove (Удалить)*.

Группировку условий по И или ИЛИ можно добавить с помощью соответствующих кнопок. Все добавленные на верхний уровень (то есть без явной группировки) условия объединяются по И.

При выборе условия в дереве в правой части редактора открывается список его свойств.

С помощью соответствующих флажков можно сделать выбранное в таблице условие скрытым или обязательным для заполнения. Параметр скрытого условия не отображается пользователю, поэтому он должны быть введен во время редактирования фильтра.

Свойство *Width* позволяет задать ширину поля ввода параметра для текущего условия. По умолчанию, условия на панели фильтров отображаются в три колонки. Ширина поля равняется количеству колонок, которое оно может занять (1, 2 или 3).

Значение параметра текущего условия по умолчанию можно задать в поле *Default value (Значение по умолчанию)*.

Специальный заголовок условия фильтрации можно задать в поле *Caption (Заголовок)*.

Поле *Operation* позволяет выбрать оператор поиска. Список доступных операторов зависит от типа атрибута.

[[gui_Filter_component]]
*Описание компонента Filter*

XML-имя компонента: `filter`.

image::gui_filter_dia.png[align="center"]

Компонент реализован для блоков *Web Client* и *Desktop Client*.

Пример объявления компонента в XML-дескрипторе экрана: 

[source, xml]
----
include::{sourcesdir}/gui_vcl/filter_1.xml[]
---- 

Здесь в элементе `dsContext` определен <<datasources,источник данных>> `collectionDatasource`, который выбирает экземпляры сущности `Car` с помощью JPQL запроса. Для компонента `filter` в его атрибуте `datasource` указан фильтруемый источник данных. Данные отображаются компонентом <<gui_Table,Table>>, связанным с этим же источником. 

Элемент `filter` может содержать вложенные элементы. Все они описывают условия, доступные пользователю для выбора в диалоге добавления условий:

[[gui_Filter_properties]]
* `properties` - позволяет сделать доступными сразу несколько атрибутов сущности. Данный элемент может иметь следующие атрибуты:
+
--
[[gui_Filter_properties_include]]
** `include` - обязательный атрибут, содержит регулярное выражение, которому должно соответствовать имя атрибута сущности.

[[gui_Filter_properties_exclude]]
** `exclude` - содержит регулярное выражение, при соответствии которому атрибут сущности исключается из ранее включенных с помощью `include`.
+
Например: 
+
[source, xml]
----
include::{sourcesdir}/gui_vcl/filter_2.xml[]
---- 
+
При использовании элемента `properties` автоматически игнорируются следующие атрибуты сущности:

** Недоступные в связи с <<permissions,разрешениями>> подсистемы безопасности.

** Коллекции (`@OneToMany`, `@ManyToMany`).

** Неперсистентные атрибуты.

** Атрибуты, не имеющие <<entity_localization,локализованного названия>>.

** Атрибуты, аннотированные `@SystemLevel`.

** Атрибуты типа `byte[]`.

** Атрибут `version`.
--

[[gui_Filter_property]]
* `property` - явно включает атрибут сущности по имени. Данный элемент может иметь следующие атрибуты:
+
--
[[gui_Filter_property_name]]
** `name` - обязательный атрибут, содержит имя включаемого атрибута сущности. Может быть путем (через ".") по графу сущностей. Например: 
+
[source, xml]
----
include::{sourcesdir}/gui_vcl/filter_3.xml[]
---- 

[[gui_Filter_property_caption]]
** `caption` - локализованное название атрибута сущности для отображения условия фильтра. Как правило, представляет из себя строку с префиксом `msg://` по правилам <<messageTools.loadString,MessageTools.loadString>>().
+
Если в атрибуте `name` указан путь (через ".") по графу сущностей, то атрибут `caption` является обязательным.

[[gui_Filter_property_paramWhere]]
** `paramWhere` − задает выражение на JPQL для отбора списка значений параметра условия, если параметр является связанной сущностью. Вместо алиаса сущности параметра в выражении нужно использовать метку (placeholder) `{E}`.
+
Например, предположим, что сущность `Car` имеет ссылку на сущность `Model`. Тогда список возможных значений параметра может быть ограничен только моделями `*Audi*`: 
+
[source, xml]
----
include::{sourcesdir}/gui_vcl/filter_4.xml[]
---- 
+
В выражении JPQL можно использовать параметры экрана, атрибуты сессии, а также компоненты экрана, в том числе отображающие другие параметры. Правила задания параметров запроса описаны в <<datasource_query,>>. 
+
Пример использования параметра сессии и параметра экрана: 
+
[source, jpql]
----
{E}.createdBy = :session$userLogin and {E}.name like :param$groupName
---- 
+
Используя `paramWhere` можно вводить зависимости между параметрами. Например, предположим, что `Manufacturer` является отдельной сущностью. То есть `Car` ссылается на `Model`, которая в свою очередь ссылается на `Manufacturer`. Тогда для фильтра по `Car` можно создать два условия: первое для выбора `Manufacturer` и второе для выбора `Model`. Чтобы ограничить список моделей выбранным перед этим производителем, добавьте в выражение `paramWhere` параметр: 
+
[source, jpql]
----
{E}.manufacturer.id = :component$filter.model_manufacturer90062
---- 
+
Здесь параметр ссылается на компонент, отображающий параметр Manufacturer. Имя компонента, отображающего параметр условия, можно узнать, вызвав контекстное меню на строке таблицы условий в редакторе фильтра:
+
[[gui_Filter_parameter_component_name]]
image::gui_filter_component_name.png[align="center"]

[[gui_Filter_property_paramView]]
** `paramView` − задает <<views,представление>>, с которым будет загружаться список значений параметра условия, если параметр является связанной сущностью. Например, `++_local++`. Если не указано, используется `++_minimal++`.
--

[[gui_Filter_custom]]
* `custom` - элемент, определяющий произвольное условие. Содержимым элемента должно быть выражение на JPQL (возможно использование <<jpql_macro,JPQL Macros>>), которое будет добавлено в условие `where` запроса источника данных. Вместо алиаса отбираемой сущности в выражении нужно использовать метку (placeholder) `{E}`. Параметр условия может быть только один, и если он есть, обозначается символом `?`.
+
--
Пример фильтра с произвольными условиями:

[source, xml]
----
include::{sourcesdir}/gui_vcl/filter_5.xml[]
---- 

Созданные `custom` условия отображаются в секции *Специальные условия* диалога добавления условий:

image::gui_filter_custom.png[align="center"]

Атрибуты элемента `custom`:

[[gui_Filter_custom_name]]
** `name` − обязательный атрибут - имя условия.

[[gui_Filter_custom_caption]]
** `caption` − обязательный атрибут - локализованное название условия. Как правило, представляет из себя строку с префиксом `msg://` по правилам <<messageTools.loadString,MessageTools.loadString>>().

[[gui_Filter_custom_paramClass]]
** `paramClass` − Java-класс параметра условия. Если параметр отсутствует, то данный атрибут не обязателен.

[[gui_Filter_custom_inExpr]]
** `inExpr` − должен быть установлен в `true`, если выражение JPQL содержит условие `in (?)`. При этом пользователь будет иметь возможность ввести несколько значений параметра данного условия.

[[gui_Filter_custom_join]]
** `join` − необязательный атрибут для задания строки, которая будет добавлена в секцию `from` запроса источника данных. Это может потребоваться для создания условия по атрибуту связанной коллекции. Значение данного атрибута должно включать в себя предложения `join` или `left join`. 
+
Например, предположим что сущность `Car` имеет атрибут `repairs`, который представляет собой коллекцию экземпляров связанной сущности `Repair`. Тогда для фильтрации `Car` по атрибуту `description` сущности `Repair` можно написать следующее условие: 
+
[source, xml]
----
include::{sourcesdir}/gui_vcl/filter_6.xml[]
---- 
+
При использовании такого условия исходный запрос источника данных: 
+
[source, jpql]
----
select c from sample$Car c order by c.createTs
----
+
будет трансформирован в следующий:
+
[source, jpql]
----
select c from sample$Car c join c.repairs cr
where (cr.description like ?)
order by c.createTs
----

** `paramWhere` − задает выражение на JPQL для отбора списка значений параметра условия, если параметр является связанной сущностью. См. описание одноименного <<gui_Filter_property_paramWhere,атрибута>> элемента `property`.

** `paramView` − задает <<views,представление>>, с которым будет загружаться список значений параметра условия, если параметр является связанной сущностью. См. описание одноименного <<gui_Filter_property_paramView,атрибута>> элемента `property`.
--

Атрибуты `filter`:

[[gui_Filter_editable]]
* `editable` - если значение этого атрибута равно `false`, то кнопка *Фильтр* скрывается.

[[gui_Filter_manualApplyRequired]]
* `manualApplyRequired` − определяет, в какой момент будет применяться фильтр. Если значение атрибута равно `false`, то фильтр (пустой или по умолчанию) будет применяться сразу при открытии экрана. Это означает, что источник данных будет обновлен и связанные компоненты (например, `Table`) отобразят данные. Если значение атрибута равно `true`, то фильтр будет применяться только после нажатия на кнопку *Search*.
+
Данный атрибут имеет приоритет над свойством приложения <<cuba.gui.genericFilterManualApplyRequired,cuba.gui.genericFilterManualApplyRequired>>.

[[gui_Filter_useMaxResults]]
* `useMaxResults` − ограничивает размер страницы загружаемых в источник данных экземпляров сущности. По умолчанию `true`.
+
Если значение этого атрибута равно `false`, то фильтр не будет отображать поле *Show rows*. Количество записей в источнике данных (и соответственно, показываемых таблицей) будет ограничено только параметром `MaxFetchUI` механизма <<entity_statistics,статистики сущностей>>, по умолчанию - 10000.
+
Если данный атрибут не указан, или равен `true`, то поле *Show rows* отображается, если у пользователя также есть специфическое разрешение <<permissions,cuba.gui.filter.maxResults>>. Если разрешение `cuba.gui.filter.maxResults` отсутствует, то фильтр будет принудительно отбирать только первые N строк без возможности пользователя отключить это или указать другое N. Число N определяется параметрами `FetchUI`, `DefaultFetchUI`, получаемыми из механизма <<entity_statistics,статистики сущностей>>.
+
На рисунке далее показан вид фильтра со значением атрибута `useMaxResults="true"`, запретом специфического разрешения `cuba.gui.filter.maxResults` и параметром `DefaultFetchUI=2`
+
image::gui_filter_useMaxRezult.png[align="center"]

[[gui_Filter_textMaxResults]]
* `textMaxResults` - позволяет использовать текстовое поле вместо выпадающего списка в качестве поля *Show rows*. По умолчанию `false`.

[[gui_Filter_folderActionsEnabled]]
* `folderActionsEnabled` − при указании значения `false` позволяет скрыть следующие действия с фильтром: *Сохранить как папку поиска*, *Сохранить как папку приложения*. По умолчанию значение атрибута равно `true`, действия *Сохранить как папку поиска*, *Сохранить как папку приложения* доступны.

[[gui_Filter_applyTo]]
* `applyTo` − необязательный атрибут, содержит идентификатор компонента, с которым связан фильтр. Используется в случае, когда необходимо иметь доступ к <<gui_Table_presentations,представлениям>> связанного компонента-таблицы. Например, сохраняя фильтр как <<search_folder,папку поиска>> или как <<application_folder,папку приложения>>, можно указать, какое представление будет применятся при просмотре этой папки.
+
image::gui_filter_apply_to.png[align="center"]

[[gui_Filter_caption]]
* `caption` - позволяет задать заголовок панели фильтров.

[[gui_Filter_columnsQty]]
* `columnsQty` - задает количество колонок с условиями для конкретного фильтра. Значение по умолчанию - 3.

[[gui_Filter_defaultMode]]
* `defaultMode` - задает режим фильтра при открытии экрана. Возможные значения: `generic` и `fts`. При указании значения `fts` фильтр будет открыт в режиме полнотекстового поиска (если сущность индексируется). Значение по умолчанию - `generic`.

[[gui_Filter_modeSwitchVisible]]
* `modeSwitchVisible` - определяет видимость чек-бокса для перевода фильтра в режим полнотекстового поиска. Если полнотекстовый поиск невозможен, то чек-бокс будет невидим независимо от указаного значения. Возможные значения атрибута: `true` и `false`.

'''

Атрибуты filter::
<<gui_Filter_applyTo,applyTo>> -
<<gui_Filter_caption,caption>> -
<<gui_Filter_columnsQty,columnsQty>> -
<<gui_attr_datasource,datasource>> -
<<gui_Filter_defaultMode,defaultMode>> -
<<gui_Filter_editable,editable>> -
<<gui_attr_enable,enable>> -
<<gui_Filter_folderActionsEnabled,folderActionsEnabled>> -
<<gui_attr_id,id>> -
<<gui_Filter_manualApplyRequired,manualApplyRequired>> -
<<gui_attr_margin,margin>> -
<<gui_Filter_modeSwitchVisible,modeSwitchVisible>>
<<gui_attr_stylename,stylename>> -
<<gui_Filter_textMaxResults,textMaxResults>> -
<<gui_Filter_useMaxResults,useMaxResults>> -
<<gui_attr_visible,visible>> -
<<gui_attr_width,width>>

Элементы filter::
<<gui_Filter_custom,custom>> -
<<gui_Filter_properties,properties>> -
<<gui_Filter_property,property>>

Атрибуты properties::
<<gui_Filter_properties_exclude,exclude>> -
<<gui_Filter_properties_include,include>>

Атрибуты property::
<<gui_Filter_property_caption,caption>> -
<<gui_Filter_property_name,name>> -
<<gui_Filter_property_paramView,paramView>> -
<<gui_Filter_property_paramWhere,paramWhere>>

Атрибуты custom::
<<gui_Filter_custom_caption,caption>> -
<<gui_Filter_custom_name,name>> -
<<gui_Filter_custom_inExpr,inExpr>> -
<<gui_Filter_custom_join,join>> -
<<gui_Filter_custom_paramClass,paramClass>> -
<<gui_Filter_property_paramView,paramView>> -
<<gui_Filter_property_paramWhere,paramWhere>>

'''

[[gui_Filter_permissions]]
*Права пользователей*

* Для создания/изменения/удаления глобальных (доступных всем пользователям) фильтров пользователь должен иметь разрешение `cuba.gui.filter.global`.

* Для создания/изменения `custom` условий пользователь должен иметь разрешение `cuba.gui.filter.customConditions`.

* Чтобы иметь возможность изменять максимальное количество строк на странице таблицы с помощью флажка и поля *Show rows* пользователь должен иметь разрешение `cuba.gui.filter.maxResults`. См. также атрибут фильтра <<gui_Filter_useMaxResults,useMaxResults>>.

Информация о том, как настраивать специфические разрешения, приведена в руководстве Подсистема безопасности.

[[gui_Filter_ext_params]]
*Внешние параметры для управления фильтрами*

[[gui_Filter_app_properties]]
* *Общесистемные параметры*
+
--
Следующие свойства приложения влияют на поведение фильтров:

* <<cuba.gui.genericFilterManualApplyRequired,cuba.gui.genericFilterManualApplyRequired>> − позволяет отключить автоматическое применение фильтра (то есть загрузку данных) сразу при открытии экрана. См. также атрибут фильтра <<gui_Filter_manualApplyRequired,manualApplyRequired>>.

* <<cuba.gui.genericFilterChecking,cuba.gui.genericFilterChecking>> − позволяет включить проверку заполненности хотя-бы одного условия перед применением фильтра.

* <<cuba.gui.genericFilterControlsLayout,cuba.gui.genericFilterControlsLayout>> − определяет расположение элементов внутри фильтра.

* <<cuba.allowQueryFromSelected,cuba.allowQueryFromSelected>> позволяет отключить механизм <<sequential_filter_para,последовательного наложения фильтров>>.

* <<cuba.cuba.gui.genericFilterColumnsQty,cuba.gui.genericFilterColumnsQty>> - задает количество колонок по умолчанию для размещения условий фильтра. См также атрибут фильтра <<gui_Filter_columnsQty,columnsQty>>.

* <<cuba.gui.genericFilterConditionsLocation,cuba.gui.genericFilterConditionsLocation>> - задает расположение панели условий.

* <<cuba.gui.genericFilterPopupListSize,cuba.gui.genericFilterPopupListSize>> - задает количество позиций в выпадающем списке кнопки *Search*.
--

[[gui_Filter_screen_parameters]]
* *Параметры вызова экрана*
+
--
При вызове экрана можно указать, какой фильтр и с какими параметрами должен быть применен сразу после открытия экрана. Для этого фильтр должен быть заранее создан, сохранен в базе данных, и соответствующая запись в таблице `SEC_FILTER` должна иметь заполненное поле `CODE`.

Для указания кода фильтра в экран следует передать параметр с именем, равным идентификатору компонента фильтра в данном экране. Значением параметра должен быть код фильтра, который нужно установить и применить.

Для установки значений параметров фильтра в экран нужно передать параметры с именами, равными именам параметров, и значения в виде строк.

Пример описателя пункта главного меню, устанавливающего в открываемом экране `sample$Car.browse` в компоненте `carsFilter` фильтр с кодом `FilterByVIN`, с подстановкой в параметр условия `component$carsFilter.vin79216` значения `TMA`:

[source, xml]
----
include::{sourcesdir}/gui_vcl/filter_ext_param_1.xml[]
----

Следует отметить, что фильтр с установленным полем `CODE` обладает особыми свойствами:

* Его не могут редактировать пользователи.

* Название такого фильтра можно отображать на нескольких языках. Для этого в <<main_message_pack,главном пакете сообщений>> приложения должна быть строка с ключом, равным коду фильтра.
--

[[gui_Filter_sequential_apply]]
*Последовательное наложение фильтров*

При включенном свойстве приложения <<cuba.allowQueryFromSelected,cuba.allowQueryFromSelected>> в пользовательском интерфейсе компонента можно закреплять последний примененный фильтр и текущие результаты фильтрации. После этого можно выбрать другой фильтр или параметры и применить их на уже выбранных записях.

Данный подход позволяет решить две проблемы:

* Декомпозировать сложные фильтры.

* Применять фильтры на записи, отобранные с помощью папок <<application_folder,приложения>> или <<search_folder,поиска>>.

Чтобы применить этот механизм в пользовательском интерфейсе, выберите и примените один из фильтров. Затем нажмите на кнопку настроек фильтра и выберите *Pin applied (Закрепить)*. Фильтр закрепится в верхней части панели фильтров. Далее можно применить к выбранным записям другой фильтр. Так последовательно можно накладывать друг на друга любое количество фильтров. Также фильтры можно удалять последовательно с помощью кнопки image:gui_filter_remove.png[].

image::gui_filter_sequential.png[align="center"]

Механизм последовательного наложения фильтров основан на возможности <<dataManager,DataManager>> выполнять <<query_from_selected,последовательные запросы>>.

[[gui_Filter_params_api]]
*API для работы с параметрами фильтра*

Интерфейс `Filter` предоставляет методы для установки и чтения значений параметра фильтра из кода контроллера экрана:

* `setParamValue(String paramName, Object value)`
* `getParamValue(String paramName)`

`paramName` - имя параметра фильтра. Имя параметра фильтра является составной частью имени компонента, отображающего значение параметра фильтра. Как получить имя компонента рассматривалось <<gui_Filter_parameter_component_name, выше>>. Имя параметра - это часть имени компонента, находящаяся после последней точки. Например, если имя компонента `component$filter.model_manufacturer90062`, то имя параметра фильтра `model_manufacturer90062`.

Обратите внимание, что в методе <<abstractFrame,init()>> контроллера экрана данные методы использовать нельзя, т.к. в этот момент фильтр еще не проинициализирован. Вы можете работать с параметрами фильтра в методе <<abstractWindow,ready()>>.

[[gui_Filter_fts]]
*Режим полнотекстового поиска в фильтре*

Если источник данных фильтра содержит сущности, индексируемые системой полнотекстового поиска (см. link:{fts_man_url}[Платформа CUBA. Полнотекстовый поиск]), то в фильтре становится доступным режим полнотекстового поиска. Чтобы переключиться в него, используйте флажок *Full-Text Search* ("Полнотекстовый поиск").

image::gui_filter_fts.png[align="center"]

В этом режиме фильтр имеет всего одно поле для задание критериев поиска, и поиск производится по индексируемым подсистемой FTS полям сущности.

Если таблица указана в атрибуте <<gui_Filter_applyTo,applyTo>>, то при наведении указателя мыши на строку таблицы во всплывающем окне будет написано, в каких полях сущности было найдено условие поиска.

Для скрытия переключателя режима фильтра установите значение `false` атрибуту фильтра <<gui_Filter_modeSwitchVisible,modeSwitchVisible>>.

Если необходимо, чтобы фильтр по умолчанию открывался в режиме полнотекстового поиска, установите значение `fts` атрибуту <<gui_Filter_defaultMode,defaultMode>>.

[[gui_GroupTable]]
====== GroupTable

Компонент `GroupTable` - это таблица с возможностью динамической группировки по любому полю. Для того чтобы сгруппировать таблицу по какой-либо колонке, нужно в заголовке таблицы перетащить эту колонку в позицию слева от элемента image:gui_groupTableIcon.png[]. Сгруппированные значения можно разворачивать и сворачивать с помощью кнопок image:gui_groupBox_plus.png[]/image:gui_groupBox_minus.png[].

image::gui_groupTableDragColumn.png[align="center"]

XML-имя компонента: `groupTable`.

image::gui_GroupTable_dia.png[align="center"]

Компонент реализован только для блока *Web Client*. В *Desktop Client* ведет себя как обычная таблица.

Для `GroupTable` в атрибуте `datasource` элемента `rows` должен быть указан <<datasources,groupDatasource>>. В противном случае группировка работать не будет.

Пример использования:

[source, xml]
----
include::{sourcesdir}/gui_vcl/grouptable_1.xml[]
----

[[gui_GroupTable_group]]
`group` − необязательный элемент, может в единственном экземпляре находиться внутри <<gui_Table_columns,columns>>. Содержит набор элементов `column`, по которым будет выполняться первоначальная группировка при открытии экрана.

[[gui_GroupTable_groupAllowed]]
Элемент `column` может содержать атрибут `groupAllowed` с булевским значением. С помощью этого атрибута можно запретить пользователю группировать таблицу по данной колонке.

[[gui_GroupTable_showTotalAggregation]]
При включенном атрибуте `aggregatable` таблица отображает результаты агрегации по всем строкам в дополнительной строке вверху, а также результаты агрегации по группам. Отображение агрегации по всем строкам можно отключить, установив `false` в атрибуте `showTotalAggregation`.

В остальном функциональность `GroupTable` аналогична простой таблице <<gui_Table,Table>>.

'''

Атрибуты groupTable::
<<gui_attr_align,align>> -
<<gui_Table_aggregatable,aggregatable>> -
<<gui_Table_aggregationStyle,aggregationStyle>> -
<<gui_Table_columnControlVisible,columnControlVisible>> -
<<gui_Table_allowPopupMenu,contextMenuEnabled>> -
<<gui_Table_editable,editable>> -
<<gui_attr_enable,enable>> -
<<gui_attr_height,height>> -
<<gui_attr_id,id>> -
<<gui_Table_multiLineCells,multiLineCells>> -
<<gui_Table_multiselect,multiselect>> -
<<gui_Table_presentations,presentations>> -
<<gui_Table_reorderingAllowed,reorderingAllowed>> -
<<gui_GroupTable_showTotalAggregation,showTotalAggregation>> -
<<gui_Table_sortable,sortable>> -
<<gui_attr_stylename,stylename>> -
<<gui_attr_visible,visible>> -
<<gui_attr_width,width>>

Элементы groupTable::
<<gui_Table_actions,actions>> -
<<gui_Table_buttonsPanel,buttonsPanel>> -
<<gui_Table_columns,columns>> -
<<gui_Table_rows,rows>> -
<<gui_Table_rowsCount,rowsCount>>

Элементы columns::
<<gui_Table_columns,column>> -
<<gui_GroupTable_group,group>>

Атрибуты <<gui_Table_columns,column>>::
<<gui_Table_column_align,align>> -
<<gui_Table_column_caption,caption>> -
<<gui_attr_captionProperty,captionProperty>> -
<<gui_Table_column_collapsed,collapsed>> -
<<gui_DateField_dateFormat,dateFormat>> -
<<gui_Table_column_editable,editable>> -
<<gui_GroupTable_groupAllowed,groupAllowed>> -
<<gui_Table_column_id,id>> -
<<gui_Table_column_link,link>> -
<<gui_Table_column_linkInvoke,linkInvoke>> -
<<gui_Table_column_linkScreen,linkScreen>> -
<<gui_Table_column_linkScreenOpenType,linkScreenOpenType>> -
<<gui_Table_column_maxTextLength,maxTextLength>> -
<<gui_attr_optionsDatasource,optionsDatasource>> -
<<gui_DateField_resolution,resolution>> -
<<gui_Table_column_sortable,sortable>> -
<<gui_attr_visible,visible>> -
<<gui_Table_column_width,width>>

Элементы <<gui_Table_columns,column>>::
<<gui_Table_column_aggregation,aggregation>> -
<<gui_formatter,formatter>>

Атрибуты <<gui_Table_rows,rows>>::
<<gui_attr_datasource,datasource>>

'''

[[gui_Label]]
====== Label

Надпись (`Label`) − текстовый компонент, отображающий статический текст либо значение атрибута сущности.

XML-имя компонента: `label`

image::gui_label_dia.png[align="center"]

Компонент `Label` реализован для блоков *Web Client* и *Desktop Client*.

Пример задания надписи с текстом, взятым из <<message_packs,пакета локализованных сообщений>>:

[source, xml]
----
include::{sourcesdir}/gui_vcl/label_1.xml[]
----

[[gui_Label_value]]
Атрибут `value` предназначен для задания текста надписи.

В веб клиенте текст, содержащийся в атрибуте `value`, будет разбит на несколько строк, если по длине он превысит значение атрибута <<gui_attr_width,width>>. Поэтому для отображения многострочной надписи, достаточно указать абсолютное значение атрибута <<gui_attr_width,width>>. Если текст надписи слишком длинный, а значение атрибута <<gui_attr_width,width>> не определено, то текст будет урезан.

[source, xml]
----
include::{sourcesdir}/gui_vcl/label_2.xml[]
----

Параметры надписи можно задать в контроллере экрана. Для этого необходимо задать компоненту идентификатор, по которому получить ссылку на него в контроллере:

[source, xml]
----
include::{sourcesdir}/gui_vcl/label_3.xml[]
----

[source, java]
----
include::{sourcesdir}/gui_vcl/label_4.java[]
----

Компонент `Label` может отображать значение атрибута сущности. Для этого используются атрибуты <<gui_attr_datasource,datasource>> и <<gui_attr_property,property>>. Например:

[source, xml]
----
include::{sourcesdir}/gui_vcl/label_5.xml[]
----

В данном случае компонент отображает атрибут `name` сущности `Customer`, находящейся в источнике данных `customerDs`.

[[gui_Label_htmlEnabled]]
Атрибут `htmlEnabled` указывает, каким образом будет рассматриваться значение атрибута <<gui_Label_value,value>>: при `htmlEnabled="true"` как HTML-код, иначе как строка. Обратите внимание, что не все HTML-теги поддерживаются в десктоп-реализации экрана.

'''

Атрибуты label::
<<gui_attr_align,align>> -
<<gui_attr_datasource,datasource>> -
<<gui_attr_enable,enable>> -
<<gui_attr_height,height>> -
<<gui_Label_htmlEnabled,htmlEnabled>> -
<<gui_attr_id,id>> -
<<gui_attr_property,property>> -
<<gui_attr_stylename,stylename>> -
<<gui_Label_value,value>> -
<<gui_attr_visible,visible>> -
<<gui_attr_width,width>>

Элементы label::
<<gui_formatter,formatter>>

'''

[[gui_Link]]
====== Link

Ссылка (`Link`) − компонент-гиперссылка, позволяющая открывать внешние веб-ресурсы единообразно для веб и десктоп клиента.

XML-имя компонента: `link`

image::gui_link_dia.png[align="center"]

Пример XML-описания компонента `link`: 

[source, xml]
----
<link caption="Link" url="https://www.cuba-platform.com" target="_blank"/>
----

Атрибуты `link`: 

[[gui_Link_url]]
* `url` - адрес ресурса.

[[gui_Link_target]]
* `target` - для веб клиента задает способ открытия страницы, аналогичен атрибуту `target` HTML-тега `<a>`.

'''

Атрибуты link::
<<gui_attr_align,align>> -
<<gui_attr_caption,caption>> -
<<gui_attr_description,description>> -
<<gui_attr_enable,enable>> -
<<gui_attr_id,id>> -
<<gui_attr_icon,icon>> -
<<gui_attr_stylename,stylename>> -
<<gui_Link_url,url>> -
<<gui_Link_target,target>> -
<<gui_attr_visible,visible>> -
<<gui_attr_width,width>>

'''

[[gui_LinkButton]]
====== LinkButton

Кнопка-ссылка (`LinkButton`) − кнопка, выглядящая как гиперссылка.

XML-имя компонента: `linkButton`

image::gui_linkButton_dia.png[align="center"]

Компонент кнопки-ссылки реализован для блоков *Web Client* и *Desktop Client*.

Кнопка-ссылка может содержать текст или пиктограмму (или и то и другое). На рисунке ниже отражены разные виды кнопок.

image::gui_linkButtonTypes.png[align="center"]

Кнопка-ссылка отличается от обычной кнопки `Button` только своим внешним видом. Все свойства и поведение идентичны описанным для <<gui_Button,Button>>.

Пример XML-описания кнопки-ссылки, вызывающей метод `someMethod()` контроллера, с надписью (атрибут <<gui_attr_caption,caption>>), всплывающей подсказкой (атрибут <<gui_attr_description,description>>) и пиктограммой (атрибут <<gui_attr_icon,icon>>):

[source, xml]
----
include::{sourcesdir}/gui_vcl/linkbutton_1.xml[]
----

'''

Атрибуты linkButton::
<<gui_Button_action,action>> -
<<gui_attr_align,align>> -
<<gui_attr_caption,caption>> -
<<gui_attr_description,description>> -
<<gui_attr_enable,enable>> -
<<gui_attr_icon,icon>> -
<<gui_attr_id,id>> -
<<gui_Button_invoke,invoke>> -
<<gui_attr_stylename,stylename>> -
<<gui_attr_visible,visible>> -
<<gui_attr_width,width>>

'''

[[gui_LookupField]]
====== LookupField

Компонент для выбора значения из выпадающего списка. Выпадающий список реализует фильтрацию значений по мере ввода пользователя и постраничный вывод доступных значений.

image::gui_lookupField.png[align="center"]

XML-имя компонента: `lookupField`.

image::gui_LookupField_dia.png[align="center"]

Компонент LookupField реализован для блоков *Web Client* и *Desktop Client*.

* Простейший вариант использования `LookupField` - выбор значения перечисления (`enum`) для атрибута сущности. Например, сущность `Role` имеет атрибут `type` типа `RoleType`, который является перечислением. Тогда для редактирования этого атрибута можно использовать `LookupField` следующим образом:
+
[source, xml]
----
include::{sourcesdir}/gui_vcl/lookupfield_1.xml[]
----
+
Как видно из примера, в экране описывается <<datasources,источник данных>> `roleDs` для сущности `Role`. В компоненте `lookupField` в атрибуте <<gui_attr_datasource,datasource>> указывается ссылка на источник данных, а в атрибуте <<gui_attr_property,property>> − название атрибута сущности, значение которого должно быть отображено. В данном случае атрибут является перечислением, и в выпадающем списке будут отображены <<enum_localization,локализованные названия>> всех значений этого перечисления.

* Аналогично можно использовать `LookupField` для выбора экземпляра связанной сущности. Для формирования списка опций используется атрибут <<gui_attr_optionsDatasource,optionsDatasource>>:
+
[source, xml]
----
include::{sourcesdir}/gui_vcl/lookupfield_2.xml[]
----
+
В данном случае компонент отобразит отобразит <<namePattern,имена экземпляров>> сущности `Colour`, находящихся в источнике данных `colorsDs`, а выбранное значение подставится в атрибут `colour` сущности `Car`, находящейся в источнике данных `carDs`.
+
С помощью атрибута <<gui_attr_captionProperty,captionProperty>> можно указать, какой атрибут сущности использовать вместо имени экземпляра для строковых названий опций.

* Список опций компонента может быть задан произвольно с помощью методов `setOptionsList()` и `setOptionsMap()`, либо с помощью XML-атрибута `optionsDatasource`.

** Метод `setOptionsList()` позволяет программно задать список опций компонента. Для этого объявляем компонент в XML-дескрипторе:
+
[source, xml]
----
include::{sourcesdir}/gui_vcl/lookupfield_3.xml[]
----
+
Затем инжектируем компонент в контроллер и в методе `init()` задаем ему список опций:
+
[source, java]
----
include::{sourcesdir}/gui_vcl/lookupfield_4.java[]
----
+
В выпадающем списке компонента отобразятся числа 2, 4, 5, 7. Выбранное число подставится в атрибут `numberOfSeats` сущности, находящейся в источнике данных `modelDs`.

** Метод `setOptionsMap()` позволяет задать строковые названия и значения опций по отдельности. Например, для описанного в XML-дескрипторе компонента `numberOfSeatsField` в методе `init()` контроллера задаем мэп опций:
+
[source, java]
----
include::{sourcesdir}/gui_vcl/lookupfield_5.java[]
----
+
В выпадающем списке компонента отобразятся строки `*two*`, `*four*`, `*five*`, `*seven*`. Однако значением компонента будет число, соответствующее выбранной строке. Оно и подставится в атрибут `numberOfSeats` сущности, находящейся в источнике данных `modelDs`.

[[gui_LookupField_filterMode]]
* С помощью атрибута `filterMode` можно задать тип фильтрации опций при вводе пользователя:

** `NO` − нет фильтрации.

** `STARTS_WITH` − по началу фразы.

** `CONTAINS` − по любому вхождению (используется по умолчанию).

* Если у компонента `LookupField` не установлен атрибут <<gui_attr_required,required>>, и если связанный атрибут сущности не объявлен как обязательный, то в списке опций компонента присутствует пустая строка, при выборе которой компонент возвращает значение `null`. Атрибут <<gui_attr_nullName,nullName>> позволяет задать строку, отображаемую в этом случае вместо пустой. Пример использования:
+
[source, xml]
----
include::{sourcesdir}/gui_vcl/lookupfield_6.xml[]
----
+
В данном случае вместо пустой строки отобразится строка `(none)`, при выборе которой в связанный атрибут сущности подставится значение `null`.
+
При программном задании списка опций методом `setOptionsList()` можно одну из опций передать в метод `setNullOption()`. Тогда при ее выборе пользователем значением компонента будет `null`.

* Компонент `LookupField` способен обрабатывать ввод пользователя при отсутствии подходящей опции в списке. Для этого используются методы `setNewOptionAllowed()` и `setNewOptionHandler()`. Например:
+
[source, java]
----
include::{sourcesdir}/gui_vcl/lookupfield_7.java[]
----
+
Обработчик `NewOptionHandler` вызывается, если пользователь ввел некоторое значение, не совпадающее ни с одной из опций, и нажал *Enter*. В данном случае в обработчике создается новый экземпляр сущности `Colour`, его атрибут `name` устанавливается в значение, введенное пользователем, этот экземпляр добавляется в источник данных опций и выбирается в компоненте.
+
[[gui_LookupField_newOptionHandler]]
Вместо имплементации интерфейса `LookupField.NewOptionHandler` для обработки ввода пользователя можно использовать XML-атрибут `newOptionHandler` с указанным в нем методом контроллера. Данный метод должен иметь два параметра - первый типа `LookupField`, второй типа `String`. В них будут переданы соответственно экзампляр компонента и введенное пользователем значение. Атрибут `newOptionAllowed` используется вместо метода `setNewOptionAllowed()` для того, чтобы разрешить добавление новых опций.

'''

Атрибуты lookupField::
<<gui_attr_align,align>> -
<<gui_attr_caption,caption>> -
<<gui_attr_captionProperty,captionProperty>> -
<<gui_attr_datasource,datasource>> -
<<gui_attr_description,description>> -
<<gui_attr_editable,editable>> -
<<gui_attr_enable,enable>> -
<<gui_LookupField_filterMode,filterMode>> -
<<gui_attr_height,height>> -
<<gui_attr_id,id>> -
<<gui_attr_inputPrompt,inputPrompt>> -
<<gui_LookupField_newOptionHandler,newOptionAllowed>> -
<<gui_LookupField_newOptionHandler,newOptionHandler>> -
<<gui_attr_nullName,nullName>> -
<<gui_attr_optionsDatasource,optionsDatasource>> -
<<gui_attr_property,property>> -
<<gui_attr_required,required>> -
<<gui_attr_requiredMessage,requiredMessage>> -
<<gui_attr_stylename,stylename>> -
<<gui_attr_visible,visible>> -
<<gui_attr_width,width>>

Элементы lookupField::
<<gui_validator,validator>>

'''

[[gui_LookupPickerField]]
====== LookupPickerField

Компонент `LookupPickerField` позволяет отображать экземпляр сущности в текстовом поле, выбирать экземпляр в выпадающем списке и выполнять действия нажатием на кнопки справа.

image::gui_lookupPickerField.png[align="center"]

XML-имя компонента: `lookupPickerField`.

image::gui_LookupPickerField_dia.png[align="center"]

Компонент реализован для блоков *Web Client* и *Desktop Client*.

`LookupPickerField` является по сути гибридом <<gui_LookupField,LookupField>> и <<gui_PickerField,PickerField>>, поэтому все описанное для этих интерфейсов верно и для него. Исключением является список действий по умолчанию, добавляемых при определении компонента в XML: для `LookupPickerField` это действия `lookup` image:lookupBtn.png[] и `open` image:openBtn.png[].

Пример использования `LookupPickerField` для выбора значения ссылочного атрибута `colour` сущности `Car`:

[source, xml]
----
include::{sourcesdir}/gui_vcl/lookuppickerfield_1.xml[]
----

'''

Атрибуты lookupPickerField::
<<gui_attr_align,align>> -
<<gui_attr_caption,caption>> -
<<gui_attr_captionProperty,captionProperty>> -
<<gui_attr_datasource,datasource>> -
<<gui_attr_description,description>> -
<<gui_attr_editable,editable>> -
<<gui_attr_enable,enable>> -
<<gui_LookupField_filterMode,filterMode>> -
<<gui_attr_height,height>> -
<<gui_attr_id,id>> -
<<gui_attr_inputPrompt,inputPrompt>> -
<<gui_PickerField_metaclass,metaClass>> -
<<gui_LookupField_newOptionHandler,newOptionAllowed>> -
<<gui_LookupField_newOptionHandler,newOptionHandler>> -
<<gui_attr_nullName,nullName>> -
<<gui_attr_optionsDatasource,optionsDatasource>> -
<<gui_attr_property,property>> -
<<gui_attr_required,required>> -
<<gui_attr_requiredMessage,requiredMessage>> -
<<gui_attr_stylename,stylename>> -
<<gui_attr_visible,visible>> -
<<gui_attr_width,width>>

Элементы lookupPickerField::
<<gui_Action,actions>> -
<<gui_validator,validator>>

'''

[[gui_MaskedField]]
====== MaskedField

Текстовое поле, в которое данные вводятся в определенном формате. `MaskedField` удобно использовать, например, для ввода телефонных номеров. 

XML-имя компонента: `maskedField`.

image::gui_MaskedField_dia.png[align="center"]

Компонент `MaskedField` реализован только для блока *Web Client*.

`MaskedField` в основном повторяет функциональность <<gui_TextField,TextField>>, за исключением того, что ему нельзя установить `datatype`. То есть `MaskedField` предназначен для работы только с текстом и строковыми атрибутами сущностей. `MaskedField` имеет следующие специфические атрибуты:

[[gui_MaskedField_mask]]
* `mask` - задает маску для поля. Чтобы задать маску, используются следующие символы:

** `#` - цифра

** `U` - буква верхнего регистра

** `L` - буква нижнего регистра

** `?` - буква

** `А` - буква или цифра

** `*` - любой символ

** `H` - hex символ в верхнем регистре

** `h` - hex символ в нижнем регистре

** `~` - знак + или -

[[gui_MaskedField_valueMode]]
* `valueMode` - определяет формат возвращаемого значения (с маской, или без) и может принимать значение `masked` или `clear`.

Пример текстового поля с маской для ввода номеров телефонов: 

[source, xml]
----
include::{sourcesdir}/gui_vcl/maskedfield_1.xml[]
----

[source, java]
----
include::{sourcesdir}/gui_vcl/maskedfield_2.java[]
----

image::gui_MaskedField.png[align="center"]

image::gui_MaskedField_maskedValueMode.png[align="center"]

'''

Атрибуты maskedField::
<<gui_attr_align,align>> -
<<gui_attr_caption,caption>> -
<<gui_attr_datasource,datasource>> -
<<gui_attr_description,description>> -
<<gui_attr_editable,editable>> -
<<gui_attr_enable,enable>> -
<<gui_attr_height,height>> -
<<gui_attr_id,id>> -
<<gui_MaskedField_mask,mask>> -
<<gui_TextField_maxLength,maxLength>> -
<<gui_attr_property,property>> -
<<gui_attr_required,required>> -
<<gui_attr_requiredMessage,requiredMessage>> -
<<gui_attr_stylename,stylename>> -
<<gui_TextField_trim,trim>> -
<<gui_MaskedField_valueMode,valueMode>> -
<<gui_attr_visible,visible>> -
<<gui_attr_width,width>>

Элементы maskedField::
<<gui_validator,validator>>

'''

[[gui_OptionsGroup]]
====== OptionsGroup

Компонент, который обеспечивает выбор из списка опций, используя группу переключателей для выбора единственного значения или группу флажков для выбора нескольких значений.

image::gui_optionsGroup.png[align="center"]

XML-имя компонента: `optionsGroup`.

image::gui_OptionsGroup_dia.png[align="center"]

Компонент `OptionsGroup` реализован для блоков *Web Client* и *Desktop Client*.

* Простейший вариант использования `OptionsGroup` - выбор значения перечисления (`enum`) для атрибута сущности. Например, сущность `Role` имеет атрибут `type` типа `RoleType`, который является перечислением. Тогда для редактирования этого атрибута можно использовать `OptionsGroup` следующим образом:
+
[source, xml]
----
include::{sourcesdir}/gui_vcl/optionsgroup_1.xml[]
----
+
Как видно из примера, в экране описывается <<datasources,источник данных>> `roleDs` для сущности `Role`. В компоненте `optionsGroup` в атрибуте <<gui_attr_datasource,datasource>> указывается ссылка на источник данных, а в атрибуте <<gui_attr_property,property>> − название атрибута сущности, значение которого должно быть отображено.
+
В результате компонент примет следующий вид:
+
image::gui_optionsGroup_roleType.png[align="center"]

* Список опций компонента может быть задан произвольно с помощью методов `setOptionsList()` и `setOptionsMap()`, либо с помощью XML-атрибута `optionsDatasource`.

** Метод `setOptionsList()` позволяет программно задать список опций компонента. Для этого объявляем компонент в XML-дескрипторе:
+
[source, xml]
----
include::{sourcesdir}/gui_vcl/optionsgroup_2.xml[]
----
+
Затем инжектируем компонент в контроллер и в методе `init()` задаем ему список опций:
+
[source, java]
----
include::{sourcesdir}/gui_vcl/optionsgroup_3.java[]
----
+
Компонент примет следующий вид:
+
image::gui_optionsGroup_integerList.png[align="center"]
+
При этом метод `getValue()` компонента в зависимости от выбранной опции будет возвращать `Integer` значения 2,4,5,7.

** Метод `setOptionsMap()` позволяет задать строковые названия и значения опций по отдельности. Например, для описанного в XML-дескрипторе компонента `numberOfSeatsField` в методе `init()` контроллера задаем мэп опций:
+
[source, java]
----
include::{sourcesdir}/gui_vcl/optionsgroup_4.java[]
----
+
Компонент примет следующий вид:
+
image::gui_optionsGroup_integerMap.png[align="center"]
+
При этом метод `getValue()` компонента в зависимости от выбранной опции будет возвращать `Integer` значения 2,4,5,7, а не строки, отображаемые на экране.

** Компонент может брать список опций из источника данных. Для этого используется атрибут <<gui_attr_optionsDatasource,optionsDatasource>>. Например:
+
[source, xml]
----
include::{sourcesdir}/gui_vcl/optionsgroup_5.xml[]
----
+
В данном случае компонент `coloursField` отобразит <<namePattern,имена экземпляров>> сущности `Colour`, находящихся в источнике данных `coloursDs`, а его метод `getValue()` вернет выбранный экземпляр сущности.
+
С помощью атрибута <<gui_attr_captionProperty,captionProperty>> можно указать, какой атрибут сущности использовать вместо имени экземпляра для строковых названий опций.

[[gui_OptionsGroup_multiselect]]
* С помощью атрибута `multiselect` можно переключить `OptionsGroup` в режим множественного выбора. Если `multiselect` включен, то компонент отображается как группа независимых флажков, а значением компонента является список выбранных опций.
+
Например, создадим в XML-дескрипторе экрана компонент:
+
[source, xml]
----
include::{sourcesdir}/gui_vcl/optionsgroup_6.xml[]
----
+
И в контроллере зададим для него список опций - значения перечисления `RoleType`:
+
[source, java]
----
include::{sourcesdir}/gui_vcl/optionsgroup_7.java[]
----
+
Компонент примет следующий вид:
+
image::gui_optionsGroup_roleType_multi.png[align="center"]
+
В данном случае метод `getValue()` компонента вернет объект типа `java.util.List`, содержащий значения `RoleType.READONLY` и `RoleType.DENYING`.
+
Этот пример иллюстрирует также способность компонента `OptionsGroup` автоматически отображать локализованные значения перечислений, входящих в модель данных приложения.

[[gui_OptionsGroup_orientation]]
* Атрибут `orientation` задает расположение элементов группы. По умолчанию элементы располагаются по вертикали. Значение `horizontal` задает горизонтальное расположение.

'''

Атрибуты optionsGroup::
<<gui_attr_align,align>> -
<<gui_attr_caption,caption>> -
<<gui_attr_captionProperty,captionProperty>> -
<<gui_attr_datasource,datasource>> -
<<gui_attr_description,description>> -
<<gui_attr_editable,editable>> -
<<gui_attr_enable,enable>> -
<<gui_attr_id,id>> -
<<gui_OptionsGroup_multiselect,multiselect>> -
<<gui_attr_height,height>> -
<<gui_attr_optionsDatasource,optionsDatasource>> -
<<gui_OptionsGroup_orientation,orientation>> -
<<gui_attr_property,property>> -
<<gui_attr_required,required>> -
<<gui_attr_requiredMessage,requiredMessage>> -
<<gui_attr_stylename,stylename>> -
<<gui_attr_visible,visible>> -
<<gui_attr_width,width>>

Элементы optionsGroup::
<<gui_validator,validator>>

'''

[[gui_PasswordField]]
====== PasswordField

Текстовое поле, которое вместо символов, введенных пользователем, отображает эхо-символы. 

XML-имя компонента: `passwordField`.

image::gui_PasswordField_dia.png[align="center"]

`PasswordField` реализован для блоков *Web Client* и *Desktop Client*.

`PasswordField` в основном аналогичен компоненту <<gui_TextField,TextField>>, за исключением того, что ему нельзя установить `datatype`. То есть `PasswordField` предназначен для работы только с текстом и строковыми атрибутами сущностей. 

Пример использования:

[source, xml]
----
include::{sourcesdir}/gui_vcl/passwordfield_1.xml[]
----

[source, java]
----
include::{sourcesdir}/gui_vcl/passwordfield_2.java[]
----

image::gui_PasswordField.png[align="center"]

'''

Атрибуты passwordField::
<<gui_attr_align,align>> -
<<gui_attr_caption,caption>> -
<<gui_attr_datasource,datasource>> -
<<gui_attr_description,description>> -
<<gui_attr_editable,editable>> -
<<gui_attr_enable,enable>> -
<<gui_attr_height,height>> -
<<gui_attr_id,id>> -
<<gui_TextField_maxLength,maxLength>> -
<<gui_attr_property,property>> -
<<gui_attr_required,required>> -
<<gui_attr_requiredMessage,requiredMessage>> -
<<gui_attr_stylename,stylename>> -
<<gui_attr_visible,visible>> -
<<gui_attr_width,width>>

Элементы passwordField::
<<gui_validator,validator>>

'''

[[gui_PickerField]]
====== PickerField

`PickerField` позволяет отображать экземпляр сущности в текстовом поле и выполнять действия нажатием на кнопки справа.

image::PickerField.png[align="center"]

XML-имя компонента: `pickerField`.

image::gui_pickerField_dia.png[align="center"]

Компонент `PickerField` реализован для блоков *Web Client* и *Desktop Client*.

* Как правило, `PickerField` используется для работы со ссылочными атрибутами сущностей. При этом компоненту достаточно указать атрибуты <<gui_attr_datasource,datasource>> и <<gui_attr_property,property>>:
+
[source, xml]
----
include::{sourcesdir}/gui_vcl/pickerfield_1.xml[]
----
+
Как видно из примера, в экране описывается <<datasources,источник данных>> `carDs` для некоторой сущности `Car`, имеющей атрибут `colour`. В элементе `pickerField` в атрибуте `datasource` указывается ссылка на источник данных, а в атрибуте `property` − название атрибута сущности, значение которого должно быть отображено в компоненте. Атрибут сущности должен являться ссылкой на другую сущность, в приведенном примере это `Colour`.

[[gui_PickerField_actions]]
* Для `PickerField` можно определить произвольное количество <<gui_Action,действий>>, отображаемых кнопками справа. Это можно сделать как в XML-дескрипторе с помощью вложенного элемента `actions`, так и программно в контроллере методом `addAction()`. 

** Существуют <<standard_actions,стандартные действия>>, определенные перечислением `PickerField.ActionType`: `lookup`, `clear`, `open`. Они выполняют соответственно выбор связанной сущности, очистку поля и открытие экрана редактирования выбранной связанной сущности. Для стандартных действий в XML не нужно определять никаких атрибутов, кроме идентификатора. Если при объявлении компонента никаких действий в элементе `actions` не задано, загрузчик XML определит для него действия `lookup` и `clear`. Чтобы добавить к действиям по умолчанию, например, действие `open`, нужно определить элемент `actions` следующим образом:
+
[source, xml]
----
include::{sourcesdir}/gui_vcl/pickerfield_2.xml[]
----
+
Элемент `action` не дополняет, а переопределяет набор стандартных действий, поэтому необходимо указывать идентификаторы всех требуемых действий. Компонент примет следующий вид:
+
image::gui_pickerFieldActionsSt.png[align="center"]
+
Для программного задания стандартных действий служат методы `addLookupAction()`, `addOpenAction()` и `addClearAction()`. Если компонент определен в XML-дескрипторе без вложенного элемента `actions`, то достаточно добавить недостающие действия:
+
[source, java]
----
include::{sourcesdir}/gui_vcl/pickerfield_3.java[]
----
+
Если же компонент создается в контроллере, то никаких действий по умолчанию он не получает, и необходимо добавить все нужные действия явно:
+
[source, java]
----
include::{sourcesdir}/gui_vcl/pickerfield_4.java[]
----
+
Стандартные действия можно параметризовать. В XML-дескрипторе возможности для этого ограничены: существует только атрибут `openType`, в котором можно задать режим открытия экрана выбора (для `LookupAction`) или редактирования (для `OpenAction`).
+
При программном создании действий можно задать любые свойства объектов `PickerField.LookupAction`, `PickerField.OpenAction` и `PickerField.ClearAction`, возвращаемых методами добавления стандартных действий. Например, так можно задать специфический экран выбора:
+
[source, java]
----
include::{sourcesdir}/gui_vcl/pickerfield_5.java[]
----
+
Подробнее см. JavaDocs классов <<standard_actions,стандартных действий>>.

** Произвольные действия в XML-дескрипторе также определяются во вложенном элементе `actions`, например:
+
[source, xml]
----
include::{sourcesdir}/gui_vcl/pickerfield_6.xml[]
----
+
Программно задать произвольное действие можно следующим образом:
+
[source, java]
----
include::{sourcesdir}/gui_vcl/pickerfield_7.java[]
----
+
Декларативное и программное создание действий подробно описано в разделе <<gui_Action>>.

[[gui_PickerField_metaclass]]
* Компонент `PickerField` можно использовать без непосредственной привязки к данным, то есть без указания <<gui_attr_datasource,datasource>> и <<gui_attr_property,property>>. В этом случае для указания типа сущности, с которой должен работать `PickerField`, используется атрибут `metaClass`. Например:
+
[source, xml]
----
include::{sourcesdir}/gui_vcl/pickerfield_8.xml[]
----
+
Экземпляр выбранной сущности можно получить, инжектировав компонент в контроллер и вызвав его метод `getValue()`.
+
[WARNING]
====
Для правильной работы компонента `PickerField` необходима либо установка атрибута `metaClass`, либо одновременная установка атрибутов <<gui_attr_datasource,datasource>> и <<gui_attr_property,property>>.
====

* В компоненте `PickerField` можно использовать горячие клавиши: см. <<shortcuts,>>.

'''

Атрибуты pickerField::
<<gui_attr_align,align>> -
<<gui_attr_caption,caption>> -
<<gui_attr_captionProperty,captionProperty>> -
<<gui_attr_datasource,datasource>> -
<<gui_attr_description,description>> -
<<gui_attr_editable,editable>> -
<<gui_attr_enable,enable>> -
<<gui_attr_height,height>> -
<<gui_attr_id,id>> -
<<gui_PickerField_metaclass,metaClass>> -
<<gui_attr_property,property>> -
<<gui_attr_required,required>> -
<<gui_attr_requiredMessage,requiredMessage>> -
<<gui_attr_stylename,stylename>> -
<<gui_attr_visible,visible>> -
<<gui_attr_width,width>>

Элементы pickerField::
<<gui_PickerField_actions,actions>> -
<<gui_validator,validator>>

'''

[[gui_PopupButton]]
====== PopupButton

Кнопка с выпадающим списком действий.

image::PopupButton.png[align="center"]

XML-имя компонента: `popupButton`.

image::gui_popupButton_dia.png[align="center"]

Компонент реализован для блоков *Web Client* и *Desktop Client*.

Кнопка с выпадающим списком действий может содержать текст или пиктограмму (или и то и другое). На рисунке ниже отражены разные виды кнопок.

image::gui_popupButtonTypes.png[align="center"]

[[gui_PopupButton_actions]]
Пример кнопки с выпадающим списком, содержащим два действия: 

[source, xml]
----
include::{sourcesdir}/gui_vcl/popupButton_1.xml[]
----

Кнопка имеет надпись, заданную с помощью атрибута <<gui_attr_caption,caption>>, и всплывающую подсказку, определенную в атрибуте <<gui_attr_description,description>>. Выпадающий список <<gui_Action,действий>> задан в элемене `actions`. `PopupButton` отображает только следующие свойства действий: `caption`, `enable`, `visible`. Свойства `description`, `icon`, `shortcut` игнорируются.

'''

Атрибуты popupButton::
<<gui_attr_align,align>> -
<<gui_attr_caption,caption>> -
<<gui_attr_description,description>> -
<<gui_attr_enable,enable>> -
<<gui_attr_icon,icon>> -
<<gui_attr_id,id>> -
<<gui_attr_stylename,stylename>> -
<<gui_attr_visible,visible>> -
<<gui_attr_width,width>>

Элементы popupButton::
<<gui_PopupButton_actions,actions>>

'''

[[gui_ProgressBar]]
====== ProgressBar

Компонент `ProgressBar` служит для отображения хода выполнения некоторого длительного процесса. 

image::gui_progressBar.png[align="center"]

XML-имя компонента: `progressBar`

image::gui_progressBar_dia.png[align="center"]

Компонент реализован для блоков *Web Client* и *Desktop Client*. 

Пример использования компонента совместно с механизмом <<background_tasks,фоновых задач>>: 

[source, xml]
----
include::{sourcesdir}/gui_vcl/progressbar_1.xml[]
----

[source, java]
----
include::{sourcesdir}/gui_vcl/progressbar_2.java[]
----

Здесь в методе `BackgroundTask.progress()`, выполняемом в UI-потоке, компоненту `ProgressBar` устанавливается текущее значение. Значением компонента должно быть число типа `float` от `0.0` до `1.0`.

[[gui_ProgressBar_indeterminate]]
Если выполняемый процесс не может передавать информацию о прогрессе, то с помощью атрибута `indeterminate` можно задать отображение неопределенного состояния индикатора. Если значение атрибута равно `true`, то индикатор отображает неопределенное состояние. По умолчанию `false`. Например:

[source, xml]
----
include::{sourcesdir}/gui_vcl/progressbar_3.xml[]
----

'''

Атрибуты progressBar::
<<gui_attr_align,align>> -
<<gui_attr_enable,enable>> -
<<gui_attr_height,height>> -
<<gui_attr_id,id>> -
<<gui_ProgressBar_indeterminate,indeterminate>> -
<<gui_attr_stylename,stylename>> -
<<gui_attr_visible,visible>> -
<<gui_attr_width,width>>

'''

[[gui_RelatedEntities]]
====== RelatedEntities

`RelatedEntities` - компонент в виде кнопки с выпадающим списком, при нажатии показывающим список классов, связанных с сущностью, экземпляры которой отображаются в таблице. Пользователь выбирает интересующий его класс сущности, после чего открывается новый браузер с экземплярами данной сущности, связанными с выбранными экземплярами в начальной таблице.

image::gui_relatedEntities.png[align="center"]

XML-имя компонента: `relatedEntities`

image::gui_relatedEntities_dia.png[align="center"]

Компонент реализован для блоков *Web Client* и *Desktop Client*.

При отборе связанных сущностей для отображения учитываются разрешения пользователя на открытие экранов, чтение сущностей и чтение атрибутов.

По умолчанию для выбранного в списке класса сущности открывается браузер сущности, определенный по соглашениям (`{entity_name}.browse`, `{entity_name}.lookup`). Опционально, экран можно явно задать в компоненте.

В открытом браузере динамически создается фильтр, который выбирает связанные с выбранными сущностями записи.

Пример описания компонента в XML-дескрипторе экрана:

[source, xml]
----
include::{sourcesdir}/gui_vcl/relatedentities_1.xml[]
----

[[gui_RelatedEntities_for]]
Атрибут `for` является обязательным. В нем указывается идентификатор таблицы.

Атрибут `++openType="NEW_TAB"++` устанавливает режим открытия браузера (новая вкладка). По умолчанию браузер открывается в текущей вкладке.

Элемент `property` позволяет явно задать связанную сущность, которая будет отображаться в выпадающем списке.

Атрибуты `property`:

[[gui_RelatedEntities_property_name]]
* `name` - имя атрибута текущей сущности, ссылающегося на связанную сущность

[[gui_RelatedEntities_property_screen]]
* `screen` - идентификатор браузера, открывающегося при выборе сущности в списке

[[gui_RelatedEntities_property_filterCaption]]
* `filterCaption` - имя динамически формируемого фильтра

[[gui_RelatedEntities_exclude]]
Атрибут `exclude` позволяет исключить определенные связанные сущности из числа отображаемых. В качестве значения указываются ссылочные атрибуты текущей сущности, разделенные запятыми.

image::gui_relatedEntitiesTable.png[align="center"]

'''

Атрибуты relatedEntities::
<<gui_attr_align,align>> -
<<gui_attr_caption,caption>> -
<<gui_attr_description,description>> -
<<gui_attr_enable,enable>> -
<<gui_RelatedEntities_exclude,exclude>> -
<<gui_RelatedEntities_for,for>> -
<<gui_attr_icon,icon>> -
<<gui_attr_id,id>> -
<<gui_attr_openType,openType>> -
<<gui_attr_stylename,stylename>> -
<<gui_attr_visible,visible>> -
<<gui_attr_width,width>>

Атрибуты property::
<<gui_attr_caption,caption>> -
<<gui_RelatedEntities_property_filterCaption,filterCaption>> -
<<gui_RelatedEntities_property_name,name>> -
<<gui_RelatedEntities_property_screen,screen>>

'''

[[gui_RichTextArea]]
====== RichTextArea

Текстовая область для отображения и ввода форматированного текста.

XML-имя компонента: `richTextArea`

image::gui_RichTextArea_dia.png[align="center"]

Компонент `RichTextArea` реализован только для блока *Web Client*.

`RichTextArea` в основном повторяет функциональность `<<gui_TextField,TextField>>`, за исключением того, что ему нельзя установить `datatype`. То есть `RichTextArea` предназначен для работы только с текстом и строковыми атрибутами сущностей.

image::gui_RichTextAreaInfo.png[align="center"]

'''

Атрибуты richTextArea::
<<gui_attr_align,align>> -
<<gui_attr_caption,caption>> -
<<gui_attr_datasource,datasource>> -
<<gui_attr_description,description>> -
<<gui_attr_editable,editable>> -
<<gui_attr_enable,enable>> -
<<gui_attr_height,height>> -
<<gui_attr_id,id>> -
<<gui_attr_property,property>> -
<<gui_attr_required,required>> -
<<gui_attr_requiredMessage,requiredMessage>> -
<<gui_attr_stylename,stylename>> -
<<gui_attr_visible,visible>> -
<<gui_attr_width,width>>

'''

[[gui_SearchPickerField]]
====== SearchPickerField

Компонент `SearchPickerField` служит для поиска экземпляров сущностей по вводимой пользователем строке. Пользователю достаточно ввести несколько символов и нажать клавишу *Enter*. Если поиск дал несколько совпадений, найденные значения отображаются в виде выпадающего списка. Если же критерию поиска соответствует только один экземпляр, он сразу становится значением компонента. `SearchPickerField` позволяет также выполнять действия нажатием на кнопки справа.

image::gui_searchPickerFieldOverlap.png[align="center"]

XML-имя компонента: `searchPickerField`.

image::gui_SearchPickerField_dia.png[align="center"]

Компонент реализован для блоков *Web Client* и *Desktop Client*.

* Для работы компонента `SearchPickerField` необходимо создать <<datasources,collectionDatasource>>, и задать в нем запрос, содержащий условия поиска. Условие обязательно должно содержать параметр с именем `custom$searchString` - именно в него компонент передает введенную пользователем подстроку при нажатии *Enter*. Источник данных с условием поиска должен быть указан в атрибуте <<gui_attr_optionsDatasource,optionsDatasource>> компонента. Например:
+
[source, xml]
----
include::{sourcesdir}/gui_vcl/searchpickerfield_1.xml[]
----
+
В данном случае компонент будет искать экземпляры сущности `Colour` по вхождению подстроки в ее атрибут `name`. Префикс `(?i)` служит для регистро-независимого поиска (см. <<datasource_query_case_insensitive,Поиск подстроки без учета регистра>>). Выбранное значение подставится в атрибут `colour` сущности `Car`, находящейся в источнике данных `carDs`.

[[gui_SearchPickerField_minSearchStringLength]]
* С помощью атрибута `minSearchStringLength` можно задать минимальное количество символов, которое должен ввести пользователь для поиска значения.

* В контроллере экрана для компонента можно реализовать методы, вызываемые в двух случаях:
** если количество введенных символов меньше значения атрибута `minSearchStringLength`.

** если поиск введенных пользователем символов не дал результатов.
+
Пример реализации методов для вывода на экран сообщений:
+
[source, java]
----
include::{sourcesdir}/gui_vcl/searchpickerfield_2.java[]
----

* `SearchPickerField` реализует интерфейсы <<gui_LookupField,LookupField>> и <<gui_PickerField,PickerField>>, поэтому все описанное для этих интерфейсов в части работы с сущностями верно и для него. Исключением является список действий по умолчанию, добавляемых при определении компонента в XML: для `SearchPickerField` это действия `lookup` image:lookupBtn.png[] и `open` image:openBtn.png[].

'''

Атрибуты searchPickerField::
<<gui_attr_align,align>> -
<<gui_attr_caption,caption>> -
<<gui_attr_captionProperty,captionProperty>> -
<<gui_attr_datasource,datasource>> -
<<gui_attr_description,description>> -
<<gui_attr_editable,editable>> -
<<gui_attr_enable,enable>> -
<<gui_LookupField_filterMode,filterMode>> -
<<gui_attr_height,height>> -
<<gui_attr_id,id>> -
<<gui_attr_inputPrompt,inputPrompt>> -
<<gui_PickerField_metaclass,metaClass>> -
<<gui_SearchPickerField_minSearchStringLength,minSearchStringLength>> -
<<gui_LookupField_newOptionHandler,newOptionAllowed>> -
<<gui_LookupField_newOptionHandler,newOptionHandler>> -
<<gui_attr_nullName,nullName>> -
<<gui_attr_optionsDatasource,optionsDatasource>> -
<<gui_attr_property,property>> -
<<gui_attr_required,required>> -
<<gui_attr_requiredMessage,requiredMessage>> -
<<gui_attr_stylename,stylename>> -
<<gui_attr_visible,visible>> -
<<gui_attr_width,width>>

Элементы searchPickerField::
<<gui_Action,actions>> -
<<gui_validator,validator>>

'''

[[gui_Table]]
====== Table

Компонент `Table` позволяет выводить информацию в табличном виде, сортировать данные, управлять колонками и заголовками таблицы, вызывать действия для выбранных строк.

image::gui_table.png[align="center"]

XML-имя компонента: `table`

image::gui_Table_dia.png[align="center"]

Компонент реализован для блоков *Web Client* и *Desktop Client*. 

Пример описания таблицы в XML-дескрипторе экрана: 

[source, xml]
----
include::{sourcesdir}/gui_vcl/table_1.xml[]
----

Здесь в элементе `dsContext` определен <<datasources,источник данных>> `collectionDatasource`, который выбирает сущности `Order` с помощью <<jpql,JPQL>> запроса `select o from sales$Order o order by o.date`. Для компонента `table` в элементе `rows` указывается используемый источник данных, а в элементе `columns` - какие атрибуты сущности, содержащейся в источнике данных, использовать в качестве колонок.

Элементы `table`:

[[gui_Table_rows]]
* `rows` - обязательный элемент, в атрибуте `datasource` которого необходимо объявить используемый таблицей <<datasources,источник данных>>.
+
Для строк можно настроить отображение заголовков - задать каждой строке свой значок в дополнительной колонке слева. Для этого в контроллере экрана необходимо реализовать интерфейс `Table.IconProvider` и установить его таблице: 
+
[source, java]
----
include::{sourcesdir}/gui_vcl/tableIconProvider_1.java[]
---- 

[[gui_Table_columns]]
* `columns` - обязательный элемент, определяет набор колонок таблицы.
+
Каждая колонка описывается во вложенном элементе `column` со следующими атрибутами:
+
--
[[gui_Table_column_id]]
** `id` − обязательный атрибут, содержит название атрибута сущности, выводимого в колонке. Может быть как непосредственным атрибутом сущности, находящейся в источнике данных, так и атрибутом связанной сущности - переход по графу объектов обозначается точкой. Например: 
+
[source, xml]
----
include::{sourcesdir}/gui_vcl/tableId_1.xml[]
---- 

[[gui_Table_column_caption]]
** `caption` − необязательный атрибут, содержит заголовок колонки. Если не задан, будет отображено <<entity_localization,локализованное название атрибута>> сущности.

[[gui_Table_column_collapsed]]
** `collapsed` − необязательный атрибут, при указании `true` колонка будет изначально скрыта. Пользователь может управлять отображением колонок с помощью меню, доступного по кнопке image:gui_table_columnControl.png[] в правой верхней части таблицы, если атрибут `columnControlVisible` таблицы не `false`. По умолчанию `collapsed` имеет значение `false`.

[[gui_Table_column_width]]
** `width` − необязательный атрибут, отвечает за изначальную ширину колонки.

[[gui_Table_column_align]]
** `align` - необязательный атрибут, устанавливает выравнивание текста в ячейках данной колонки. Возможные значения: `LEFT`, `RIGHT`, `CENTER`. По умолчанию `LEFT`.

[[gui_Table_column_editable]]
** `editable` − необязательный атрибут, разрешает/запрещает редактирование данной колонки в редактируемой таблице. Чтобы колонка была редактируемой, атрибут <<gui_Table_editable,editable>> всей таблицы также должен быть установлен в `true`.

[[gui_Table_column_sortable]]
** `sortable` − необязательный атрибут, позволяющий запретить сортировку колонки. Вступает в действие, если атрибут <<gui_Table_sortable,sortable>> всей таблицы установлен в `true` (что имеет место по умолчанию).

[[gui_Table_column_maxTextLength]]
** `maxTextLength` - необязательный атрибут, позволяет ограничивать количество символов в ячейке. При этом если разница между фактическим и допустимым количеством символов не превышает порог в 10 символов, "лишние" символы не скрываются. Для просмотра полной записи надо кликнуть на ее видимую часть. Пример колонки с ограничением в 5 символов:
+
image::gui_table_column_maxTextLength.png[align="center"]

[[gui_Table_column_link]]
** `link` - установка атрибута в `true` позволяет отобразить в ячейке таблицы ссылку на экран просмотра экземпляра сущности (поддерживается только для *Web Client*). Атрибут `link="true"`) может указываться и для колонок примитивных типов: в этом случае, при нажатии на ссылку будет открываться редактор основной сущности таблицы. Такой подход может применяться для упрощения навигации - пользователи смогут открывать редактор одним кликом по некоторому ключевому атрибуту.

[[gui_Table_column_linkScreen]]
** `linkScreen` - позволяет указать идентификатор экрана, который будет открыт по нажатию на ссылку, включенную свойством `link`.

[[gui_Table_column_linkScreenOpenType]]
** `linkScreenOpenType` - задает режим открытия экрана (`++THIS_TAB++`, `++NEW_TAB++` или `DIALOG`).

[[gui_Table_column_linkInvoke]]
** `linkInvoke` - позволяет заменить открытие окна на вызов метода контроллера.

[[gui_Table_column_captionProperty]]
** `captionProperty` - имя атрибута сущности, который должен быть отображен в колонке вместо указанного в <<gui_Table_column_id,id>>. Например, если имеется связанная сущность `Priority` с атрибутами `name` и `orderNo`, можно определить следующую колонку:
+
[source, xml]
----
include::{sourcesdir}/gui_vcl/tableColumnCaptionProperty_1.xml[]
----
+
В этом случае в колонке будет отображаться название приоритета, а сортировка колонки будет осуществляться по атрибуту `orderNo`.

** Элемент `column` может содержать вложенный элемент <<gui_formatter,formatter>> для представления значения атрибута в виде, отличном от стандартного для данного <<datatype,Datatype>>: 
+
[source, xml]
----
include::{sourcesdir}/gui_vcl/tableFormatter_1.xml[]
----
--

[[gui_Table_rowsCount]]
* `rowsCount` − необязательный элемент, создающий для таблицы компонент `RowsCount`, который позволяет загружать в таблицу данные постранично. Размер страницы задается путем ограничения количества записей в источнике данных методом `CollectionDatasource.setMaxResults()`. Как правило, это делает связанный с источником данных таблицы компонент <<gui_Filter,Filter>>, однако при отсутствии универсального фильтра можно вызвать этот метод и напрямую из контроллера экрана.
+
Компонент `RowsCount` может также отобразить общее число записей, возвращаемых текущим запросом в источнике данных, без извлечения этих записей. Для этого при щелчке пользователя на знаке "?" он вызывает метод `AbstractCollectionDatasource.getCount()`, что приводит к выполнению в БД запроса с такими же, как у текущего запроса условиями, но с агрегатной функцией `++COUNT(*)++` вместо результатов. Полученное число отображается вместо знака "?".

[[gui_Table_actions]]
* `actions` − необязательный элемент для описания <<gui_Action,действий>>, связанных с таблицей. Кроме описания произвольных действия поддерживаются следующие <<standard_actions, стандартные действия>>, определяемые перечислением `ListActionType`: `create`, `edit`, `remove`, `refresh`, `add`, `exclude`, `excel`.

[[gui_Table_buttonsPanel]]
* `buttonsPanel` - необязательный элемент, создающий над таблицей контейнер <<gui_ButtonsPanel,ButtonsPanel>> для отображения кнопок действий.

Атрибуты `table`:

[[gui_Table_multiselect]]
* Атрибут `multiselect` позволяет задать режим множественного выделения строк в таблице. Если `multiselect` равен `true`, то пользователь может выделить несколько строк с помощью клавиатуры или мыши, удерживая клавиши *Ctrl* или *Shift*. По умолчанию режим множественного выделения отключен.

[[gui_Table_sortable]]
* Атрибут `sortable` разрешает или запрещает сортировку в таблице. По умолчанию имеет значение `true`. Если сортировка разрешена, то при нажатии на название колонки справа от названия появляется значок image:gui_sortable_down.png[]/image:gui_sortable_up.png[]. Сортировку некоторой отдельной колонки можно запретить с помощью атрибута <<gui_Table_column_sortable, sortable>> этой колонки.
+
При включенной с помощью элемента `rowsCount` (см. выше) страничной загрузке таблицы сортировка производится разными способами в зависимости от того, умещаются ли все записи на одной странице. Если умещаются, то сортировка производится в памяти, без обращений к БД. Если же страниц больше одной, то сортировка производится на базе данных путем отправки нового запроса с соответствующим `ORDER BY`.
+
Колонка таблицы может ссылаться на локальный атрибут или на связанную сущность. Например:
+
[source, xml]
----
include::{sourcesdir}/gui_vcl/tableSortable_1.xml[]
----
+
В последнем случае, сортировка на базе данных производится по атрибутам, указанным в аннотации `@NamePattern` связанной сущности. Если у связанной сущности нет такой аннотации, то сортировка производится в памяти только в пределах текущей страницы.
+
Если колонка таблицы ссылается на неперсистентный атрибут, то сортировка на базе данных производится по атрибутам, указанным в параметре `related()` аннотации `@MetaProperty`. Если такой параметр не указан, то сортировка производится в памяти только в пределах текущей страницы.

[[gui_Table_presentations]]
* Атрибут `presentations` управляет механизмом <<gui_presentations,представлений>>. Значение по умолчанию равно `false`. Когда значение атрибута равно `true`, то в верхнем правом углу таблицы появляется значок image:gui_presentation.png[]. Механизм представлений реализован только для блока *Web Client*.

[[gui_Table_columnControlVisible]]
* Установка атрибута `columnControlVisible` в `false` запрещает пользователю скрывать колонки с помощью меню, выпадающего при нажатия на кнопку image:gui_table_columnControl.png[] в правой части шапки таблицы. Флажками в меню отмечаются отображаемые в данный момент колонки.
+
image::gui_table_columnControl_all.png[align="center"]

[[gui_Table_reorderingAllowed]]
* Установка атрибута `reorderingAllowed` в `false` запрещает пользователю менять местами колонки, перетаскивая их с помощью мыши.

[[gui_attr_table_allowContextMenu]]
* Атрибут `contextMenuEnabled` разрешает или запрещает показывать контекстное меню. По умолчанию атрибут имеет значение `true`. В контекстном меню отображаются действия таблицы (если они есть), и пункт *Системная информация*, содержащий информацию о выбранной сущности (если у пользователя есть <<permissions,разрешение>> `cuba.gui.showInfo`).

[[gui_Table_multiLineCells]]
* Если атрибуту `multiLineCells` таблицы присвоить значение `true`, то ячейки, содержащие текст с переносами строк, будут отображать его в несколько строк. В таком режиме в веб клиенте для правильной работы полосы прокрутки все строки текущей страницы таблицы будут загружены веб-браузером сразу, без ленивой загрузки видимой части таблицы. По умолчанию атрибут имеет значение `false`.

[[gui_Table_aggregatable]]
* Атрибут `aggregatable` включает режим агрегации строк таблицы. Поддерживаются следующие операции:
+
--

** `SUM` - сумма

** `AVG` - среднее значение

** `COUNT` - количество

** `MIN` - минимальное значение

** `MAX` - максимальное значение

[[gui_Table_column_aggregation]]
Для агрегируемых колонок необходимо указать элемент `aggregation` с атрибутом `type`, задающим функцию агрегации. Агрегированные значения столбцов выводятся в дополнительной строке вверху таблицы. Пример описания таблицы с агрегацией:

[source, xml]
----
include::{sourcesdir}/gui_vcl/tableAggregatable_1.xml[]
---- 

Для отображения агрегированного значения в виде, отличном от стандартного для данного <<datatype,Datatype>>, для него можно указать <<gui_formatter,Formatter>>: 

[source, xml]
----
include::{sourcesdir}/gui_vcl/tableAggregatable_2.xml[]
---- 

В дополнение к операциям, перечисленным выше, можно задать собственную стратегию агрегации путем создания класса, реализующего интерфейс `AggregationStrategy`, и передачи его методу `setAggregation()` класса `Table.Column` в составе экземпляра `AggregationInfo`. Например: 

[source, java]
----
include::{sourcesdir}/gui_vcl/tableAggregationStrategy_1.java[]
----

[source, java]
----
include::{sourcesdir}/gui_vcl/tableAggregationStrategy_2.java[]
----
--

[[gui_Table_editable]]
* Атрибут `editable` позволяет перевести таблицу в режим in-place редактирования ячеек. В этом режиме в колонках, имеющих атрибут `editable = true`, отображаются компоненты для редактирования значений атрибутов сущности, находящейся в источнике данных.
+
Тип компонента для каждой редактируемой колонки выбирается автоматически на основании типа атрибута сущности. Например, для строковых и числовых атрибутов используется <<gui_TextField,TextField>>, для `Date` - <<gui_DateField,DateField>>, для перечислений - <<gui_LookupField,LookupField>>, для ссылок на другие сущности - <<gui_PickerField,PickerField>>. 
+
Для редактируемой колонки типа `Date` можно дополнительно указать атрибуты `dateFormat` или `resolution` аналогично описанным для <<gui_DateField,DateField>>.
+
Для редактируемой колонки, отображающей связанную сущность, можно дополнительно указать атрибуты <<gui_attr_optionsDatasource,optionsDatasource>> и <<gui_attr_captionProperty,captionProperty>>. При указании `optionsDatasource` вместо <<gui_PickerField,PickerField>> используется компонент <<gui_LookupField,LookupField>>.
+
Произвольно настроить отображение ячеек, в том числе для редактирования содержимого, можно с помощью метода `Table.addGeneratedColumn()` - см. ниже.

Методы интерфейса `Table`:

* `getSelected()`, `getSingleSelected()` - возвращают экземпляры сущностей, соответствующие выделенным в таблице строкам. Коллекцию можно получить вызовом метода `getSelected()`. Если ничего не выбрано, возвращается пустой набор. Если `multiselect` отключен, удобно пользоваться методом `getSingleSelected()`, возвращающим одну выбранную сущность или `null`, если ничего не выбрано.

* Метод `addGeneratedColumn()` позволяет задать собственное представление данных в колонке. Он принимает два параметра: идентификатор колонки и реализацию интерфейса`Table.ColumnGenerator`. Идентификатор может совпадать с одним из идентификаторов, указанных для колонок таблицы в XML-дескрипторе - в этом случае новая колонка вставляется вместо заданной в XML. Если идентификатор не совпадает ни с одной колонкой, создается новая справа. 
+
Метод `generateCell()` интерфейса `Table.ColumnGenerator` вызывается таблицей для каждой строки, и в него передается экземпляр сущности, отображаемой в данной строке. Метод `generateCell()` должен вернуть визуальный компонент, который и будет отображаться в ячейке. 
+
Пример использования: 
+
[source, java]
----
include::{sourcesdir}/gui_vcl/tableColumnGenerator_1.java[]
---- 
+
В данном случае в ячейках колонки `colour` таблицы отображается компонент <<gui_LookupPickerField,LookupPickerField>>. Компонент должен сохранять свое значение в атрибут `colour` сущности, экземпляр которой отображается в данной строке. Для этого у таблицы методом `getItemDatasource()` запрашивается источник данных для текущего экземпляра сущности, и передается компоненту `LookupPickerField`. 
+
Если в ячейке необходимо отобразить просто динамически сформированный текст, вместо компонента <<gui_Label,Label>> используйте класс `Table.PlainTextCell`. Это упростит отрисовку и сделает таблицу быстрее.
+
Если в метод `addGeneratedColumn()` передан идентификатор колонки, не объявленной в XML-дескрипторе, то может понадобиться установить заголовок новой колонки следующим образом: 
+
[source, java]
----
carsTable.getColumn("colour").setCaption("Colour");
---- 

* Метод `setClickListener()` может избавить от необходимости добавлять генерируемые колонки с компонентами, если нужно нарисовать что-либо в ячейках и получать оповещения когда пользователь кликает на эти ячейки. Имплементация класса `CellClickListener`, передаваемая в данный метод, получает текущий экземпляр сущности и идентификатор колонки. Содержимое ячеек будет завернуто в элемент `span` со стилем `cuba-table-clickable-cell`, который можно использовать для задания отображения ячеек.

* Метод `setStyleProvider()` позволяет задать стиль отображения ячеек таблицы. Параметром метода должна быть реализация интерфейса `Table.StyleProvider`. Метод `getStyleName()` этого интерфейса вызывается таблицей отдельно для каждой строки и для каждой ячейки. Если метод вызван для строки, то первый параметр содержит экземпляр сущности, отображаемый этой строкой, а второй параметр `null`. Если же метод вызван для ячейки, то второй параметр содержит имя атрибута, отображаемого этой ячейкой.
+
Пример задания стилей: 
+
[source, java]
----
include::{sourcesdir}/gui_vcl/table_setStyleProvider_1.java[]
----
+
Далее нужно определить заданные для строк и ячеек стили в теме приложения. Подробная информация о создании темы находится в <<gui_themes,Создание темы приложения>>. Для веб-клиента новые стили определяются в файле `styles.scss`. Имена стилей, заданные в контроллере, совместно с префиксами, обозначающими строку или колонку таблицы, образуют CSS-селекторы. Например:
+
[source, css]
----
include::{sourcesdir}/gui_vcl/table_setStyleProvider_2.css[]
----

* Метод `addPrintable()` позволяет задать специфическое представление данных колонки при выводе в XLS-файл, осуществляемом <<standard_actions,стандартным действием>> `excel` или напрямую с помощью класса `ExcelExporter`. Метод принимает идентификатор колонки и реализацию интерфейса `Table.Printable` для нее. Например: 
+
[source, java]
----
include::{sourcesdir}/gui_vcl/table_addPrintable_1.java[]
---- 
+
Метод `getValue()` интерфейса `Table.Printable` должен возвращать данные, которые будут находиться в ячейке таблицы. Это может быть не только строка - метод может возвращать значения других типов, например, числовые данные или даты, и они будут представлены в XLS-файле соответствующим образом. 
+
Если форматированный вывод в XLS необходим для генерируемой колонки, нужно использовать реализацию интерфейса `Table.PrintableColumnGenerator`, передавая ее методу `addGeneratedColumn()`. Значение для вывода в ячейку XLS-документа задается в методе `getValue()` этого интерфейса: 
+
[source, java]
----
include::{sourcesdir}/gui_vcl/table_addPrintable_2.java[]
---- 
+
Если генерируемой колонке тем или иным способом не задано представления `Printable`, то в случае, если колонке соответствует атрибут сущности, будет выведено его значение, в противном случае не будет выведено ничего.

* Метод `setItemClickAction()` позволяет задать <<gui_Action,действие>>, выполняемое при двойном клике на строке таблицы. Если такое действие не задано, при двойном клике таблица пытается найти среди своих действий подходящее в следующем порядке:

** Действие, назначенное на клавишу *Enter* посредством свойства `shortcut`.

** Действие с именем `edit`.

** Действие с именем `view`.
+
Если такое действие найдено и имеет свойство `enabled = true`, оно выполняется.

* Метод `setEnterPressAction()` позволяет задать <<gui_Action,действие>>, выполняемое при нажатии клавиши *Enter*. Если такое действие не задано, таблица пытается найти среди своих действий подходящее в следующем порядке:
+
--
** Действие, назначенное методом `setItemClickAction()`.

** Действие, назначенное на клавишу *Enter* посредством свойства `shortcut`.

** Действие с именем `edit`.

** Действие с именем `view`.

Если такое действие найдено и имеет свойство `enabled = true`, оно выполняется.
--

'''

Атрибуты table::
<<gui_attr_align,align>> -
<<gui_Table_aggregatable,aggregatable>> -
<<gui_Table_aggregationStyle,aggregationStyle>> -
<<gui_Table_columnControlVisible,columnControlVisible>> -
<<gui_Table_allowPopupMenu,contextMenuEnabled>> -
<<gui_Table_editable,editable>> -
<<gui_attr_enable,enable>> -
<<gui_attr_height,height>> -
<<gui_attr_id,id>> -
<<gui_Table_multiLineCells,multiLineCells>> -
<<gui_Table_multiselect,multiselect>> -
<<gui_Table_presentations,presentations>> -
<<gui_Table_reorderingAllowed,reorderingAllowed>> -
<<gui_Table_sortable,sortable>> -
<<gui_attr_stylename,stylename>> -
<<gui_attr_visible,visible>> -
<<gui_attr_width,width>>

Элементы table::
<<gui_Table_actions,actions>> -
<<gui_Table_buttonsPanel,buttonsPanel>> -
<<gui_Table_columns,columns>> -
<<gui_Table_rows,rows>> -
<<gui_Table_rowsCount,rowsCount>>

Атрибуты <<gui_Table_columns,column>>::
<<gui_Table_column_align,align>> -
<<gui_Table_column_caption,caption>> -
<<gui_Table_column_captionProperty,captionProperty>> -
<<gui_Table_column_collapsed,collapsed>> -
<<gui_DateField_dateFormat,dateFormat>> -
<<gui_Table_column_editable,editable>> -
<<gui_Table_column_id,id>> -
<<gui_Table_column_link,link>> -
<<gui_Table_column_linkInvoke,linkInvoke>> -
<<gui_Table_column_linkScreen,linkScreen>> -
<<gui_Table_column_linkScreenOpenType,linkScreenOpenType>> -
<<gui_Table_column_maxTextLength,maxTextLength>> -
<<gui_attr_optionsDatasource,optionsDatasource>> -
<<gui_DateField_resolution,resolution>> -
<<gui_Table_column_sortable,sortable>> -
<<gui_attr_visible,visible>> -
<<gui_Table_column_width,width>>

Элементы <<gui_Table_columns,column>>::
<<gui_Table_column_aggregation,aggregation>> -
<<gui_formatter,formatter>>

Атрибуты <<gui_Table_rows,rows>>::
<<gui_attr_datasource,datasource>>

'''

[[gui_TextArea]]
====== TextArea

Текстовая область − многострочное текстовое поле для редактирования текста.

XML-имя компонента: `textArea`

image::gui_TextArea_dia.png[align="center"]

Компонент `TextArea` реализован для блоков *Web Client* и *Desktop Client*.

`TextArea` в основном повторяет функциональность <<gui_TextField,TextField>>, за исключением того, что ему нельзя установить `datatype`. То есть `TextArea` предназначен для работы только с текстом и строковыми атрибутами сущностей.

Компонент `TextArea` имеет следующие специфические атрибуты:

[[gui_TextArea_cols_rows]]
* `cols` и `rows` задают количество строк и столбцов текста:
+
[source, xml]
----
include::{sourcesdir}/gui_vcl/textarea_1.xml[]
----
+
Значения `width` и `height` имеют приоритет над значениями `cols` и `rows`.

[[gui_TextArea_resizable]]
* `resizable` - при задании атрибуту значения `true` и установке количества строк, больших одной, появляется возможность изменять размеры компонента:
+
[source, xml]
----
include::{sourcesdir}/gui_vcl/textarea_2.xml[]
----
+
image::gui_textField_resizable.png[align="center"]

'''

Атрибуты textArea::
<<gui_attr_align,align>> -
<<gui_attr_caption,caption>> -
<<gui_TextArea_cols_rows,cols>> -
<<gui_attr_datasource,datasource>> -
<<gui_attr_description,description>> -
<<gui_attr_editable,editable>> -
<<gui_attr_enable,enable>> -
<<gui_attr_height,height>> -
<<gui_attr_id,id>> -
<<gui_TextField_maxLength,maxLength>> -
<<gui_attr_property,property>> -
<<gui_attr_required,required>> -
<<gui_attr_requiredMessage,requiredMessage>> -
<<gui_TextArea_resizable,resizable>> -
<<gui_TextArea_cols_rows,rows>> -
<<gui_attr_stylename,stylename>> -
<<gui_TextField_trim,trim>> -
<<gui_attr_visible,visible>> -
<<gui_attr_width,width>>

'''

[[gui_TextField]]
====== TextField

Поле для редактирования текста. Может использоваться как для работы с атрибутами сущностей, так и для ввода и отображения произвольной текстовой информации.

XML-имя компонента: `textField`

image::gui_TextField_dia.png[align="center"]

Компонент текстового поля реализован для блоков *Web Client* и *Desktop Client*.

* Пример текстового поля с заголовком, взятым из <<message_packs,пакета локализованных сообщений>>:
+
[source, xml]
----
include::{sourcesdir}/gui_vcl/textfield_1.xml[]
----
+
На рисунке ниже показан вид простого текстового поля.
+
image::gui_textField_data.png[align="center"]

* Для создания текстового поля, связанного с данными, необходимо использовать атрибуты <<gui_attr_datasource,datasource>> и <<gui_attr_property,property>>.
+
[source, xml]
----
include::{sourcesdir}/gui_vcl/textfield_2.xml[]
----
+
Как видно из примера, в экране описывается <<datasources,источник данных>> `customerDs` для некоторой сущности `Покупатель (Customer)`, имеющей атрибут `name`. В компоненте текстового поля в атрибуте <<gui_attr_datasource,datasource>> указывается ссылка на источник данных, а в атрибуте <<gui_attr_property,property>> − название атрибута сущности, значение которого должно быть отображено в текстовом поле.

[[gui_TextField_datatype]]
* Если поле не связано с атрибутом сущности (то есть не указан источник данных и название атрибута), то можно указать тип данных с помощью атрибута `datatype`. Тип данных используется для форматирования значения поля. В качестве значения атрибута может быть указано любое имя типа данных, зарегистрированного в метаданных приложения - см. <<datatype,>>. Как правило, в `TextField` используются следующие типы данных:
** `decimal`

** `double`

** `int`

** `long`
+
В качестве примера рассмотрим текстовое поле с типом данных `Integer`. 
+
[source, xml]
----
include::{sourcesdir}/gui_vcl/textfield_3.xml[]
----
+
Если в таком поле ввести значение, которое невозможно интерпретировать как целое число, то при потере фокуса полем будет выведено сообщение об ошибке и значение поля вернется на предыдущее.

* Текстовому полю может быть назначен <<gui_validator,валидатор>> - класс, реализующий интерфейс `Field.Validator`. Валидатор позволяет дополнительно к `datatype` ограничить вводимую пользователем информацию. Например, для создания поля ввода положительных целых чисел нужно создать класс валидатора:
+
[source, java]
----
include::{sourcesdir}/gui_vcl/textfield_4.java[]
----
+
и задать его для текстового поля с типом данных `int` в элементе <<gui_validator,validator>>:
+
[source, xml]
----
include::{sourcesdir}/gui_vcl/textfield_5.xml[]
----
+
В отличие от проверки вводимой строки на соответствие типу данных, валидация срабатывает не сразу при потере полем фокуса, а только при вызове у поля метода `validate()`. Это означает, что поле (и связанный с ним атрибут сущности) может некоторое время содержать значение, не удовлетворяющее условиям валидации (в приведенном примере неположительное число). Это не является проблемой, так как обычно поля редактирования с валидацией располагаются в <<screen_edit,экране редактирования>>, а он автоматически вызывает валидацию всех своих полей перед коммитом. Если же поле находится не в экране редактирования, то необходимо вызывать метод `validate()` поля в контроллере явно.

* Если текстовое поле связано с атрибутом сущности (через `datasource` и `property`), и если для атрибута сущности в <<entity_attr_annotations,JPA-аннотации>> `@Column` указан параметр `length`, то `TextField` будет соответственно ограничивать максимальную длину вводимого текста.
+
[[gui_TextField_maxLength]]
Если текстовое поле не связано с атрибутом, либо для него не определено значение `length`, либо это значение нужно переопределить, то для ограничения максимальной длины вводимого текста можно использовать атрибут `maxLength`. Значение "-1" означает отсутствие ограничения. Например:
+
[source, xml]
----
include::{sourcesdir}/gui_vcl/textfield_6.xml[]
----

[[gui_TextField_trim]]
* По умолчанию текстовое поле отсекает пробелы в начале и конце введенной строки. То есть если пользователь ввел строку " aaa bbb " то значением поля, возвращаемым методом `getValue()` и сохраняемым в связанный атрибут сущности, будет строка "aaa bbb". Для того, чтобы отключить отсечение пробелов, используйте атрибут `trim` со значением `false`.
+
Следует иметь в виду, что отсечение пробелов работает только при вводе нового значения. Если в значении связанного атрибута уже присутствуют пробелы, они будут отображаться, пока пользователь не изменит значение поля.

* Текстовое поле всегда вместо введенной пустой строки возвращает `null`. Соответственно, при включенном атрибуте `trim` строка, состоящая из одних пробелов также превратится в `null`.

* Метод `setCursorPosition()` используется для установки позиции курсора в указанный индекс (начинается с 0). После вызова метода поле принимает фокус ввода.

'''

Атрибуты textField::
<<gui_attr_align,align>> -
<<gui_attr_caption,caption>> -
<<gui_attr_datasource,datasource>> -
<<gui_TextField_datatype,datatype>> -
<<gui_attr_description,description>> -
<<gui_attr_editable,editable>> -
<<gui_attr_enable,enable>> -
<<gui_attr_height,height>> -
<<gui_attr_id,id>> -
<<gui_attr_inputPrompt,inputPrompt>> -
<<gui_TextField_maxLength,maxLength>> -
<<gui_attr_property,property>> -
<<gui_attr_required,required>> -
<<gui_attr_requiredMessage,requiredMessage>> -
<<gui_attr_stylename,stylename>> -
<<gui_TextField_trim,trim>> -
<<gui_attr_visible,visible>> -
<<gui_attr_width,width>>

Элементы textField::
<<gui_validator,validator>>

'''

[[gui_TimeField]]
====== TimeField

Поле для отображения и ввода времени.

image::gui_timeField.png[align="center"]

XML-имя компонента: `timeField`.

image::gui_timeField_dia.png[align="center"]

Компонент `TimeField` реализован для блоков *Web Client* и *Desktop Client*.

* Для создания поля времени, связанного с данными, необходимо использовать атрибуты <<gui_attr_datasource,datasource>> и <<gui_attr_property,property>>:
+
[source, xml]
----
include::{sourcesdir}/gui_vcl/timefield_1.xml[]
----
+
Как видно из примера, в экране описывается источник данных `orderDs` для некоторой сущности Заказ (`Order`), имеющей атрибут `deliveryTime`. В компоненте ввода времени в атрибуте `datasource` указывается ссылка на источник данных, а в атрибуте `property` − название атрибута сущности, значение которого должно быть отображено в поле.
+
Связанный атрибут сущности должен быть типа `java.util.Date` или `java.sql.Time`.

* Формат отображения времени определяется <<datatype,типом данных>> `time` и задается в <<main_message_pack,главном пакете локализованных сообщений>> в ключе `timeFormat`.

[[gui_TimeField_timeFormat]]
* Формат отображения времени можно также задать в атрибуте `timeFormat` компонента. Это может быть как сама строка формата, так и ключ в пакете сообщений (с префиксом `msg://`).

[[gui_TimeField_showSeconds]]
* Независимо от упомянутого выше формата отображением секунд можно управлять с помощью атрибута `showSeconds`. По умолчанию секунды отображаются, если формат содержит символы `ss`.
+
[source, xml]
----
include::{sourcesdir}/gui_vcl/timefield_2.xml[]
----
+
image::gui_timeFieldSec.png[align="center"]

'''

Атрибуты timeField::
<<gui_attr_align,align>> -
<<gui_attr_caption,caption>> -
<<gui_attr_editable,editable>> -
<<gui_attr_enable,enable>> -
<<gui_attr_datasource,datasource>> -
<<gui_attr_description,description>> -
<<gui_attr_height,height>> -
<<gui_attr_id,id>> -
<<gui_attr_property,property>> -
<<gui_attr_required,required>> -
<<gui_attr_requiredMessage,requiredMessage>> -
<<gui_TimeField_showSeconds,showSeconds>> -
<<gui_attr_stylename,stylename>> -
<<gui_TimeField_timeFormat,timeFormat>> -
<<gui_attr_visible,visible>> -
<<gui_attr_width,width>>

Элементы timeField::
<<gui_validator,validator>>

'''

[[gui_TokenList]]
====== TokenList

Компонент `TokenList` представляет собой упрощенный вариант работы со списком сущностей: названия экземпляров располагаются в вертикальном или горизонтальном списке, добавление производится из выпадающего списка, удаление - с помощью кнопок, расположенных рядом с каждым экземпляром.

image::gui_tokenList.png[align="center"]

XML-имя компонента: `tokenList`

image::gui_TokenList_dia.png[align="center"]

Компонент реализован для блоков *Web Client* и *Desktop Client*.

Пример описания компонента `TokenList` в XML-дескрипторе экрана: 

[source, xml]
----
include::{sourcesdir}/gui_vcl/tokenList_1.xml[]
---- 

Здесь в элементе `dsContext` определен вложенный источник данных `productsDs`, содержащий коллекцию входящих в состав заказа продуктов. Кроме того, определен источник данных `allProductsDs`, содержащий коллекцию всех продуктов, имеющихся в базе данных. Компонент `TokenList` с идентификатором `productsList` отображает содержимое источника данных `productsDs`, а также позволяет изменять эту коллекцию, добавляя в него экземпляры из источника данных `allProductsDs`.

Атрибуты `tokenList`:

[[gui_TokenList_position]]
* `position` - задает позиционирование раскрывающегося списка. Атрибут может принимать два значения: `TOP`, `BOTTOM`. По умолчанию `TOP`.
+
image::gui_tokenListBottom.png[align="center"]

[[gui_TokenList_inline]]
* Атрибут `inline` задает отображение списка выбранных значений: вертикально или горизонтально. Значение `true` соответствует горизонтальному расположению, значение `false` − вертикальному. Так выглядит компонент с горизонтальным расположением значений:
+
image::gui_tokenListInline.png[align="center"]

[[gui_TokenList_simple]]
*  `simple` - значение `true` позволяет убрать компонент выбора, оставляя только кнопку добавления. При нажатии на кнопку добавления сразу показывается экран списка экземпляров сущности, тип которой задан источником данных `datasource`. Идентификатор экрана выбора определяется по правилам, описанным для <<picker_actions,стандартного действия>> `PickerField.LookupAction`.
+
image::gui_tokenListSimple.png[align="center"]

Элементы `tokenList`:

[[gui_TokenList_lookup]]
* `lookup` − описатель компонента выбора значений.
+
--
Атрибуты элемента `lookup`:

[[gui_TokenList_lookup_lookup]]
** Атрибут `lookup` задает возможность выбора значений через экран выбора сущностей:
+
image::gui_tokenListLookup.png[align="center"]

[[gui_TokenList_lookup_lookupScreen]]
** Атрибут `lookupScreen` задает идентификатор экрана для выбора значений в режиме `lookup="true"`. Если данный атрибут не задан, то идентификатор экрана выбора определяется по правилам, описанным для <<picker_actions,стандартного действия>> `PickerField.LookupAction`.

** Атрибут `openType` можно задать способ открытия экрана выбора, аналогично описанному для <<picker_actions,стандартного действия>> `PickerField.LookupAction`. По умолчанию - `++THIS_TAB++`.

[[gui_TokenList_lookup_multiselect]]
** Если значение атрибута `multiselect` установлено в `true`, то в мэп параметров экрана выбора в ключе `MULTI_SELECT` передается значение `true`. Этот признак можно использовать для установки в экране режима множественного выбора. Данный ключ определен в перечислении `WindowParams`, поэтому с ним удобно работать следующим образом:
+
[source, java]
----
include::{sourcesdir}/gui_vcl/tokenListMultiselect_1.java[]
----
--

[[gui_TokenList_button]]
* `button` − описатель кнопки добавления значений. Может содержать атрибуты <<gui_attr_caption,caption>> и <<gui_attr_icon,icon>>.

'''

Атрибуты tokenList::
<<gui_attr_align,align>> -
<<gui_attr_caption,caption>> -
<<gui_attr_captionProperty,captionProperty>> -
<<gui_attr_datasource,datasource>> -
<<gui_attr_description,description>> -
<<gui_attr_editable,editable>> -
<<gui_attr_enable,enable>> -
<<gui_attr_height,height>> -
<<gui_attr_id,id>> -
<<gui_TokenList_inline,inline>> -
<<gui_TokenList_position,position>> -
<<gui_TokenList_simple,simple>> -
<<gui_attr_stylename,stylename>> -
<<gui_attr_visible,visible>> -
<<gui_attr_width,width>>

Элементы tokenList::
<<gui_TokenList_button,button>> -
<<gui_TokenList_lookup,lookup>>

Атрибуты <<gui_TokenList_lookup,lookup>>::
<<gui_attr_captionProperty,captionProperty>> -
<<gui_LookupField_filterMode,filterMode>> -
<<gui_TokenList_lookup_lookup,lookup>> -
<<gui_TokenList_lookup_lookupScreen,lookupScreen>> -
<<gui_TokenList_lookup_multiselect,multiselect>> -
<<gui_attr_openType,openType>> -
<<gui_attr_optionsDatasource,optionsDatasource>>

Атрибуты <<gui_TokenList_button,button>>::
<<gui_attr_caption,caption>> -
<<gui_attr_icon,icon>>

'''

[[gui_Tree]]
====== Tree

Компонент `Tree` предназначен для отображения иерархической структуры, представленной сущностями, содержащими ссылки на самих себя.

image::gui_Tree.png[align="center"]

XML-имя компонента: `tree`

image::gui_tree_dia.png[align="center"]

Компонент реализован для блоков *Web Client* и *Desktop Client*. 

[[gui_Tree_treechildren]]
Для `Tree` в атрибуте `datasource` элемента `treechildren` должен быть указан <<datasources,hierarchicalDatasource>>. Объявление `hierarchicalDatasource` должно содержать атрибут `hierarchyProperty` - имя атрибута сущности, являющегося ссылкой на саму себя. 

Пример описания компонента `Tree` в XML-дескрипторе экрана:

[source, xml]
----
include::{sourcesdir}/gui_vcl/tree_1.xml[]
----

В атрибуте `captionProperty` элемента `treechildren` можно задать имя свойства сущности, отображаемого в дереве. Если этот атрибут не определен, то будет отображаться <<namePattern,имя экземпляра>> сущности.

[[gui_Tree_multiselect]]
Атрибут `multiselect` позволяет задать режим множественного выделения элементов дерева. Если `multiselect` равен `true`, то пользователь может выделить несколько элементов с помощью клавиатуры или мыши, удерживая клавиши *Ctrl* или *Shift*. По умолчанию режим множественного выделения отключен.

Метод `setItemClickAction()` позволяет задать <<gui_Action,действие>>, которое будет выполнено при двойном клике по узлу дерева.

'''

Атрибуты tree::
<<gui_attr_enable,enable>> -
<<gui_attr_height,height>> -
<<gui_attr_id,id>> -
<<gui_Tree_multiselect,multiselect>> -
<<gui_attr_stylename,stylename>> -
<<gui_attr_visible,visible>> -
<<gui_attr_width,width>>

Элементы tree::
<<gui_Table_actions,actions>> -
<<gui_Tree_treechildren,treechildren>>

Атрибуты treechildren::
<<gui_attr_captionProperty,captionProperty>> -
<<gui_attr_datasource,datasource>>

'''

[[gui_TreeTable]]
====== TreeTable

Компонент `TreeTable` − иерархическая таблица, отображающая в первой колонке древовидную структуру. Предназначена для работы с сущностями, которые содержат ссылки на самих себя. Это могут быть например, файловая система или организационная структура предприятия.

image::gui_treeTable.png[align="center"]

XML-имя компонента: `treeTable`

image::gui_TreeTable_dia.png[align="center"]

Компонент реализован для блоков *Web Client* и *Desktop Client*. 

Для `TreeTable` в атрибуте `datasource` элемента `rows` должен быть указан <<datasources,hierarchicalDatasource>>. Объявление `hierarchicalDatasource` должно содержать атрибут `hierarchyProperty` - имя атрибута сущности, являющегося ссылкой на саму себя. 

Пример описания таблицы в XML-дескрипторе экрана:

[source, xml]
----
include::{sourcesdir}/gui_vcl/treetable_1.xml[]
----

Функциональность `TreeTable` аналогична простой таблице <<gui_Table,Table>>. 

'''

Атрибуты treeTable::
<<gui_attr_align,align>> -
<<gui_Table_aggregatable,aggregatable>> -
<<gui_Table_aggregationStyle,aggregationStyle>> -
<<gui_Table_columnControlVisible,columnControlVisible>> -
<<gui_Table_allowPopupMenu,contextMenuEnabled>> -
<<gui_Table_editable,editable>> -
<<gui_attr_enable,enable>> -
<<gui_attr_height,height>> -
<<gui_attr_id,id>> -
<<gui_Table_multiLineCells,multiLineCells>> -
<<gui_Table_multiselect,multiselect>> -
<<gui_Table_presentations,presentations>> -
<<gui_Table_reorderingAllowed,reorderingAllowed>> -
<<gui_Table_sortable,sortable>> -
<<gui_attr_stylename,stylename>> -
<<gui_attr_visible,visible>> -
<<gui_attr_width,width>>

Элементы treeTable::
<<gui_Table_actions,actions>> -
<<gui_Table_buttonsPanel,buttonsPanel>> -
<<gui_Table_columns,columns>> -
<<gui_Table_rows,rows>> -
<<gui_Table_rowsCount,rowsCount>>

Атрибуты <<gui_Table_columns,column>>::
<<gui_Table_column_align,align>> -
<<gui_Table_column_caption,caption>> -
<<gui_attr_captionProperty,captionProperty>> -
<<gui_Table_column_collapsed,collapsed>> -
<<gui_DateField_dateFormat,dateFormat>> -
<<gui_Table_column_editable,editable>> -
<<gui_Table_column_id,id>> -
<<gui_Table_column_link,link>> -
<<gui_Table_column_linkInvoke,linkInvoke>> -
<<gui_Table_column_linkScreen,linkScreen>> -
<<gui_Table_column_linkScreenOpenType,linkScreenOpenType>> -
<<gui_Table_column_maxTextLength,maxTextLength>> -
<<gui_attr_optionsDatasource,optionsDatasource>> -
<<gui_DateField_resolution,resolution>> -
<<gui_Table_column_sortable,sortable>> -
<<gui_attr_visible,visible>> -
<<gui_Table_column_width,width>>

Элементы <<gui_Table_columns,column>>::
<<gui_Table_column_aggregation,aggregation>> -
<<gui_formatter,formatter>>

Атрибуты <<gui_Table_rows,rows>>::
<<gui_attr_datasource,datasource>>

'''

[[gui_TwinColumn]]
====== TwinColumn

Компонент `TwinColumn` представляет собой сдвоенный список для множественного выбора опций. В левом списке содержатся доступные невыбранные значения, в правом списке содержатся выбранные значения. Пользователь выбирает значения, перенося их из левого в правый список и обратно с помощью двойного клика или соответствующих кнопок. Для каждого значения можно задать уникальный стиль отображения и пиктограмму.

image::TwinColumn.png[align="center"]

XML-имя компонента: `twinColumn`

image::gui_TwinColumn_dia.png[align="center"]

Компонент реализован только для блока *Web Client*.

Пример использования компонента `twinColumn` для выбора экземпляров сущности:

[source, xml]
----
include::{sourcesdir}/gui_vcl/twincolumn_1.xml[]
----

В данном случае компонент `coloursField` отобразит <<namePattern,имена экземпляров>> сущности `Colour`, находящихся в источнике данных `coloursDs`, а его метод `getValue()` вернет коллекцию выбранных экземпляров сущности.

[[gui_TwinColumn_addAllBtnEnabled]]
Атрибут `addAllBtnEnabled` задает отображение кнопок, позволяющих перемещать между списками все опции сразу.

[[gui_TwinColumn_columns_rows]]
Атрибут `columns` используется для задания количества символов в строке, а атрибут `rows` − для задания количества строк текста в каждом списке. 

Для задания внешнего вида опций можно реализовать интерфейс `TwinColumn.StyleProvider` и возвращать название стиля и путь к пиктограмме в зависимости от конкретного экземпляра сущности, отображаемого в компоненте.

Список опций компонента `TwinColumn` может быть задан произвольно с помощью методов `setOptionsList()` и `setOptionsMap()`, аналогично описанному для компонента <<gui_OptionsGroup,OptionsGroup>>.

'''

Атрибуты twinColumn::
<<gui_attr_align,align>> -
<<gui_TwinColumn_addAllBtnEnabled,addAllBtnEnabled>> -
<<gui_attr_caption,caption>> -
<<gui_attr_captionProperty,captionProperty>> -
<<gui_TwinColumn_columns_rows,columns>> -
<<gui_attr_datasource,datasource>> -
<<gui_attr_description,description>> -
<<gui_attr_editable,editable>> -
<<gui_attr_enable,enable>> -
<<gui_attr_height,height>> -
<<gui_attr_id,id>> -
<<gui_attr_optionsDatasource,optionsDatasource>> -
<<gui_attr_property,property>> -
<<gui_attr_required,required>> -
<<gui_attr_requiredMessage,requiredMessage>> -
<<gui_TwinColumn_columns_rows,rows>> -
<<gui_attr_stylename,stylename>> -
<<gui_attr_visible,visible>> -
<<gui_attr_width,width>>

Элементы twinColumn::
<<gui_validator,validator>>

'''

[[gui_layouts]]
===== Контейнеры

<<gui_BoxLayout,BoxLayout>>

<<gui_ButtonsPanel,ButtonsPanel>>

<<gui_Frame,Frame>>

<<gui_GridLayout,GridLayout>>

<<gui_GroupBoxLayout,GroupBoxLayout>>

<<gui_ScrollBoxLayout,ScrollBoxLayout>>

<<gui_SplitPanel,SplitPanel>>

<<gui_TabSheet,TabSheet>>

[[gui_BoxLayout]]
====== BoxLayout

`BoxLayout` представляет собой контейнер с последовательным размещением компонентов.

Существует три типа `BoxLayout`, определяемых именем XML-элемента:

* `hbox` − горизонтальное расположение компонентов.
+
image::gui_hbox.png[align="center"]
+
[source, xml]
----
include::{sourcesdir}/gui_vcl/boxlayout_1.xml[]
----

* `vbox` − вертикальное расположение компонентов. `vbox` имеет 100% ширину по умолчанию.
+
image::gui_vbox.png[align="center"]
+
[source, xml]
----
include::{sourcesdir}/gui_vcl/boxlayout_2.xml[]
----

* `flowBox` − горизонтальное расположение компонентов с переносом вниз. При недостатке места по горизонтали непомещающиеся компоненты будут перенесены "на следующую строку" (поведение аналогично *Swing* `FlowLayout`).
+
image::gui_flowbox.png[align="center"]
+
[source, xml]
----
include::{sourcesdir}/gui_vcl/boxlayout_3.xml[]
----

'''

Атрибуты hbox, vbox, flowBox::
<<gui_attr_align,align>> -
<<gui_attr_enable,enable>> -
<<gui_attr_expand,expand>> -
<<gui_attr_height,height>> -
<<gui_attr_id,id>> -
<<gui_attr_margin,margin>> -
<<gui_attr_spacing,spacing>> -
<<gui_attr_stylename,stylename>> -
<<gui_attr_visible,visible>> -
<<gui_attr_width,width>>

'''

[[gui_ButtonsPanel]]
====== ButtonsPanel

`ButtonsPanel` - контейнер, унифицирующий использование и размещение компонентов (чаще всего кнопок) для управления данными в таблице.

image::gui_buttonsPanel.png[align="center"]

XML-имя компонента: `buttonsPanel`.

Пример описания `ButtonsPanel` в XML-дескрипторе экрана:

[source, xml]
----
include::{sourcesdir}/gui_vcl/buttonspanel_1.xml[]
----

Элемент `buttonsPanel` можно разместить как внутри `table`, так и в произвольном месте экрана. 

Если `buttonsPanel` находится внутри `table`, то она комбинируется с компонентом <<gui_Table_rowsCount,rowsCount>> таблицы, тем самым оптимально расходуя место по вертикали. Кроме того, в этом случае при открытии экрана выбора методом `Frame.openLookup()` (например, из компонента <<gui_PickerField,PickerField>>) панель кнопок скрывается.

[[gui_ButtonsPanel_alwaysVisible]]
Атрибут `alwaysVisible` служит для отключения скрытия панели в экране выбора при его открытии методом `Frame.openLookup()`. Если значение атрибута равно `true`, то панель с кнопками не скрывается. По умолчанию значение атрибута равно `false`.

'''

Атрибуты buttonsPanel::
<<gui_attr_align,align>> -
<<gui_ButtonsPanel_alwaysVisible,alwaysVisible>> -
<<gui_attr_enable,enable>> -
<<gui_attr_expand,expand>> -
<<gui_attr_height,height>> -
<<gui_attr_id,id>> -
<<gui_attr_stylename,styleName>> -
<<gui_attr_visible,visible>> -
<<gui_attr_width,width>>

'''

[[gui_GridLayout]]
====== GridLayout

`GridLayout` - контейнер, располагающий компоненты по сетке.

image::gui_gridlayout.png[align="center"]

XML-имя компонента: `grid`.

Пример использования контейнера:

[source, xml]
----
include::{sourcesdir}/gui_vcl/gridlayout_1.xml[]
----

Элементы `grid`:
[[gui_GridLayout_columns]]
* `columns` - обязательный элемент, описывает колонки сетки. Должен либо иметь атрибут `count`, либо вложенные элементы `column` для каждой колонки.
+
[[gui_GridLayout_columns_count]]
В простейшем случае достаточно задать число колонок в атрибуте `count`. Тогда, если ширина всего контейнера явно задана в пикселах или процентах, незанятое место будет распределяться между колонками равными долями.
+
[[gui_GridLayout_column_flex]]
Для распределения незанятого места неравными долями необходимо определить для каждой колонки элемент `column` и задать для него атрибут `flex`.
+
Пример сетки, в которой вторая и четвертая колонки занимают все лишнее место по горизонтали, причем четвертая колонка забирает себе в три раза больше лишнего места:
+
[source, xml]
----
include::{sourcesdir}/gui_vcl/gridlayout_2.xml[]
----
+
Если атрибут `flex` не указан, или указано значение 0, то ширина данной колонки будет установлена по содержимому, если хотя-бы одна другая колонка имеет ненулевой `flex`. В приведенном примере первая и третья колонки получат ширину по максимальной длине текста надписей.
+
[TIP]
====
Для того, чтобы лишнее место вообще образовалось, необходимо установить всему контейнеру ширину в пикселах или процентах. В противном случае ширина колонок будет рассчитана по ширине содержимого, и атрибут `flex` не будет иметь никакого эффекта.
====

[[gui_GridLayout_rows]]
* `rows` − обязательный элемент, содержит последовательность строк. Каждая строка определяется в своем элементе `row`.
+
[[gui_GridLayout_row_flex]]
Элемент `row` может содержать атрибут `flex`, аналогичный описанному для `column`, но влияющий на распределение лишнего места по вертикали при заданной общей высоте сетки.
+
Элемент `row` должен содержать элементы компонентов, отображаемых в ячейках данной строки сетки. Число компонентов в одной строке не должно превышать заданного количества колонок, но может быть меньше.

Любой компонент, находящийся в контейнере `grid`, может иметь атрибуты <<gui_attr_colspan,colspan>> и <<gui_attr_rowspan,rowspan>>. Эти атрибуты задают соответственно сколько колонок и строк будет занимать данный компонент. Например, так можно растянуть поле `Field3` на три колонки:

[source, xml]
----
include::{sourcesdir}/gui_vcl/gridlayout_3.xml[]
----

В результате компоненты будут располагаться следующим образом:

image::gui_gridlayout_colspan.png[align="center"]

'''

Атрибуты grid::
<<gui_attr_align,align>> -
<<gui_attr_enable,enable>> -
<<gui_attr_height,height>> -
<<gui_attr_id,id>> -
<<gui_attr_margin,margin>> -
<<gui_attr_spacing,spacing>> -
<<gui_attr_stylename,styleName>> -
<<gui_attr_visible,visible>> -
<<gui_attr_width,width>>

Элементы grid::
<<gui_GridLayout_columns,columns>> -
<<gui_GridLayout_rows,rows>>

Атрибуты columns::
<<gui_GridLayout_columns_count,count>>

Атрибуты column::
<<gui_GridLayout_column_flex,flex>>

Атрибуты row::
<<gui_GridLayout_row_flex,flex>> -
<<gui_attr_visible,visible>>

'''

[[gui_GroupBoxLayout]]
====== GroupBoxLayout

`GroupBoxLayout` - контейнер, позволяющий выделить рамкой содержащиеся в нем компоненты, и задать им общий заголовок. Кроме того, он умеет сворачивать свое содержимое.

image::gui_groupBox.png[align="center"]

XML-имя компонента: `groupBox`.

Пример описание контейнера в XML-дескрипторе экрана:

[source, xml]
----
include::{sourcesdir}/gui_vcl/groupboxlayout_1.xml[]
----

Атрибуты `groupBox`:

* `caption` - заголовок группы.

[[gui_GroupBox_orientation]]
* `orientation` - задает направление расположения вложенных компонентов − `horizontal` или `vertical`. По умолчанию `vertical`.

[[gui_GroupBox_collapsable]]
* `collapsable` − значение `true` позволяет пользователю скрывать содержимое компонента с помощью значков image:gui_groupBox_minus.png[]/image:gui_groupBox_plus.png[].

[[gui_GroupBox_collapsed]]
* `collapsed` − если указано значение `true`, то содержимое компонента будет свернуто сразу после открытия экрана. Используется совместно с `collapsable="true"`. 
+
Пример свернутого `GroupBox`:
+
image::gui_groupBox_collapsed.png[align="center"]

Контейнер `groupBox` по умолчанию имеет ширину 100% аналогично <<gui_BoxLayout,vbox>>.

'''

Атрибуты groupBox::
<<gui_attr_align,align>> -
<<gui_attr_caption,caption>> -
<<gui_GroupBox_collapsable,collapsable>> -
<<gui_GroupBox_collapsed,collapsed>> -
<<gui_attr_expand,expand>> -
<<gui_attr_height,height>> -
<<gui_attr_id,id>> -
<<gui_GroupBox_orientation,orientation>> -
<<gui_attr_spacing,spacing>> -
<<gui_attr_stylename,stylename>> -
<<gui_attr_width,width>>

'''

[[gui_Frame]]
====== Frame

Элемент `frame` предназначен для включения в экран <<frame,фреймов>>.

Атрибуты:

[[gui_Frame_src]]
* `src` − путь к XML-дескриптору фрейма.

[[gui_Frame_screen]]
* `screen` - идентификатор фрейма в <<screens.xml,screens.xml>> (если фрейм зарегистрирован).

Должен быть указан один из этих атрибутов. Если указано оба, фрейм будет загружен из явно указанного в `src` файла.

'''

Атрибуты frame::
<<gui_attr_align,align>> -
<<gui_attr_height,height>> -
<<gui_attr_id,id>> -
<<gui_Frame_screen,screen>> -
<<gui_Frame_src,src>> -
<<gui_attr_stylename,stylename>> -
<<gui_attr_visible,visible>> -
<<gui_attr_width,width>>

'''

[[gui_ScrollBoxLayout]]
====== ScrollBoxLayout

`ScrollBoxLayout` − контейнер, который позволяет прокручивать свое содержимое.

image::gui_scrollBox.png[align="center"]

XML-имя компонента: `scrollBox`

Пример описание контейнера с прокруткой в XML-дескрипторе экрана:

[source, xml]
----
include::{sourcesdir}/gui_vcl/scrollboxlayout_1.xml[]
----

[[gui_ScrollBox_orientation]]
* С помощью атрибута `orientation` можно задавать направление расположения вложенных компонентов − `horizontal` или `vertical`. По умолчанию `vertical`.

[[gui_ScrollBox_scrollBars]]
* Атрибут `scrollBars` позволяет настраивать полосы прокрутки. Может принимать значения `horizontal`, `vertical` - для прокрутки по горизонтали и вертикали соответственно, `both` - для прокрутки во всех направлениях. Установка значения `none` запрещает прокрутку в любом направлении

[WARNING]
====
Вложенные в `scrollBox` компоненты должны иметь фиксированные размеры или размеры по умолчанию. Нельзя устанавливать `height="100%"` или `width="100%"`.

В то же время `scrollBox` не может вычислять свои собственные размеры по содержимому. Ему нужно либо указать абсолютные размеры, либо растянуть в родительском контейнере, установив `height="100%"` и `width="100%"`.
====

'''

Атрибуты scrollBox::
<<gui_attr_align,align>> -
<<gui_attr_height,height>> -
<<gui_attr_id,id>> -
<<gui_attr_margin,margin>> -
<<gui_ScrollBox_orientation,orientation>> -
<<gui_ScrollBox_scrollBars,scrollBars>> -
<<gui_attr_spacing,spacing>> -
<<gui_attr_stylename,stylename>> -
<<gui_attr_width,width>>

'''

[[gui_SplitPanel]]
====== SplitPanel

`SplitPanel` − контейнер, разбитый на две области, размер которых по горизонтали либо вертикали можно менять путем перемещения разделителя. 

image::gui_splitPanel.png[align="center"]

XML-имя компонента: `split`.

Пример описания панели с разделителем в XML-дескрипторе экрана:

[source, xml]
----
include::{sourcesdir}/gui_vcl/splitpanel_1.xml[]
----

Внутри контейнера `split` обязательно должны находиться два вложенных контейнера или компонента, которые и будут расположены по обе стороны разделителя.

Атрибуты `split`:

[[gui_SplitPanel_orientation]]
* `orientation` - задает ориентацию расположения компонентов. `horizontal` - вложенные компоненты располагаются горизонтально, `vertical` - вертикально.

[[gui_SplitPanel_pos]]
* `pos` - целое число, определяющее процентное соотношение размера первой области по отношению ко второй. Например, `pos="30"` означает соотношение областей 30/70. По умолчанию соотношение областей составляет 50/50.

[[gui_SplitPanel_locked]]
* Если атрибут `locked` установлен в `true`, то пользователи не смогут изменить положение разделителя.

'''

Атрибуты split::
<<gui_attr_align,align>> -
<<gui_attr_height,height>> -
<<gui_attr_id,id>> -
<<gui_SplitPanel_locked,locked>> -
<<gui_SplitPanel_orientation,orientation>> -
<<gui_SplitPanel_pos,pos>> -
<<gui_attr_width,width>>

'''

[[gui_TabSheet]]
====== TabSheet

Контейнер `TabSheet` - это панель с вкладками (`tabs`). В один момент времени отображается содержимое только одной вкладки.

image::gui_tabsheet.png[align="center"]

XML-имя компонента: `tabSheet`.

Пример описания панели с вкладками в XML-дескрипторе экрана:

[source, xml]
----
include::{sourcesdir}/gui_vcl/tabsheet_1.xml[]
----

Компонент `tabSheet` должен иметь вложенные элементы `tab`, описывающие вкладки. Каждая вкладка является контейнером с вертикальным расположением компонентов, аналогичным <<gui_BoxLayout,vbox>>.

Атрибуты элемента `tab`:

[[gui_TabSheet_tab_id]]
* `id` - идентификатор вкладки. Следует отметить, что вкладка не является компонентом, и данный идентификатор используется только в рамках `TabSheet` для работы с ней из кода контроллера.

* <<gui_attr_caption,caption>> - заголовок вкладки.

[[gui_TabSheet_tab_lazy]]
* `lazy` - задает отложенную загрузку содержимого вкладки. 
+
При открытии экрана lazy-вкладки не загружают свое содержимое, что приводит к созданию меньшего количества компонентов в памяти. Компоненты вкладки загружаются только в тот момент, когда пользователь выбирает данную вкладку. Кроме того, если на lazy-вкладке расположены визуальные компоненты, связанные с <<datasources,источником данных>>, содержащим JPQL запрос, то этот запрос также не выполняется. В результате экран открывается быстрее, а данные загружаются только в тот момент, когда пользователь действительно хочет их увидеть, выбирая данную вкладку. 
+
Следует иметь в виду, что компоненты, расположенные на lazy-вкладке, не существуют в момент открытия экрана. Поэтому их нельзя <<screen_controller_injection,инжектировать>> в контроллер, и нельзя получить вызовом `getComponent()` в методе `init()` контроллера. Обратиться к компонентам `lazy`-вкладки можно только после того, как пользователь на нее переключился. Этот момент можно отловить с помощью слушателя `TabSheet.TabChangeListener`, например: 
+
[source, java]
----
include::{sourcesdir}/gui_vcl/tabsheet_2.java[]
----
+
По умолчанию вкладки не являются `lazy`, а значит, загружают свое содержимое в момент открытия экрана.

[[gui_TabSheet_tab_detachable]]
* `detachable` - значение `true` в десктоп-реализации экрана дает возможность отсоединять вкладку в отдельное окно. Это позволяет, например, размещать части UI приложения на разных мониторах. Отделяемая вкладка имеет специальную кнопку в заголовке:
+
image::gui_tabsheetDetachable.png[align="center"]

'''

Атрибуты tabSheet::
<<gui_attr_height,height>> -
<<gui_attr_id,id>> -
<<gui_attr_stylename,stylename>> -
<<gui_attr_visible,visible>> -
<<gui_attr_width,width>>

Атрибуты tab::
<<gui_attr_caption,caption>> -
<<gui_TabSheet_tab_detachable,detachable>> -
<<gui_attr_enable,enable>> -
<<gui_attr_expand,expand>> -
<<gui_attr_margin,margin>> -
<<gui_TabSheet_tab_id,id>> -
<<gui_TabSheet_tab_lazy,lazy>> -
<<gui_attr_spacing,spacing>> -
<<gui_attr_stylename,stylename>> -
<<gui_attr_visible,visible>>

'''

[[gui_misc]]
===== Разное

В данном разделе рассматриваются различные элементы универсального пользовательского интерфейса, имеющие отношение к визуальным компонентам.

[[gui_formatter]]
====== Formatter

Formatter предназначен для преобразования некоторого значения в строку.

[WARNING]
====
Formatter предназначен для использования с read-only компонентами, такими как <<gui_Label,Label>>, колонка <<gui_Table,Table>> и тому подобными. Для форматирования значения в редактируемых компонентах, например <<gui_TextField,TextField>>, используйте механизм `<<datatype,Datatype>>`.
====

В XML-дескрипторе экрана formatter для компонента может быть задан во вложенном элементе `formatter`. Элемент имеет единственный атрибут:

* `class` − имя класса, реализующего интерфейс `com.haulmont.cuba.gui.components.Formatter`

Если конструктор класса formatter принимает параметр типа `org.dom4j.Element`, то ему будет передан элемент XML, описывающий данный `formatter`. Это можно использовать для параметризации экземпляра formatter'а, например, строкой форматирования. В частности, имеющиеся в платформе классы `DateFormatter` и `NumberFormatter` могут брать строку форматирования из атрибута `format`. Пример использования:

[source, xml]
----
include::{sourcesdir}/gui_vcl/formatter_1.xml[]
----

Кроме того, класс `DateFormatter` распознает также атрибут `type`, который может принимать значения `DATE` или `DATETIME`. В этом случае форматирование производится с помощью механизма `<<datatype,Datatype>>` по строке формата `dateFormat` или `dateTimeFormat` соответственно. Например:

[source, xml]
----
include::{sourcesdir}/gui_vcl/formatter_2.xml[]
----

[TIP]
====
Если formatter реализован внутренним классом, то он должен быть объявлен с модификатором `static`, а его имя для загрузки отделяется символом "$", например:

`<formatter class="com.sample.sales.gui.OrderBrowse$CurrencyFormatter"/>`
====

Formatter можно назначить компоненту не только в XML-дескрипторе экрана, но и программно, передавая экземпляр formatter'а в метод `setFormatter()` компонента.

Пример объявления собственного formatter'а и использования его для форматирования значения колонки таблицы:

[source, java]
----
include::{sourcesdir}/gui_vcl/formatter_3.java[]
----

[source, java]
----
include::{sourcesdir}/gui_vcl/formatter_4.java[]
----

[[gui_presentations]]
====== Presentations

Механизм представлений позволяет пользователям системы управлять настройками отображения таблиц.

image::gui_presentations.png[align="center"]

Пользователи могут:

* Сохранять представления под уникальными именами. Настройки таблицы автоматически сохраняются в активном представлении.

* Редактировать и удалять представления.

* Переключаться между представлениями.

* Задавать представление по умолчанию, которое будет применяться при открытии экрана.

* Создавать глобальные представления, доступные всем пользователям системы. Для создания, изменения и удаления глобальных представлений пользователь должен иметь <<permissions,разрешение>> `cuba.gui.presentations.global`.

Представления доступны в компонентах, реализующих интерфейс `com.haulmont.cuba.gui.components.Component.HasPresentations`. В платформе такими компонентами являются:

* <<gui_Table,Table>>

* <<gui_GroupTable,GroupTable>>

* <<gui_TreeTable,TreeTable>>

[[gui_Timer]]
====== Timer

Таймер − это невизуальный компонент, позволяющий выполнять некоторый код контроллера экрана через определенные промежутки времени. Срабатывание таймера происходит в потоке обработки событий пользовательского интерфейса, что позволяет обновлять экран без каких-либо ограничений. Таймер прекращает работу при закрытии экрана, для которого он был создан.

Компонент реализован для блоков *Web Client* и *Desktop Client*. Для веб клиента реализация таймеров основана на опросе сервера из веб-браузера, для десктоп клиента - на `javax.swing.Timer`.

Основной способ создания таймеров - декларативно в XML-дескрипторе экрана в элементе `timers`, располагающемся между элементами `dsContext` и `layout`. 

Для описания таймера используется элемент `timer`.

* Атрибут `delay` является обязательным атрибутом, в нем задается интервал срабатывания таймера в миллисекундах.

* `autostart` - необязательный атрибут, при установке которого в `true` таймер стартует сразу после открытия экрана. По умолчанию `false`, что означает что для старта таймера необходимо вызвать его метод `start()`.

* `repeating` − необязательный атрибут, включает многократное срабатывание таймера. Если значение атрибута равно `true`, то таймер выполняется циклически, через равные промежутки времени, заданные в атрибуте `delay`. В противном случае таймер выполняется один раз через `delay` миллисекунд после старта таймера.

* `onTimer` − необязательный атрибут, содержащий имя метода, вызываемого при срабатывании таймера. Метод-обработчик должен быть определен в контроллере экрана с модификатором `public` и иметь один параметр типа `com.haulmont.cuba.gui.components.Timer`. 

Пример использования таймера для периодического обновления содержимого таблицы:

[source, xml]
----
include::{sourcesdir}/gui_vcl/timer_1.xml[]
----

[source, java]
----
include::{sourcesdir}/gui_vcl/timer_2.java[]
----

Таймер можно инжектировать в поле контроллера, либо получить методом `Window.getTimer()`. Управлять активностью таймера можно с помощью его методов `start()` и `stop()`. Для уже активного таймера вызов `start()` игнорируется. После остановки таймера методом `stop()` его можно снова запустить методом `start()`.

Пример определения таймера в XML дескрипторе и использования листенеров в контроллере:

[source, xml]
----
include::{sourcesdir}/gui_vcl/timer_3.xml[]
----

[source, java]
----
include::{sourcesdir}/gui_vcl/timer_4.java[]
----

Таймер можно также создавать в коде контроллера следующим образом:

[source, java]
----
include::{sourcesdir}/gui_vcl/timer_5.java[]
----

[[gui_validator]]
====== Validator

Валидатор предназначен для проверки значения, введенного в визуальном компоненте.

[WARNING]
====
Следует отличать валидацию от проверки типа данных. Если для некоторого компонента, например <<gui_TextField,TextField>>, задан тип, отличный от строкового (это происходит при связывании с атрибутом сущности или назначении `datatype`), то компонент не позволяет ввести значение, не удовлетворяющее этому типу - при потере фокуса или нажатии *Enter* компонент отобразит предыдущее значение.

Валидация же срабатывает не сразу при вводе или потере компонентом фокуса, а только при вызове у компонента метода `validate()`. Это означает, что компонент (и связанный с ним атрибут сущности) может некоторое время содержать значение, не удовлетворяющее условиям валидации. Это не является проблемой, так как обычно компоненты ввода с валидацией располагаются в <<screen_edit,экране редактирования>>, а он автоматически вызывает валидацию всех своих компонентов перед коммитом. Если же компонент находится не в экране редактирования, то необходимо вызывать его метод `validate()` в контроллере явно.
====

В XML-дескрипторе экрана валидатор для компонента может быть задан во вложенном элементе `validator`. Возможные атрибуты элемента `validator`:

* `script` − путь к скрипту Groovy, осуществляющему валидацию.

* `class` − имя класса Java, реализующего интерфейс `Field.Validator`.

Groovy-валидатор и стандартные классы Java-валидаторов, расположенные в пакете `com.haulmont.cuba.gui.components.validators` поддерживают атрибут `message` − сообщение, выводимое пользователю в случае ошибки валидации. Атрибут должен содержать сообщение или ключ в пакете сообщений экрана, например:

[source, xml]
----
include::{sourcesdir}/gui_vcl/validator_1.xml[]
----

[source, properties]
----
include::{sourcesdir}/gui_vcl/validator_1.properties[]
---- 

Выбор механизма валидации осуществляется следующим образом:

* Если не указано значение атрибута `script`, и сам элемент `validator` не содержит текста выражения Groovy, то в качестве валидатора используется класс, указанный в атрибуте `class`.

* Если элемент `validator` содержит текст, то он будет использован как выражение Groovy и выполнен с помощью <<scripting,Scripting>>.

* В противном случае с помощью <<scripting,Scripting>> будет выполнен скрипт Groovy, указанный в атрибуте `script`.

В выражение или скрипт Groovy будет передана одна переменная `value`, содержащая значение, введенное в визуальном компоненте. Выражение или скрипт должны вернуть `boolean` значение: `true` − valid, `false` − not valid.

Если в качестве валидатора используется класс Java, то он должен иметь либо дефолтный конструктор без параметров, либо конструктор со следующим набором параметров: 

* `org.dom4j.Element`, `String` - в этот конструктор будут переданы XML-элемент валидатора и имя пакета сообщений экрана.

* `org.dom4j.Element` - в этот конструктор будет передан XML-элемент валидатора.

[TIP]
====
Если валидатор реализован внутренним классом, то он должен быть объявлен с модификатором `static`, а его имя для загрузки отделяется символом "$", например:

[source, xml]
----
<validator class="com.sample.sales.gui.AddressEdit$ZipValidator"/>
----
====

Платформа уже содержит несколько реализаций наиболее часто используемых валидаторов (см. пакет `com.haulmont.cuba.gui.components.validators`), которые можно применять в проектах:

* `DateValidator`

* `DoubleValidator`

* `EmailValidator`

* `IntegerValidator`

* `LongValidator`

* `PatternValidator`

* `RangeValidator`

* `ScriptValidator`

* `StringValidator`

Валидатор-класс можно назначить компоненту не только в XML-дескрипторе экрана, но и программно, передавая экземпляр валидатора в метод `addValidator()` компонента.

Пример создания класса валидатора почтового индекса: 

[source, java]
----
include::{sourcesdir}/gui_vcl/validator_2.java[]
---- 

Использование валидатора почтового индекса и стандартного валидатора по шаблону в полях компонента <<gui_FieldGroup,FieldGroup>>: 

[source, xml]
----
include::{sourcesdir}/gui_vcl/validator_3.xml[]
---- 

Пример программного задания валидатора: 

[source, java]
----
include::{sourcesdir}/gui_vcl/validator_4.java[]
---- 

[[gui_attributes]]
===== XML-атрибуты компонентов

[[gui_attr_align]]
align:: 
+
--
Атрибут, задающий расположение компонента относительно вышестоящего контейнера.

Возможные значения:

* `++TOP_RIGHT++`

* `++TOP_LEFT++`

* `++TOP_CENTER++`

* `++MIDDLE_RIGHT++`

* `++MIDDLE_LEFT++`

* `++MIDDLE_CENTER++`

* `++BOTTOM_RIGHT++`

* `++BOTTOM_LEFT++`

* `++BOTTOM_CENTER++`

--

[[gui_attr_caption]]
caption:: 
+
--
Атрибут, устанавливающий заголовок для визуального компонента.

Значением атрибута должна быть либо строка сообщения, либо ключ в <<message_packs,пакете сообщений>>. В случае ключа значение должно начинаться с префикса `msg://`

Способы задания ключа:

* Короткий ключ − при этом сообщение ищется в пакете, заданном для данного экрана:
+
[source, plain]
----
caption="msg://infoFieldCaption"
----

* Полный ключ, с заданием пакета:
+
[source, plain]
----
caption="msg://com.company.sample.gui.screen/infoFieldCaption"
----

--

[[gui_attr_captionProperty]]
captionProperty:: 
+
--
Задает имя атрибута сущности, отображаемого компонентом. Используется только для сущностей, находящихся в источнике данных (например заданном для <<gui_LookupField,LookupField>> свойством <<gui_attr_optionsDatasource,optionsDatasource>>).

Если `captionProperty` не задан, будет отображаться <<namePattern,имя экземпляра>>.
--

[[gui_attr_colspan]]
colspan:: 
+
--
Указывает, сколько колонок сетки должен занять компонент (по умолчанию 1).

Данный атрибут может быть назначен любому компоненту, находящемуся непосредственно внутри контейнера <<gui_GridLayout,GridLayout>>.
--

[[gui_attr_datasource]]
datasource:: 
+
--
Предназначен для задания <<datasources,источника данных>>, описанного в секции `dsContext` XML-дескриптора экрана.

При указании атрибута `datasource` для компонента, реализующего интерфейс `DatasourceComponent`, необходимо также задать атрибут <<gui_attr_property,property>>.
--

[[gui_attr_description]]
description:: 
Атрибут, задающий текст подсказки для компонента.

[[gui_attr_editable]]
editable:: 
+
--
Атрибут, указывающий на возможность редактирования содержимого компонента (не путать с <<gui_attr_enable,enable>>).

Возможные значения − `true`, `false`. По умолчанию `true`.

На возможность редактирования содержимого для компонента, связанного с данными (наследника `DatasourceComponent` или `ListComponent`), влияет также подсистема безопасности. Если по данным <<chapter_security,подсистемы безопасности>> данный компонент должен быть недоступен для редактирования, значение атрибута `editable` не принимается во внимание.
--

[[gui_attr_enable]]
enable:: 
+
--
Атрибут компонента, устанавливающий его состояние: доступен, недоступен.

Если компонент недоступен, то он не принимает фокус ввода. Недоступность контейнера приводит к тому, что все его компоненты также становятся недоступными. Возможные значения − `true`, `false`. По умолчанию все компоненты доступны.
--

[[gui_attr_expand]]
expand:: 
+
--
Атрибут контейнера для управления его внутренней компоновкой.

Задает компонент внутри контейнера, который необходимо расширить на все доступное пространство в направлении размещения компонентов. Для контейнера с вертикальным размещением устанавливает компоненту 100% высоту, для контейнера с горизонтальным размещением - 100% ширину. Кроме того, при изменении размера контейнера изменять размер будет именно этот компонент.
--

[[gui_attr_height]]
height:: 
+
--
Атрибут, устанавливающий высоту компонента.

Может быть задана в пикселях либо в процентах от высоты вышестоящего контейнера. Например: `100px`, `100%`, `50`. Если единица измерения не указана, подразумевается высота в пикселях.

Установка значения в `%` означает, что компонент по высоте займет соответствующую часть пространства, предоставляемого контейнером более высокого уровня.

При выборе значения `AUTO` или `-1px` для компонента устанавливается высота по умолчанию, для контейнера высота определяется по содержимому, то есть суммарной высотой вложенных компонентов.
--

[[gui_attr_icon]]
icon:: 
+
--
Атрибут, устанавливающий пиктограмму для визуального компонента.

Значением атрибута должен быть путь к файлу пиктограммы относительно каталога <<gui_themes,темы>>. Например:

[source, xml]
----
icon="icons/create.png"
----

Если пиктограмма должна быть выбрана в зависимости от языка пользователя, можно указать путь к ней в пакете сообщений, а в атрибуте `icon` − ключ сообщения, например: 

[source, xml]
----
icon="msg://addIcon"
---- 

В веб клиенте с <<web_theme,темой>> Halo (или производной от нее) вместо файлов можно использовать элементы шрифта Font Awesome. Для этого достаточно указать константу из класса `com.vaadin.server.FontAwesome` с префиксом `font-icon:` например: 

[source, xml]
----
icon="font-icon:BOOK"
----
--

[[gui_attr_id]]
id:: 
+
--
Идентификатор компонента.

Рекомендуется формировать значение по правилам Java-идентификаторов и использовать camelСase, например, `userGrid`, `filterPanel`.Может быть указан для любого компонента и должен быть уникальным в пределах экрана.
--

[[gui_attr_inputPrompt]]
inputPrompt:: 
+
--
Атрибут `inputPrompt` задает строку, отображаемую в поле, если его значение равно `null`.

Атрибут используется для компонентов <<gui_TextField,TextField>>, <<gui_LookupField,LookupField>>, <<gui_LookupPickerField,LookupPickerField>>, <<gui_SearchPickerField,SearchPickerField>> только в веб клиенте.
--

[[gui_attr_margin]]
margin:: 
+
--
Атрибут `margin` устанавливает наличие отступа между внешними границами и содержимым контейнера.

Может иметь два вида значений:

* `margin="true"` − установить отступ со всех сторон сразу

* `margin="true,false,true,false"` − установить отступ только сверху и снизу (формат значения "сверху,справа,снизу,слева")

По умолчанию отступы отсутствуют.
--

[[gui_attr_nullName]]
nullName:: 
+
--
Идентификатор опции, выбор которой будет равносилен установке значения в `null`.

Атрибут используется для компонентов <<gui_LookupField,LookupField>>, <<gui_LookupPickerField,LookupPickerField>>, <<gui_SearchPickerField,SearchPickerField>>.

Пример для компонента <<gui_LookupField,LookupField>>, установка значения атрибута в <<screen_xml_glossentry,XML-дескрипторе>>:

[source, xml]
----
include::{sourcesdir}/gui_vcl/nullname_1.xml[]
----

Пример для компонента <<gui_LookupField,LookupField>>, установка значения атрибута в <<screen_controller_glossentry,контроллере>>: 

[source, xml]
----
include::{sourcesdir}/gui_vcl/nullname_2.xml[]
----

[source, java]
----
include::{sourcesdir}/gui_vcl/nullname_3.java[]
----
--

[[gui_attr_openType]]
openType::
+
--
Задает режим открытия связанного экрана. Соответствует перечислению `WindowManager.OpenType` со значениями `NEW_TAB`, `THIS_TAB`, `NEW_WINDOW`, `DIALOG`.  По умолчанию `THIS_TAB`.
--

[[gui_attr_optionsDatasource]]
optionsDatasource:: 
+
--
Задает имя <<datasources,источника данных>>, используемого для формирования списка опций.

Совместно с `optionsDatasource` может использоваться атрибут <<gui_attr_captionProperty,captionProperty>>.
--

[[gui_attr_property]]
property:: 
+
--
Атрибут компонента, реализующего интерфейс `DatasourceComponent`.

Предназначен для задания имени атрибута сущности, значение которого будет отображаться или редактироваться данным визуальным компонентом.

Используется всегда совместно с атрибутом <<gui_attr_datasource,datasource>>.
--

[[gui_attr_required]]
required:: 
+
--
Атрибут визуального компонента, реализующего интерфейс `Field`. Указывает, что в данное поле обязательно должно быть введено значение.

Возможные значения атрибута − `true`, `false`. По умолчанию `false`.

Совместно с `required` может использоваться атрибут <<gui_attr_requiredMessage,requiredMessage>>.
--

[[gui_attr_requiredMessage]]
requiredMessage:: 
+
--
XML-атрибут, используемый совместно с атрибутом <<gui_attr_required,required>>. Позволяет установить сообщение, выводимое пользователю в случае нарушения требования <<gui_attr_required,required>>.

Атрибут может содержать сообщение или ключ в пакете сообщений, например: `requiredMessage="msg://infoTextField.requiredMessage"`
--

[[gui_attr_rowspan]]
rowspan:: 
+
--
Указывает, сколько строк сетки должен занять компонент (по умолчанию 1).

Данный атрибут может быть назначен любому компоненту, находящемуся непосредственно внутри контейнера <<gui_GridLayout,GridLayout>>.
--

[[gui_attr_spacing]]
spacing:: 
+
--
Атрибут `spacing` устанавливает наличие отступов между компонентами внутри контейнера.

Возможные значения − `true`, `false`.

По умолчанию отступы отсутствуют.
--

[[gui_attr_stylename]]
stylename:: 
Атрибут, задающий имя стиля компонента. Подробнее см. <<gui_themes>>.
[[gui_attr_visible]]
visible:: 
+
--
Атрибут, устанавливающий видимость компонента. Возможные значения − `true`, `false`. 

Если контейнер невидим, не видны и все его компоненты. По умолчанию все компоненты видимы.
--

[[gui_attr_width]]
width:: 
+
--
Атрибут, устанавливающий ширину компонента.

Значение может быть задано в пикселях или в процентах от ширины вышестоящего контейнера. Например: `100px`, `100%`, `50`. Если единица измерения не указана, подразумевается ширина в пикселях. Простановка значения в `%` означает, что компонент по ширине займет соответствующую часть пространства, предоставляемого контейнером более высокого уровня.

При выборе значения `AUTO` или `-1px` для компонента устанавливается ширина по умолчанию, для контейнера ширина определяется по содержимому, то есть суммарной шириной вложенных компонентов.
--

