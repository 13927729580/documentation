[[creation]]
== Creating Reports

Creating a report in the system involves two dependent elements: visual presentation template and description of the data extracted for the report. The template is created in XLS(X), DOC(X), HTML formats using external tools, and the description of report data is created in the report designer screen.

Depending on the template and report parameters, the generated report can be in PDF, XLS(X), DOC(X) or HTML.

The report data structure can either be described in the report designer by creating bands, queries and other elements, or programmed in a Java class that implements a special interface. The report can take parameters from the user or from the calling code. You can specify users who will have access to the report, and system screens where it should appear.

The main components of the report generator are shown in the following diagram:

image::reporting.png[align="center"]

* `YARG` - framework, which is the core of the report generator.
* `Report Engine` integrates YARG into CUBA platform and provides additional functionality such as access rights to reports and integration with screens.
* `Report Designer` is a tool for describing and storing reports. It includes the infrastructure for storing report descriptions and templates, as well as screens to create and manage reports.
* `Report` - report data structure descriptor, including _Bands_ (report bands) and _Datasets_ (datasets which are being output in the bands).
* `Report Template` - report visual presentation template.

[[structure]]
=== Report Data Structure

The *Report structure* tab of the report editor is described below:

image::report_structure.png[align="center"]

The top part contains fields to enter general report properties:

* *Name* - report name. The name can be localized in the *Localization* tab.
* *Group* - report group, which is used for grouping in the standard report browser.
* *Default template* - report output <<template,template>>.
* *System code* - optional code, which you may use to identify the report in the application code.

The main element of the report data structure is the band hierarchy - *Report bands*.

A report band has the following parameters:

* *Band name* - unique band name within the report. It must contain only Latin letters, numbers and underscores.
* *Orientation* - band orientation: *Horizontal* or *Vertical*. Horizontal bands are copied downwards, vertical - to the right. Horizontal bands may contain sub-bands.
* *Parent band* - parent band.

Each band includes one or more datasets. At the moment when a report is run, datasets are transformed into lists of rows, where each row contains a map of name-value pairs. A band appears in the report as many times as there are rows in its longest dataset. Field names are specified in the report template and are replaced with corresponding values from the dataset when the report is produced. When describing datasets, you can use <<parameters,external parameters>> of the report as well as fields from other bands - this allows creating linked bands.

Each report has the *Root* band. You can create datasets in it and refer to their fields from other bands, but you cannot use the *Root* band in the report template.

The *Dataset name* column value is used for user convenience only.

The *Link field* is used to merge data from multiple datasets inside one band. It can be used when the whole data for the report row could not be received by a single query or a Groovy script.

Supported dataset types are described below.

[[structure_sql]]
==== SQL Dataset

*SQL* dataset is produced as result of SQL query execution. It is recommended to use aliases for query result fields with the help of the `as` operator. It is also recommended to enclose the aliases in double quotes to prevent possible case conversion by the DBMS:

[source, sql]
----
select u.name as "userName", u.login as "userLogin" 
from sec_user u
----

You can use report input parameters and parent bands fields in the query. Parameters should be addressed by name enclosed in `${}`, for example, `${dateFrom}`. Parent band fields should be addressed similarly, by adding the band name in front of the field name: `${band1.field1}`.

Below is an example of an SQL query with a `groupId` parameter, obtained from the `group` parent band and an external  `active` parameter:

[source, sql]
----
select u.name as "userName", u.login as "userLogin" 
from sec_user u
where u.group_id = ${group.groupId} 
    and u.active = ${active}
    and u.delete_ts is null
----

[WARNING]
====
You should manually include conditions to filter soft deleted records for SQL queries.
====

By default, SQL queries are executed on the main database. If you want to query an additional data store (see Developer's Manual), set its name in the *Data store* field.

[[query_preprocessing]]
Query preprocessing in bands::
+
--
If you need to modify the SQL/JPQL query dynamically depending on the report input parameters, or the parameter values from the parent band, you can use the SQL preprocessing. The template engine enables you to modify SQL/JPQL queries using Groovy. In order to activate it, check the *Preprocess query as Groovy template* checkbox below the band editor. The resulting query will be processed by `GStringTemplateEngine` that will have access to:

* the report parameters: `${<parameter_name>}`,

* values from parent bands: `{<band_name>.<parameter_name>}`.

Let's consider the following example: depending on whether the `createTs2` report parameter is passed you need to select one of the query conditions: `e.create_ts < ${createTs2}` or `e.create_ts < current_timestamp`.

In this case the query should look like:

[source, sql]
----
select e.create_ts, e.id, e.vin from ref_car e
where
e.create_ts >= \${createTs1}
and
<% out << (createTs2 != null  ? 'e.create_ts < ${createTs2}' : 'e.create_ts < current_timestamp')%>
----

Thus, if the `createTs2` parameter is not passed, the initial query will be transformed into the following resulting query:

[source, sql]
----
select e.create_ts, e.id, e.vin from ref_car e
where
e.create_ts >= \${createTs1}
and
e.create_ts < current_timestamp
----

If `createTs2` is passed, the following resulting query will be used for the band:

[source, sql]
----
select e.create_ts, e.id, e.vin from ref_car e
where
e.create_ts >= \${createTs1}
and
e.create_ts < ${createTs2}
----
--

[[structure_jpql]]
==== JPQL Dataset

*JPQL* dataset is produced as result of JPQL query execution. The resulted query fields must have aliases provided using the `as` operator. You can use report input parameters and parent bands fields in the JPQL query, similar to SQL query.

Below is an example of a JPQL query with a `groupId` parameter, obtained from the `group` parent band and an external `active` parameter:

[source, jpql]
----
select u.name as userName, u.login as userLogin
from sec$User u
where u.group.id = ${group.groupId}
    and u.active = ${active}
----

JPQL queries automatically support soft deletion and return only records which are not deleted.

You can also activate <<query_preprocessing,query preprocessing>> by checking the *Preprocess query as Groovy template* checkbox below the band editor.

By default, JPQL queries use entities mapped to the the main database. If you want to query entities from an additional data store (see Developer's Manual), set its name in the *Data store* field.

[[structure_groovy]]
==== Groovy Dataset

*Groovy* dataset is produced as result of a Groovy script execution. The script must return an object of the `List<Map<String, Object>>` type. Each element of this list - an object of the `Map<String, Object>` type - corresponds to one dataset record.

The following objects are passed into the script:

* `dataManager` - an object of the `com.haulmont.cuba.core.global.DataManager` type that provides CRUD functionality. For example:
+
[source, groovy]
----
LoadContext<Book> loadContext = LoadContext.create(Book.class)
        .setId(bookId)
        .setView("book.edit")
def book = dataManager.load(loadContext)
----

* `metadata` - an object of the `com.haulmont.cuba.core.global.Metadata` type, providing access the application metadata. For example:
+
[source, groovy]
----
def metaClass = metadata.getClassNN('sec$User')
----

* `params` - external report parameters map. Below is an example to get a parameter value:
+
[source, groovy]
----
def active = params['active']
----

* `parentBand` - parent band as an object of the `com.haulmont.yarg.structure.BandData` type. This object allows you to get a parent band field value by invoking the `getParameterValue()` method, for example:
+
[source, groovy]
----
def groupId = parentBand.getParameterValue('groupId')
----

* `persistence` - an object of the `com.haulmont.cuba.core.Persistence` type that allows you to manage transactions and get the `EntityManager`, for example:
+
[source, groovy]
----
def tx = persistence.createTransaction()
try {
    def em = persistence.getEntityManager()
    def query = em.createQuery('select g from sec$Group g')
...
    tx.commit()
} finally {
    tx.end()
}
----
+
For working with an additional data store, pass its name as a parameter to `createTransaction()` and `getEntityManager()` methods. By default, the main database is used.
+
[source, groovy]
----
def tx = persistence.createTransaction('myStore')
try {
    def em = persistence.getEntityManager('myStore')
...
    tx.commit()
} finally {
    tx.end()
}
----

* `security` -  an object of the `com.haulmont.cuba.core.global.Security` type used to check user access rights to different objects in the system. For example:
+
[source, groovy]
----
if (security.isEntityOpPermitted(Book.class, EntityOp.READ) {
    ...
}
----

* `timeSource` - an object of the `com.haulmont.cuba.core.global.TimeSource` type used to obtain the current time. For example:
+
[source, groovy]
----
def currentDate = timeSource.currentTimestamp()
----

* `transactional` - a method that takes a closure, which should be executed in a new transaction, as parameter. The current `EntityManager` becomes the closure parameter. For example:
+
[source, groovy]
----
transactional { em ->
    def query = em.createQuery('select g from sec$Group g')
    ...
}
----
+
Below is an example of the Groovy script which extracts users by the group which is output in the parent band and by the `active` external parameter:
+
[source, groovy]
----
def result = []
transactional { em ->
    def query = em.createQuery('select u from sec$User u where u.group.id = ?1 and u.active = ?2')
    query.setParameter(1, parentBand.getParameterValue('groupId'))
    query.setParameter(2, params['active'])
    query.resultList.each { user ->
        result.add(['userLogin': user.login, 'userName': user.name])
    }
}
return result
----

* `userSession` - an object of the `com.haulmont.cuba.security.global.UserSession` type associated with the currently authenticated user. For example:
+
[source, groovy]
----
def user = userSession.currentOrSubstitutedUser
----

* `userSessionSource` - an object of the `com.haulmont.cuba.core.global.UserSessionSource` type which is used to obtain current user session object. For example:
+
[source, groovy]
----
def locale = userSessionSource.locale
----

[TIP]
====
You can use static methods of the `AppBeans` class to access any Spring beans of the middleware tier, for example:

[source, groovy]
----
def myService = com.haulmont.cuba.core.global.AppBeans.get('sample_MyService')
----
====

[[structure_entity]]
==== Entity Dataset

*Entity* dataset consists of a single row and is produced using attributes of a single entity instance and the entities related to it.

The data source is produced from an external parameter of the *Entity* type, which must be described in the *Parameters and Formats* tab. The value in the *Entity parameter name* field must match the parameter name.

The report template must contain fields with entity attribute names. Attributes used in the template should be listed in the special window, which is invoked by the *Select entity attributes* button.

[[structure_list]]
==== List of Entities Dataset

*List of entities* dataset is produced using a list of entity instances.

The data source is produced using an external parameter being a *List of entities*, which must be described in the *Parameters and Formats* tab. The value in the *Entity parameter name* field must match the parameter alias.

The report template must contain fields with entity attribute names. Attributes used in the template should be listed in the special window, which is invoked by the *Entity attributes* button.

[[structure_json]]
==== JSON Dataset

*JSON* dataset is generated from JSON data. This data can be received from the following sources:

. *Groovy script*
+
--
The script provided by the user is supposed to return JSON data as a string.

For example:

[source, plain]
----
include::{sourcesdir}/json.groovy[]
----
--

. *URL*
+
--
The report engine will perform a GET HTTP query against the URL.

For example:

[source, plain]
----
https://jsonplaceholder.typicode.com/users
----
--

. *Parameter of a String type*
+
--
The report external parameter of String type which contains the JSON data must be described in the *Parameters and Formats* tab.
--

The received JSON tree is queried using the JsonPath query. For example, you can use the `$.store.book[*]` JsonPath to return all books from the following JSON tree:

[source, json]
----
include::{sourcesdir}/json.json[]
----

For more details on JsonPath expressions see http://goessner.net/articles/JsonPath/.

[[template]]
=== Report Template

You can create several templates for a single report in the *Templates* tab of the report editor. One of them must be selected as the default template in the *Report structure* tab.

Below is the form to add a template:

image::report_template.png[align="center"]

* *Template code* - template code for its identification.

* *Output type* - report output type. It should be consistent with the template file type according to the rules described in <<template_to_output>>.

* *Template file* - template file, which is loaded from the file system and saved to the database along with the report structure description.

* *Output name pattern* - optional file name pattern, which will be used for the produced report download.
It can either be a constant string or contain report parameter as a variable, e.g. `${header.authorName}.xlsx`. More sophisticated patterns with several parameters and string concatenation can also be created as a script in any band of report structure, e.g. `${Root.title}.xlsx`, where `title` is a result of the script:
+
[source, groovy]
----
[['title' : ('Report for '+params['author'].firstName+' '+params['author'].lastName)]]
----

* *Defined with class* - flag to use the template <<template_custom,defined by a class>>.

* *Custom class name* - template class name used if the *Defined with class* flag is set.

[[template_xls]]
==== XLSX and XLS Templates

You can create XLSX and XLS templates using Microsoft Office or LibreOffice.

Each report band must have a corresponding region in the template, which is named as the band. For instance, a report has two bands - Header and Data. This means that template should also have Header and Data named ranges. To create named regions, select the desired cell ranges and enter the name in the field in the application top left corner. To edit existing named regions, use the *Formulas* -> *Name Manager* menu command in Microsoft Office, and the *Insert* -> *Names* -> *Manage* command in OpenOffice.
Vice versa, each part of the sheet you want to show should be a band in report (at least an empty band).

The bands are output in the order specified in the <<structure,report structure>>.

Bands can be horizontally and vertically oriented. If the band is horizontal, suitable named region will grow downward, vertical will grow rightward. Horizontal bands may be organized in tree-like structure and contain sub-bands (nested or children bands). Therefore, for sub-bands, you need to create named regions directly under the regions that correspond to the parent bands.
XLSX formatter render children bands using the following algorithm:

* Write the first row of parent band ->
* Write all first row's children rows ->
* Write the next row of parent band.

The band dataset fields are placed in the template using strings having `++${field_name}++` format, where `++field_name++` is the corresponding band field name. For example:

image::report_template_xls.png[align="center"]

You can add variables to the reporting template. Variables should be inserted into sheet names or the header/footer of XLSX template having `++${<BandName>.<variableName>}++` format.

Cells may contain formatting as well as multiple fields inside. To output images or formulas, you need to place them entirely into the corresponding named region linked with the band.

Formulas can reference the cells of the same band or another band. To be processed by formatter, the formulas should use either range of cells in the band, or direct cells coordinates, e.g. `(A1*B1)` or `($B:$B)`.

To process the data as an Excel chart, create a band and a same-named region for this chart, and make a reference to related bands using *Select data* button in the chart context menu. If your chart data is in a continuous range of cells, select any cell in that range. Your chart will include all the data in the range. If your data isn't in a continuous range, select nonadjacent cells or ranges.

Converting XLSX to PDF and CSV::
+
--
XLSX reports can be automatically converted to CSV and PDF format. <<open_office,OpenOffice/LibreOffice>> should be installed for the PDF conversion.

image::csv_output.png[align="center"]
--

[[crosstab_xls]]
===== Crosstab Reports

You can create a crosstab, or matrix, report using Microsoft Office or LibreOffice.

The report template should contain a horizontal band with a vertical child band, as report generator allows only horizontal bands to have children. The child band will use a result from the parent band as the query parameter.

Below is an example of a template which outputs the list of `Operators` vertically and `Calls` made by each operator horizontally grouped by the dates of calls.

image::crosstab_template.png[align="center"]

The vertical `DataHeader` band fills the report with call dates to the right:

[source, sql]
----
include::{sourcesdir}/crosstab_template_1.jpql[]
----

The horizontal `Operators` band  lists the names of operators from up to down:

[source, sql]
----
include::{sourcesdir}/crosstab_template_2.jpql[]
----

The nested vertical `Data` band uses the operators `id` from the parent band as a query parameter to fill the matrix:

[source, groovy]
----
include::{sourcesdir}/crosstab_template_3.groovy[]
----

As a result, the report is extended both vertically and horizontally:

image::crosstab_report.png[align="center"]

[[template_csv]]
==== CSV Templates

You can create CSV templates using Microsoft Office or LibreOffice.

Bands in CSV template should be horizontally oriented, so the suitable named region will grow downward. Also, bands should belong to the first level of data, i.e. be the children of the Root band. In all other respects, the same principles as for <<template_xls,XLS/XLSX templates>> should be used.

.CSV template example
image::csv_template.png[align="center"]

.CSV output
image::csv_report.png[align="center"]

[[template_doc]]
==== DOCX and DOC Templates

You can create DOC and DOCX templates using Microsoft Office or OpenOffice / LibreOffice.

A template of these types can include document text and optionally one or more tables. The document text outputs the data from the first rows of arbitrary bands. In a table, you can output an arbitrary number of band rows.

To place a field in the document text, you should use a string having `++${band_name.field_name}++` format, where `++band_name++` is the band name, `++field_name++` - name of a band's field.

In order to output data into a table, you should tie it to a band. This is done by specifying `++##band=band_name++` in the table's first cell, where `++band_name++` is the band name. The table fields are placed using `++${field_name}++` format, where `++field_name++` is the field name of the band associated with the table. You can use band name prefix to access fields of other bands, same as in the document text fields. You can output several fields in a single table cell.

Horizontal bands in DOCX and DOC cannot contain sub-bands. If you need to use sub-bands, you would better use XLS(X) format.
[WARNING]
====
The table must contain either one or two rows. If the table has two rows, then the corresponding band fields must be in the second row. The first row should contain the marker with the corresponding band name and, if necessary, static text or other band fields.
====

Below is an example of a template which outputs a report consisting of two bands, `Book` and `Authors`. The first band outputs a book name and genre, and the second outputs a list of authors of this book.

image::report_template_doc.png[align="center"]

[WARNING]
====
Cells data format is not supported in DOCX and DOC templates. To avoid numbers or dates formatting problems due to user's locale, such as unnecessary numeric separators, try to cast your data to string.
For example, wrap
[source, sql]
----
select e.year as "year"
----
into
[source, sql]
----
select cast(e.year as varchar(4)) as "year"
----
====

[[template_html]]
==== HTML Template

An HTML template is defined in an `.html` file (`UTF-8` encoding without `BOM`). You can use HTML/CSS features of https://github.com/flyingsaucerproject/flyingsaucer[Flying Saucer] library, its main guide is available at http://flyingsaucerproject.github.io/flyingsaucer/r8/guide/users-guide-R8.html

To control page size, page headers and footers, use special CSS rules and properties. You can find an example of a report with repeatable header and footer blocks in the <<example_html,Sample Reports>> section.

FreeMarker tags are used to place data (FreeMarker documentation is available at http://freemarker.org/docs).

The FreeMarker document model has the following structure:

[source, groovy]
----
Band { 
      bands [ bandName : [ band, .. ], .. ]
      fields [ fieldName : fieldValue, .. ] 
}
----

For example, you should use the following expression to access the `name` field in a row having index 0 of the `band` band:

[source, groovy]
----
Root.bands.band[0].fields.name
----

You may use variables for convenience, e.g.:

[source, html]
----
<#assign headerRow = Root.bands.Header[0]>
<p>Date: ${headerRow.fields.reportDate}</p>
----

Below is an example of a template which outputs a report consisting of two bands, `Book` and `Authors`. The first band outputs a book name and genre, and the second outputs a list of authors of this book.

[source, html]
----
include::{sourcesdir}/examples_html_6.html[]
----

Below is a more complex example. Let us assume we have the following bands structure:

[source, groovy]
----
Root {
    HeaderBand {
        query = return [[ "name" : "Column1" ],[ "name" : "Column2" ]]
    }
    Band1 {
        query = return [
                ["field1" : "Value 11", "field2" : "Value 12"],
                ["field1" : "Value 21" , "field2" : "Value 22"]
        ]
    }
    Band2 {
        query = return [[ "header" : "Header1" ], [ "header" : "Header2" ]]
        SubBand1 {
            query = return [["header" : 'SubHeader1'] , [ "header" : 'SubHeader2' ]]
        }
    }
}
----

* Inserting a field:

[source, html]
----
include::{sourcesdir}/examples_html_8.html[]
----

* Inserting a list:

[source, html]
----
include::{sourcesdir}/examples_html_9.html[]
----

* Inserting a table:

[source, html]
----
include::{sourcesdir}/examples_html_10.html[]
----

* Inserting a multi-level list:

[source, html]
----
include::{sourcesdir}/examples_html_11.html[]
----

*Embedded pictures*

At the moment, CUBA Reporting add-on does not provide means of inserting images into HTML-reports similarly to DOCX/XLSX reports. Images still can be embedded with the `img` tag and the link to the picture in the `src` attribute. There are two ways to add images to the HTML-report:

* by URL
+
An image can be hosted on the Tomcat server or any external hosting up to the local file reference. For example, the image hosted in the `deploy\tomcat\webapps\ROOT\images` folder can be inserted like:
[source, html]
----
<img src="http://localhost:8080/images/SomeImage.jpg" height="68" width="199" border="0" align="right"/>
----

* by Bitmap
+
An image is added as a byte array within the `src` attribute. This approach allows you to use variables for the `FileDescriptor` attributes of the entities. The byte array can even be added directly to the template, even though this approach is not recommended:
[source, html]
----
<img alt="SomePicture.png" src="data:image/png;base64,iVBORw0K ..... AcEP9PwxD0hNKK1FCAAAAAElFTkSuQmCC"/>
----

[[html_to_pdf]]
===== Converting HTML to PDF

Reports which have a template in HTML format and the PDF output format do not always properly display fonts. To resolve this, add `cuba/fonts` subdirectory with required `.ttf` fonts to the Middleware configuration directory (`tomcat/conf/app-core` in default deployment configuration). Additionally, you can use existing operating system fonts by specifying their path in the <<reporting.fontsDir,reporting.fontsDir>> application property.

In order to resolve the fonts issue on a Ubuntu server, you should do the following:

* Install the `ttf-mscorefonts-installer` package:
+
----
$ sudo apt-get install ttf-mscorefonts-installer
----

* Set the <<reporting.fontsDir,reporting.fontsDir>> application property:
+
----
reporting.fontsDir = /usr/share/fonts/truetype/msttcorefonts
----

* Explicitly specify fonts in HTML templates, for example:

[source, html]
----
<html>
<head>
    <style type="text/css">
        * {
            font-family: Times New Roman;
        }
    </style>
----

Another thing to mention is parsing of special characters. To avoid errors when converting HTML to PDF, it is recommended to wrap your fields in `<![CDATA[ ]]>` construction in your HTML template file:
[source, html]
----
<tr>
	<td> <![CDATA[${(row.fields('book_name'))!?string!}]]> </td>
	<td> <![CDATA[${(row.fields('author'))!?string!}]]> </td>
</tr>
----
[[template_custom]]
==== Class-Defined Template

Class-defined templates are used when it is too difficult or impossible to select data using SQL, JPQL or Groovy. They are used, for example, when the report is a result of combining several other reports. 

The class defining the template must implement the `com.haulmont.yarg.formatters.CustomReport` interface. In the class, you need to define the `createReport()` method, which returns an array of bytes and takes the following input parameters:

* `report` - report descriptor of the `com.haulmont.yarg.structure.Report` type.
* `rootBand` - root band data of the `com.haulmont.yarg.structure.BandData` type.
* `params` - map of external report parameters.

Below is an example of a simple class-defined template. It creates an HTML document showing the name of a book selected as report parameter: 

[source, java]
----
package com.sample.library.report;

import com.haulmont.yarg.formatters.CustomReport;
import com.haulmont.yarg.structure.BandData;
import com.haulmont.yarg.structure.Report;
import com.sample.library.entity.Book;
import java.util.Map;

public class BookReport implements CustomReport {
    @Override
    public byte[] createReport(Report report, BandData rootBand, Map<String, Object> params) {
        Book book = (Book) params.get("book");
        String html = "<html><body>";
        html += "<p>Name: " + book.getName() + "</p>";
        html += "</body></html>";
        return html.getBytes();
    }
}
----

[[template_chart]]
==== Chart Template

Chart output type is available if the application project includes the *charts* component. Resulting chart is displayed in the *Reports* -> *Show Charts* screen of your web application.

Two types of diagrams are supported: Pie chart and Serial chart. Each type has its own set of parameters.

Pie chart:

image::chart_template_pie.png[align="center"]

* *Band name* - a band providing data for the chart.
* *Title field* - a field from which segment names will be taken.
* *Value field* - a field from which segment values will be taken.
* *Color field* - a field from which segment colors will be taken. The color value should be specified in the https://en.wikipedia.org/wiki/Web_colors[web] format. If not defined, colours will be chosen automatically.
* *Units* - this text will be added to legend values.

Serial chart:

image::chart_template_serial.png[align="center"]

* *Band name* - a band providing data for the chart.
* *Category field* - a field from which category names will be taken.
* *Category axis caption* - a caption for the horizontal axis.
* *Value axis caption* - a caption for the vertical axis.
* *Value axis units* - this text will be added to values.

At least one row definition must be added for the serial chart:

* *Value field* - a field from which row values will be taken.
* *Type* - row display type.
* *Color field* - a field from which segment colors will be taken. The color value should be specified in the https://en.wikipedia.org/wiki/Web_colors[web] format. If not defined, colours will be chosen automatically.

[[table_output]]
==== Table Formatter

Table output is available for all types of reports. To use table formatter, select *Table* as the output type in the report template editor.

image::report_table_output.png[align="center"]

The report generator will get the band data and draw a sortable table for each band from first level of the hierarchy.

The table displays columns for all properties for SQL, JPQL datasets. Is the Entity/List of Entities dataset is used, the table will display only the columns for selected attributes. In the latter case the column names should be localized.

Resulting table is displayed in the *Reports > Show Report Table* screen of your web application. The *Excel* button enables you to download the displayed table as an Excel file.

image::show_report_table.png[align="center"]

[[template_to_output]]
==== Output format compliance matrix

[options="header"]
|===============
|Template / Output|XLSX|XLS|CSV|DOCX|DOC|PDF  |HTML |Chart
|XLSX             |+   |   |+  |    |   |+ ^1^|+ ^1^|
|XLS              |    |+  |   |    |   |+ ^1^|     |
|CSV              |    |+  |+  |    |   |+ ^1^|     |
|DOCX             |    |   |   |+   |   |+ ^2^|+ ^2^|
|DOC              |    |   |   |    |  +|+ ^1^|     |
|HTML             |    |   |   |    |   |+    |+    |
|Chart            |    |   |   |    |   |     |     |+
|===============

^1^ - OpenOffice/LibreOffice must be <<open_office,installed>> for output.

^2^ - depending on the <<reporting.openoffice.docx.useOfficeForPdfConversion,reporting.openoffice.docx.useOfficeForPdfConversion>> application property, the output can be performed with or without OpenOffice/LibreOffice. In the latter case, you need to provide required fonts, as described in <<html_to_pdf>>.

[[parameters]]
=== External Report Parameters

External parameters are passed from the outside when running a report and can be used as conditions in datasets. All external parameters become fields for each report band, so you can use them directly in the template as dataset fields. If any dataset contains field with the same name, it overrides the external parameter in the corresponding band and the report uses the dataset field value.

You can describe the external parameters in the *Parameters and Formats* tab of the report editor. The form for adding parameters is provided below:

image::report_parameter.png[align="center"]

*Properties* tab:

* *Caption* - parameter name, as it will appear in the parameter input form when running the report.
* *Parameter alias* - parameter alias used to access it in datasets.
* *Parameter type* - parameter type.
* *Hidden* - flag that defines whether the request for parameter should be hidden from users.
* *Required parameter?* - flag determining if the parameter is mandatory.
* *Entity* - if the *Entity* or *List of entities* of entities parameter type is selected, then you need to select the entity type in this field.
* *Entity selection screen* - optional screen identifier, which will be used to select entity instances. If the screen is not specified, selection will be made from a special screen generic for all entities.
* *Enumeration* - if the *Enumeration* parameter type is specified, then you need to select the enumeration type in this field.
* *Default value* - defines the parameter value that will be used by default if no other value is selected by the user.
* *Default date(time) is current* - if the temporal parameter type is specified (`Date`, `Time` or `Date and time`), this flag defines whether the current timestamp will be used as the default parameter value.

In the *Localization* tab, you can define the parameter name for different locales. In order to do this, you should enter the `++locale_name = parameter_name++` pairs, for example:

[source, properties]
----
ru = Книга
----

The *Transformation* tab allows you to apply a Groovy script on the parameter before using it in the report.

In the *Validation* tab, you can define a Groovy scripts with some condition for the parameter validation, see the details below.

[[report_parameter_validation]]
Input parameters validation::
+
--
You can validate an input parameter and/or define the cross-parameter validation.

. You can enable validation of each parameter in the *Validation* tab of parameter editor by checking the *Validate* checkbox. The validation logic is specified be the Groovy script. The script should check the parameter value and call the `invalid()` method if the value is not valid. This method will show the user an alert with the given message about the report validation errors.
+
The following variables are passed into the script:
+
* `value` - the parameter value entered by the user.
+
* `dataManager` - an object of the `DataManager` type that provides CRUD functionality.
+
* `metadata` - an object of the `Metadata` type that provides access to the application metadata.
+
* `security` - an object of the `Security` type used to check user access rights to different objects in the system.
+
* `userSession` - an object of the `UserSession` type associated with the currently authenticated user.
+
image::report_parameter_validation.png[align="center"]

. Cross-parameter validation can be enabled by checking the *Validate* checkbox in the *Cross parameters validation* section of the *Parameters and Formats* tab. The validation logic is specified by the Groovy script. The script should check whether or not parameters values make sense in relation to each other and call the `invalid()` method if they do not. This method will show the user an alert with the given message about the report validation errors.
+
The following variables are passed into the script:
+
* `params` - external report parameters map.
+
* `dataManager` - an object of the `DataManager` type that provides CRUD functionality.
+
* `metadata` - an object of the `Metadata` type that provides access the application metadata.
+
* `security` - an object of the `Security` type used to check user access rights to different objects in the system.
+
* `userSession` - an object of the `UserSession` type associated with the currently authenticated user.
+
image::cross_parameter_validation.png[align="center"]
--

[[formatters]]
=== Field Value Formats

You can specify the formatting for any field output by the report in the *Parameters and Formats* tab of the report editor. Below is the form to add a format:

image::report_formatter.png[align="center"]

* *Value name* - report field name with the band prefix, for example `Book.name`.
* *Format string* - field format. For number values, you must specify the format according to the `java.text.DecimalFormat` rules, for dates - `java.text.SimpleDateFormat`.

With the help of formats, it is possible to insert images and HTML blocks into the document.

* In order to insert an image, you must specify the image URL as the field value and the format string must be as follows: `${image:<Width>x<Height>}`, for example `${image:200x300}`.
+
To work with the the `FileDescriptor`, you can use the `${imageFileId:WxH}` value formatter that accepts both the `FileDescriptor` `id` and the link to the `FileDecriptor` instance itself.

* In order to insert an HTML block, you should return an HTML markup in the field, and select `${html}` as the format string. In the output value, you may omit top-level tags up to `<body>` inclusive. If necessary, all missing top-level tags will be added automatically. All blocks should be encoded with `UTF-8`. CSS and the `style` attribute are not supported.

You can specify your own custom formats as well. To do this, type the new value in the field without opening the dropdown and press Enter. You can also choose any format from the dropdown, edit its name in the field and press Enter. Custom format will be saved in both cases.
[[permissions]]
=== Report Access Rights

You can define user rights to access the report as well as report availability in certain application screens in the *Roles and Screens* tab of the report editor.

If the report roles list contains at least one role, the report will be available only to users with this role. If no roles are specified, the report is available to everyone.

The screens list allows to specify, which screens the report will be available in when invoking `RunReportAction`, `TablePrintFormAction` or `EditorPrintFormAction` <<run_actions, actions>>. If no screen is specified, the report won't be available from any screen.

[[localization]]
=== Report Name Localization

You can localize the report name - show the name in the language, which the user is logged in with, in the report list. In order to do this, you need to go to the *Localization* tab and enter pairs, `++locale_name = report_name++`, as separate lines in the text field, for example:

[source, properties]
----
en = Books by author
ru = Книги по автору
----