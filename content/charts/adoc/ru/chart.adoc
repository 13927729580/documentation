[[chart]]
== Отображение диаграмм

Подсистема отображения диаграмм платформы CUBA поддерживает большое количество типов диаграмм: круговые, линейные,
пузырьковые, лепестковые, диаграммы с накоплением и прочие. Имеется возможность экспорта диаграмм. Для большинства типов
диаграмм поддерживается прокрутка и зуммирование. Подсистема отображения диаграмм работает только в веб клиенте.

Библиотека AmCharts, на которой основана реализация подсистемы отображения диаграмм, распространяется по лицензии,
позволяющей использовать ее бесплатно при сохранении ссылки на сайт библиотеки. Для своего проекта Вы можете
http://www.amcharts.com/online-store/[купить^] лицензию на AmCharts и убрать ссылку.

[[chart_dependency]]
=== Добавление диаграмм в проект
Для использования диаграмм в Вашем проекте, необходимо активировать элемент *charts* в списке *App components* на экране
редактирования свойств проекта (секция *Project properties*, кнопка *Edit*) в CUBA Studio.

[[chart_configuration]]
=== Конфигурация диаграмм

Для отображения диаграмм используется компонент `Chart`, являющийся универсальным холстом. Вид диаграммы задается с помощью конкретного интерфейса <<chart_types,типа диаграммы>>, унаследованного от `Chart`.

Диаграммы можно описывать как в XML-дескрипторе, так и в контроллере экрана. Для описания в дескрипторе необходимо подключить соответствующий `namespace`:

[source, xml]
----
<window xmlns="http://schemas.haulmont.com/cuba/window.xsd"
        xmlns:chart="http://schemas.haulmont.com/charts/charts.xsd"
        ...>
----

Соответствие элементов XML видам диаграмм:

* `chart:xyChart` - XYChart
* `chart:serialChart` - SerialChart
* `chart:pieChart` - PieChart
* `chart:funnelChart` - FunnelChart
* `chart:gaugeChart` - AngularGaugeChart
* `chart:radarChart` - RadarChart
* `chart:ganttChart` - GanttChart

Каждый вид диаграммы имеет свой набор атрибутов и методов, которые повторяют функционал соответствующих диаграмм библиотеки AmCharts. Документация по свойствам и методам диаграмм находится по адресу
http://docs.amcharts.com/3/javascriptcharts[docs.amcharts.com/3/javascriptcharts^].

Все атрибуты конфигурации могут иметь значение `null`, вместо таких значений будут использоваться значения по умолчанию (кроме случаев, указанных в документации AmCharts).

Таким же образом можно описывать диаграммы в контроллере экрана. Можно как указывать отдельные свойства, так и добавлять составные объекты:

[source,java]
----
include::{sourcesdir}/chart/chart_configure.java[]
----

Диаграммы можно сделать отзывчивыми с помощью плагина `responsive`. Он позволяет на лету изменять внешний вид диаграммы, автоматически подстраивая её под изменения разрешения экрана. Больше информации о плагине `responsive` вы можете найти на https://www.amcharts.com/kbase/making-charts-responsive/[сайте AmCharts].

Элемент `responsive` содержит вложенные элементы `rules`, в которых задаются правила отклика диаграмм. Вы можете настроить скрытие/отображение легенды, заголовков осей, разделителей, заголовков диаграмм, ползунков масштаба, перемещение подписей с осей внутрь графика и т.п.:

[source,xml]
----
include::{sourcesdir}/chart/responsive.xml[]
----

Диаграммы могут быть экспортированы из работающего приложения в формате изображения или исходных данных. Для создания меню экспорта используется элемент `chart:export`, включающий по умолчанию следующие атрибуты:

* *Download as...* с доступными форматами: PNG, JPG, SVG, PDF
* *Save as...* с доступными форматами: CSV, XLSX, JSON
* *Annotate...*, используемый для добавления заметок и векторных аннотаций. Информацию о плагине для создания аннотаций вы можете найти https://www.amcharts.com/export-now-supports-annotating-charts-with-text-icons-arrows/[здесь].
* *Print*, открывающий стандартное окно отправки страницы на печать.

image::chart/charts_export_menu_1.png[align="center"]

Меню экспорта может быть настроено для ограничения доступа пользователей к данным диаграммы. Собственное меню экспорта может содержать только формат(ы) изображения, например:

[source,xml]
----
include::{sourcesdir}/chart/chart_export_menu.xml[]
----

В этом случае пользователю будут доступны только кнопки для прямого скачивания диаграммы в заданных форматах:

image::chart/charts_export_menu_2.png[align="center"]

[[chart_data_binding]]
=== Связь с данными

Реализовано три варианта передачи данных в диаграмму: через интерфейс `DataProvider`, через механизм источников данных, или с использованием <<chart_data_simplified,упрощённого API>>, позволяющего привязывать данные напрямую при помощи метода `addData()` и удобных конструкторов класса `MapDataItem`. Последний способ подходит для диаграмм, не привязанных к какому-либо источнику данных.

* Интерфейс `DataProvider` имеет стандартную реализацию: класс `ListDataProvider`. Он содержит список экземпляров `DataItem` из которых будут браться данные для диаграммы. Существует несколько стандартных реализаций интерфейса `DataItem`:
 ** `EntityDataItem` принимает экземпляр сущности.
 ** `MapDataItem` содержит набор пар ключ-значение.
 ** `SimpleDataItem` принимает экземпляр любого `public` класса.

Экземпляр `DataProvider` передается методу `setDataProvider()` конфигурации диаграммы. Данный способ предоставления данных для диаграммы наиболее универсален, однако требует создания экземпляров `DataProvider` и `DataItem` в коде контроллера экрана.

* Источник данных типа `CollectionDatasource` устанавливается для компонента `Chart` вызовом метода `setDatasource()`. Данный вариант требует наличия сущности, представляющей данные диаграммы. Он удобен, когда такая сущность уже есть в модели данных приложения, а также когда данные диаграммы нужно отобразить и в виде таблицы.

В главе <<chart_example>> проиллюстрированы все три способа получения данных.

Используемые для отображения свойства сущности или значения, содержащиеся в экземпляре `DataProvider`, задаются в атрибутах диаграммы, причем атрибуты различаются для разных типов диаграмм. Например для компонента `chart:pieChart` необходимо задать атрибуты `valueField` и `titleField`.В качестве значений могут выступать типы `Integer`, `Long`, `Double`, `String`, `Boolean`, `Date`.

Динамическое добавление данных в существующий график поддерживается для обоих механизмов.

[[chart_listeners]]
=== События

Имеется возможность настроить реакцию на различные типы событий. Следующие типы слушателей событий доступны для всех видов диаграмм:

* `LegendItemHideListener` - скрытие элемента легенды.
* `LegendItemShowListener` - показ элемента легенды.
* `LegendLabelClickListener` - щелчок по ярлыку легенды.
* `LegendMarkerClickListener` - щелчок по маркеру легенды.

Для каждого вида диаграмм также доступны свои типы слушателей:

AngularGaugeChart::
* `ChartClickListener` - щелчок по холсту.
* `ChartRightClickListener` - щелчок по холсту правой клавишей мыши.

FunnelChart::
* `SliceClickListener` - щелчок по элементу круговой диаграммы.
* `SlicePullInListener` - элемент круговой диаграммы соединён с диаграммой.
* `SlicePullOutListener` - элемент круговой диаграммы отсоединён от диаграммы.
* `SliceRightClickListener` - щелчок по элементу круговой диаграммы правой клавишей мыши.

GanttChart::
* `AxisZoomListener` - масштабирование оси графика.
* `ChartClickListener` - щелчок по холсту.
* `ChartRightClickListener` - щелчок по холсту правой клавишей мыши.
* `CursorPeriodSelectListener` - выбор периода отображения курсором.
* `CursorZoomListener` - масштабирование области графика курсором.
* `GraphClickListener` - щелчок по графику.
* `GraphItemClickListener` - щелчок по элементу графика.
* `GraphItemRightClickListener` - щелчок по элементу графика правой клавишей мыши.
* `ZoomListener` - масштабирование холста.

PieChart::
* `ChartClickListener` - щелчок по холсту.
* `ChartRightClickListener` - щелчок по холсту правой клавишей мыши.
* `SliceClickListener` - щелчок по элементу круговой диаграммы.
* `SlicePullInListener` - элемент круговой диаграммы соединён с диаграммой.
* `SlicePullOutListener` - элемент круговой диаграммы отсоединён от диаграммы.
* `SliceRightClickListener` - щелчок по элементу круговой диаграммы правой клавишей мыши.

RadarChart::
* `AxisZoomListener` - масштабирование оси графика.
* `ChartClickListener` - щелчок по холсту.
* `ChartRightClickListener` - щелчок по холсту правой клавишей мыши.
* `GraphClickListener` - щелчок по графику.
* `GraphItemClickListener` - щелчок по элементу графика.
* `GraphItemRightClickListener` - щелчок по элементу графика правой клавишей мыши.

SerialChart::
* `AxisZoomListener` - масштабирование оси графика.
* `ChartClickListener` - щелчок по холсту.
* `ChartRightClickListener` - щелчок по холсту правой клавишей мыши.
* `CursorPeriodSelectListener` - выбор периода отображения курсором.
* `CursorZoomListener` - масштабирование области графика курсором.
* `GraphClickListener` - щелчок по графику.
* `GraphItemClickListener` - щелчок по элементу графика.
* `GraphItemRightClickListener` - щелчок по элементу графика правой клавишей мыши.
* `ZoomListener` - масштабирование холста.

StockChartGroup::
* `DataSetSelectorCompareListener` - сравнение селекторов наборов данных.
* `DataSetSelectorSelectListener` - выбор селектора набора данных.
* `DataSetSelectorUnCompareListener` - отмена сравнения селекторов наборов данных.
* `PeriodSelectorChangeListener` - выбор периода отображения при помощи селектора.
* `StockChartClickListener` - щелчок по холсту фондовой диаграммы.
* `StockChartRightClickListener` - щелчок по холсту фондовой диаграммы правой клавишей мыши.
* `StockEventClickListener` - щелчок по событию фондовой диаграммы.
* `StockEventRollOutListener` - разворачивание события фондовой диаграммы.
* `StockEventRollOverListener` - сворачивание события фондовой диаграммы.
* `StockGraphClickListener` - щелчок по фондовой диаграмме.
* `StockGraphItemClickListener` - щелчок по элементу фондовой диаграммы.
* `StockGraphItemRightClickListener` -  щелчок по элементу фондовой диаграммы правой клавишей мыши.
* `StockGraphItemRollOutListener` - разворачивание элемента фондовой диаграммы.
* `StockGraphItemRollOverListener` - сворачивание элемента фондовой диаграммы.
* `StockGraphRollOutListener` - разворачивание фондовой диаграммы.
* `StockGraphRollOverListener` - сворачивание элемента фондовой диаграммы.
* `ZoomListener` - масштабирование холста.


XYChart::
* `AxisZoomListener` - масштабирование оси графика.
* `ChartClickListener` - щелчок по холсту.
* `CursorPeriodSelectListener` - выбор периода отображения курсором.
* `CursorZoomListener` - масштабирование области графика курсором.
* `GraphClickListener` - щелчок по графику.
* `GraphItemClickListener` - щелчок по элементу графика.
* `GraphItemRightClickListener` - щелчок по элементу графика правой клавишей мыши.

Пример использования событий проиллюстрирован в разделе <<section_use_of_events>>.

Чтобы мигрировать старый код, в котором используются слушатели событий, на новую версию платформы, необходимо привести компонент `Chart` к конкретному типу диаграммы или заново инжектировать его с конкретным типом диаграммы:
[source,java]
----
@Inject
private Chart pieChart;
----
[source,java]
----
((PieChart)pieChart).addSliceClickListener(event -> {});
----

Кроме обработки событий, интерфейс `SeriesBasedChart` содержит методы `zoomOut`, `zoomToIndexes` и `zoomToDates` для манипуляций с осями диаграммы.

Подобные методы для управления осями значений также есть и в интерфейсе `CoordinateChart`: `zoomOutValueAxes`, `zoomOutValueAxis`, `zoomOutValueAxis`, `zoomValueAxisToValues` и `zoomValueAxisToValues`.

[[chart_example]]
=== Пример работы с диаграммами

В данной главе мы рассмотрим применение подсистемы отображения диаграмм.

[[chart_project_setup]]
==== Настройка проекта приложения

. Запустите *CUBA Studio*, создайте новый проект и назовите его `sampler`.

. Откройте окно свойств проекта *Project properties* -> *Edit* и в списке *App components* включите проект *charts*,
затем сохраните изменения. Studio предложит пересоздать скрипты Gradle - согласитесь.

. Запустите *Run* -> *Deploy*. На этом этапе будет произведена сборка приложения, и оно будет развернуто на сервере
Tomcat в подкаталоге `build/tomcat`.

. Запустите *Build* -> *Create or update IDEA project files* чтобы создать проектные файлы для *IntelliJ IDEA*.

После выполнения вышеописанных действий функциональность для отображения диаграмм подключена к приложению и готова к работе. 

[[chart_data_simplified]]
==== Создание диаграммы с использованием Data Binding API

Для первого примера мы создадим максимально простую диаграмму, используя упрощённый API.

Добавим компонент `chart` к экрану. Чтобы наполнить диаграмму данными, используем метод `addData()`. В качестве параметра передадим экземпляры класса `MapDataItem`, содержащие пары ключ-значение:

[source,xml]
----
<chart:pieChart id="pieChart"
                titleField="key"
                valueField="value"/>
----

[source,java]
----
pieChart.addData(MapDataItem.of("key", "piece of apple pie",
                                "value", 75),
                MapDataItem.of("key", "piece of blueberry pie",
                                "value", 20),
                MapDataItem.of("key", "piece of cherry pie",
                                "value", 10));
----

image::chart/chart_simple.png[align="center"]

[[chart_data_from_entity]]
==== Создание диаграммы с данными из сущности

В этом примере мы создадим диаграмму похожую на
https://www.amcharts.com/demos/3d-stacked-column-chart/[3D Stacked Column Chart^] из демо AmCharts. `JavaScript` код
выглядит следующим образом:

[source,javascript]
----
include::{sourcesdir}/chart/column3d-chart.js[]
----

[[cdb_create_model]]
===== Создание сущности

. Откройте кладку *DATA MODEL* в CUBA Studio и нажмите кнопку *New -> Entity*.

. В диалоге создания новой сущности задайте ей имя `CountryGrowth` и выберите тип `Not persistent`, после чего нажмите
кнопку *OK*.

. Используя *Entity Designer* добавьте атрибуты:
* `country` типа `String`
* `year2014` типа `Double`
* `year2015` типа `Double`

. Откройте вкладку *Source*, чтобы увидеть сгенерированный код:
+
[source,java]
----
include::{sourcesdir}/chart/CountryGrowth.java[]
----
+
Этот класс описывает неперсистентную сущность. Экземпляр этого класса содержит процент роста ВВП страны за 2014 и 2015 года.

. Нажмите кнопку *OK*, чтобы сохранить сущность и закрыть экран дизайнера.

[[cdb_creating_chart]]
===== Создание диаграммы

[[cdb_xml_descriptor]]
====== XML-дескриптор экрана

Откройте в CUBA Studio вкладку *GENERIC UI* и создайте экран в модуле *web*. Введите значение
`column3d-chart.xml` в поле *Descriptor*. В полях *Id*, *Controller Name* и
*Messages Pack* будут сгенерированы подходящие значения. Сохраните изменения. Далее перейдите на вкладку *XML* и
замените ее содержимое на следующий код:

[source, xml]
----
include::{sourcesdir}/chart/column3d-chart.xml[]
----

В корневой элемент дескриптора экрана добавлен атрибут `xmlns:chart`:

[source, xml]
----
<window xmlns:chart="http://schemas.haulmont.com/charts/charts.xsd"
    ...
    >
----

Диаграмма получает данные из источника `countryGrowthDs`, указанного в атрибуте `datasource`. Для отображения названий и
значений используются атрибуты `country`, `year2014` и `year2015` сущности `CountryGrowth`, список экземпляров которой
находится в источнике данных.

Компонент `chart:serialChart` содержит следующие атрибуты:

* `angle` - определяет угол наклона диаграммы. Может принимать значения от `0` до `90`.

* `balloonText` - определяет текст всплывающей подсказки при наведении на колонку диаграммы. Доступны для использования
тэги `\[[value]]`, `\[[title]]`, `\[[persents]]`, `\[[description]]`, а также ключи из `DataItem`, список которых
хранится в экземпляре `DataProvider`, либо имена атрибутов сущности в источнике данных. Для использования `html` тегов,
их нужно экранировать.

* `depth3D` - толщина диаграммы. При использовании совместно с атрибутом `angle` позволяет создать эффект объема.

* `plotAreaFillAlphas` - степень непрозрачности области графика.

* `startDuration` - длительность анимации в секундах.

* `categoryField` - ключ из набора пар, содержащихся в объектах `DataItem`, список которых хранится в экземпляре
`DataProvider`, по которому будут взяты значения для подписи оси категорий.

Компонент `chart:serialChart` содержит следующие элементы:

* `chart:categoryAxis` - элемент, описывающий ось категорий.
** Атрибут `gridPosition` определяет будет ли линия сетки расположена по центру ячейки или от ее начала.

* `chart:valueAxes` - элемент, описывающий вертикальные оси значений. В данном случае используется только одна ось,
описываемая элементом `chart:axis`
** Атрибут `position` задает положение оси значений относительно диаграммы.
** Установка атрибуту `stackType` значения `BOX_3D` говорит о том, что колонки гистограммы будут расположены одна
позади другой.

* `chart:graphs` - элемент, описывающий графы диаграммы. Граф описывается элементом `chart:graph`.
** Атрибут `type` задает тип графа и может быть: line, column, step line, smoothed line, olhc и candlestick.
** Атрибут `valueField`определяет ключ из набора пар, содержащихся в объектах DataItem, список которых хранится в
экземпляре DataProvider, по которому будет взято значение.
** Атрибут `fillAlphas` задает степень непрозрачности заполнения.
** Атрибут `lineAlpha` задает степень непрозрачности линии (или рамки колонки).

* `chart:export` – добавляет возможность сохранить полученный график.

[[cdb_screen_controller]]
====== Контроллер экрана

Перейдите на вкладку *Controller* и замените ее содержимое на следующий код:

[source, java]
----
include::{sourcesdir}/chart/Column3dChart.java[]
----

В методе `init(Map<String, Object> params)` происходит заполнение источника данных `countryGrowthDs` данными. Метод
`refresh()` производит инициализацию источника данных. Этот метод необходимо вызвать, несмотря на атрибут
`refreshMode="NEVER"`, установленный в XML-дескрипторе.

[[cdb_result]]
===== Результат

. Откройте ссылку *Open web menu* на вкладке *GENERIC UI* в CUBA Studio.

. Убедитесь, что в меню `application` добавлен элемент `column3d-chart`. Это происходит автоматически при создании нового экрана из Studio.

. Выполните комманду *Run* -> *Start application server*.

После входа в приложение и открытия экрана из меню приложения вы увидите диаграмму, как показано ниже:

.Трехмерная гистограмма
image::chart/column3d-chart.svg[align="center", width="800"]

[[chart_with_data_provider]]
==== Создание диаграммы с данными из DataProvider

Данная диаграмма получает данные из экземпляра `DataProvider`, создаваемого в контроллере экрана, поэтому атрибут
`datasource` не определен.

[[cdp_creating_chart]]
===== Создание диаграммы

[[cdp_xml_descriptor]]
====== XML-дескриптор экрана

Откройте в CUBA Studio вкладку *Screens* и создайте экран в модуле *web*. Введите значение
`com/company/sampler/web/screens/stackedarea-chart.xml` в поле *Descriptor*. В полях *Id*, *Controller Name* и
*Messages Pack* будут сгенерированы подходящие значения. Сохраните изменения. Далее перейдите на вкладку *XML* и
замените ее содержимое на следующий код:

[source, xml]
----
include::{sourcesdir}/chart/stackedarea-chart.xml[]
----

В корневой элемент дескриптора экрана добавлен атрибут `xmlns:chart`:

[source, xml]
----
<window xmlns:chart="http://schemas.haulmont.com/charts/charts.xsd"
    ...
>
----

Компонент `chart:serialChart` содержит следующие атрибуты:

* `categoryField` - ключ из набора пар, содержащихся в объектах `DataItem`, список которых хранится в экземпляре
`DataProvider`, по которому будут взяты значения для подписи оси категорий.

Компонент `chart:serialChart` содержит следующие элементы:

* `chart:chartCursor` - необязательный элемент, добавляющий курсор к диаграмме. Курсор следует за указателем мыши и
показывает всплывающие подсказки со значениями элементов диаграммы над которыми находится указатель мыши.
** Атрибут `cursorAlpha` задает степень непрозрачности линий курсора.

* `chart:legend` - определяет легенду графика.
** Атрибут `position` определяет положение легенды относительно диаграммы.
** Атрибут `equalWidths` определяет, должны ли все элементы легенды быть такой же ширины как самый широкий.
** Атрибут `periodValueText` задает текст, который будет показан в значении легенды, когда пользователь не раполагает
указатель мыши ни над одним элементом данных. Теги должны состоять из пары значений - название поля
(value / open / close / high / low) и значение периода, для которого дожно быть показано значение -
open / close / high / low / sum / average / count.
** Атрибут `valueAlign` задает выранивание значения. Возможные значения "left" и "right".
** Атрибут `valueWidth` задает ширину значения.

* `chart:valueAxes` - элемент, описывающий вертикальные оси значений. В данном случае используется только одна ось,
описываемая элементом `chart:axis`
** Атрибут `position` задает положение оси значений относительно диаграммы.
** Атрибут `title` задает заголовок оси значения.
** Установка атрибуту `stackType` значения `REGULAR` говорит о том, что используется диаграмма с накоплением. По
умолчанию значение этого атрибута - `none`, в таком случае используется диаграмма без накопления.
** Атрибут `gridAlpha` задает степень непрозрачности линий сетки.

* `chart:graphs` - элемент, описывающий графы диаграммы. Граф описывается элементом `chart:graph`.
** Атрибут `type` задает тип графа и может быть: line, column, step line, smoothed line, olhc и candlestick.
** Атрибут `valueField` определяет ключ из набора пар, содержащихся в объектах `DataItem`, список которых хранится в
экземпляре `DataProvider`, по которому будет взято значение.
** Атрибут `fillAlphas` задает степень непрозрачности заполнения.
** Атрибут `lineAlpha` задает степень непрозрачности линии (или рамки колонки).
** Атрибут `hidden` определяет, будет ли граф отображаться.

* `chart:categoryAxis` - элемент, описывающий ось категорий.
** Установка атрибуту `startOnAxis` значения `true` дает указание начинать отрисовывать график сразу от оси значений.
По умолчанию этот атрибут имеет значение `false`. В этом случае между осью значений и графиком имеется некоторый помежуток.
** Атрибут `gridAlpha` задает степень непрозрачности линий сетки.
** Атрибут `axisColor` задает цвет оси.

* `chart:export` – добавляет возможность сохранить полученный график.

[[cdp_screen_controller]]
====== Контроллер экрана

Перейдите на вкладку *Controller* и замените ее содержимое на следующий код:

[source,java]
----
include::{sourcesdir}/chart/StackedAreaChart.java[]
----

В методе `init(Map<String, Object> params)` происходит установка данных в диаграмму с накоплением. Диаграммы подобного
типа показывают отношение отдельных составляющих к их совокупному значению.

[[cdp_result]]
===== Результат

. Откройте вкладку *Main Menu* в CUBA Studio и нажмите кнопку *edit* для `web-menu.xml`.

. Выберите элемент *`application`* и нажмите кнопку *new*.

. В диалоге создания элемента меню выберите `stackedarea-chart` в поле *id* и нажмите *add*.

. Выполните комманду *Run* -> *Start application server*.

После входа в приложение и открытия экрана из меню приложения вы увидите диаграмму, как показано ниже:

.Диаграмма с накоплением
image::chart/stackedarea-chart.svg[align="center", width="800"]

[[section_incremental_data_update]]
==== Создание диаграммы с инкрементальным обновлением данных

В следующем примере мы рассмотрим диаграмму, которая получает данные из источника данных и обновляет их автоматически. Когда в источник добавляются новые данные, диаграмма не обновляется полностью: новые точки добавляются в график на лету каждые 2 секунды. Этот принцип удобно использовать при создании динамически обновляемых виджетов.

Пример основан на тестовом приложении https://github.com/cuba-platform/sample-sales[Sales], к которому мы добавим диаграмму для отображения динамики новых заказов, то есть создания новых экземпляров сущности `Order`.

. Скачайте приложение *Sales* и добавьте к нему компонент *charts*, следуя инструкции из раздела <<chart_project_setup>>.

. Создайте в Studio новый пустой экран. Назовите его *orders-history*, так как в нём будет отображаться история создания новых заказов.

. Добавьте к экрану компонент `serialChart`. Чтобы реализовать инкрементальное обновление данных, необходимо создать источник данных с типом `collectionDatasource` и привязать к нему диаграмму. В этом примере мы не будем загружать данные из базы, вместо этого мы будем создавать тестовые данные на лету, поэтому запрос в источнике данных создавать не нужно.
+
Для оси категорий укажите атрибут `date`, для оси значений - атрибут `amount`.
+
[source, xml]
----
include::{sourcesdir}/chart/chart_incremental-update.xml[]
----

. Для обновления данных на лету используйте `timer` - специальный UI-компонент, который будет отправлять HTTP-запросы на сторону сервера.
+
Отройте вкладку *Properties* дизайнера экрана и нажмите на кнопку *Timers*, чтобы добавить таймер на экран. Заполните поле *id*. Допустим, мы хотим, чтобы данные обновлялись каждые 2 секунды, в этом случае в поле *delay* укажем значение 2000 миллисекунд.
+
В поле *onTimer* укажем имя метода Java - `updateChart`. Этот метод будет вызываться каждый раз при срабатывании события таймера. Сгенерируйте метод в контроллере экрана, нажав на кнопку *>>*, после чего сохраните его, нажав *Apply*.
+
.Создание таймера
image::chart/chart_incremental-update.png[align="center"]

. Откройте контроллер экрана в IDE. Для разработки логики работы таймера нам понадобится инжектировать следующие зависимости: `timeSource`, `metadata` и экземпляр источника данных. Мы будем генерировать новый экземпляр сущности `Order` с произвольным значением `amount` при каждом событии срабатывания таймера. Новый экземпляр добавляется к источнику данных с помощью метода `includeItem()`.
+
Инициализируйте диаграмму в методе `init()`, создав таким же образом исходный экземпляр сущности `Order`.
+
[source, java]
----
include::{sourcesdir}/chart/chart_incremental-update.java[]
----
+
На этом этапе диаграмма полностью функциональна, но размер источника данных после запуска таймера будет стремительно расти, поэтому реализуем ограничение количества отображаемых заказов.
+
.Данные автоматически обновляются каждые 2 секунды
image::chart/chart_incremental-update_2.png[align="center"]

. Создайте экземпляр класса `Queue` для очереди заказов. При каждом срабатывании таймера созданный заказ будет добавлен наверх очереди `itemsQueue`. Когда размер очереди превышает 10 заказов, самый старый заказ удаляется.
+
[source, java]
----
private Queue<Order> itemsQueue = new LinkedList<>();
----
+
[source, java]
----
include::{sourcesdir}/chart/chart_incremental-update_2.java[]
----

'''

Результат::

Данные поступают в браузер инкрементально. Если открыть консоль разработчика в Chrome, на вкладке *Network* будет видно, что каждые 2 секунды страница отправляет HTTP-запрос на backend и в ответе получает очень маленький JSON, содержащий только операции `add` и `remove` со значениями поля `amount`. Это позволяет избежать повторной пересылки всех данных диаграммы.

.Одновременно отображаются только последние 10 заказов
image::chart/chart_incremental-update_3.gif[align="center"]

'''

[[section_use_of_events]]
==== Использование событий

Проиллюстрируем использование событий. Добавим в экран, созданный в разделе <<cdb_creating_chart>>, обработку события
нажатия на элемент графа. Откройте XML-дескриптор экрана в IDE, затем инжектируйте диаграмму:

[source, java]
----
@Inject
private SerialChart chart;
----

Далее добавьте слушателя в конце метода `init(Map<String, Object> params)`. Если график получает данные через `DataProvider`, для обработки нажатия на элемент графа используется метод `getDataItemNN()`. В данном примере компонент `SerialChart` привязан к источнику данных, поэтому для получения элемента используется другой метод: `getEntityNN()`:

[source, java]
----
include::{sourcesdir}/chart/GraphItemClickListener.java[]
----

Для просмотра результата пересоберите проект командой *Run* -> *Restart application server* и зайдите в систему.
Откройте экран и нажмите на одину из колонок гистограммы.

.Диаграмма с обработкой события нажатия на элемент графа
image::chart/chart-with-event.png[align="center", width="800", height="367"]

[[custom_json]]
==== Конфигурация с помощью JSON

Для конфигурации графика, помимо указания атрибутов в XML, можно напрямую использовать JSON, описанный в http://docs.amcharts.com/3/javascriptcharts[документации AmCharts].

Рассмотрим это на примере serialChart:

[source, xml]
----
include::{sourcesdir}/chart/custom_json_1.xml[]
----

Для графика заданы определенные данные:

[source,java]
----
include::{sourcesdir}/chart/custom_json_2.java[]
----

image::chart/chart_custom_json.png[align="center"]

Теперь мы можем изменить конфигурацию графика. Например, добавить заголовок:

[source,java]
----
include::{sourcesdir}/chart/custom_json_3.java[]
----

image::chart/chart_custom_json_title.png[align="center"]

Также возможно задать JSON конфигурацию с помощью XML:

[source, xml]
----
include::{sourcesdir}/chart/custom_json_4.xml[]
----

[[chart_types]]
=== Типы диаграмм
Существует несколько типов диаграмм, поддерживаемых платформой.

.Иерархия видов диаграмм
image::chart/charts_hierarchy_diagram.png[align="center"]

Эти интерфейсы представлены в виде готовых компонентов:

* <<gauge_chart,AngularGaugeChart>>,
* <<funnel_chart,FunnelChart>>,
* <<gantt_chart,GanttChart>>,
* <<pie_chart,PieChart>>,
* <<radar_chart,RadarChart>>,
* <<serial_chart,SerialChart>>,
* <<xy_chart,XYChart>>.

Все компоненты содержат константу `NAME`, таким образом, поддерживается их создание с помощью `ComponentsFactory`.

[[serial_chart]]
==== SerialChart

Компонент `SerialChart` позволяет вам создать большое количество диаграмм: линейчатые, диаграммы с областями,
гистограммы, диаграммы с накоплением и прочие. Такие диаграммы поддерживают несколько осей в простом или логарифмическом
масштабе. Данные могут быть отображены на равных/неравных отрезках или на временной шкале.

++++
<div class="manual-live-demo-container">
    <a href="https://demo.cuba-platform.com/sampler/open?screen=line-chart" class="live-demo-btn" target="_blank">ДЕМОНСТРАЦИЯ</a>
</div>
++++

.SerialChart в виде линейного графика
image::chart/line-chart.svg[align="center", width="800"]

++++
<div class="manual-live-demo-container">
    <a href="https://demo.cuba-platform.com/sampler/open?screen=columnline-chart" class="live-demo-btn" target="_blank">ДЕМОНСТРАЦИЯ</a>
</div>
++++

.SerialChart в виде гистограммы
image::chart/column-chart.svg[align="center", width="800"]

[[pie_chart]]
==== PieChart

Компонент `PieChart` позволяет вам создать круговые диаграммы.

++++
<div class="manual-live-demo-container">
    <a href="https://demo.cuba-platform.com/sampler/open?screen=pie3d-chart" class="live-demo-btn" target="_blank">ДЕМОНСТРАЦИЯ</a>
</div>
++++

.PieChart
image::chart/pie-chart.svg[align="center", width="800"]

[[xy_chart]]
==== XYChart

Компонент `XYChart` позволяет вам создать точечные диаграммы, графики и пузырьковые диаграммы. Такие диаграммы
поддерживают несколько осей в простом или логарифмическом масштабе.

++++
<div class="manual-live-demo-container">
    <a href="https://demo.cuba-platform.com/sampler/open?screen=xy-chart" class="live-demo-btn" target="_blank">ДЕМОНСТРАЦИЯ</a>
</div>
++++

.XYChart
image::chart/xy-chart.svg[align="center", width="800"]

[[funnel_chart]]
==== FunnelChart

Компонент `FunnelChart` позволяет вам создать пирамиды или конусы.

++++
<div class="manual-live-demo-container">
    <a href="https://demo.cuba-platform.com/sampler/open?screen=funnel3d-chart" class="live-demo-btn" target="_blank">ДЕМОНСТРАЦИЯ</a>
</div>
++++

.FunnelChart
image::chart/funnel-chart.svg[align="center", width="800"]

[[radar_chart]]
==== RadarChart

Компонент `RadarChart` позволяет вам создать радиальные/сетчатые диаграммы.

++++
<div class="manual-live-demo-container">
    <a href="https://demo.cuba-platform.com/sampler/open?screen=polar-chart" class="live-demo-btn" target="_blank">ДЕМОНСТРАЦИЯ</a>
</div>
++++

.RadarChart
image::chart/radar-chart.svg[align="center", width="800"]

[[gauge_chart]]
==== AngularGaugeChart

Компонент `AngularGaugeChart` позволяет вам создать диаграмму-спидометр.

++++
<div class="manual-live-demo-container">
    <a href="https://demo.cuba-platform.com/sampler/open?screen=gauge-chart" class="live-demo-btn" target="_blank">ДЕМОНСТРАЦИЯ</a>
</div>
++++

.GaugeChart
image::chart/gauge-chart.svg[align="center", width="800"]

[[gantt_chart]]
==== GanttChart

Компонент `GanttChart` позволяет вам создать диаграмму Ганта.

++++
<div class="manual-live-demo-container">
    <a href="https://demo.cuba-platform.com/sampler/open?screen=gantt-chart" class="live-demo-btn" target="_blank">ДЕМОНСТРАЦИЯ</a>
</div>
++++

.GanttChart
image::chart/gantt-chart.svg[align="center", width="800"]

[[stock_chart]]
==== StockChartGroup

Компонент `StockChartGroup` позволяет вам создать фондовую диаграмму.

Фондовые диаграммы поддерживают несколько наборов данных и имеют готовый к использованию селектор наборов данных. Наборы
данных можно сравнивать между собой.

++++
<div class="manual-live-demo-container">
    <a href="https://demo.cuba-platform.com/sampler/open?screen=stockchart-multiple-datasets" class="live-demo-btn" target="_blank">ДЕМОНСТРАЦИЯ</a>
</div>
++++

.StockChart с несколькими наборами данных
image::chart/stock-chart-with-datasets.svg[align="center", width="800"]

Фондовые диаграммы могут отображать различные типы аннотаций на графе или оси. Эти аннотации называются stock events.

++++
<div class="manual-live-demo-container">
    <a href="https://demo.cuba-platform.com/sampler/open?screen=stockchart-stock-events" class="live-demo-btn" target="_blank">ДЕМОНСТРАЦИЯ</a>
</div>
++++

.StockChart содержащий StockEvents
image::chart/stock-chart-with-stockevents.svg[align="center", width="800"]

Фондовые диаграммы поддерживают любое количество панелей. Каждая панель может иметь любое количество графов. Каждая
панель - это отдельная диаграмма и базируется на SerialChart. Другими словами, панель может все то же самое, что и эта
диаграмма.

++++
<div class="manual-live-demo-container">
    <a href="https://demo.cuba-platform.com/sampler/open?screen=stockchart-multiple-panels" class="live-demo-btn" target="_blank">ДЕМОНСТРАЦИЯ</a>
</div>
++++

.StockChart с несколькими панелями
image::chart/stock-chart-with-panels.svg[align="center", width="800"]

[[chart_replacement]]
=== Замена версии AmCharts

Версию библиотеки AmCharts, включенную в платформу, можно заменить на другую. Для этого необходимо:

. Скачать исходный код charts и stock charts с сайта https://www.amcharts.com/download/[AmCharts^].
. Объединить содержимое папок `amcharts` в одну папку.
. Скопировать папку `amcharts` в `{project.rootDir}/modules/web/web/VAADIN/resources`
. Произвести развертывание приложения заново.

Для использования новых атрибутов, добавленных в новой версии, необходимо в контроллере экрана задать пользовательскую
JSON строку для диаграммы, как показано ниже.

[source, java]
----
CubaAmchartsScene cubaAmchartsScene = (CubaAmchartsScene) WebComponentsHelper.unwrap(chart);
cubaAmchartsScene.setJson("{\"valueScrollbar\":{\"autoGridCount\":true}}");
----